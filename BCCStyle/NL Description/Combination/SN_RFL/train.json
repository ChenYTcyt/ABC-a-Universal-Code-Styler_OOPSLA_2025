[
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> twoSum(vector<int> &numberList, int targetSum)\n{\n    unordered_map<int, int> indexMap;\n    for(int currentIndex= 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        int complementValue= targetSum - numberList[currentIndex];\n        if(indexMap.find(complementValue) != indexMap.end())\n        {\n            return {indexMap[complementValue], currentIndex};\n        }\n        indexMap[numberList[currentIndex]= currentIndex;\n    }\n    return {};\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> twoSum(std::vector<int> &numberList, int targetSum)\n{\n    std::unordered_map<int, int> indexMap;\n    for(int currentIndex= 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        int complementValue= targetSum - numberList[currentIndex];\n        if(indexMap.find(complementValue) != indexMap.end())\n        {\n            return {indexMap[complementValue], currentIndex};\n        }\n        indexMap[numberList[currentIndex]]= currentIndex;\n    }\n    return {};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct ListNode\n{\n    int Value;\n    ListNode *Next;\n    ListNode(int x) : Value(x), Next(NULL) {}\n};\n\nListNode *addTwoNumbers(ListNode *firstList, ListNode *secondList)\n{\n    ListNode dummyNode(0);\n    ListNode *currentNode= &dummyNode;\n    int carry= 0;\n\n    while(firstList || secondList || carry)\n    {\n        int sum= (firstList ? firstList->Value : 0) + (secondList ? secondList->Value : 0) + carry;\n        carry= sum / 10;\n        currentNode->Next= new ListNode(sum % 10);\n        currentNode= currentNode->Next;\n\n        if(firstList)\n            firstList= firstList->Next;\n        if(secondList)\n            secondList= secondList->Next;\n    }\n\n    return dummyNode.Next;\n}",
    "output": "struct ListNode\n{\n    int Value;\n    ListNode *Next;\n    ListNode(int x) : Value(x), Next(NULL) {}\n};\n\nListNode *addTwoNumbers(ListNode *firstList, ListNode *secondList)\n{\n    ListNode dummyNode(0);\n    ListNode *currentNode= &dummyNode;\n    int carry= 0;\n\n    while(firstList || secondList || carry)\n    {\n        int sum= (firstList ? firstList->Value : 0) + (secondList ? secondList->Value : 0) + carry;\n        carry= sum / 10;\n        currentNode->Next= new ListNode(sum % 10);\n        currentNode= currentNode->Next;\n\n        if(firstList)\n            firstList= firstList->Next;\n        if(secondList)\n            secondList= secondList->Next;\n    }\n\n    return dummyNode.Next;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint lengthOfLongestSubstring(string inputString)\n{\n    int startIndex= 0, endIndex= 0, longestLength= 0;\n    unordered_set<char> uniqueCharacters;\n\n    while(endIndex < inputString.size())\n    {\n        if(uniqueCharacters.find(inputString[endIndex]) == uniqueCharacters.end())\n        {\n            uniqueCharacters.insert(inputString[endIndex]);\n            longestLength= max(longestLength, endIndex - startIndex + 1);\n            endIndex++;\n        }\n        else\n        {\n            uniqueCharacters.erase(inputString[startIndex]);\n            startIndex++;\n        }\n    }\n\n    return longestLength;\n}",
    "output": "#include <bits/stdc++.h>\nint lengthOfLongestSubstring(std::string inputString)\n{\n    int startIndex= 0, endIndex= 0, longestLength= 0;\n    std::unordered_set<char> uniqueCharacters;\n\n    while(endIndex < inputString.size())\n    {\n        if(uniqueCharacters.find(inputString[endIndex]) == uniqueCharacters.end())\n        {\n            uniqueCharacters.insert(inputString[endIndex]);\n            longestLength= std::max(longestLength, endIndex - startIndex + 1);\n            endIndex++;\n        }\n        else\n        {\n            uniqueCharacters.erase(inputString[startIndex]);\n            startIndex++;\n        }\n    }\n\n    return longestLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble findMedianSortedArrays(vector<int> &firstArray, vector<int> &secondArray)\n{\n    if(firstArray.size() > secondArray.size())\n    {\n        return findMedianSortedArrays(secondArray, firstArray);\n    }\n\n    int firstArraySize= firstArray.size();\n    int secondArraySize= secondArray.size();\n    int lowIndex= 0;\n    int highIndex= firstArraySize;\n\n    while(lowIndex <= highIndex)\n    {\n        int partitionX= (lowIndex + highIndex) / 2;\n        int partitionY= (firstArraySize + secondArraySize + 1) / 2 - partitionX;\n\n        int maxLeftX= (partitionX == 0) ? INT_MIN : firstArray[partitionX - 1];\n        int minRightX= (partitionX == firstArraySize) ? INT_MAX : firstArray[partitionX];\n\n        int maxLeftY= (partitionY == 0) ? INT_MIN : secondArray[partitionY - 1];\n        int minRightY= (partitionY == secondArraySize) ? INT_MAX : secondArray[partitionY];\n\n        if(maxLeftX <= minRightY && maxLeftY <= minRightX)\n        {\n            if((firstArraySize + secondArraySize) % 2 == 0)\n            {\n                return (double(max(maxLeftX, maxLeftY) + min(minRightX, minRightY))) / 2;\n            }\n            else\n            {\n                return double(max(maxLeftX, maxLeftY));\n            }\n        }\n        else if(maxLeftX > minRightY)\n        {\n            highIndex= partitionX - 1;\n        }\n        else\n        {\n            lowIndex= partitionX + 1;\n        }\n    }\n    return 0;\n}",
    "output": "#include <bits/stdc++.h>\ndouble findMedianSortedArrays(std::vector<int> &firstArray, std::vector<int> &secondArray)\n{\n    if(firstArray.size() > secondArray.size())\n    {\n        return findMedianSortedArrays(secondArray, firstArray);\n    }\n\n    int firstArraySize= firstArray.size();\n    int secondArraySize= secondArray.size();\n    int lowIndex= 0;\n    int highIndex= firstArraySize;\n\n    while(lowIndex <= highIndex)\n    {\n        int partitionX= (lowIndex + highIndex) / 2;\n        int partitionY= (firstArraySize + secondArraySize + 1) / 2 - partitionX;\n\n        int maxLeftX= (partitionX == 0) ? INT_MIN : firstArray[partitionX - 1];\n        int minRightX= (partitionX == firstArraySize) ? INT_MAX : firstArray[partitionX];\n\n        int maxLeftY= (partitionY == 0) ? INT_MIN : secondArray[partitionY - 1];\n        int minRightY= (partitionY == secondArraySize) ? INT_MAX : secondArray[partitionY];\n\n        if(maxLeftX <= minRightY && maxLeftY <= minRightX)\n        {\n            if((firstArraySize + secondArraySize) % 2 == 0)\n            {\n                return (static_cast<double>(std::max(maxLeftX, maxLeftY) + std::min(minRightX, minRightY))) / 2;\n            }\n            else\n            {\n                return static_cast<double>(std::max(maxLeftX, maxLeftY));\n            }\n        }\n        else if(maxLeftX > minRightY)\n        {\n            highIndex= partitionX - 1;\n        }\n        else\n        {\n            lowIndex= partitionX + 1;\n        }\n    }\n    return 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring longestPalindromicSubstring(string inputString)\n{\n    int stringLength = inputString.size();\n    if(stringLength == 0)\n        return \"\";\n    int palindromeStart = 0, maxLength = 1;\n\n    for(int currentIndex = 0; currentIndex < stringLength; ++currentIndex)\n    {\n        int leftIndex = currentIndex, rightIndex = currentIndex;\n\n        while(rightIndex < stringLength - 1 && inputString[rightIndex] == inputString[rightIndex + 1])\n            rightIndex++;\n        currentIndex = rightIndex;\n\n        while(leftIndex > 0 && rightIndex < stringLength - 1 && inputString[leftIndex - 1] == inputString[rightIndex + 1])\n        {\n            leftIndex--;\n            rightIndex++;\n        }\n\n        int palindromeLength = rightIndex - leftIndex + 1;\n        if(palindromeLength > maxLength)\n        {\n            palindromeStart = leftIndex;\n            maxLength = palindromeLength;\n        }\n    }\n\n    return inputString.substr(palindromeStart, maxLength);\n}",
    "output": "#include <bits/stdc++.h>\nstd::string longestPalindromicSubstring(std::string inputString)\n{\n    int stringLength= inputString.size();\n    if(stringLength == 0)\n        return \"\";\n    int palindromeStart= 0, maxLength= 1;\n\n    for(int currentIndex= 0; currentIndex < stringLength; ++currentIndex)\n    {\n        int leftIndex= currentIndex, rightIndex= currentIndex;\n\n        while(rightIndex < stringLength - 1 && inputString[rightIndex] == inputString[rightIndex + 1])\n            rightIndex++;\n        currentIndex= rightIndex;\n\n        while(leftIndex > 0 && rightIndex < stringLength - 1 && inputString[leftIndex - 1] == inputString[rightIndex + 1])\n        {\n            leftIndex--;\n            rightIndex++;\n        }\n\n        int palindromeLength= rightIndex - leftIndex + 1;\n        if(palindromeLength > maxLength)\n        {\n            palindromeStart= leftIndex;\n            maxLength= palindromeLength;\n        }\n    }\n\n    return inputString.substr(palindromeStart, maxLength);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring convertToZigzag(string inputString, int numberOfRows)\n{\n    if(numberOfRows == 1 || numberOfRows >= inputString.size())\n        return inputString;\n\n    vector<string> zigzagRows(min(numberOfRows, int(inputString.size())));\n    int currentRow = 0;\n    bool isGoingDown = false;\n\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char character = inputString[i];\n        zigzagRows[currentRow] += character;\n        if(currentRow == 0 || currentRow == numberOfRows - 1)\n            isGoingDown = !isGoingDown;\n        currentRow += isGoingDown ? 1 : -1;\n    }\n\n    string result;\n    for (int i = 0; i < zigzagRows.size(); ++i)\n        result += zigzagRows[i];\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string convertToZigzag(std::string inputString, int numberOfRows)\n{\n    if(numberOfRows == 1 || numberOfRows >= inputString.size())\n        return inputString;\n\n    std::vector<std::string> zigzagRows(std::min(numberOfRows, int(inputString.size())));\n    int currentRow= 0;\n    bool isGoingDown= false;\n\n    for(char character : inputString)\n    {\n        zigzagRows[currentRow]+= character;\n        if(currentRow == 0 || currentRow == numberOfRows - 1)\n            isGoingDown= !isGoingDown;\n        currentRow+= isGoingDown ? 1 : -1;\n    }\n\n    std::string result;\n    for(std::string row : zigzagRows)\n        result+= row;\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int reverseInteger(int inputNumber)\n{\n    long long reversedNumber= 0;\n    while(inputNumber != 0)\n    {\n        reversedNumber= reversedNumber * 10 + inputNumber % 10;\n        inputNumber/= 10;\n    }\n    return (reversedNumber < INT_MIN || reversedNumber > INT_MAX) ? 0 : reversedNumber;\n}",
    "output": "int reverseInteger(int inputNumber)\n{\n    long long reversedNumber= 0;\n    while(inputNumber != 0)\n    {\n        reversedNumber= reversedNumber * 10 + inputNumber % 10;\n        inputNumber/= 10;\n    }\n    return (reversedNumber < INT_MIN || reversedNumber > INT_MAX) ? 0 : reversedNumber;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint myAtoi(string inputString)\n{\n    long convertedValue= 0;\n    int currentIndex= 0, sign= 1;\n    while(inputString[currentIndex] == ' ')\n        currentIndex++;\n    if(inputString[currentIndex] == '-' || inputString[currentIndex] == '+')\n        sign= (inputString[currentIndex++] == '+') ? 1 : -1;\n    while(isdigit(inputString[currentIndex]))\n    {\n        convertedValue= convertedValue * 10 + (inputString[currentIndex++] - '0');\n        if(convertedValue * sign > INT_MAX)\n            return INT_MAX;\n        if(convertedValue * sign < INT_MIN)\n            return INT_MIN;\n    }\n    return convertedValue * sign;\n}",
    "output": "#include <bits/stdc++.h>\nint myAtoi(std::string inputString)\n{\n    long convertedValue= 0;\n    int currentIndex= 0, sign= 1;\n    while(inputString[currentIndex] == ' ')\n        currentIndex++;\n    if(inputString[currentIndex] == '-' || inputString[currentIndex] == '+')\n        sign= (inputString[currentIndex++] == '+') ? 1 : -1;\n    while(std::isdigit(inputString[currentIndex]))\n    {\n        convertedValue= convertedValue * 10 + (inputString[currentIndex++] - '0');\n        if(convertedValue * sign > INT_MAX)\n            return INT_MAX;\n        if(convertedValue * sign < INT_MIN)\n            return INT_MIN;\n    }\n    return convertedValue * sign;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "bool isPalindrome(int inputNumber)\n{\n    if(inputNumber < 0)\n        return false;\n    int originalNumber= inputNumber, reversedNumber= 0;\n    while(inputNumber > 0)\n    {\n        reversedNumber= reversedNumber * 10 + inputNumber % 10;\n        inputNumber/= 10;\n    }\n    return originalNumber == reversedNumber;\n}",
    "output": "bool isPalindrome(int inputNumber)\n{\n    if(inputNumber < 0)\n        return false;\n    int originalNumber= inputNumber, reversedNumber= 0;\n    while(inputNumber > 0)\n    {\n        reversedNumber= reversedNumber * 10 + inputNumber % 10;\n        inputNumber/= 10;\n    }\n    return originalNumber == reversedNumber;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isMatch(string inputString, string pattern)\n{\n    int stringLength = inputString.length(), patternLength = pattern.length();\n    vector<vector<bool>> dynamicProgrammingTable(stringLength + 1, vector<bool>(patternLength + 1, false));\n    dynamicProgrammingTable[0][0] = true;\n\n    for(int patternIndex = 1; patternIndex <= patternLength; patternIndex++)\n    {\n        if(pattern[patternIndex - 1] == '*' && dynamicProgrammingTable[0][patternIndex - 2])\n        {\n            dynamicProgrammingTable[0][patternIndex] = true;\n        }\n    }\n\n    for(int stringIndex = 1; stringIndex <= stringLength; stringIndex++)\n    {\n        for(int patternIndex = 1; patternIndex <= patternLength; patternIndex++)\n        {\n            if(pattern[patternIndex - 1] == inputString[stringIndex - 1] || pattern[patternIndex - 1] == '.')\n            {\n                dynamicProgrammingTable[stringIndex][patternIndex] = dynamicProgrammingTable[stringIndex - 1][patternIndex - 1];\n            }\n            else if(pattern[patternIndex - 1] == '*')\n            {\n                dynamicProgrammingTable[stringIndex][patternIndex] = dynamicProgrammingTable[stringIndex][patternIndex - 2] ||\n                                                                    (dynamicProgrammingTable[stringIndex - 1][patternIndex] &&\n                                                                     (inputString[stringIndex - 1] == pattern[patternIndex - 2] || pattern[patternIndex - 2] == '.'));\n            }\n        }\n    }\n\n    return dynamicProgrammingTable[stringLength][patternLength];\n}",
    "output": "bool isMatch(std::string inputString, std::string pattern)\n{\n    int stringLength= inputString.length(), patternLength= pattern.length();\n    std::vector<std::vector<bool>> dynamicProgrammingTable(stringLength + 1, std::vector<bool>(patternLength + 1, false));\n    dynamicProgrammingTable[0][0]= true;\n\n    for(int patternIndex= 1; patternIndex <= patternLength; patternIndex++)\n    {\n        if(pattern[patternIndex - 1] == '*' && dynamicProgrammingTable[0][patternIndex - 2])\n        {\n            dynamicProgrammingTable[0][patternIndex]= true;\n        }\n    }\n\n    for(int stringIndex= 1; stringIndex <= stringLength; stringIndex++)\n    {\n        for(int patternIndex= 1; patternIndex <= patternLength; patternIndex++)\n        {\n            if(pattern[patternIndex - 1] == inputString[stringIndex - 1] || pattern[patternIndex - 1] == '.')\n            {\n                dynamicProgrammingTable[stringIndex][patternIndex]= dynamicProgrammingTable[stringIndex - 1][patternIndex - 1];\n            }\n            else if(pattern[patternIndex - 1] == '*')\n            {\n                dynamicProgrammingTable[stringIndex][patternIndex]= dynamicProgrammingTable[stringIndex][patternIndex - 2] ||\n                                                                    (dynamicProgrammingTable[stringIndex - 1][patternIndex] &&\n                                                                     (inputString[stringIndex - 1] == pattern[patternIndex - 2] || pattern[patternIndex - 2] == '.'));\n            }\n        }\n    }\n\n    return dynamicProgrammingTable[stringLength][patternLength];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxArea(vector<int> &height)\n{\n    int maxArea= 0, leftPointer= 0, rightPointer= height.size() - 1;\n    while(leftPointer < rightPointer)\n    {\n        maxArea= max(maxArea, min(height[leftPointer], height[rightPointer]) * (rightPointer - leftPointer));\n        if(height[leftPointer] < height[rightPointer])\n        {\n            leftPointer++;\n        }\n        else\n        {\n            rightPointer--;\n        }\n    }\n    return maxArea;\n}",
    "output": "#include <bits/stdc++.h>\nint maxArea(std::vector<int> &height)\n{\n    int maxArea= 0, leftPointer= 0, rightPointer= height.size() - 1;\n    while(leftPointer < rightPointer)\n    {\n        maxArea= std::max(maxArea, std::min(height[leftPointer], height[rightPointer]) * (rightPointer - leftPointer));\n        if(height[leftPointer] < height[rightPointer])\n        {\n            leftPointer++;\n        }\n        else\n        {\n            rightPointer--;\n        }\n    }\n    return maxArea;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring intToRoman(int number)\n{\n    vector<pair<int, string>> romanNumerals = {\n        {1000, \"M\"},\n        {900, \"CM\"},\n        {500, \"D\"},\n        {400, \"CD\"},\n        {100, \"C\"},\n        {90, \"XC\"},\n        {50, \"L\"},\n        {40, \"XL\"},\n        {10, \"X\"},\n        {9, \"IX\"},\n        {5, \"V\"},\n        {4, \"IV\"},\n        {1, \"I\"}};\n    string romanRepresentation = \"\";\n    \n    for (int i = 0; i < romanNumerals.size(); ++i)\n    {\n        while (number >= romanNumerals[i].first)\n        {\n            romanRepresentation += romanNumerals[i].second;\n            number -= romanNumerals[i].first;\n        }\n    }\n    return romanRepresentation;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string intToRoman(int number)\n{\n    std::vector<std::pair<int, std::string>> romanNumerals= {\n        {1000, \"M\"},\n        {900, \"CM\"},\n        {500, \"D\"},\n        {400, \"CD\"},\n        {100, \"C\"},\n        {90, \"XC\"},\n        {50, \"L\"},\n        {40, \"XL\"},\n        {10, \"X\"},\n        {9, \"IX\"},\n        {5, \"V\"},\n        {4, \"IV\"},\n        {1, \"I\"}};\n    std::string romanRepresentation= \"\";\n    for(const auto &pair : romanNumerals)\n    {\n        while(number >= pair.first)\n        {\n            romanRepresentation+= pair.second;\n            number-= pair.first;\n        }\n    }\n    return romanRepresentation;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint romanToInt(string romanString)\n{\n    unordered_map<char, int> romanValues = {{'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}};\n    int totalValue = 0;\n    int previousValue = 0;\n\n    for (int i = 0; i < romanString.size(); ++i)\n    {\n        char currentChar = romanString[i];\n        int currentValue = romanValues[currentChar];\n        if (currentValue > previousValue)\n            totalValue += currentValue - (2 * previousValue);\n        else\n            totalValue += currentValue;\n        previousValue = currentValue;\n    }\n\n    return totalValue;\n}",
    "output": "#include <bits/stdc++.h>\nint romanToInt(std::string romanString)\n{\n    std::unordered_map<char, int> romanValues= {{'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}};\n    int totalValue= 0;\n    int previousValue= 0;\n\n    for(char currentChar : romanString)\n    {\n        int currentValue= romanValues[currentChar];\n        if(currentValue > previousValue)\n            totalValue+= currentValue - (2 * previousValue);\n        else\n            totalValue+= currentValue;\n        previousValue= currentValue;\n    }\n\n    return totalValue;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring longestCommonPrefix(vector<string> &stringArray)\n{\n    if(stringArray.empty())\n        return \"\";\n\n    for(int characterIndex= 0; characterIndex < stringArray[0].size(); ++characterIndex)\n    {\n        char currentChar= stringArray[0][characterIndex];\n        for(int stringIndex= 1; stringIndex < stringArray.size(); ++stringIndex)\n        {\n            if(characterIndex == stringArray[stringIndex].size() || stringArray[stringIndex][characterIndex] != currentChar)\n            {\n                return stringArray[0].substr(0, characterIndex);\n            }\n        }\n    }\n    return stringArray[0];\n}",
    "output": "#include <bits/stdc++.h>\nstd::string longestCommonPrefix(std::vector<std::string> &stringArray)\n{\n    if(stringArray.empty())\n        return \"\";\n\n    for(int characterIndex= 0; characterIndex < stringArray[0].size(); ++characterIndex)\n    {\n        char currentChar= stringArray[0][characterIndex];\n        for(int stringIndex= 1; stringIndex < stringArray.size(); ++stringIndex)\n        {\n            if(characterIndex == stringArray[stringIndex].size() || stringArray[stringIndex][characterIndex] != currentChar)\n            {\n                return stringArray[0].substr(0, characterIndex);\n            }\n        }\n    }\n    return stringArray[0];\n}\n"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> findThreeSum(vector<int> &inputNumbers)\n{\n    vector<vector<int>> tripletResults;\n    sort(inputNumbers.begin(), inputNumbers.end());\n\n    for(int currentIndex= 0; currentIndex < (int)inputNumbers.size() - 2; ++currentIndex)\n    {\n        if(currentIndex == 0 || inputNumbers[currentIndex] != inputNumbers[currentIndex - 1])\n        {\n            int leftIndex= currentIndex + 1, rightIndex= inputNumbers.size() - 1;\n            while(leftIndex < rightIndex)\n            {\n                int currentSum= inputNumbers[currentIndex] + inputNumbers[leftIndex] + inputNumbers[rightIndex];\n                if(currentSum == 0)\n                {\n                    tripletResults.push_back({inputNumbers[currentIndex], inputNumbers[leftIndex], inputNumbers[rightIndex]});\n                    while(leftIndex < rightIndex && inputNumbers[leftIndex] == inputNumbers[leftIndex + 1])\n                        ++leftIndex;\n                    while(leftIndex < rightIndex && inputNumbers[rightIndex] == inputNumbers[rightIndex - 1])\n                        --rightIndex;\n                    ++leftIndex;\n                    --rightIndex;\n                }\n                else if(currentSum < 0)\n                {\n                    ++leftIndex;\n                }\n                else\n                {\n                    --rightIndex;\n                }\n            }\n        }\n    }\n\n    return tripletResults;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> findThreeSum(std::vector<int> &inputNumbers)\n{\n    std::vector<std::vector<int>> tripletResults;\n    std::sort(inputNumbers.begin(), inputNumbers.end());\n\n    for(int currentIndex= 0; currentIndex < (int)inputNumbers.size() - 2; ++currentIndex)\n    {\n        if(currentIndex == 0 || inputNumbers[currentIndex] != inputNumbers[currentIndex - 1])\n        {\n            int leftIndex= currentIndex + 1, rightIndex= inputNumbers.size() - 1;\n            while(leftIndex < rightIndex)\n            {\n                int currentSum= inputNumbers[currentIndex] + inputNumbers[leftIndex] + inputNumbers[rightIndex];\n                if(currentSum == 0)\n                {\n                    tripletResults.push_back({inputNumbers[currentIndex], inputNumbers[leftIndex], inputNumbers[rightIndex]});\n                    while(leftIndex < rightIndex && inputNumbers[leftIndex] == inputNumbers[leftIndex + 1])\n                        ++leftIndex;\n                    while(leftIndex < rightIndex && inputNumbers[rightIndex] == inputNumbers[rightIndex - 1])\n                        --rightIndex;\n                    ++leftIndex;\n                    --rightIndex;\n                }\n                else if(currentSum < 0)\n                {\n                    ++leftIndex;\n                }\n                else\n                {\n                    --rightIndex;\n                }\n            }\n        }\n    }\n\n    return tripletResults;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint threeSumClosest(vector<int> &numbers, int target)\n{\n    sort(numbers.begin(), numbers.end());\n    int closestSum = numbers[0] + numbers[1] + numbers[2];\n    for(int index = 0; index < numbers.size() - 2; ++index)\n    {\n        int leftPointer = index + 1;\n        int rightPointer = numbers.size() - 1;\n        while(leftPointer < rightPointer)\n        {\n            int currentSum = numbers[index] + numbers[leftPointer] + numbers[rightPointer];\n            if(currentSum == target)\n            {\n                return currentSum;\n            }\n            if(abs(target - currentSum) < abs(target - closestSum))\n            {\n                closestSum = currentSum;\n            }\n            if(currentSum < target)\n            {\n                leftPointer++;\n            }\n            else\n            {\n                rightPointer--;\n            }\n        }\n    }\n    return closestSum;\n}",
    "output": "#include <bits/stdc++.h>\nint threeSumClosest(std::vector<int> &numbers, int target)\n{\n    std::sort(numbers.begin(), numbers.end());\n    int closestSum= numbers[0] + numbers[1] + numbers[2];\n    for(int index= 0; index < numbers.size() - 2; ++index)\n    {\n        int leftPointer= index + 1;\n        int rightPointer= numbers.size() - 1;\n        while(leftPointer < rightPointer)\n        {\n            int currentSum= numbers[index] + numbers[leftPointer] + numbers[rightPointer];\n            if(currentSum == target)\n            {\n                return currentSum;\n            }\n            if(abs(target - currentSum) < abs(target - closestSum))\n            {\n                closestSum= currentSum;\n            }\n            if(currentSum < target)\n            {\n                leftPointer++;\n            }\n            else\n            {\n                rightPointer--;\n            }\n        }\n    }\n    return closestSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> getLetterCombinations(string inputDigits)\n{\n    if(inputDigits.empty())\n        return {};\n    vector<string> phoneMapping = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    vector<string> combinations = {\"\"};\n\n    for (int i = 0; i < inputDigits.size(); ++i)\n    {\n        char digit = inputDigits[i];\n        vector<string> tempCombinations;\n        for (int j = 0; j < combinations.size(); ++j)\n        {\n            const string &combination = combinations[j];\n            for (int k = 0; k < phoneMapping[digit - '2'].size(); ++k)\n            {\n                char letter = phoneMapping[digit - '2'][k];\n                tempCombinations.push_back(combination + letter);\n            }\n        }\n        combinations.swap(tempCombinations);\n    }\n    return combinations;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> getLetterCombinations(std::string inputDigits)\n{\n    if(inputDigits.empty())\n        return {};\n    std::vector<std::string> phoneMapping= {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    std::vector<std::string> combinations= {\"\"};\n\n    for(char digit : inputDigits)\n    {\n        std::vector<std::string> tempCombinations;\n        for(const std::string &combination : combinations)\n        {\n            for(char letter : phoneMapping[digit - '2'])\n            {\n                tempCombinations.push_back(combination + letter);\n            }\n        }\n        combinations.swap(tempCombinations);\n    }\n    return combinations;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> fourSum(vector<int> &numberList, int targetSum)\n{\n    vector<vector<int>> result;\n    int size= numberList.size();\n    if(size < 4)\n        return result;\n\n    sort(numberList.begin(), numberList.end());\n    for(int firstIndex= 0; firstIndex < size - 3; firstIndex++)\n    {\n        if(firstIndex > 0 && numberList[firstIndex] == numberList[firstIndex - 1])\n            continue;\n\n        for(int secondIndex= firstIndex + 1; secondIndex < size - 2; secondIndex++)\n        {\n            if(secondIndex > firstIndex + 1 && numberList[secondIndex] == numberList[secondIndex - 1])\n                continue;\n\n            int leftIndex= secondIndex + 1;\n            int rightIndex= size - 1;\n            while(leftIndex < rightIndex)\n            {\n                int currentSum= numberList[firstIndex] + numberList[secondIndex] + numberList[leftIndex] + numberList[rightIndex];\n                if(currentSum == targetSum)\n                {\n                    result.push_back({numberList[firstIndex], numberList[secondIndex], numberList[leftIndex], numberList[rightIndex]});\n                    ++leftIndex;\n                    --rightIndex;\n                    while(leftIndex < rightIndex && numberList[leftIndex] == numberList[leftIndex - 1])\n                        ++leftIndex;\n                    while(leftIndex < rightIndex && numberList[rightIndex] == numberList[rightIndex + 1])\n                        --rightIndex;\n                }\n                else if(currentSum < targetSum)\n                {\n                    ++leftIndex;\n                }\n                else\n                {\n                    --rightIndex;\n                }\n            }\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> fourSum(std::vector<int> &numberList, int targetSum)\n{\n    std::vector<std::vector<int>> result;\n    int size = numberList.size();\n    if(size < 4)\n        return result;\n\n    std::sort(numberList.begin(), numberList.end());\n    for(int firstIndex = 0; firstIndex < size - 3; firstIndex++)\n    {\n        if(firstIndex > 0 && numberList[firstIndex] == numberList[firstIndex - 1])\n            continue;\n\n        for(int secondIndex = firstIndex + 1; secondIndex < size - 2; secondIndex++)\n        {\n            if(secondIndex > firstIndex + 1 && numberList[secondIndex] == numberList[secondIndex - 1])\n                continue;\n\n            int leftIndex = secondIndex + 1;\n            int rightIndex = size - 1;\n            while(leftIndex < rightIndex)\n            {\n                int currentSum = numberList[firstIndex] + numberList[secondIndex] + numberList[leftIndex] + numberList[rightIndex];\n                if(currentSum == targetSum)\n                {\n                    result.push_back({numberList[firstIndex], numberList[secondIndex], numberList[leftIndex], numberList[rightIndex]});\n                    ++leftIndex;\n                    --rightIndex;\n                    while(leftIndex < rightIndex && numberList[leftIndex] == numberList[leftIndex - 1])\n                        ++leftIndex;\n                    while(leftIndex < rightIndex && numberList[rightIndex] == numberList[rightIndex + 1])\n                        --rightIndex;\n                }\n                else if(currentSum < targetSum)\n                {\n                    ++leftIndex;\n                }\n                else\n                {\n                    --rightIndex;\n                }\n            }\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *removeNthFromEnd(ListNode *head, int n)\n{\n    ListNode *firstPointer= head;\n    ListNode *secondPointer= head;\n\n    for(int i= 0; i < n; i++)\n    {\n        firstPointer= firstPointer->next;\n    }\n\n    if(firstPointer == NULL)\n    {\n        head= head->next;\n        return head;\n    }\n\n    while(firstPointer->next != NULL)\n    {\n        firstPointer= firstPointer->next;\n        secondPointer= secondPointer->next;\n    }\n\n    secondPointer->next= secondPointer->next->next;\n\n    return head;\n}",
    "output": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *removeNthFromEnd(ListNode *head, int n)\n{\n    ListNode *firstPointer= head;\n    ListNode *secondPointer= head;\n\n    for(int i= 0; i < n; i++)\n    {\n        firstPointer= firstPointer->next;\n    }\n\n    if(firstPointer == NULL)\n    {\n        head= head->next;\n        return head;\n    }\n\n    while(firstPointer->next != NULL)\n    {\n        firstPointer= firstPointer->next;\n        secondPointer= secondPointer->next;\n    }\n\n    secondPointer->next= secondPointer->next->next;\n\n    return head;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValid(string inputString)\n{\n    stack<char> bracketStack;\n\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentChar = inputString[i];\n        if (currentChar == '(' || currentChar == '{' || currentChar == '[')\n        {\n            bracketStack.push(currentChar);\n        }\n        else\n        {\n            if (bracketStack.empty())\n                return false;\n            if (currentChar == ')' && bracketStack.top() != '(')\n                return false;\n            if (currentChar == '}' && bracketStack.top() != '{')\n                return false;\n            if (currentChar == ']' && bracketStack.top() != '[')\n                return false;\n            bracketStack.pop();\n        }\n    }\n\n    return bracketStack.empty();\n}",
    "output": "bool isValid(std::string inputString)\n{\n    std::stack<char> bracketStack;\n\n    for(char currentChar : inputString)\n    {\n        if(currentChar == '(' || currentChar == '{' || currentChar == '[')\n        {\n            bracketStack.push(currentChar);\n        }\n        else\n        {\n            if(bracketStack.empty())\n                return false;\n            if(currentChar == ')' && bracketStack.top() != '(')\n                return false;\n            if(currentChar == '}' && bracketStack.top() != '{')\n                return false;\n            if(currentChar == ']' && bracketStack.top() != '[')\n                return false;\n            bracketStack.pop();\n        }\n    }\n\n    return bracketStack.empty();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "ListNode *mergeTwoLists(ListNode *firstList, ListNode *secondList)\n{\n    if(firstList == NULL)\n        return secondList;\n    if(secondList == NULL)\n        return firstList;\n\n    if(firstList->val < secondList->val)\n    {\n        firstList->next= mergeTwoLists(firstList->next, secondList);\n        return firstList;\n    }\n    else\n    {\n        secondList->next= mergeTwoLists(firstList, secondList->next);\n        return secondList;\n    }\n}",
    "output": "ListNode *mergeTwoLists(ListNode *firstList, ListNode *secondList)\n{\n    if(firstList == NULL)\n        return secondList;\n    if(secondList == NULL)\n        return firstList;\n\n    if(firstList->val < secondList->val)\n    {\n        firstList->next= mergeTwoLists(firstList->next, secondList);\n        return firstList;\n    }\n    else\n    {\n        secondList->next= mergeTwoLists(firstList, secondList->next);\n        return secondList;\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generateParenthesisHelper(int openCount, int closeCount, string currentCombination, vector<string> &resultCombinations)\n{\n    if(openCount == 0 && closeCount == 0)\n    {\n        resultCombinations.push_back(currentCombination);\n        return;\n    }\n    if(openCount > 0)\n    {\n        generateParenthesisHelper(openCount - 1, closeCount + 1, currentCombination + '(', resultCombinations);\n    }\n    if(closeCount > 0)\n    {\n        generateParenthesisHelper(openCount, closeCount - 1, currentCombination + ')', resultCombinations);\n    }\n}\n\nvector<string> generateParenthesis(int count)\n{\n    vector<string> resultCombinations;\n    generateParenthesisHelper(count, 0, \"\", resultCombinations);\n    return resultCombinations;\n}",
    "output": "#include <bits/stdc++.h>\nvoid generateParenthesisHelper(int openCount, int closeCount, std::string currentCombination, std::vector<std::string> &resultCombinations)\n{\n    if(openCount == 0 && closeCount == 0)\n    {\n        resultCombinations.push_back(currentCombination);\n        return;\n    }\n    if(openCount > 0)\n    {\n        generateParenthesisHelper(openCount - 1, closeCount + 1, currentCombination + '(', resultCombinations);\n    }\n    if(closeCount > 0)\n    {\n        generateParenthesisHelper(openCount, closeCount - 1, currentCombination + ')', resultCombinations);\n    }\n}\n\nstd::vector<std::string> generateParenthesis(int count)\n{\n    std::vector<std::string> resultCombinations;\n    generateParenthesisHelper(count, 0, \"\", resultCombinations);\n    return resultCombinations;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode() : value(0), next(NULL) {}\n    ListNode(int x) : value(x), next(NULL) {}\n    ListNode(int x, ListNode *next) : value(x), next(next) {}\n};\n\nclass Solution\n{\n  public:\n    ListNode *mergeKLists(vector<ListNode *> &listOfLists)\n    {\n        if(listOfLists.empty())\n            return NULL;\n        while(listOfLists.size() > 1)\n        {\n            listOfLists.push_back(merge2Lists(listOfLists[0], listOfLists[1]));\n            listOfLists.erase(listOfLists.begin());\n            listOfLists.erase(listOfLists.begin());\n        }\n        return listOfLists[0];\n    }\n\n    ListNode *merge2Lists(ListNode *firstList, ListNode *secondList)\n    {\n        if(!firstList)\n            return secondList;\n        if(!secondList)\n            return firstList;\n        if(firstList->value <= secondList->value)\n        {\n            firstList->next= merge2Lists(firstList->next, secondList);\n            return firstList;\n        }\n        else\n        {\n            secondList->next= merge2Lists(firstList, secondList->next);\n            return secondList;\n        }\n    }\n};",
    "output": "#include <bits/stdc++.h>\nstruct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode() : value(0), next(NULL) {}\n    ListNode(int x) : value(x), next(NULL) {}\n    ListNode(int x, ListNode *next) : value(x), next(next) {}\n};\n\nclass Solution\n{\n  public:\n    ListNode *mergeKLists(std::vector<ListNode *> &listOfLists)\n    {\n        if(listOfLists.empty())\n            return NULL;\n        while(listOfLists.size() > 1)\n        {\n            listOfLists.push_back(merge2Lists(listOfLists[0], listOfLists[1]));\n            listOfLists.erase(listOfLists.begin());\n            listOfLists.erase(listOfLists.begin());\n        }\n        return listOfLists[0];\n    }\n\n    ListNode *merge2Lists(ListNode *firstList, ListNode *secondList)\n    {\n        if(!firstList)\n            return secondList;\n        if(!secondList)\n            return firstList;\n        if(firstList->value <= secondList->value)\n        {\n            firstList->next= merge2Lists(firstList->next, secondList);\n            return firstList;\n        }\n        else\n        {\n            secondList->next= merge2Lists(firstList, secondList->next);\n            return secondList;\n        }\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "ListNode *swapPairs(ListNode *head)\n{\n    if(!head || !head->next)\n        return head;\n\n    ListNode *secondNode= head->next;\n    head->next= swapPairs(secondNode->next);\n    secondNode->next= head;\n\n    return secondNode;\n}",
    "output": "ListNode *swapPairs(ListNode *head)\n{\n    if(!head || !head->next)\n        return head;\n\n    ListNode *secondNode= head->next;\n    head->next= swapPairs(secondNode->next);\n    secondNode->next= head;\n\n    return secondNode;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode() : value(0), next(NULL) {}\n    ListNode(int x) : value(x), next(NULL) {}\n    ListNode(int x, ListNode *next) : value(x), next(next) {}\n};\n\nListNode *reverseKGroup(ListNode *head, int groupSize)\n{\n    if(head == NULL || groupSize == 1)\n        return head;\n\n    int length= 0;\n    ListNode *current= head;\n    while(current != NULL)\n    {\n        length++;\n        current= current->next;\n    }\n\n    ListNode dummy(0);\n    dummy.next= head;\n    ListNode *previous= &dummy;\n    current= head;\n\n    while(length >= groupSize)\n    {\n        for(int i= 1; i < groupSize; i++)\n        {\n            ListNode *temp= current->next;\n            current->next= temp->next;\n            temp->next= previous->next;\n            previous->next= temp;\n        }\n        previous= current;\n        current= current->next;\n        length-= groupSize;\n    }\n\n    return dummy.next;\n}",
    "output": "struct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode() : value(0), next(NULL) {}\n    ListNode(int x) : value(x), next(NULL) {}\n    ListNode(int x, ListNode *next) : value(x), next(next) {}\n};\n\nListNode *reverseKGroup(ListNode *head, int groupSize)\n{\n    if(head == NULL || groupSize == 1)\n        return head;\n\n    int length= 0;\n    ListNode *current= head;\n    while(current != NULL)\n    {\n        length++;\n        current= current->next;\n    }\n\n    ListNode dummy(0);\n    dummy.next= head;\n    ListNode *previous= &dummy;\n    current= head;\n\n    while(length >= groupSize)\n    {\n        for(int i= 1; i < groupSize; i++)\n        {\n            ListNode *temp= current->next;\n            current->next= temp->next;\n            temp->next= previous->next;\n            previous->next= temp;\n        }\n        previous= current;\n        current= current->next;\n        length-= groupSize;\n    }\n\n    return dummy.next;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint removeDuplicates(vector<int> &numberList)\n{\n    if(numberList.empty())\n        return 0;\n    int uniqueIndex= 0;\n    for(int currentIndex= 1; currentIndex < numberList.size(); currentIndex++)\n    {\n        if(numberList[currentIndex] != numberList[uniqueIndex])\n        {\n            uniqueIndex++;\n            numberList[uniqueIndex]= numberList[currentIndex];\n        }\n    }\n    return uniqueIndex + 1;\n}",
    "output": "#include <bits/stdc++.h>\nint removeDuplicates(std::vector<int> &numberList)\n{\n    if(numberList.empty())\n        return 0;\n    int uniqueIndex= 0;\n    for(int currentIndex= 1; currentIndex < numberList.size(); currentIndex++)\n    {\n        if(numberList[currentIndex] != numberList[uniqueIndex])\n        {\n            uniqueIndex++;\n            numberList[uniqueIndex]= numberList[currentIndex];\n        }\n    }\n    return uniqueIndex + 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint removeElement(vector<int> &numList, int valueToRemove)\n{\n    int currentIndex= 0;\n    for(int checkIndex= 0; checkIndex < numList.size(); checkIndex++)\n    {\n        if(numList[checkIndex] != valueToRemove)\n        {\n            numList[currentIndex]= numList[checkIndex];\n            currentIndex++;\n        }\n    }\n    return currentIndex;\n}",
    "output": "#include <bits/stdc++.h>\nint removeElement(std::vector<int> &numList, int valueToRemove)\n{\n    int currentIndex= 0;\n    for(int checkIndex= 0; checkIndex < numList.size(); checkIndex++)\n    {\n        if(numList[checkIndex] != valueToRemove)\n        {\n            numList[currentIndex]= numList[checkIndex];\n            currentIndex++;\n        }\n    }\n    return currentIndex;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint strStr(string haystack, string needle)\n{\n    if(needle.empty())\n        return 0;\n\n    size_t position= haystack.find(needle);\n    if(position != string::npos)\n        return position;\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint strStr(std::string haystack, std::string needle)\n{\n    if(needle.empty())\n        return 0;\n\n    std::size_t position= haystack.find(needle);\n    if(position != std::string::npos)\n        return position;\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int divide(int dividend, int divisor)\n{\n    if(dividend == INT_MIN && divisor == -1)\n    {\n        return INT_MAX;\n    }\n\n    int sign= (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n\n    long long absoluteDividend= labs(dividend);\n    long long absoluteDivisor= labs(divisor);\n    int result= 0;\n\n    while(absoluteDividend >= absoluteDivisor)\n    {\n        long long temp= absoluteDivisor, multiple= 1;\n        while(absoluteDividend >= (temp << 1))\n        {\n            temp<<= 1;\n            multiple<<= 1;\n        }\n        absoluteDividend-= temp;\n        result+= multiple;\n    }\n\n    return result * sign;\n}",
    "output": "int divide(int dividend, int divisor)\n{\n    if(dividend == INT_MIN && divisor == -1)\n    {\n        return INT_MAX;\n    }\n\n    int sign= (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n\n    long long absoluteDividend= labs(dividend);\n    long long absoluteDivisor= labs(divisor);\n    int result= 0;\n\n    while(absoluteDividend >= absoluteDivisor)\n    {\n        long long temp= absoluteDivisor, multiple= 1;\n        while(absoluteDividend >= (temp << 1))\n        {\n            temp<<= 1;\n            multiple<<= 1;\n        }\n        absoluteDividend-= temp;\n        result+= multiple;\n    }\n\n    return result * sign;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findSubstring(string inputString, vector<string> &wordList)\n{\n    if(inputString.empty() || wordList.empty())\n        return {};\n\n    unordered_map<string, int> wordCountMap;\n    for (int i = 0; i < wordList.size(); ++i)\n    {\n        ++wordCountMap[wordList[i]];\n    }\n\n    int wordLength = wordList[0].size();\n    int totalWords = wordList.size();\n    int totalLength = wordLength * totalWords;\n    vector<int> resultIndices;\n\n    for(int i = 0; i <= (int)inputString.size() - totalLength; ++i)\n    {\n        unordered_map<string, int> tempWordCount;\n        for(int j = 0; j < totalWords; ++j)\n        {\n            string currentWord = inputString.substr(i + j * wordLength, wordLength);\n            if(wordCountMap.find(currentWord) == wordCountMap.end())\n                break;\n            ++tempWordCount[currentWord];\n            if(tempWordCount[currentWord] > wordCountMap[currentWord])\n                break;\n            if(j + 1 == totalWords)\n                resultIndices.push_back(i);\n        }\n    }\n\n    return resultIndices;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findSubstring(std::string inputString, std::vector<std::string> &wordList)\n{\n    if(inputString.empty() || wordList.empty())\n        return {};\n\n    std::unordered_map<std::string, int> wordCountMap;\n    for(const auto &word : wordList)\n    {\n        ++wordCountMap[word];\n    }\n\n    int wordLength= wordList[0].size();\n    int totalWords= wordList.size();\n    int totalLength= wordLength * totalWords;\n    std::vector<int> resultIndices;\n\n    for(int i= 0; i <= (int)inputString.size() - totalLength; ++i)\n    {\n        std::unordered_map<std::string, int> tempWordCount;\n        for(int j= 0; j < totalWords; ++j)\n        {\n            std::string currentWord= inputString.substr(i + j * wordLength, wordLength);\n            if(wordCountMap.find(currentWord) == wordCountMap.end())\n                break;\n            ++tempWordCount[currentWord];\n            if(tempWordCount[currentWord] > wordCountMap[currentWord])\n                break;\n            if(j + 1 == totalWords)\n                resultIndices.push_back(i);\n        }\n    }\n\n    return resultIndices;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid nextPermutation(vector<int> &numbers)\n{\n    int size= numbers.size(), firstIndex, secondIndex;\n    for(firstIndex= size - 2; firstIndex >= 0; firstIndex--)\n    {\n        if(numbers[firstIndex] < numbers[firstIndex + 1])\n            break;\n    }\n    if(firstIndex < 0)\n    {\n        reverse(numbers.begin(), numbers.end());\n    }\n    else\n    {\n        for(secondIndex= size - 1; secondIndex > firstIndex; secondIndex--)\n        {\n            if(numbers[secondIndex] > numbers[firstIndex])\n                break;\n        }\n        swap(numbers[firstIndex], numbers[secondIndex]);\n        reverse(numbers.begin() + firstIndex + 1, numbers.end());\n    }\n}",
    "output": "#include <bits/stdc++.h>\nvoid nextPermutation(std::vector<int> &numbers)\n{\n    int size= numbers.size(), firstIndex, secondIndex;\n    for(firstIndex= size - 2; firstIndex >= 0; firstIndex--)\n    {\n        if(numbers[firstIndex] < numbers[firstIndex + 1])\n            break;\n    }\n    if(firstIndex < 0)\n    {\n        std::reverse(numbers.begin(), numbers.end());\n    }\n    else\n    {\n        for(secondIndex= size - 1; secondIndex > firstIndex; secondIndex--)\n        {\n            if(numbers[secondIndex] > numbers[firstIndex])\n                break;\n        }\n        std::swap(numbers[firstIndex], numbers[secondIndex]);\n        std::reverse(numbers.begin() + firstIndex + 1, numbers.end());\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint longestValidParentheses(string parenthesesString)\n{\n    int stringLength= parenthesesString.length();\n    int longestValidLength= 0;\n    stack<int> indexStack;\n\n    for(int currentIndex= 0; currentIndex < stringLength; ++currentIndex)\n    {\n        if(parenthesesString[currentIndex] == '(')\n        {\n            indexStack.push(currentIndex);\n        }\n        else\n        {\n            if(!indexStack.empty() && parenthesesString[indexStack.top()] == '(')\n            {\n                indexStack.pop();\n            }\n            else\n            {\n                indexStack.push(currentIndex);\n            }\n        }\n    }\n\n    if(indexStack.empty())\n    {\n        longestValidLength= stringLength;\n    }\n    else\n    {\n        int rightIndex= stringLength, leftIndex= 0;\n        while(!indexStack.empty())\n        {\n            leftIndex= indexStack.top();\n            indexStack.pop();\n            longestValidLength= max(longestValidLength, rightIndex - leftIndex - 1);\n            rightIndex= leftIndex;\n        }\n        longestValidLength= max(longestValidLength, rightIndex);\n    }\n\n    return longestValidLength;\n}",
    "output": "#include <bits/stdc++.h>\nint longestValidParentheses(string parenthesesString)\n{\n    int stringLength= parenthesesString.length();\n    int longestValidLength= 0;\n    std::stack<int> indexStack;\n\n    for(int currentIndex= 0; currentIndex < stringLength; ++currentIndex)\n    {\n        if(parenthesesString[currentIndex] == '(')\n        {\n            indexStack.push(currentIndex);\n        }\n        else\n        {\n            if(!indexStack.empty() && parenthesesString[indexStack.top()] == '(')\n            {\n                indexStack.pop();\n            }\n            else\n            {\n                indexStack.push(currentIndex);\n            }\n        }\n    }\n\n    if(indexStack.empty())\n    {\n        longestValidLength= stringLength;\n    }\n    else\n    {\n        int rightIndex= stringLength, leftIndex= 0;\n        while(!indexStack.empty())\n        {\n            leftIndex= indexStack.top();\n            indexStack.pop();\n            longestValidLength= std::max(longestValidLength, rightIndex - leftIndex - 1);\n            rightIndex= leftIndex;\n        }\n        longestValidLength= std::max(longestValidLength, rightIndex);\n    }\n\n    return longestValidLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint searchInRotatedSortedArray(vector<int> &numberList, int targetNumber)\n{\n    int leftIndex= 0, rightIndex= numberList.size() - 1;\n    while(leftIndex <= rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(numberList[midIndex] == targetNumber)\n        {\n            return midIndex;\n        }\n        if(numberList[midIndex] >= numberList[leftIndex])\n        {\n            if(targetNumber >= numberList[leftIndex] && targetNumber < numberList[midIndex])\n            {\n                rightIndex= midIndex - 1;\n            }\n            else\n            {\n                leftIndex= midIndex + 1;\n            }\n        }\n        else\n        {\n            if(targetNumber > numberList[midIndex] && targetNumber <= numberList[rightIndex])\n            {\n                leftIndex= midIndex + 1;\n            }\n            else\n            {\n                rightIndex= midIndex - 1;\n            }\n        }\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint searchInRotatedSortedArray(std::vector<int> &numberList, int targetNumber)\n{\n    int leftIndex= 0, rightIndex= numberList.size() - 1;\n    while(leftIndex <= rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(numberList[midIndex] == targetNumber)\n        {\n            return midIndex;\n        }\n        if(numberList[midIndex] >= numberList[leftIndex])\n        {\n            if(targetNumber >= numberList[leftIndex] && targetNumber < numberList[midIndex])\n            {\n                rightIndex= midIndex - 1;\n            }\n            else\n            {\n                leftIndex= midIndex + 1;\n            }\n        }\n        else\n        {\n            if(targetNumber > numberList[midIndex] && targetNumber <= numberList[rightIndex])\n            {\n                leftIndex= midIndex + 1;\n            }\n            else\n            {\n                rightIndex= midIndex - 1;\n            }\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> searchRange(vector<int> &sortedNumbers, int target)\n{\n    int startIndex= -1, endIndex= -1;\n    int leftIndex= 0, rightIndex= sortedNumbers.size() - 1;\n    while(leftIndex <= rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(sortedNumbers[midIndex] < target)\n        {\n            leftIndex= midIndex + 1;\n        }\n        else\n        {\n            rightIndex= midIndex - 1;\n            if(sortedNumbers[midIndex] == target)\n            {\n                startIndex= midIndex;\n            }\n        }\n    }\n\n    leftIndex= 0, rightIndex= sortedNumbers.size() - 1;\n    while(leftIndex <= rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(sortedNumbers[midIndex] > target)\n        {\n            rightIndex= midIndex - 1;\n        }\n        else\n        {\n            leftIndex= midIndex + 1;\n            if(sortedNumbers[midIndex] == target)\n            {\n                endIndex= midIndex;\n            }\n        }\n    }\n\n    return {startIndex, endIndex};\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> searchRange(std::vector<int> &sortedNumbers, int target)\n{\n    int startIndex= -1, endIndex= -1;\n    int leftIndex= 0, rightIndex= sortedNumbers.size() - 1;\n    while(leftIndex <= rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(sortedNumbers[midIndex] < target)\n        {\n            leftIndex= midIndex + 1;\n        }\n        else\n        {\n            rightIndex= midIndex - 1;\n            if(sortedNumbers[midIndex] == target)\n            {\n                startIndex= midIndex;\n            }\n        }\n    }\n\n    leftIndex= 0, rightIndex= sortedNumbers.size() - 1;\n    while(leftIndex <= rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(sortedNumbers[midIndex] > target)\n        {\n            rightIndex= midIndex - 1;\n        }\n        else\n        {\n            leftIndex= midIndex + 1;\n            if(sortedNumbers[midIndex] == target)\n            {\n                endIndex= midIndex;\n            }\n        }\n    }\n\n    return {startIndex, endIndex};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint searchInsert(vector<int> &sortedNumbers, int target)\n{\n    int leftIndex= 0, rightIndex= sortedNumbers.size() - 1;\n    while(leftIndex <= rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(sortedNumbers[midIndex] == target)\n            return midIndex;\n        if(sortedNumbers[midIndex] < target)\n            leftIndex= midIndex + 1;\n        else\n            rightIndex= midIndex - 1;\n    }\n    return leftIndex;\n}",
    "output": "#include <bits/stdc++.h>\nint searchInsert(std::vector<int> &sortedNumbers, int target)\n{\n    int leftIndex= 0, rightIndex= sortedNumbers.size() - 1;\n    while(leftIndex <= rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(sortedNumbers[midIndex] == target)\n            return midIndex;\n        if(sortedNumbers[midIndex] < target)\n            leftIndex= midIndex + 1;\n        else\n            rightIndex= midIndex - 1;\n    }\n    return leftIndex;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidSudoku(vector<vector<char>> &sudokuBoard)\n{\n    unordered_set<string> seenValues;\n\n    for(int rowIndex= 0; rowIndex < 9; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < 9; colIndex++)\n        {\n            char currentValue= sudokuBoard[rowIndex][colIndex];\n            if(currentValue != '.')\n            {\n                string rowString= to_string(currentValue) + \" in row \" + to_string(rowIndex);\n                string colString= to_string(currentValue) + \" in col \" + to_string(colIndex);\n                string boxString= to_string(currentValue) + \" in box \" + to_string(rowIndex / 3) + \"-\" + to_string(colIndex / 3);\n                if(seenValues.count(rowString) || seenValues.count(colString) || seenValues.count(boxString))\n                {\n                    return false;\n                }\n                seenValues.insert(rowString);\n                seenValues.insert(colString);\n                seenValues.insert(boxString);\n            }\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isValidSudoku(std::vector<std::vector<char>> &sudokuBoard)\n{\n    std::unordered_set<std::string> seenValues;\n\n    for(int rowIndex= 0; rowIndex < 9; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < 9; colIndex++)\n        {\n            char currentValue= sudokuBoard[rowIndex][colIndex];\n            if(currentValue != '.')\n            {\n                std::string rowString= std::to_string(currentValue) + \" in row \" + std::to_string(rowIndex);\n                std::string colString= std::to_string(currentValue) + \" in col \" + std::to_string(colIndex);\n                std::string boxString= std::to_string(currentValue) + \" in box \" + std::to_string(rowIndex / 3) + \"-\" + std::to_string(colIndex / 3);\n                if(seenValues.count(rowString) || seenValues.count(colString) || seenValues.count(boxString))\n                {\n                    return false;\n                }\n                seenValues.insert(rowString);\n                seenValues.insert(colString);\n                seenValues.insert(boxString);\n            }\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValid(vector<vector<char>> &sudokuBoard, int rowIndex, int colIndex, char candidate)\n{\n    for(int i= 0; i < 9; i++)\n    {\n        if(sudokuBoard[i][colIndex] == candidate)\n            return false;\n        if(sudokuBoard[rowIndex][i] == candidate)\n            return false;\n        if(sudokuBoard[3 * (rowIndex / 3) + i / 3][3 * (colIndex / 3) + i % 3] == candidate)\n            return false;\n    }\n    return true;\n}\n\nbool solveSudokuHelper(vector<vector<char>> &sudokuBoard)\n{\n    for(int rowIndex= 0; rowIndex < 9; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < 9; colIndex++)\n        {\n            if(sudokuBoard[rowIndex][colIndex] == '.')\n            {\n                for(char candidate= '1'; candidate <= '9'; candidate++)\n                {\n                    if(isValid(sudokuBoard, rowIndex, colIndex, candidate))\n                    {\n                        sudokuBoard[rowIndex][colIndex]= candidate;\n\n                        if(solveSudokuHelper(sudokuBoard))\n                            return true;\n\n                        sudokuBoard[rowIndex][colIndex]= '.';\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid solveSudoku(vector<vector<char>> &sudokuBoard)\n{\n    solveSudokuHelper(sudokuBoard);\n}",
    "output": "#include <bits/stdc++.h>\nbool isValid(std::vector<std::vector<char>> &sudokuBoard, int rowIndex, int colIndex, char candidate)\n{\n    for(int i= 0; i < 9; i++)\n    {\n        if(sudokuBoard[i][colIndex] == candidate)\n            return false;\n        if(sudokuBoard[rowIndex][i] == candidate)\n            return false;\n        if(sudokuBoard[3 * (rowIndex / 3) + i / 3][3 * (colIndex / 3) + i % 3] == candidate)\n            return false;\n    }\n    return true;\n}\n\nbool solveSudokuHelper(std::vector<std::vector<char>> &sudokuBoard)\n{\n    for(int rowIndex= 0; rowIndex < 9; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < 9; colIndex++)\n        {\n            if(sudokuBoard[rowIndex][colIndex] == '.')\n            {\n                for(char candidate= '1'; candidate <= '9'; candidate++)\n                {\n                    if(isValid(sudokuBoard, rowIndex, colIndex, candidate))\n                    {\n                        sudokuBoard[rowIndex][colIndex]= candidate;\n\n                        if(solveSudokuHelper(sudokuBoard))\n                            return true;\n\n                        sudokuBoard[rowIndex][colIndex]= '.';\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid solveSudoku(std::vector<std::vector<char>> &sudokuBoard)\n{\n    solveSudokuHelper(sudokuBoard);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring countAndSay(int n)\n{\n    if(n == 1)\n        return \"1\";\n    string previousSequence = countAndSay(n - 1);\n    string result = \"\";\n    int count = 1;\n    for(int i = 1; i < previousSequence.length(); i++)\n    {\n        if(previousSequence[i] == previousSequence[i - 1])\n        {\n            count++;\n        }\n        else\n        {\n            result += to_string(count) + previousSequence[i - 1];\n            count = 1;\n        }\n    }\n    result += to_string(count) + previousSequence.back();\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string countAndSay(int n)\n{\n    if(n == 1)\n        return \"1\";\n    std::string previousSequence= countAndSay(n - 1);\n    std::string result= \"\";\n    int count= 1;\n    for(int i= 1; i < previousSequence.length(); i++)\n    {\n        if(previousSequence[i] == previousSequence[i - 1])\n        {\n            count++;\n        }\n        else\n        {\n            result+= std::to_string(count) + previousSequence[i - 1];\n            count= 1;\n        }\n    }\n    result+= std::to_string(count) + previousSequence.back();\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid findCombinations(vector<int> &candidateNumbers, int targetSum, int startIndex, vector<int> &currentCombination, vector<vector<int>> &allCombinations)\n{\n    if(targetSum == 0)\n    {\n        allCombinations.push_back(currentCombination);\n        return;\n    }\n    if(startIndex == candidateNumbers.size() || targetSum < 0)\n    {\n        return;\n    }\n\n    findCombinations(candidateNumbers, targetSum, startIndex + 1, currentCombination, allCombinations);\n\n    currentCombination.push_back(candidateNumbers[startIndex]);\n    findCombinations(candidateNumbers, targetSum - candidateNumbers[startIndex], startIndex, currentCombination, allCombinations);\n    currentCombination.pop_back();\n}\n\nvector<vector<int>> combinationSum(vector<int> &candidateNumbers, int targetSum)\n{\n    vector<int> currentCombination;\n    vector<vector<int>> allCombinations;\n    findCombinations(candidateNumbers, targetSum, 0, currentCombination, allCombinations);\n    return allCombinations;\n}",
    "output": "#include <bits/stdc++.h>\nvoid findCombinations(std::vector<int> &candidateNumbers, int targetSum, int startIndex, std::vector<int> &currentCombination, std::vector<std::vector<int>> &allCombinations)\n{\n    if(targetSum == 0)\n    {\n        allCombinations.push_back(currentCombination);\n        return;\n    }\n    if(startIndex == candidateNumbers.size() || targetSum < 0)\n    {\n        return;\n    }\n\n    findCombinations(candidateNumbers, targetSum, startIndex + 1, currentCombination, allCombinations);\n\n    currentCombination.push_back(candidateNumbers[startIndex]);\n    findCombinations(candidateNumbers, targetSum - candidateNumbers[startIndex], startIndex, currentCombination, allCombinations);\n    currentCombination.pop_back();\n}\n\nstd::vector<std::vector<int>> combinationSum(std::vector<int> &candidateNumbers, int targetSum)\n{\n    std::vector<int> currentCombination;\n    std::vector<std::vector<int>> allCombinations;\n    findCombinations(candidateNumbers, targetSum, 0, currentCombination, allCombinations);\n    return allCombinations;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid combine(vector<int> &candidateNumbers, int targetSum, vector<vector<int>> &resultCombinations, vector<int> &currentCombination, int startIndex)\n{\n    if(targetSum == 0)\n    {\n        resultCombinations.push_back(currentCombination);\n        return;\n    }\n\n    for(int i= startIndex; i < candidateNumbers.size() && targetSum >= candidateNumbers[i]; ++i)\n    {\n        if(i == startIndex || candidateNumbers[i] != candidateNumbers[i - 1])\n        {\n            currentCombination.push_back(candidateNumbers[i]);\n            combine(candidateNumbers, targetSum - candidateNumbers[i], resultCombinations, currentCombination, i + 1);\n            currentCombination.pop_back();\n        }\n    }\n}\n\nvector<vector<int>> combinationSum2(vector<int> &candidateNumbers, int targetSum)\n{\n    vector<vector<int>> resultCombinations;\n    vector<int> currentCombination;\n    sort(candidateNumbers.begin(), candidateNumbers.end());\n    combine(candidateNumbers, targetSum, resultCombinations, currentCombination, 0);\n    return resultCombinations;\n}",
    "output": "#include <bits/stdc++.h>\nvoid combine(std::vector<int> &candidateNumbers, int targetSum, std::vector<std::vector<int>> &resultCombinations, std::vector<int> &currentCombination, int startIndex)\n{\n    if(targetSum == 0)\n    {\n        resultCombinations.push_back(currentCombination);\n        return;\n    }\n\n    for(int i= startIndex; i < candidateNumbers.size() && targetSum >= candidateNumbers[i]; ++i)\n    {\n        if(i == startIndex || candidateNumbers[i] != candidateNumbers[i - 1])\n        {\n            currentCombination.push_back(candidateNumbers[i]);\n            combine(candidateNumbers, targetSum - candidateNumbers[i], resultCombinations, currentCombination, i + 1);\n            currentCombination.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<int>> combinationSum2(std::vector<int> &candidateNumbers, int targetSum)\n{\n    std::vector<std::vector<int>> resultCombinations;\n    std::vector<int> currentCombination;\n    std::sort(candidateNumbers.begin(), candidateNumbers.end());\n    combine(candidateNumbers, targetSum, resultCombinations, currentCombination, 0);\n    return resultCombinations;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findFirstMissingPositive(vector<int> &positiveNumbers)\n{\n    int size= positiveNumbers.size();\n    for(int index= 0; index < size; ++index)\n        while(positiveNumbers[index] > 0 && positiveNumbers[index] <= size && positiveNumbers[positiveNumbers[index] - 1] != positiveNumbers[index])\n            swap(positiveNumbers[index], positiveNumbers[positiveNumbers[index] - 1]);\n\n    for(int index= 0; index < size; ++index)\n        if(positiveNumbers[index] != index + 1)\n            return index + 1;\n    return size + 1;\n}",
    "output": "#include <bits/stdc++.h>\nint findFirstMissingPositive(std::vector<int> &positiveNumbers)\n{\n    int size= positiveNumbers.size();\n    for(int index= 0; index < size; ++index)\n        while(positiveNumbers[index] > 0 && positiveNumbers[index] <= size && positiveNumbers[positiveNumbers[index] - 1] != positiveNumbers[index])\n            std::swap(positiveNumbers[index], positiveNumbers[positiveNumbers[index] - 1]);\n\n    for(int index= 0; index < size; ++index)\n        if(positiveNumbers[index] != index + 1)\n            return index + 1;\n    return size + 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint trap(vector<int> &height)\n{\n    int numberOfBars= height.size();\n    int leftPointer= 0, rightPointer= numberOfBars - 1, maxLeftHeight= 0, maxRightHeight= 0, trappedWater= 0;\n\n    while(leftPointer < rightPointer)\n    {\n        if(height[leftPointer] <= height[rightPointer])\n        {\n            maxLeftHeight= max(maxLeftHeight, height[leftPointer]);\n            trappedWater+= maxLeftHeight - height[leftPointer];\n            leftPointer++;\n        }\n        else\n        {\n            maxRightHeight= max(maxRightHeight, height[rightPointer]);\n            trappedWater+= maxRightHeight - height[rightPointer];\n            rightPointer--;\n        }\n    }\n\n    return trappedWater;\n}",
    "output": "#include <bits/stdc++.h>\nint trap(std::vector<int> &height)\n{\n    int numberOfBars= height.size();\n    int leftPointer= 0, rightPointer= numberOfBars - 1, maxLeftHeight= 0, maxRightHeight= 0, trappedWater= 0;\n\n    while(leftPointer < rightPointer)\n    {\n        if(height[leftPointer] <= height[rightPointer])\n        {\n            maxLeftHeight= std::max(maxLeftHeight, height[leftPointer]);\n            trappedWater+= maxLeftHeight - height[leftPointer];\n            leftPointer++;\n        }\n        else\n        {\n            maxRightHeight= std::max(maxRightHeight, height[rightPointer]);\n            trappedWater+= maxRightHeight - height[rightPointer];\n            rightPointer--;\n        }\n    }\n\n    return trappedWater;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring multiply(string firstNumber, string secondNumber)\n{\n    int firstLength= firstNumber.size(), secondLength= secondNumber.size();\n    string result(firstLength + secondLength, '0');\n    for(int i= firstLength - 1; i >= 0; i--)\n    {\n        for(int j= secondLength - 1; j >= 0; j--)\n        {\n            int position1= i + j, position2= i + j + 1;\n            int product= (firstNumber[i] - '0') * (secondNumber[j] - '0') + (result[position2] - '0');\n            result[position1]+= product / 10;\n            result[position2]= (product % 10) + '0';\n        }\n    }\n    while(result.size() > 1 && result[0] == '0')\n        result.erase(result.begin());\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string multiply(std::string firstNumber, std::string secondNumber)\n{\n    int firstLength= firstNumber.size(), secondLength= secondNumber.size();\n    std::string result(firstLength + secondLength, '0');\n    for(int i= firstLength - 1; i >= 0; i--)\n    {\n        for(int j= secondLength - 1; j >= 0; j--)\n        {\n            int position1= i + j, position2= i + j + 1;\n            int product= (firstNumber[i] - '0') * (secondNumber[j] - '0') + (result[position2] - '0');\n            result[position1]+= product / 10;\n            result[position2]= (product % 10) + '0';\n        }\n    }\n    while(result.size() > 1 && result[0] == '0')\n        result.erase(result.begin());\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isMatch(const string &sourceString, const string &patternString)\n{\n    int sourceLength = sourceString.size(), patternLength = patternString.size();\n    int sourceIndex = 0, patternIndex = 0, asteriskIndex = -1, matchIndex;\n    while(sourceIndex < sourceLength)\n    {\n        if(patternIndex < patternLength && (sourceString[sourceIndex] == patternString[patternIndex] || patternString[patternIndex] == '?'))\n        {\n            sourceIndex++;\n            patternIndex++;\n        }\n        else if(patternIndex < patternLength && patternString[patternIndex] == '*')\n        {\n            matchIndex = sourceIndex;\n            asteriskIndex = patternIndex++;\n        }\n        else if(asteriskIndex >= 0)\n        {\n            sourceIndex = ++matchIndex;\n            patternIndex = asteriskIndex + 1;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    while(patternIndex < patternLength && patternString[patternIndex] == '*')\n        patternIndex++;\n    return patternIndex == patternLength;\n}",
    "output": "bool isMatch(const std::string &sourceString, const std::string &patternString)\n{\n    int sourceLength= sourceString.size(), patternLength= patternString.size();\n    int sourceIndex= 0, patternIndex= 0, asteriskIndex= -1, matchIndex;\n    while(sourceIndex < sourceLength)\n    {\n        if(patternIndex < patternLength && (sourceString[sourceIndex] == patternString[patternIndex] || patternString[patternIndex] == '?'))\n        {\n            sourceIndex++;\n            patternIndex++;\n        }\n        else if(patternIndex < patternLength && patternString[patternIndex] == '*')\n        {\n            matchIndex= sourceIndex;\n            asteriskIndex= patternIndex++;\n        }\n        else if(asteriskIndex >= 0)\n        {\n            sourceIndex= ++matchIndex;\n            patternIndex= asteriskIndex + 1;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    while(patternIndex < patternLength && patternString[patternIndex] == '*')\n        patternIndex++;\n    return patternIndex == patternLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint jump(vector<int> &nums)\n{\n    int totalJumps= 0, currentEnd= 0, currentFarthest= 0;\n\n    for(int index= 0; index < nums.size() - 1; index++)\n    {\n        currentFarthest= max(currentFarthest, index + nums[index]);\n        if(index == currentEnd)\n        {\n            totalJumps++;\n            currentEnd= currentFarthest;\n        }\n    }\n    return totalJumps;\n}",
    "output": "#include <bits/stdc++.h>\nint jump(std::vector<int> &nums)\n{\n    int totalJumps= 0, currentEnd= 0, currentFarthest= 0;\n\n    for(int index= 0; index < nums.size() - 1; index++)\n    {\n        currentFarthest= std::max(currentFarthest, index + nums[index]);\n        if(index == currentEnd)\n        {\n            totalJumps++;\n            currentEnd= currentFarthest;\n        }\n    }\n    return totalJumps;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generatePermutations(vector<int> &numberList, int currentIndex, vector<vector<int>> &permutations)\n{\n    if(currentIndex == numberList.size() - 1)\n    {\n        permutations.push_back(numberList);\n        return;\n    }\n\n    for(int i= currentIndex; i < numberList.size(); i++)\n    {\n        swap(numberList[currentIndex], numberList[i]);\n        generatePermutations(numberList, currentIndex + 1, permutations);\n        swap(numberList[currentIndex], numberList[i]);\n    }\n}\n\nvector<vector<int>> permute(vector<int> &numberList)\n{\n    vector<vector<int>> permutations;\n    generatePermutations(numberList, 0, permutations);\n    return permutations;\n}",
    "output": "#include <bits/stdc++.h>\nvoid generatePermutations(std::vector<int> &numberList, int currentIndex, std::vector<std::vector<int>> &permutations)\n{\n    if(currentIndex == numberList.size() - 1)\n    {\n        permutations.push_back(numberList);\n        return;\n    }\n\n    for(int i= currentIndex; i < numberList.size(); i++)\n    {\n        std::swap(numberList[currentIndex], numberList[i]);\n        generatePermutations(numberList, currentIndex + 1, permutations);\n        std::swap(numberList[currentIndex], numberList[i]);\n    }\n}\n\nstd::vector<std::vector<int>> permute(std::vector<int> &numberList)\n{\n    std::vector<std::vector<int>> permutations;\n    generatePermutations(numberList, 0, permutations);\n    return permutations;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid backtrack(vector<vector<int>> &permutations, vector<int> &numbers, int startIndex)\n{\n    if(startIndex == numbers.size())\n    {\n        permutations.push_back(numbers);\n        return;\n    }\n    for(int currentIndex= startIndex; currentIndex < numbers.size(); currentIndex++)\n    {\n        if(currentIndex > startIndex && numbers[currentIndex] == numbers[startIndex])\n            continue;\n        swap(numbers[startIndex], numbers[currentIndex]);\n        backtrack(permutations, numbers, startIndex + 1);\n        swap(numbers[startIndex], numbers[currentIndex]);\n    }\n}\n\nvector<vector<int>> permuteUnique(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end());\n    vector<vector<int>> permutations;\n    backtrack(permutations, numbers, 0);\n    return permutations;\n}",
    "output": "#include <bits/stdc++.h>\nvoid backtrack(std::vector<std::vector<int>> &permutations, std::vector<int> &numbers, int startIndex)\n{\n    if(startIndex == numbers.size())\n    {\n        permutations.push_back(numbers);\n        return;\n    }\n    for(int currentIndex= startIndex; currentIndex < numbers.size(); currentIndex++)\n    {\n        if(currentIndex > startIndex && numbers[currentIndex] == numbers[startIndex])\n            continue;\n        std::swap(numbers[startIndex], numbers[currentIndex]);\n        backtrack(permutations, numbers, startIndex + 1);\n        std::swap(numbers[startIndex], numbers[currentIndex]);\n    }\n}\n\nstd::vector<std::vector<int>> permuteUnique(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end());\n    std::vector<std::vector<int>> permutations;\n    backtrack(permutations, numbers, 0);\n    return permutations;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid rotate(vector<vector<int>> &matrix)\n{\n    int size = matrix.size();\n    for(int rowIndex = 0; rowIndex < size / 2; rowIndex++)\n    {\n        for(int columnIndex = rowIndex; columnIndex < size - rowIndex - 1; columnIndex++)\n        {\n            int tempValue = matrix[rowIndex][columnIndex];\n            matrix[rowIndex][columnIndex] = matrix[size - columnIndex - 1][rowIndex];\n            matrix[size - columnIndex - 1][rowIndex] = matrix[size - rowIndex - 1][size - columnIndex - 1];\n            matrix[size - rowIndex - 1][size - columnIndex - 1] = matrix[columnIndex][size - rowIndex - 1];\n            matrix[columnIndex][size - rowIndex - 1] = tempValue;\n        }\n    }\n}",
    "output": "#include <bits/stdc++.h>\nvoid rotate(std::vector<std::vector<int>> &matrix)\n{\n    int size= matrix.size();\n    for(int rowIndex= 0; rowIndex < size / 2; rowIndex++)\n    {\n        for(int columnIndex= rowIndex; columnIndex < size - rowIndex - 1; columnIndex++)\n        {\n            int tempValue= matrix[rowIndex][columnIndex];\n            matrix[rowIndex][columnIndex]= matrix[size - columnIndex - 1][rowIndex];\n            matrix[size - columnIndex - 1][rowIndex]= matrix[size - rowIndex - 1][size - columnIndex - 1];\n            matrix[size - rowIndex - 1][size - columnIndex - 1]= matrix[columnIndex][size - rowIndex - 1];\n            matrix[columnIndex][size - rowIndex - 1]= tempValue;\n        }\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<string>> groupAnagrams(vector<string> &inputStrings)\n{\n    map<string, vector<string>> anagramMap;\n\n    for (int i = 0; i < inputStrings.size(); ++i)\n    {\n        string currentString = inputStrings[i];\n        string sortedKey = currentString;\n        sort(sortedKey.begin(), sortedKey.end());\n        anagramMap[sortedKey].push_back(currentString);\n    }\n\n    vector<vector<string>> anagramGroups;\n    for (auto &entry : anagramMap)\n    {\n        anagramGroups.push_back(entry.second);\n    }\n\n    return anagramGroups;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string> &inputStrings)\n{\n    std::map<std::string, std::vector<std::string>> anagramMap;\n\n    for(std::string currentString : inputStrings)\n    {\n        std::string sortedKey= currentString;\n        std::sort(sortedKey.begin(), sortedKey.end());\n        anagramMap[sortedKey].push_back(currentString);\n    }\n\n    std::vector<std::vector<std::string>> anagramGroups;\n    for(auto &entry : anagramMap)\n    {\n        anagramGroups.push_back(entry.second);\n    }\n\n    return anagramGroups;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "double myPow(double baseValue, int exponentValue)\n{\n    if(exponentValue == 0)\n        return 1;\n    if(exponentValue < 0)\n    {\n        baseValue= 1 / baseValue;\n        exponentValue= -exponentValue;\n    }\n    double resultValue= 1;\n    double currentProductValue= baseValue;\n    for(long long i= exponentValue; i; i/= 2)\n    {\n        if((i % 2) == 1)\n        {\n            resultValue= resultValue * currentProductValue;\n        }\n        currentProductValue= currentProductValue * currentProductValue;\n    }\n    return resultValue;\n}",
    "output": "double myPow(double baseValue, int exponentValue)\n{\n    if(exponentValue == 0)\n        return 1;\n    if(exponentValue < 0)\n    {\n        baseValue= 1 / baseValue;\n        exponentValue= -exponentValue;\n    }\n    double resultValue= 1;\n    double currentProductValue= baseValue;\n    for(long long i= exponentValue; i; i/= 2)\n    {\n        if((i % 2) == 1)\n        {\n            resultValue= resultValue * currentProductValue;\n        }\n        currentProductValue= currentProductValue * currentProductValue;\n    }\n    return resultValue;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isSafe(const vector<string> &chessBoard, int currentRow, int currentCol, int boardSize)\n{\n    for(int i= 0; i < currentCol; ++i)\n    {\n        if(chessBoard[currentRow][i] == 'Q')\n            return false;\n    }\n    for(int i= currentRow, j= currentCol; i >= 0 && j >= 0; --i, --j)\n    {\n        if(chessBoard[i][j] == 'Q')\n            return false;\n    }\n    for(int i= currentRow, j= currentCol; i < boardSize && j >= 0; ++i, --j)\n    {\n        if(chessBoard[i][j] == 'Q')\n            return false;\n    }\n    return true;\n}\n\nvoid solve(vector<vector<string>> &solutions, vector<string> &chessBoard, int boardSize, int currentCol)\n{\n    if(currentCol == boardSize)\n    {\n        solutions.push_back(chessBoard);\n        return;\n    }\n    for(int currentRow= 0; currentRow < boardSize; ++currentRow)\n    {\n        if(isSafe(chessBoard, currentRow, currentCol, boardSize))\n        {\n            chessBoard[currentRow][currentCol]= 'Q';\n            solve(solutions, chessBoard, boardSize, currentCol + 1);\n            chessBoard[currentRow][currentCol]= '.';\n        }\n    }\n}\n\nvector<vector<string>> solveNQueens(int boardSize)\n{\n    vector<vector<string>> solutions;\n    vector<string> chessBoard(boardSize, string(boardSize, '.'));\n    solve(solutions, chessBoard, boardSize, 0);\n    return solutions;\n}",
    "output": "#include <bits/stdc++.h>\nbool isSafe(const std::vector<std::string> &chessBoard, int currentRow, int currentCol, int boardSize)\n{\n    for(int i= 0; i < currentCol; ++i)\n    {\n        if(chessBoard[currentRow][i] == 'Q')\n            return false;\n    }\n    for(int i= currentRow, j= currentCol; i >= 0 && j >= 0; --i, --j)\n    {\n        if(chessBoard[i][j] == 'Q')\n            return false;\n    }\n    for(int i= currentRow, j= currentCol; i < boardSize && j >= 0; ++i, --j)\n    {\n        if(chessBoard[i][j] == 'Q')\n            return false;\n    }\n    return true;\n}\n\nvoid solve(std::vector<std::vector<std::string>> &solutions, std::vector<std::string> &chessBoard, int boardSize, int currentCol)\n{\n    if(currentCol == boardSize)\n    {\n        solutions.push_back(chessBoard);\n        return;\n    }\n    for(int currentRow= 0; currentRow < boardSize; ++currentRow)\n    {\n        if(isSafe(chessBoard, currentRow, currentCol, boardSize))\n        {\n            chessBoard[currentRow][currentCol]= 'Q';\n            solve(solutions, chessBoard, boardSize, currentCol + 1);\n            chessBoard[currentRow][currentCol]= '.';\n        }\n    }\n}\n\nstd::vector<std::vector<std::string>> solveNQueens(int boardSize)\n{\n    std::vector<std::vector<std::string>> solutions;\n    std::vector<std::string> chessBoard(boardSize, std::string(boardSize, '.'));\n    solve(solutions, chessBoard, boardSize, 0);\n    return solutions;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isSafe(vector<int> &columnPositions, int row)\n{\n    int currentColumn= columnPositions.size();\n    for(int i= 0; i < columnPositions.size(); i++)\n    {\n        if(columnPositions[i] == row || abs(i - currentColumn) == abs(columnPositions[i] - row))\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid backtrack(int boardSize, vector<int> &columnPositions, int &solutionCount)\n{\n    if(columnPositions.size() == boardSize)\n    {\n        solutionCount++;\n        return;\n    }\n\n    for(int row= 0; row < boardSize; row++)\n    {\n        if(isSafe(columnPositions, row))\n        {\n            columnPositions.push_back(row);\n            backtrack(boardSize, columnPositions, solutionCount);\n            columnPositions.pop_back();\n        }\n    }\n}\n\nint totalNQueens(int boardSize)\n{\n    vector<int> columnPositions;\n    int solutionCount= 0;\n    backtrack(boardSize, columnPositions, solutionCount);\n    return solutionCount;\n}",
    "output": "#include <bits/stdc++.h>\n// for abs\n\nbool isSafe(std::vector<int> &columnPositions, int row)\n{\n    int currentColumn = columnPositions.size();\n    for(int i = 0; i < columnPositions.size(); i++)\n    {\n        if(columnPositions[i] == row || std::abs(i - currentColumn) == std::abs(columnPositions[i] - row))\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid backtrack(int boardSize, std::vector<int> &columnPositions, int &solutionCount)\n{\n    if(columnPositions.size() == boardSize)\n    {\n        solutionCount++;\n        return;\n    }\n\n    for(int row = 0; row < boardSize; row++)\n    {\n        if(isSafe(columnPositions, row))\n        {\n            columnPositions.push_back(row);\n            backtrack(boardSize, columnPositions, solutionCount);\n            columnPositions.pop_back();\n        }\n    }\n}\n\nint totalNQueens(int boardSize)\n{\n    std::vector<int> columnPositions;\n    int solutionCount = 0;\n    backtrack(boardSize, columnPositions, solutionCount);\n    return solutionCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSubArray(vector<int> &numberArray)\n{\n    int maxSum= numberArray[0];\n    int currentSum= maxSum;\n\n    for(int index= 1; index < numberArray.size(); index++)\n    {\n        currentSum= max(currentSum + numberArray[index], numberArray[index]);\n        maxSum= max(maxSum, currentSum);\n    }\n\n    return maxSum;\n}",
    "output": "#include <bits/stdc++.h>\nint maxSubArray(std::vector<int> &numberArray)\n{\n    int maxSum= numberArray[0];\n    int currentSum= maxSum;\n\n    for(int index= 1; index < numberArray.size(); index++)\n    {\n        currentSum= std::max(currentSum + numberArray[index], numberArray[index]);\n        maxSum= std::max(maxSum, currentSum);\n    }\n\n    return maxSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> spiralOrder(vector<vector<int>> &matrix)\n{\n    vector<int> spiralResult;\n    if(matrix.empty())\n        return spiralResult;\n    int totalRows= matrix.size(), totalCols= matrix[0].size();\n    int rowStartIndex= 0, colStartIndex= 0, rowEndIndex= totalRows - 1, colEndIndex= totalCols - 1;\n\n    while(rowStartIndex <= rowEndIndex && colStartIndex <= colEndIndex)\n    {\n        for(int colIndex= colStartIndex; colIndex <= colEndIndex; ++colIndex)\n        {\n            spiralResult.push_back(matrix[rowStartIndex][colIndex]);\n        }\n        rowStartIndex++;\n        for(int rowIndex= rowStartIndex; rowIndex <= rowEndIndex; ++rowIndex)\n        {\n            spiralResult.push_back(matrix[rowIndex][colEndIndex]);\n        }\n        colEndIndex--;\n        if(rowStartIndex <= rowEndIndex)\n        {\n            for(int colIndex= colEndIndex; colIndex >= colStartIndex; --colIndex)\n            {\n                spiralResult.push_back(matrix[rowEndIndex][colIndex]);\n            }\n        }\n        rowEndIndex--;\n        if(colStartIndex <= colEndIndex)\n        {\n            for(int rowIndex= rowEndIndex; rowIndex >= rowStartIndex; --rowIndex)\n            {\n                spiralResult.push_back(matrix[rowIndex][colStartIndex]);\n            }\n        }\n        colStartIndex++;\n    }\n    return spiralResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> spiralOrder(std::vector<std::vector<int>> &matrix)\n{\n    std::vector<int> spiralResult;\n    if(matrix.empty())\n        return spiralResult;\n    int totalRows= matrix.size(), totalCols= matrix[0].size();\n    int rowStartIndex= 0, colStartIndex= 0, rowEndIndex= totalRows - 1, colEndIndex= totalCols - 1;\n\n    while(rowStartIndex <= rowEndIndex && colStartIndex <= colEndIndex)\n    {\n        for(int colIndex= colStartIndex; colIndex <= colEndIndex; ++colIndex)\n        {\n            spiralResult.push_back(matrix[rowStartIndex][colIndex]);\n        }\n        rowStartIndex++;\n        for(int rowIndex= rowStartIndex; rowIndex <= rowEndIndex; ++rowIndex)\n        {\n            spiralResult.push_back(matrix[rowIndex][colEndIndex]);\n        }\n        colEndIndex--;\n        if(rowStartIndex <= rowEndIndex)\n        {\n            for(int colIndex= colEndIndex; colIndex >= colStartIndex; --colIndex)\n            {\n                spiralResult.push_back(matrix[rowEndIndex][colIndex]);\n            }\n        }\n        rowEndIndex--;\n        if(colStartIndex <= colEndIndex)\n        {\n            for(int rowIndex= rowEndIndex; rowIndex >= rowStartIndex; --rowIndex)\n            {\n                spiralResult.push_back(matrix[rowIndex][colStartIndex]);\n            }\n        }\n        colStartIndex++;\n    }\n    return spiralResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canJump(vector<int> &jumpArray)\n{\n    int maxReach= 0;\n    for(int currentIndex= 0; currentIndex < jumpArray.size(); ++currentIndex)\n    {\n        if(currentIndex > maxReach)\n            return false;\n        maxReach= max(maxReach, currentIndex + jumpArray[currentIndex]);\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool canJump(std::vector<int> &jumpArray)\n{\n    int maxReach= 0;\n    for(int currentIndex= 0; currentIndex < jumpArray.size(); ++currentIndex)\n    {\n        if(currentIndex > maxReach)\n            return false;\n        maxReach= std::max(maxReach, currentIndex + jumpArray[currentIndex]);\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> merge(vector<vector<int>> &intervalList)\n{\n    if(intervalList.empty())\n        return {};\n\n    sort(intervalList.begin(), intervalList.end());\n    vector<vector<int>> mergedIntervals;\n    mergedIntervals.push_back(intervalList[0]);\n\n    for(int currentIndex= 1; currentIndex < intervalList.size(); currentIndex++)\n    {\n        if(mergedIntervals.back()[1] >= intervalList[currentIndex][0])\n        {\n            mergedIntervals.back()[1]= max(mergedIntervals.back()[1], intervalList[currentIndex][1]);\n        }\n        else\n        {\n            mergedIntervals.push_back(intervalList[currentIndex]);\n        }\n    }\n\n    return mergedIntervals;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> merge(std::vector<std::vector<int>> &intervalList)\n{\n    if(intervalList.empty())\n        return {};\n\n    std::sort(intervalList.begin(), intervalList.end());\n    std::vector<std::vector<int>> mergedIntervals;\n    mergedIntervals.push_back(intervalList[0]);\n\n    for(int currentIndex= 1; currentIndex < intervalList.size(); currentIndex++)\n    {\n        if(mergedIntervals.back()[1] >= intervalList[currentIndex][0])\n        {\n            mergedIntervals.back()[1]= std::max(mergedIntervals.back()[1], intervalList[currentIndex][1]);\n        }\n        else\n        {\n            mergedIntervals.push_back(intervalList[currentIndex]);\n        }\n    }\n\n    return mergedIntervals;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> insert(vector<vector<int>> &intervals, vector<int> &newInterval)\n{\n    vector<vector<int>> mergedIntervals;\n    int currentIndex= 0;\n\n    while(currentIndex < intervals.size() && intervals[currentIndex][1] < newInterval[0])\n    {\n        mergedIntervals.push_back(intervals[currentIndex]);\n        currentIndex++;\n    }\n\n    while(currentIndex < intervals.size() && intervals[currentIndex][0] <= newInterval[1])\n    {\n        newInterval[0]= min(newInterval[0], intervals[currentIndex][0]);\n        newInterval[1]= max(newInterval[1], intervals[currentIndex][1]);\n        currentIndex++;\n    }\n\n    mergedIntervals.push_back(newInterval);\n\n    while(currentIndex < intervals.size())\n    {\n        mergedIntervals.push_back(intervals[currentIndex]);\n        currentIndex++;\n    }\n\n    return mergedIntervals;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> insert(std::vector<std::vector<int>> &intervals, std::vector<int> &newInterval)\n{\n    std::vector<std::vector<int>> mergedIntervals;\n    int currentIndex= 0;\n\n    while(currentIndex < intervals.size() && intervals[currentIndex][1] < newInterval[0])\n    {\n        mergedIntervals.push_back(intervals[currentIndex]);\n        currentIndex++;\n    }\n\n    while(currentIndex < intervals.size() && intervals[currentIndex][0] <= newInterval[1])\n    {\n        newInterval[0]= std::min(newInterval[0], intervals[currentIndex][0]);\n        newInterval[1]= std::max(newInterval[1], intervals[currentIndex][1]);\n        currentIndex++;\n    }\n\n    mergedIntervals.push_back(newInterval);\n\n    while(currentIndex < intervals.size())\n    {\n        mergedIntervals.push_back(intervals[currentIndex]);\n        currentIndex++;\n    }\n\n    return mergedIntervals;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint lengthOfLastWord(string inputString)\n{\n    int wordLength= 0;\n    int tailIndex= inputString.length() - 1;\n    while(tailIndex >= 0 && inputString[tailIndex] == ' ')\n        tailIndex--;\n    while(tailIndex >= 0 && inputString[tailIndex] != ' ')\n    {\n        wordLength++;\n        tailIndex--;\n    }\n    return wordLength;\n}",
    "output": "#include <bits/stdc++.h>\nint lengthOfLastWord(std::string inputString)\n{\n    int wordLength= 0;\n    int tailIndex= inputString.length() - 1;\n    while(tailIndex >= 0 && inputString[tailIndex] == ' ')\n        tailIndex--;\n    while(tailIndex >= 0 && inputString[tailIndex] != ' ')\n    {\n        wordLength++;\n        tailIndex--;\n    }\n    return wordLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> generateMatrix(int size)\n{\n    vector<vector<int>> matrix(size, vector<int>(size));\n    int currentValue= 1, topBoundary= 0, bottomBoundary= size - 1, leftBoundary= 0, rightBoundary= size - 1;\n\n    while(currentValue <= size * size)\n    {\n        for(int i= leftBoundary; i <= rightBoundary; i++)\n        {\n            matrix[topBoundary][i]= currentValue++;\n        }\n\n        for(int i= topBoundary + 1; i <= bottomBoundary; i++)\n        {\n            matrix[i][rightBoundary]= currentValue++;\n        }\n\n        if(topBoundary < bottomBoundary && leftBoundary < rightBoundary)\n        {\n            for(int i= rightBoundary - 1; i >= leftBoundary; i--)\n            {\n                matrix[bottomBoundary][i]= currentValue++;\n            }\n\n            for(int i= bottomBoundary - 1; i > topBoundary; i--)\n            {\n                matrix[i][leftBoundary]= currentValue++;\n            }\n        }\n\n        topBoundary++, bottomBoundary--, leftBoundary++, rightBoundary--;\n    }\n\n    return matrix;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> generateMatrix(int size)\n{\n    std::vector<std::vector<int>> matrix(size, std::vector<int>(size));\n    int currentValue= 1, topBoundary= 0, bottomBoundary= size - 1, leftBoundary= 0, rightBoundary= size - 1;\n\n    while(currentValue <= size * size)\n    {\n        for(int i= leftBoundary; i <= rightBoundary; i++)\n        {\n            matrix[topBoundary][i]= currentValue++;\n        }\n\n        for(int i= topBoundary + 1; i <= bottomBoundary; i++)\n        {\n            matrix[i][rightBoundary]= currentValue++;\n        }\n\n        if(topBoundary < bottomBoundary && leftBoundary < rightBoundary)\n        {\n            for(int i= rightBoundary - 1; i >= leftBoundary; i--)\n            {\n                matrix[bottomBoundary][i]= currentValue++;\n            }\n\n            for(int i= bottomBoundary - 1; i > topBoundary; i--)\n            {\n                matrix[i][leftBoundary]= currentValue++;\n            }\n        }\n\n        topBoundary++, bottomBoundary--, leftBoundary++, rightBoundary--;\n    }\n\n    return matrix;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring getPermutation(int totalNumbers, int permutationIndex)\n{\n    vector<int> factorials(totalNumbers, 1);\n    vector<char> numberList(totalNumbers, '1');\n    string result;\n    int index;\n\n    for(int i= 1; i <= totalNumbers; ++i)\n    {\n        numberList[i - 1]+= i - 1;\n        factorials[i - 1]*= i;\n    }\n\n    permutationIndex--;\n\n    for(int i= totalNumbers; i >= 1; --i)\n    {\n        index= permutationIndex / factorials[i - 1];\n        permutationIndex%= factorials[i - 1];\n        result.push_back(numberList[index]);\n        numberList.erase(numberList.begin() + index);\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string getPermutation(int totalNumbers, int permutationIndex)\n{\n    std::vector<int> factorials(totalNumbers, 1);\n    std::vector<char> numberList(totalNumbers, '1');\n    std::string result;\n    int index;\n\n    for(int i= 1; i <= totalNumbers; ++i)\n    {\n        numberList[i - 1]+= i - 1;\n        factorials[i - 1]*= i;\n    }\n\n    permutationIndex--;\n\n    for(int i= totalNumbers; i >= 1; --i)\n    {\n        index= permutationIndex / factorials[i - 1];\n        permutationIndex%= factorials[i - 1];\n        result.push_back(numberList[index]);\n        numberList.erase(numberList.begin() + index);\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *rotateRight(ListNode *head, int rotationCount)\n{\n    if(!head || !head->next || rotationCount == 0)\n        return head;\n\n    ListNode *currentNode= head;\n    int length= 1;\n    while(currentNode->next)\n    {\n        length++;\n        currentNode= currentNode->next;\n    }\n    currentNode->next= head;\n    rotationCount= length - rotationCount % length;\n\n    while(rotationCount--)\n    {\n        currentNode= currentNode->next;\n    }\n    head= currentNode->next;\n    currentNode->next= NULL;\n\n    return head;\n}",
    "output": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *rotateRight(ListNode *head, int rotationCount)\n{\n    if(!head || !head->next || rotationCount == 0)\n        return head;\n\n    ListNode *currentNode= head;\n    int length= 1;\n    while(currentNode->next)\n    {\n        length++;\n        currentNode= currentNode->next;\n    }\n    currentNode->next= head;\n    rotationCount= length - rotationCount % length;\n\n    while(rotationCount--)\n    {\n        currentNode= currentNode->next;\n    }\n    head= currentNode->next;\n    currentNode->next= NULL;\n\n    return head;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint uniquePaths(int rows, int columns)\n{\n    vector<vector<int>> dynamicProgramming(rows, vector<int>(columns, 1));\n    for(int rowIndex= 1; rowIndex < rows; rowIndex++)\n    {\n        for(int columnIndex= 1; columnIndex < columns; columnIndex++)\n        {\n            dynamicProgramming[rowIndex][columnIndex]= dynamicProgramming[rowIndex - 1][columnIndex] + dynamicProgramming[rowIndex][columnIndex - 1];\n        }\n    }\n    return dynamicProgramming[rows - 1][columns - 1];\n}",
    "output": "#include <bits/stdc++.h>\nint uniquePaths(int rows, int columns)\n{\n    std::vector<std::vector<int>> dynamicProgramming(rows, std::vector<int>(columns, 1));\n    for(int rowIndex= 1; rowIndex < rows; rowIndex++)\n    {\n        for(int columnIndex= 1; columnIndex < columns; columnIndex++)\n        {\n            dynamicProgramming[rowIndex][columnIndex]= dynamicProgramming[rowIndex - 1][columnIndex] + dynamicProgramming[rowIndex][columnIndex - 1];\n        }\n    }\n    return dynamicProgramming[rows - 1][columns - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint uniquePathsWithObstacles(vector<vector<int>> &obstacleGrid)\n{\n    int rowCount = obstacleGrid.size();\n    int colCount = obstacleGrid[0].size();\n    if(obstacleGrid[0][0] == 1)\n        return 0;\n\n    obstacleGrid[0][0] = 1;\n    for(int rowIndex = 1; rowIndex < rowCount; ++rowIndex)\n        obstacleGrid[rowIndex][0] = (obstacleGrid[rowIndex][0] == 0 && obstacleGrid[rowIndex - 1][0] == 1) ? 1 : 0;\n    for(int colIndex = 1; colIndex < colCount; ++colIndex)\n        obstacleGrid[0][colIndex] = (obstacleGrid[0][colIndex] == 0 && obstacleGrid[0][colIndex - 1] == 1) ? 1 : 0;\n\n    for(int rowIndex = 1; rowIndex < rowCount; ++rowIndex)\n        for(int colIndex = 1; colIndex < colCount; ++colIndex)\n            if(obstacleGrid[rowIndex][colIndex] == 0)\n                obstacleGrid[rowIndex][colIndex] = obstacleGrid[rowIndex - 1][colIndex] + obstacleGrid[rowIndex][colIndex - 1];\n            else\n                obstacleGrid[rowIndex][colIndex] = 0;\n\n    return obstacleGrid[rowCount - 1][colCount - 1];\n}",
    "output": "#include <bits/stdc++.h>\nint uniquePathsWithObstacles(std::vector<std::vector<int>> &obstacleGrid)\n{\n    int rowCount= obstacleGrid.size();\n    int colCount= obstacleGrid[0].size();\n    if(obstacleGrid[0][0] == 1)\n        return 0;\n\n    obstacleGrid[0][0]= 1;\n    for(int rowIndex= 1; rowIndex < rowCount; ++rowIndex)\n        obstacleGrid[rowIndex][0]= (obstacleGrid[rowIndex][0] == 0 && obstacleGrid[rowIndex - 1][0] == 1) ? 1 : 0;\n    for(int colIndex= 1; colIndex < colCount; ++colIndex)\n        obstacleGrid[0][colIndex]= (obstacleGrid[0][colIndex] == 0 && obstacleGrid[0][colIndex - 1] == 1) ? 1 : 0;\n\n    for(int rowIndex= 1; rowIndex < rowCount; ++rowIndex)\n        for(int colIndex= 1; colIndex < colCount; ++colIndex)\n            if(obstacleGrid[rowIndex][colIndex] == 0)\n                obstacleGrid[rowIndex][colIndex]= obstacleGrid[rowIndex - 1][colIndex] + obstacleGrid[rowIndex][colIndex - 1];\n            else\n                obstacleGrid[rowIndex][colIndex]= 0;\n\n    return obstacleGrid[rowCount - 1][colCount - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minPathSum(vector<vector<int>> &grid)\n{\n    int rowCount= grid.size(), columnCount= grid[0].size();\n\n    for(int rowIndex= 1; rowIndex < rowCount; rowIndex++)\n        grid[rowIndex][0]+= grid[rowIndex - 1][0];\n\n    for(int columnIndex= 1; columnIndex < columnCount; columnIndex++)\n        grid[0][columnIndex]+= grid[0][columnIndex - 1];\n\n    for(int rowIndex= 1; rowIndex < rowCount; rowIndex++)\n    {\n        for(int columnIndex= 1; columnIndex < columnCount; columnIndex++)\n        {\n            grid[rowIndex][columnIndex]+= min(grid[rowIndex - 1][columnIndex], grid[rowIndex][columnIndex - 1]);\n        }\n    }\n    return grid[rowCount - 1][columnCount - 1];\n}",
    "output": "#include <bits/stdc++.h>\nint minPathSum(std::vector<std::vector<int>> &grid)\n{\n    int rowCount = grid.size(), columnCount = grid[0].size();\n\n    for(int rowIndex = 1; rowIndex < rowCount; rowIndex++)\n        grid[rowIndex][0] += grid[rowIndex - 1][0];\n\n    for(int columnIndex = 1; columnIndex < columnCount; columnIndex++)\n        grid[0][columnIndex] += grid[0][columnIndex - 1];\n\n    for(int rowIndex = 1; rowIndex < rowCount; rowIndex++)\n    {\n        for(int columnIndex = 1; columnIndex < columnCount; columnIndex++)\n        {\n            grid[rowIndex][columnIndex] += std::min(grid[rowIndex - 1][columnIndex], grid[rowIndex][columnIndex - 1]);\n        }\n    }\n    return grid[rowCount - 1][columnCount - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isNumber(const string &inputString)\n{\n    regex numberPattern(\"^[-+]?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(e[-+]?[0-9]+)?$\");\n    return regex_match(inputString, numberPattern);\n}",
    "output": "#include <bits/stdc++.h>\nbool isNumber(const std::string &inputString)\n{\n    std::regex numberPattern(\"^[-+]?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(e[-+]?[0-9]+)?$\");\n    return std::regex_match(inputString, numberPattern);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> plusOne(vector<int> &digits)\n{\n    int numberOfDigits = digits.size();\n\n    for(int index = numberOfDigits - 1; index >= 0; index--)\n    {\n        if(digits[index] < 9)\n        {\n            digits[index]++;\n            return digits;\n        }\n        digits[index] = 0;\n    }\n\n    digits.insert(digits.begin(), 1);\n    return digits;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> plusOne(std::vector<int> &digits)\n{\n    int numberOfDigits= digits.size();\n\n    for(int index= numberOfDigits - 1; index >= 0; index--)\n    {\n        if(digits[index] < 9)\n        {\n            digits[index]++;\n            return digits;\n        }\n        digits[index]= 0;\n    }\n\n    digits.insert(digits.begin(), 1);\n    return digits;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "using namespace std;\n\nstring addBinary(string binaryA, string binaryB)\n{\n    string binaryResult = \"\";\n    int indexA = binaryA.size() - 1, indexB = binaryB.size() - 1, carry = 0;\n    while(indexA >= 0 || indexB >= 0 || carry)\n    {\n        if(indexA >= 0)\n            carry += binaryA[indexA--] - '0';\n        if(indexB >= 0)\n            carry += binaryB[indexB--] - '0';\n        binaryResult = char(carry % 2 + '0') + binaryResult;\n        carry /= 2;\n    }\n    return binaryResult;\n}",
    "output": "std::string addBinary(std::string binaryA, std::string binaryB)\n{\n    std::string binaryResult= \"\";\n    int indexA= binaryA.size() - 1, indexB= binaryB.size() - 1, carry= 0;\n    while(indexA >= 0 || indexB >= 0 || carry)\n    {\n        if(indexA >= 0)\n            carry+= binaryA[indexA--] - '0';\n        if(indexB >= 0)\n            carry+= binaryB[indexB--] - '0';\n        binaryResult= char(carry % 2 + '0') + binaryResult;\n        carry/= 2;\n    }\n    return binaryResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> fullJustify(vector<string> &words, int maxWidth)\n{\n    vector<string> justifiedText;\n    int currentIndex= 0;\n    while(currentIndex < words.size())\n    {\n        int totalCharacters= words[currentIndex].size();\n        int lastIndex= currentIndex + 1;\n        while(lastIndex < words.size())\n        {\n            if(totalCharacters + 1 + words[lastIndex].length() > maxWidth)\n                break;\n            totalCharacters+= 1 + words[lastIndex].length();\n            lastIndex++;\n        }\n        int gaps= lastIndex - currentIndex - 1;\n        stringstream lineStream;\n        if(lastIndex == words.size() || gaps == 0)\n        {\n            for(int i= currentIndex; i < lastIndex; i++)\n            {\n                lineStream << words[i];\n                if(i < lastIndex - 1)\n                    lineStream << \" \";\n            }\n            lineStream << string(maxWidth - lineStream.str().size(), ' ');\n        }\n        else\n        {\n            int evenSpaces= (maxWidth - totalCharacters) / gaps;\n            int extraSpaces= (maxWidth - totalCharacters) % gaps;\n            for(int i= currentIndex; i < lastIndex; i++)\n            {\n                lineStream << words[i];\n                if(i < lastIndex - 1)\n                {\n                    lineStream << string(evenSpaces + (i - currentIndex < extraSpaces ? 1 : 0), ' ');\n                }\n            }\n        }\n        currentIndex= lastIndex;\n        justifiedText.push_back(lineStream.str());\n    }\n    return justifiedText;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> fullJustify(std::vector<std::string> &words, int maxWidth)\n{\n    std::vector<std::string> justifiedText;\n    int currentIndex= 0;\n    while(currentIndex < words.size())\n    {\n        int totalCharacters= words[currentIndex].size();\n        int lastIndex= currentIndex + 1;\n        while(lastIndex < words.size())\n        {\n            if(totalCharacters + 1 + words[lastIndex].length() > maxWidth)\n                break;\n            totalCharacters+= 1 + words[lastIndex].length();\n            lastIndex++;\n        }\n        int gaps= lastIndex - currentIndex - 1;\n        std::stringstream lineStream;\n        if(lastIndex == words.size() || gaps == 0)\n        {\n            for(int i= currentIndex; i < lastIndex; i++)\n            {\n                lineStream << words[i];\n                if(i < lastIndex - 1)\n                    lineStream << \" \";\n            }\n            lineStream << std::string(maxWidth - lineStream.str().size(), ' ');\n        }\n        else\n        {\n            int evenSpaces= (maxWidth - totalCharacters) / gaps;\n            int extraSpaces= (maxWidth - totalCharacters) % gaps;\n            for(int i= currentIndex; i < lastIndex; i++)\n            {\n                lineStream << words[i];\n                if(i < lastIndex - 1)\n                {\n                    lineStream << std::string(evenSpaces + (i - currentIndex < extraSpaces ? 1 : 0), ' ');\n                }\n            }\n        }\n        currentIndex= lastIndex;\n        justifiedText.push_back(lineStream.str());\n    }\n    return justifiedText;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int calculateSquareRoot(int inputNumber)\n{\n    if(inputNumber == 0 || inputNumber == 1)\n        return inputNumber;\n    int lowerBound= 1, upperBound= inputNumber, squareRoot;\n    while(lowerBound <= upperBound)\n    {\n        int middle= (lowerBound + upperBound) / 2;\n        if(middle * middle == inputNumber)\n            return middle;\n        if(middle * middle < inputNumber)\n        {\n            lowerBound= middle + 1;\n            squareRoot= middle;\n        }\n        else\n        {\n            upperBound= middle - 1;\n        }\n    }\n    return squareRoot;\n}",
    "output": "int calculateSquareRoot(int inputNumber)\n{\n    if(inputNumber == 0 || inputNumber == 1)\n        return inputNumber;\n    int lowerBound= 1, upperBound= inputNumber, squareRoot;\n    while(lowerBound <= upperBound)\n    {\n        int middle= (lowerBound + upperBound) / 2;\n        if(middle * middle == inputNumber)\n            return middle;\n        if(middle * middle < inputNumber)\n        {\n            lowerBound= middle + 1;\n            squareRoot= middle;\n        }\n        else\n        {\n            upperBound= middle - 1;\n        }\n    }\n    return squareRoot;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int climbStairs(int totalSteps)\n{\n    if(totalSteps <= 2)\n        return totalSteps;\n    int previousStep= 1, currentStep= 2, nextStep;\n    for(int stepIndex= 3; stepIndex <= totalSteps; stepIndex++)\n    {\n        nextStep= previousStep + currentStep;\n        previousStep= currentStep;\n        currentStep= nextStep;\n    }\n    return nextStep;\n}",
    "output": "int climbStairs(int totalSteps)\n{\n    if(totalSteps <= 2)\n        return totalSteps;\n    int previousStep= 1, currentStep= 2, nextStep;\n    for(int stepIndex= 3; stepIndex <= totalSteps; stepIndex++)\n    {\n        nextStep= previousStep + currentStep;\n        previousStep= currentStep;\n        currentStep= nextStep;\n    }\n    return nextStep;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring simplifyPath(string inputPath)\n{\n    vector<string> pathStack;\n    istringstream pathStream{inputPath};\n    string pathPiece;\n\n    while(getline(pathStream, pathPiece, '/'))\n    {\n        if(pathPiece.empty() || pathPiece == \".\")\n            continue;\n        if(pathPiece == \"..\")\n        {\n            if(!pathStack.empty())\n                pathStack.pop_back();\n        }\n        else\n        {\n            pathStack.push_back(pathPiece);\n        }\n    }\n\n    string canonicalPath;\n    for (int i = 0; i < pathStack.size(); ++i)\n    {\n        canonicalPath += '/' + pathStack[i];\n    }\n    return pathStack.empty() ? \"/\" : canonicalPath;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string simplifyPath(std::string inputPath)\n{\n    std::vector<std::string> pathStack;\n    std::istringstream pathStream{inputPath};\n    std::string pathPiece;\n\n    while(std::getline(pathStream, pathPiece, '/'))\n    {\n        if(pathPiece.empty() || pathPiece == \".\")\n            continue;\n        if(pathPiece == \"..\")\n        {\n            if(!pathStack.empty())\n                pathStack.pop_back();\n        }\n        else\n        {\n            pathStack.push_back(pathPiece);\n        }\n    }\n\n    std::string canonicalPath;\n    for(const auto &pathElement : pathStack)\n    {\n        canonicalPath+= '/' + pathElement;\n    }\n    return pathStack.empty() ? \"/\" : canonicalPath;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minDistance(string sourceWord, string targetWord)\n{\n    int sourceLength = sourceWord.size();\n    int targetLength = targetWord.size();\n    vector<vector<int>> distanceMatrix(sourceLength + 1, vector<int>(targetLength + 1, 0));\n\n    for(int sourceIndex = 0; sourceIndex <= sourceLength; sourceIndex++)\n    {\n        for(int targetIndex = 0; targetIndex <= targetLength; targetIndex++)\n        {\n            if(sourceIndex == 0)\n            {\n                distanceMatrix[sourceIndex][targetIndex] = targetIndex;\n            }\n            else if(targetIndex == 0)\n            {\n                distanceMatrix[sourceIndex][targetIndex] = sourceIndex;\n            }\n            else if(sourceWord[sourceIndex - 1] == targetWord[targetIndex - 1])\n            {\n                distanceMatrix[sourceIndex][targetIndex] = distanceMatrix[sourceIndex - 1][targetIndex - 1];\n            }\n            else\n            {\n                distanceMatrix[sourceIndex][targetIndex] = min(min(distanceMatrix[sourceIndex - 1][targetIndex], distanceMatrix[sourceIndex][targetIndex - 1]), distanceMatrix[sourceIndex - 1][targetIndex - 1]) + 1;\n            }\n        }\n    }\n\n    return distanceMatrix[sourceLength][targetLength];\n}",
    "output": "#include <bits/stdc++.h>\nint minDistance(std::string sourceWord, std::string targetWord)\n{\n    int sourceLength= sourceWord.size();\n    int targetLength= targetWord.size();\n    std::vector<std::vector<int>> distanceMatrix(sourceLength + 1, std::vector<int>(targetLength + 1, 0));\n\n    for(int sourceIndex= 0; sourceIndex <= sourceLength; sourceIndex++)\n    {\n        for(int targetIndex= 0; targetIndex <= targetLength; targetIndex++)\n        {\n            if(sourceIndex == 0)\n            {\n                distanceMatrix[sourceIndex][targetIndex]= targetIndex;\n            }\n            else if(targetIndex == 0)\n            {\n                distanceMatrix[sourceIndex][targetIndex]= sourceIndex;\n            }\n            else if(sourceWord[sourceIndex - 1] == targetWord[targetIndex - 1])\n            {\n                distanceMatrix[sourceIndex][targetIndex]= distanceMatrix[sourceIndex - 1][targetIndex - 1];\n            }\n            else\n            {\n                distanceMatrix[sourceIndex][targetIndex]= std::min(std::min(distanceMatrix[sourceIndex - 1][targetIndex], distanceMatrix[sourceIndex][targetIndex - 1]), distanceMatrix[sourceIndex - 1][targetIndex - 1]) + 1;\n            }\n        }\n    }\n\n    return distanceMatrix[sourceLength][targetLength];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid setZeroes(vector<vector<int>> &matrix)\n{\n    int totalRows= matrix.size();\n    int totalCols= matrix[0].size();\n    bool isFirstRowZero= false, isFirstColZero= false;\n\n    for(int rowIndex= 0; rowIndex < totalRows; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < totalCols; colIndex++)\n        {\n            if(matrix[rowIndex][colIndex] == 0)\n            {\n                if(rowIndex == 0)\n                    isFirstRowZero= true;\n                if(colIndex == 0)\n                    isFirstColZero= true;\n                matrix[rowIndex][0]= 0;\n                matrix[0][colIndex]= 0;\n            }\n        }\n    }\n\n    for(int rowIndex= 1; rowIndex < totalRows; rowIndex++)\n    {\n        for(int colIndex= 1; colIndex < totalCols; colIndex++)\n        {\n            if(matrix[rowIndex][0] == 0 || matrix[0][colIndex] == 0)\n                matrix[rowIndex][colIndex]= 0;\n        }\n    }\n\n    if(isFirstRowZero)\n    {\n        for(int colIndex= 0; colIndex < totalCols; colIndex++)\n            matrix[0][colIndex]= 0;\n    }\n\n    if(isFirstColZero)\n    {\n        for(int rowIndex= 0; rowIndex < totalRows; rowIndex++)\n            matrix[rowIndex][0]= 0;\n    }\n}",
    "output": "#include <bits/stdc++.h>\nvoid setZeroes(std::vector<std::vector<int>> &matrix)\n{\n    int totalRows= matrix.size();\n    int totalCols= matrix[0].size();\n    bool isFirstRowZero= false, isFirstColZero= false;\n\n    for(int rowIndex= 0; rowIndex < totalRows; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < totalCols; colIndex++)\n        {\n            if(matrix[rowIndex][colIndex] == 0)\n            {\n                if(rowIndex == 0)\n                    isFirstRowZero= true;\n                if(colIndex == 0)\n                    isFirstColZero= true;\n                matrix[rowIndex][0]= 0;\n                matrix[0][colIndex]= 0;\n            }\n        }\n    }\n\n    for(int rowIndex= 1; rowIndex < totalRows; rowIndex++)\n    {\n        for(int colIndex= 1; colIndex < totalCols; colIndex++)\n        {\n            if(matrix[rowIndex][0] == 0 || matrix[0][colIndex] == 0)\n                matrix[rowIndex][colIndex]= 0;\n        }\n    }\n\n    if(isFirstRowZero)\n    {\n        for(int colIndex= 0; colIndex < totalCols; colIndex++)\n            matrix[0][colIndex]= 0;\n    }\n\n    if(isFirstColZero)\n    {\n        for(int rowIndex= 0; rowIndex < totalRows; rowIndex++)\n            matrix[rowIndex][0]= 0;\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool searchMatrix(vector<vector<int>> &matrix, int target)\n{\n    int rowCount= matrix.size();\n    if (rowCount == 0) return false; // Check if the matrix is empty\n    int columnCount= matrix[0].size();\n    int leftIndex= 0, rightIndex= rowCount * columnCount - 1;\n\n    while(leftIndex <= rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        int midValue= matrix[midIndex / columnCount][midIndex % columnCount];\n\n        if(midValue == target)\n        {\n            return true;\n        }\n        else if(midValue < target)\n        {\n            leftIndex= midIndex + 1;\n        }\n        else\n        {\n            rightIndex= midIndex - 1;\n        }\n    }\n\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool searchMatrix(std::vector<std::vector<int>> &matrix, int target)\n{\n    int rowCount= matrix.size();\n    int columnCount= matrix[0].size();\n    int leftIndex= 0, rightIndex= rowCount * columnCount - 1;\n\n    while(leftIndex <= rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        int midValue= matrix[midIndex / columnCount][midIndex % columnCount];\n\n        if(midValue == target)\n        {\n            return true;\n        }\n        else if(midValue < target)\n        {\n            leftIndex= midIndex + 1;\n        }\n        else\n        {\n            rightIndex= midIndex - 1;\n        }\n    }\n\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For std::swap\nusing namespace std;\n\nvoid sortColors(vector<int> &colorArray)\n{\n    int redIndex= 0, whiteIndex= 0, blueIndex= colorArray.size() - 1;\n    while(whiteIndex <= blueIndex)\n    {\n        if(colorArray[whiteIndex] == 0)\n        {\n            swap(colorArray[redIndex++], colorArray[whiteIndex++]);\n        }\n        else if(colorArray[whiteIndex] == 1)\n        {\n            whiteIndex++;\n        }\n        else\n        {\n            swap(colorArray[whiteIndex], colorArray[blueIndex--]);\n        }\n    }\n}",
    "output": "#include <bits/stdc++.h>\n// for std::swap\n\nvoid sortColors(std::vector<int> &colorArray)\n{\n    int redIndex= 0, whiteIndex= 0, blueIndex= colorArray.size() - 1;\n    while(whiteIndex <= blueIndex)\n    {\n        if(colorArray[whiteIndex] == 0)\n        {\n            std::swap(colorArray[redIndex++], colorArray[whiteIndex++]);\n        }\n        else if(colorArray[whiteIndex] == 1)\n        {\n            whiteIndex++;\n        }\n        else\n        {\n            std::swap(colorArray[whiteIndex], colorArray[blueIndex--]);\n        }\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring minWindow(string sourceString, string targetString)\n{\n    unordered_map<char, int> requiredChars, currentWin;\n    for (int i = 0; i < targetString.size(); ++i)\n    {\n        char character = targetString[i];\n        requiredChars[character]++;\n    }\n\n    int leftPtr = 0, rightPtr = 0;\n    int validCharCount = 0;\n    int windowStart = 0, minLength = INT_MAX;\n\n    while (rightPtr < sourceString.length())\n    {\n        char currentChar = sourceString[rightPtr];\n        rightPtr++;\n        if (requiredChars.count(currentChar))\n        {\n            currentWin[currentChar]++;\n            if (currentWin[currentChar] <= requiredChars[currentChar])\n                validCharCount++;\n        }\n\n        while (validCharCount == targetString.length())\n        {\n            if (rightPtr - leftPtr < minLength)\n            {\n                windowStart = leftPtr;\n                minLength = rightPtr - leftPtr;\n            }\n\n            char leftChar = sourceString[leftPtr];\n            leftPtr++;\n            if (requiredChars.count(leftChar))\n            {\n                if (currentWin[leftChar] <= requiredChars[leftChar])\n                    validCharCount--;\n                currentWin[leftChar]--;\n            }\n        }\n    }\n    return minLength == INT_MAX ? \"\" : sourceString.substr(windowStart, minLength);\n}",
    "output": "#include <bits/stdc++.h>\nstd::string minWindow(std::string sourceString, std::string targetString)\n{\n    std::unordered_map<char, int> requiredChars, currentWin;\n    for(char character : targetString)\n        requiredChars[character]++;\n\n    int leftPtr= 0, rightPtr= 0;\n    int validCharCount= 0;\n    int windowStart= 0, minLength= INT_MAX;\n\n    while(rightPtr < sourceString.length())\n    {\n        char currentChar= sourceString[rightPtr];\n        rightPtr++;\n        if(requiredChars.count(currentChar))\n        {\n            currentWin[currentChar]++;\n            if(currentWin[currentChar] <= requiredChars[currentChar])\n                validCharCount++;\n        }\n\n        while(validCharCount == targetString.length())\n        {\n            if(rightPtr - leftPtr < minLength)\n            {\n                windowStart= leftPtr;\n                minLength= rightPtr - leftPtr;\n            }\n\n            char leftChar= sourceString[leftPtr];\n            leftPtr++;\n            if(requiredChars.count(leftChar))\n            {\n                if(currentWin[leftChar] <= requiredChars[leftChar])\n                    validCharCount--;\n                currentWin[leftChar]--;\n            }\n        }\n    }\n    return minLength == INT_MAX ? \"\" : sourceString.substr(windowStart, minLength);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid backtrack(int totalNumbers, int combinationSize, int startIndex, vector<int> &currentCombination, vector<vector<int>> &allCombinations)\n{\n    if(currentCombination.size() == combinationSize)\n    {\n        allCombinations.push_back(currentCombination);\n        return;\n    }\n\n    for(int i= startIndex; i <= totalNumbers; ++i)\n    {\n        currentCombination.push_back(i);\n        backtrack(totalNumbers, combinationSize, i + 1, currentCombination, allCombinations);\n        currentCombination.pop_back();\n    }\n}\n\nvector<vector<int>> combine(int totalNumbers, int combinationSize)\n{\n    vector<vector<int>> allCombinations;\n    vector<int> currentCombination;\n    backtrack(totalNumbers, combinationSize, 1, currentCombination, allCombinations);\n    return allCombinations;\n}",
    "output": "#include <bits/stdc++.h>\nvoid backtrack(int totalNumbers, int combinationSize, int startIndex, std::vector<int> &currentCombination, std::vector<std::vector<int>> &allCombinations)\n{\n    if(currentCombination.size() == combinationSize)\n    {\n        allCombinations.push_back(currentCombination);\n        return;\n    }\n\n    for(int i= startIndex; i <= totalNumbers; ++i)\n    {\n        currentCombination.push_back(i);\n        backtrack(totalNumbers, combinationSize, i + 1, currentCombination, allCombinations);\n        currentCombination.pop_back();\n    }\n}\n\nstd::vector<std::vector<int>> combine(int totalNumbers, int combinationSize)\n{\n    std::vector<std::vector<int>> allCombinations;\n    std::vector<int> currentCombination;\n    backtrack(totalNumbers, combinationSize, 1, currentCombination, allCombinations);\n    return allCombinations;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> generateSubsets(vector<int> &inputNumbers)\n{\n    vector<vector<int>> subsetResults;\n    int totalNumbers = inputNumbers.size();\n    int totalSubsets = 1 << totalNumbers;\n\n    for(int subsetIndex = 0; subsetIndex < totalSubsets; ++subsetIndex)\n    {\n        vector<int> currentSubset;\n        for(int numberIndex = 0; numberIndex < totalNumbers; ++numberIndex)\n        {\n            if(subsetIndex & (1 << numberIndex))\n            {\n                currentSubset.push_back(inputNumbers[numberIndex]);\n            }\n        }\n        subsetResults.push_back(currentSubset);\n    }\n    return subsetResults;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> generateSubsets(std::vector<int> &inputNumbers)\n{\n    std::vector<std::vector<int>> subsetResults;\n    int totalNumbers= inputNumbers.size();\n    int totalSubsets= 1 << totalNumbers;\n\n    for(int subsetIndex= 0; subsetIndex < totalSubsets; ++subsetIndex)\n    {\n        std::vector<int> currentSubset;\n        for(int numberIndex= 0; numberIndex < totalNumbers; ++numberIndex)\n        {\n            if(subsetIndex & (1 << numberIndex))\n            {\n                currentSubset.push_back(inputNumbers[numberIndex]);\n            }\n        }\n        subsetResults.push_back(currentSubset);\n    }\n    return subsetResults;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool exist(vector<vector<char>> &board, string word)\n{\n    int rowCount= board.size();\n    int colCount= board[0].size();\n\n    function<bool(int, int, int)> dfs= [&](int row, int col, int wordIndex)\n    {\n        if(row < 0 || row >= rowCount || col < 0 || col >= colCount || board[row][col] != word[wordIndex])\n            return false;\n        if(wordIndex == word.length() - 1)\n            return true;\n\n        char temp= board[row][col];\n        board[row][col]= '/';\n        bool result= dfs(row + 1, col, wordIndex + 1) || dfs(row - 1, col, wordIndex + 1) || dfs(row, col + 1, wordIndex + 1) || dfs(row, col - 1, wordIndex + 1);\n        board[row][col]= temp;\n        return result;\n    };\n\n    for(int row= 0; row < rowCount; row++)\n        for(int col= 0; col < colCount; col++)\n            if(dfs(row, col, 0))\n                return true;\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool exist(std::vector<std::vector<char>> &board, std::string word)\n{\n    int rowCount= board.size();\n    int colCount= board[0].size();\n\n    std::function<bool(int, int, int)> dfs= [&](int row, int col, int wordIndex)\n    {\n        if(row < 0 || row >= rowCount || col < 0 || col >= colCount || board[row][col] != word[wordIndex])\n            return false;\n        if(wordIndex == word.length() - 1)\n            return true;\n\n        char temp= board[row][col];\n        board[row][col]= '/';\n        bool result= dfs(row + 1, col, wordIndex + 1) || dfs(row - 1, col, wordIndex + 1) || dfs(row, col + 1, wordIndex + 1) || dfs(row, col - 1, wordIndex + 1);\n        board[row][col]= temp;\n        return result;\n    };\n\n    for(int row= 0; row < rowCount; row++)\n        for(int col= 0; col < colCount; col++)\n            if(dfs(row, col, 0))\n                return true;\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint removeDuplicates(vector<int> &numberList)\n{\n    int currentIndex = 0;\n    for (int i = 0; i < numberList.size(); ++i)\n    {\n        int currentNumber = numberList[i];\n        if (currentIndex < 2 || currentNumber > numberList[currentIndex - 2])\n        {\n            numberList[currentIndex++] = currentNumber;\n        }\n    }\n    return currentIndex;\n}",
    "output": "#include <bits/stdc++.h>\nint removeDuplicates(std::vector<int> &numberList)\n{\n    int currentIndex= 0;\n    for(int currentNumber : numberList)\n    {\n        if(currentIndex < 2 || currentNumber > numberList[currentIndex - 2])\n        {\n            numberList[currentIndex++]= currentNumber;\n        }\n    }\n    return currentIndex;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool search(vector<int> &numberArray, int targetValue)\n{\n    int leftIndex= 0, rightIndex= numberArray.size() - 1;\n    while(leftIndex <= rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(numberArray[midIndex] == targetValue)\n            return true;\n\n        if(numberArray[midIndex] == numberArray[leftIndex])\n        {\n            leftIndex++;\n        }\n        else if(numberArray[midIndex] > numberArray[leftIndex])\n        {\n            if(numberArray[leftIndex] <= targetValue && targetValue < numberArray[midIndex])\n            {\n                rightIndex= midIndex - 1;\n            }\n            else\n            {\n                leftIndex= midIndex + 1;\n            }\n        }\n        else\n        {\n            if(numberArray[midIndex] < targetValue && targetValue <= numberArray[rightIndex])\n            {\n                leftIndex= midIndex + 1;\n            }\n            else\n            {\n                rightIndex= midIndex - 1;\n            }\n        }\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool search(std::vector<int> &numberArray, int targetValue)\n{\n    int leftIndex= 0, rightIndex= numberArray.size() - 1;\n    while(leftIndex <= rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(numberArray[midIndex] == targetValue)\n            return true;\n\n        if(numberArray[midIndex] == numberArray[leftIndex])\n        {\n            leftIndex++;\n        }\n        else if(numberArray[midIndex] > numberArray[leftIndex])\n        {\n            if(numberArray[leftIndex] <= targetValue && targetValue < numberArray[midIndex])\n            {\n                rightIndex= midIndex - 1;\n            }\n            else\n            {\n                leftIndex= midIndex + 1;\n            }\n        }\n        else\n        {\n            if(numberArray[midIndex] < targetValue && targetValue <= numberArray[rightIndex])\n            {\n                leftIndex= midIndex + 1;\n            }\n            else\n            {\n                rightIndex= midIndex - 1;\n            }\n        }\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *deleteDuplicates(ListNode *head)\n{\n    ListNode dummyNode(0);\n    dummyNode.next= head;\n    ListNode *previousNode= &dummyNode, *currentNode= head;\n    while(currentNode)\n    {\n        while(currentNode->next && currentNode->value == currentNode->next->value)\n            currentNode= currentNode->next;\n        if(previousNode->next == currentNode)\n            previousNode= previousNode->next;\n        else\n            previousNode->next= currentNode->next;\n        currentNode= currentNode->next;\n    }\n    return dummyNode.next;\n}",
    "output": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *deleteDuplicates(ListNode *head)\n{\n    ListNode dummyNode(0);\n    dummyNode.next= head;\n    ListNode *previousNode= &dummyNode, *currentNode= head;\n    while(currentNode)\n    {\n        while(currentNode->next && currentNode->value == currentNode->next->value)\n            currentNode= currentNode->next;\n        if(previousNode->next == currentNode)\n            previousNode= previousNode->next;\n        else\n            previousNode->next= currentNode->next;\n        currentNode= currentNode->next;\n    }\n    return dummyNode.next;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct ListNode\n{\n    int value;\n    ListNode *nextNode;\n    ListNode(int x) : value(x), nextNode(NULL) {}\n};\n\nListNode *deleteDuplicates(ListNode *head)\n{\n    ListNode *currentNode= head;\n    while(currentNode && currentNode->nextNode)\n    {\n        if(currentNode->nextNode->value == currentNode->value)\n        {\n            ListNode *tempNode= currentNode->nextNode;\n            currentNode->nextNode= tempNode->nextNode;\n            delete tempNode;\n        }\n        else\n        {\n            currentNode= currentNode->nextNode;\n        }\n    }\n    return head;\n}",
    "output": "struct ListNode\n{\n    int value;\n    ListNode *nextNode;\n    ListNode(int x) : value(x), nextNode(NULL) {}\n};\n\nListNode *deleteDuplicates(ListNode *head)\n{\n    ListNode *currentNode= head;\n    while(currentNode && currentNode->nextNode)\n    {\n        if(currentNode->nextNode->value == currentNode->value)\n        {\n            ListNode *tempNode= currentNode->nextNode;\n            currentNode->nextNode= tempNode->nextNode;\n            delete tempNode;\n        }\n        else\n        {\n            currentNode= currentNode->nextNode;\n        }\n    }\n    return head;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint largestRectangleArea(vector<int> &heights)\n{\n    heights.push_back(0);\n    stack<int> indexStack;\n    int maxArea= 0;\n    for(int currentIndex= 0; currentIndex < heights.size(); currentIndex++)\n    {\n        while(!indexStack.empty() && heights[indexStack.top()] > heights[currentIndex])\n        {\n            int height= heights[indexStack.top()];\n            indexStack.pop();\n            int width= indexStack.empty() ? currentIndex : currentIndex - indexStack.top() - 1;\n            maxArea= max(maxArea, height * width);\n        }\n        indexStack.push(currentIndex);\n    }\n    return maxArea;\n}",
    "output": "#include <bits/stdc++.h>\nint largestRectangleArea(std::vector<int> &heights)\n{\n    heights.push_back(0);\n    std::stack<int> indexStack;\n    int maxArea = 0;\n    for(int currentIndex = 0; currentIndex < heights.size(); currentIndex++)\n    {\n        while(!indexStack.empty() && heights[indexStack.top()] > heights[currentIndex])\n        {\n            int height = heights[indexStack.top()];\n            indexStack.pop();\n            int width = indexStack.empty() ? currentIndex : currentIndex - indexStack.top() - 1;\n            maxArea = std::max(maxArea, height * width);\n        }\n        indexStack.push(currentIndex);\n    }\n    return maxArea;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maximalRectangle(vector<vector<char>> &binaryMatrix)\n{\n    if(binaryMatrix.empty())\n        return 0;\n\n    int rowCount= binaryMatrix.size();\n    int columnCount= binaryMatrix[0].size();\n    vector<int> height(columnCount + 1, 0);\n    int maximumArea= 0;\n\n    for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n    {\n        stack<int> indexStack;\n        for(int columnIndex= 0; columnIndex <= columnCount; ++columnIndex)\n        {\n            if(columnIndex < columnCount)\n            {\n                height[columnIndex]= binaryMatrix[rowIndex][columnIndex] == '1' ? height[columnIndex] + 1 : 0;\n            }\n            while(!indexStack.empty() && height[columnIndex] < height[indexStack.top()])\n            {\n                int heightValue= height[indexStack.top()];\n                indexStack.pop();\n                int widthValue= indexStack.empty() ? columnIndex : columnIndex - indexStack.top() - 1;\n                maximumArea= max(maximumArea, heightValue * widthValue);\n            }\n            indexStack.push(columnIndex);\n        }\n    }\n\n    return maximumArea;\n}",
    "output": "#include <bits/stdc++.h>\nint maximalRectangle(std::vector<std::vector<char>> &binaryMatrix)\n{\n    if(binaryMatrix.empty())\n        return 0;\n\n    int rowCount= binaryMatrix.size();\n    int columnCount= binaryMatrix[0].size();\n    std::vector<int> height(columnCount + 1, 0);\n    int maximumArea= 0;\n\n    for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n    {\n        std::stack<int> indexStack;\n        for(int columnIndex= 0; columnIndex <= columnCount; ++columnIndex)\n        {\n            if(columnIndex < columnCount)\n            {\n                height[columnIndex]= binaryMatrix[rowIndex][columnIndex] == '1' ? height[columnIndex] + 1 : 0;\n            }\n            while(!indexStack.empty() && height[columnIndex] < height[indexStack.top()])\n            {\n                int heightValue= height[indexStack.top()];\n                indexStack.pop();\n                int widthValue= indexStack.empty() ? columnIndex : columnIndex - indexStack.top() - 1;\n                maximumArea= std::max(maximumArea, heightValue * widthValue);\n            }\n            indexStack.push(columnIndex);\n        }\n    }\n\n    return maximumArea;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *partition(ListNode *head, int partitionValue)\n{\n    ListNode lessHead(0), moreHead(0);\n    ListNode *lessPtr= &lessHead, *morePtr= &moreHead;\n\n    while(head)\n    {\n        if(head->value < partitionValue)\n        {\n            lessPtr->next= head;\n            lessPtr= head;\n        }\n        else\n        {\n            morePtr->next= head;\n            morePtr= head;\n        }\n        head= head->next;\n    }\n\n    lessPtr->next= moreHead.next;\n    morePtr->next= NULL;\n\n    return lessHead.next;\n}",
    "output": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *partition(ListNode *head, int partitionValue)\n{\n    ListNode lessHead(0), moreHead(0);\n    ListNode *lessPtr= &lessHead, *morePtr= &moreHead;\n\n    while(head)\n    {\n        if(head->value < partitionValue)\n        {\n            lessPtr->next= head;\n            lessPtr= head;\n        }\n        else\n        {\n            morePtr->next= head;\n            morePtr= head;\n        }\n        head= head->next;\n    }\n\n    lessPtr->next= moreHead.next;\n    morePtr->next= NULL;\n\n    return lessHead.next;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isScramble(string sourceString, string targetString)\n{\n    if(sourceString == targetString)\n        return true;\n    if(sourceString.size() != targetString.size() || \n       sort(sourceString.begin(), sourceString.end()) != sort(targetString.begin(), targetString.end()))\n        return false;\n\n    for(int splitIndex= 1; splitIndex < sourceString.size(); splitIndex++)\n    {\n        if(isScramble(sourceString.substr(0, splitIndex), targetString.substr(0, splitIndex)) && \n           isScramble(sourceString.substr(splitIndex), targetString.substr(splitIndex)))\n            return true;\n        if(isScramble(sourceString.substr(0, splitIndex), targetString.substr(targetString.size() - splitIndex)) && \n           isScramble(sourceString.substr(splitIndex), targetString.substr(0, targetString.size() - splitIndex)))\n            return true;\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool isScramble(std::string sourceString, std::string targetString)\n{\n    if(sourceString == targetString)\n        return true;\n    if(sourceString.size() != targetString.size() || std::sort(sourceString.begin(), sourceString.end()) != std::sort(targetString.begin(), targetString.end()))\n        return false;\n\n    for(int splitIndex= 1; splitIndex < sourceString.size(); splitIndex++)\n    {\n        if(isScramble(sourceString.substr(0, splitIndex), targetString.substr(0, splitIndex)) && isScramble(sourceString.substr(splitIndex), targetString.substr(splitIndex)))\n            return true;\n        if(isScramble(sourceString.substr(0, splitIndex), targetString.substr(targetString.size() - splitIndex)) && isScramble(sourceString.substr(splitIndex), targetString.substr(0, targetString.size() - splitIndex)))\n            return true;\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid merge(vector<int> &sortedArray1, int size1, vector<int> &sortedArray2, int size2)\n{\n    int index1= size1 - 1, index2= size2 - 1, mergeIndex= size1 + size2 - 1;\n    while(index1 >= 0 && index2 >= 0)\n    {\n        if(sortedArray1[index1] > sortedArray2[index2])\n            sortedArray1[mergeIndex--]= sortedArray1[index1--];\n        else\n            sortedArray1[mergeIndex--]= sortedArray2[index2--];\n    }\n    while(index2 >= 0)\n    {\n        sortedArray1[mergeIndex--]= sortedArray2[index2--];\n    }\n}",
    "output": "#include <bits/stdc++.h>\nvoid merge(std::vector<int> &sortedArray1, int size1, std::vector<int> &sortedArray2, int size2)\n{\n    int index1= size1 - 1, index2= size2 - 1, mergeIndex= size1 + size2 - 1;\n    while(index1 >= 0 && index2 >= 0)\n    {\n        if(sortedArray1[index1] > sortedArray2[index2])\n            sortedArray1[mergeIndex--]= sortedArray1[index1--];\n        else\n            sortedArray1[mergeIndex--]= sortedArray2[index2--];\n    }\n    while(index2 >= 0)\n    {\n        sortedArray1[mergeIndex--]= sortedArray2[index2--];\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> generateGrayCode(int numBits)\n{\n    vector<int> grayCodeSequence;\n    for(int index= 0; index < (1 << numBits); index++)\n    {\n        grayCodeSequence.push_back(index ^ (index >> 1));\n    }\n    return grayCodeSequence;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> generateGrayCode(int numBits)\n{\n    std::vector<int> grayCodeSequence;\n    for(int index= 0; index < (1 << numBits); index++)\n    {\n        grayCodeSequence.push_back(index ^ (index >> 1));\n    }\n    return grayCodeSequence;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> generateSubsetsWithDuplicates(vector<int> &inputNumbers)\n{\n    set<vector<int>> uniqueSubsets;\n    vector<int> currentSubset;\n    sort(inputNumbers.begin(), inputNumbers.end());\n    backtrack(inputNumbers, 0, currentSubset, uniqueSubsets);\n    return vector<vector<int>>(uniqueSubsets.begin(), uniqueSubsets.end());\n}\n\nvoid backtrack(vector<int> &inputNumbers, int currentIndex, vector<int> &currentSubset, set<vector<int>> &uniqueSubsets)\n{\n    uniqueSubsets.insert(currentSubset);\n    for(int i= currentIndex; i < inputNumbers.size(); i++)\n    {\n        currentSubset.push_back(inputNumbers[i]);\n        backtrack(inputNumbers, i + 1, currentSubset, uniqueSubsets);\n        currentSubset.pop_back();\n    }\n}",
    "output": "#include <bits/stdc++.h>\n// Include this for sort\n\nstd::vector<std::vector<int>> generateSubsetsWithDuplicates(std::vector<int> &inputNumbers)\n{\n    std::set<std::vector<int>> uniqueSubsets;\n    std::vector<int> currentSubset;\n    std::sort(inputNumbers.begin(), inputNumbers.end());\n    backtrack(inputNumbers, 0, currentSubset, uniqueSubsets);\n    return std::vector<std::vector<int>>(uniqueSubsets.begin(), uniqueSubsets.end());\n}\n\nvoid backtrack(std::vector<int> &inputNumbers, int currentIndex, std::vector<int> &currentSubset, std::set<std::vector<int>> &uniqueSubsets)\n{\n    uniqueSubsets.insert(currentSubset);\n    for(int i= currentIndex; i < inputNumbers.size(); i++)\n    {\n        currentSubset.push_back(inputNumbers[i]);\n        backtrack(inputNumbers, i + 1, currentSubset, uniqueSubsets);\n        currentSubset.pop_back();\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numDecodings(string encodedString)\n{\n    int stringLength = encodedString.size();\n    vector<int> decodingWays(stringLength + 1, 0);\n    decodingWays[0] = 1;\n    decodingWays[1] = encodedString[0] != '0' ? 1 : 0;\n\n    for(int currentIndex = 2; currentIndex <= stringLength; ++currentIndex)\n    {\n        int oneDigit = stoi(encodedString.substr(currentIndex - 1, 1));\n        int twoDigits = stoi(encodedString.substr(currentIndex - 2, 2));\n\n        if(oneDigit >= 1)\n            decodingWays[currentIndex] += decodingWays[currentIndex - 1];\n        if(twoDigits >= 10 && twoDigits <= 26)\n            decodingWays[currentIndex] += decodingWays[currentIndex - 2];\n    }\n    return decodingWays[stringLength];\n}",
    "output": "#include <bits/stdc++.h>\nint numDecodings(std::string encodedString)\n{\n    int stringLength= encodedString.size();\n    std::vector<int> decodingWays(stringLength + 1, 0);\n    decodingWays[0]= 1;\n    decodingWays[1]= encodedString[0] != '0' ? 1 : 0;\n\n    for(int currentIndex= 2; currentIndex <= stringLength; ++currentIndex)\n    {\n        int oneDigit= stoi(encodedString.substr(currentIndex - 1, 1));\n        int twoDigits= stoi(encodedString.substr(currentIndex - 2, 2));\n\n        if(oneDigit >= 1)\n            decodingWays[currentIndex]+= decodingWays[currentIndex - 1];\n        if(twoDigits >= 10 && twoDigits <= 26)\n            decodingWays[currentIndex]+= decodingWays[currentIndex - 2];\n    }\n    return decodingWays[stringLength];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "ListNode *reverseBetween(ListNode *head, int leftIndex, int rightIndex)\n{\n    if(!head || leftIndex == rightIndex)\n        return head;\n    ListNode dummyNode(0);\n    dummyNode.next= head;\n    ListNode *previousNode= &dummyNode;\n    for(int i= 1; i < leftIndex; ++i)\n        previousNode= previousNode->next;\n    ListNode *currentNode= previousNode->next;\n    for(int i= leftIndex; i < rightIndex; ++i)\n    {\n        ListNode *tempNode= currentNode->next;\n        currentNode->next= tempNode->next;\n        tempNode->next= previousNode->next;\n        previousNode->next= tempNode;\n    }\n    return dummyNode.next;\n}",
    "output": "ListNode *reverseBetween(ListNode *head, int leftIndex, int rightIndex)\n{\n    if(!head || leftIndex == rightIndex)\n        return head;\n    ListNode dummyNode(0);\n    dummyNode.next= head;\n    ListNode *previousNode= &dummyNode;\n    for(int i= 1; i < leftIndex; ++i)\n        previousNode= previousNode->next;\n    ListNode *currentNode= previousNode->next;\n    for(int i= leftIndex; i < rightIndex; ++i)\n    {\n        ListNode *tempNode= currentNode->next;\n        currentNode->next= tempNode->next;\n        tempNode->next= previousNode->next;\n        previousNode->next= tempNode;\n    }\n    return dummyNode.next;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> restoreIpAddress(string inputString)\n{\n    vector<string> ipAddresses;\n    string currentIp;\n    depthFirstSearch(ipAddresses, inputString, currentIp, 0, 0);\n    return ipAddresses;\n}\n\nvoid depthFirstSearch(vector<string> &ipAddresses, string inputString, string currentIp, int startIndex, int ipPart)\n{\n    if(ipPart == 4 && startIndex == inputString.size())\n    {\n        currentIp.pop_back();\n        ipAddresses.push_back(currentIp);\n        return;\n    }\n    if(ipPart == 4 || startIndex == inputString.size())\n        return;\n\n    int number= 0;\n    for(int i= startIndex; i < inputString.size(); i++)\n    {\n        number= number * 10 + (inputString[i] - '0');\n        if(number > 255)\n            break;\n        currentIp+= inputString[i];\n        depthFirstSearch(ipAddresses, inputString, currentIp + '.', i + 1, ipPart + 1);\n        if(number == 0)\n            break;\n    }\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> restoreIpAddress(std::string inputString)\n{\n    std::vector<std::string> ipAddresses;\n    std::string currentIp;\n    depthFirstSearch(ipAddresses, inputString, currentIp, 0, 0);\n    return ipAddresses;\n}\n\nvoid depthFirstSearch(std::vector<std::string> &ipAddresses, std::string inputString, std::string currentIp, int startIndex, int ipPart)\n{\n    if(ipPart == 4 && startIndex == inputString.size())\n    {\n        currentIp.pop_back();\n        ipAddresses.push_back(currentIp);\n        return;\n    }\n    if(ipPart == 4 || startIndex == inputString.size())\n        return;\n\n    int number= 0;\n    for(int i= startIndex; i < inputString.size(); i++)\n    {\n        number= number * 10 + (inputString[i] - '0');\n        if(number > 255)\n            break;\n        currentIp+= inputString[i];\n        depthFirstSearch(ipAddresses, inputString, currentIp + '.', i + 1, ipPart + 1);\n        if(number == 0)\n            break;\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nvoid inorderTraversalHelper(TreeNode *currentNode, vector<int> &traversalResult)\n{\n    if(!currentNode)\n        return;\n    inorderTraversalHelper(currentNode->leftChild, traversalResult);\n    traversalResult.push_back(currentNode->value);\n    inorderTraversalHelper(currentNode->rightChild, traversalResult);\n}\n\nvector<int> inorderTraversal(TreeNode *rootNode)\n{\n    vector<int> traversalResult;\n    inorderTraversalHelper(rootNode, traversalResult);\n    return traversalResult;\n}",
    "output": "#include <bits/stdc++.h>\nclass TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nvoid inorderTraversalHelper(TreeNode *currentNode, std::vector<int> &traversalResult)\n{\n    if(!currentNode)\n        return;\n    inorderTraversalHelper(currentNode->leftChild, traversalResult);\n    traversalResult.push_back(currentNode->value);\n    inorderTraversalHelper(currentNode->rightChild, traversalResult);\n}\n\nstd::vector<int> inorderTraversal(TreeNode *rootNode)\n{\n    std::vector<int> traversalResult;\n    inorderTraversalHelper(rootNode, traversalResult);\n    return traversalResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nvector<TreeNode *> generateTrees(int start, int end)\n{\n    vector<TreeNode *> treeList;\n    if(start > end)\n    {\n        treeList.push_back(NULL);\n        return treeList;\n    }\n\n    for(int rootValue = start; rootValue <= end; rootValue++)\n    {\n        vector<TreeNode *> leftSubtrees = generateTrees(start, rootValue - 1);\n        vector<TreeNode *> rightSubtrees = generateTrees(rootValue + 1, end);\n\n        for(int i = 0; i < leftSubtrees.size(); i++)\n        {\n            TreeNode *left = leftSubtrees[i];\n            for(int j = 0; j < rightSubtrees.size(); j++)\n            {\n                TreeNode *right = rightSubtrees[j];\n                TreeNode *newNode = new TreeNode(rootValue);\n                newNode->leftChild = left;\n                newNode->rightChild = right;\n                treeList.push_back(newNode);\n            }\n        }\n    }\n\n    return treeList;\n}\n\nvector<TreeNode *> generateTrees(int numberOfNodes)\n{\n    if(numberOfNodes == 0)\n    {\n        return vector<TreeNode *>();\n    }\n    return generateTrees(1, numberOfNodes);\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nstd::vector<TreeNode *> generateTrees(int start, int end)\n{\n    std::vector<TreeNode *> treeList;\n    if(start > end)\n    {\n        treeList.push_back(NULL);\n        return treeList;\n    }\n\n    for(int rootValue= start; rootValue <= end; rootValue++)\n    {\n        std::vector<TreeNode *> leftSubtrees= generateTrees(start, rootValue - 1);\n        std::vector<TreeNode *> rightSubtrees= generateTrees(rootValue + 1, end);\n\n        for(TreeNode *left : leftSubtrees)\n        {\n            for(TreeNode *right : rightSubtrees)\n            {\n                TreeNode *newNode= new TreeNode(rootValue);\n                newNode->leftChild= left;\n                newNode->rightChild= right;\n                treeList.push_back(newNode);\n            }\n        }\n    }\n\n    return treeList;\n}\n\nstd::vector<TreeNode *> generateTrees(int numberOfNodes)\n{\n    if(numberOfNodes == 0)\n    {\n        return std::vector<TreeNode *>();\n    }\n    return generateTrees(1, numberOfNodes);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateNumTrees(int numberOfNodes)\n{\n    vector<int> dynamicProgrammingTable(numberOfNodes + 1, 0);\n    dynamicProgrammingTable[0]= dynamicProgrammingTable[1]= 1;\n    for(int currentNodes= 2; currentNodes <= numberOfNodes; currentNodes++)\n    {\n        for(int leftNodes= 0; leftNodes < currentNodes; leftNodes++)\n        {\n            dynamicProgrammingTable[currentNodes]+= dynamicProgrammingTable[leftNodes] * dynamicProgrammingTable[currentNodes - leftNodes - 1];\n        }\n    }\n    return dynamicProgrammingTable[numberOfNodes];\n}",
    "output": "#include <bits/stdc++.h>\nint calculateNumTrees(int numberOfNodes)\n{\n    std::vector<int> dynamicProgrammingTable(numberOfNodes + 1, 0);\n    dynamicProgrammingTable[0] = dynamicProgrammingTable[1] = 1;\n    for(int currentNodes = 2; currentNodes <= numberOfNodes; currentNodes++)\n    {\n        for(int leftNodes = 0; leftNodes < currentNodes; leftNodes++)\n        {\n            dynamicProgrammingTable[currentNodes] += dynamicProgrammingTable[leftNodes] * dynamicProgrammingTable[currentNodes - leftNodes - 1];\n        }\n    }\n    return dynamicProgrammingTable[numberOfNodes];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isInterleave(string firstString, string secondString, string thirdString)\n{\n    int firstLength= firstString.length(), secondLength= secondString.length();\n    if(firstLength + secondLength != thirdString.length())\n        return false;\n\n    vector<vector<bool>> dynamicProgrammingTable(firstLength + 1, vector<bool>(secondLength + 1, false));\n    dynamicProgrammingTable[0][0]= true;\n    for(int i= 1; i <= firstLength; i++)\n        dynamicProgrammingTable[i][0]= dynamicProgrammingTable[i - 1][0] && firstString[i - 1] == thirdString[i - 1];\n    for(int j= 1; j <= secondLength; j++)\n        dynamicProgrammingTable[0][j]= dynamicProgrammingTable[0][j - 1] && secondString[j - 1] == thirdString[j - 1];\n\n    for(int i= 1; i <= firstLength; i++)\n    {\n        for(int j= 1; j <= secondLength; j++)\n        {\n            dynamicProgrammingTable[i][j]= (dynamicProgrammingTable[i - 1][j] && firstString[i - 1] == thirdString[i + j - 1]) ||\n                                           (dynamicProgrammingTable[i][j - 1] && secondString[j - 1] == thirdString[i + j - 1]);\n        }\n    }\n\n    return dynamicProgrammingTable[firstLength][secondLength];\n}",
    "output": "#include <bits/stdc++.h>\nbool isInterleave(std::string firstString, std::string secondString, std::string thirdString)\n{\n    int firstLength= firstString.length(), secondLength= secondString.length();\n    if(firstLength + secondLength != thirdString.length())\n        return false;\n\n    std::vector<std::vector<bool>> dynamicProgrammingTable(firstLength + 1, std::vector<bool>(secondLength + 1, false));\n    dynamicProgrammingTable[0][0]= true;\n    for(int i= 1; i <= firstLength; i++)\n        dynamicProgrammingTable[i][0]= dynamicProgrammingTable[i - 1][0] && firstString[i - 1] == thirdString[i - 1];\n    for(int j= 1; j <= secondLength; j++)\n        dynamicProgrammingTable[0][j]= dynamicProgrammingTable[0][j - 1] && secondString[j - 1] == thirdString[j - 1];\n\n    for(int i= 1; i <= firstLength; i++)\n    {\n        for(int j= 1; j <= secondLength; j++)\n        {\n            dynamicProgrammingTable[i][j]= (dynamicProgrammingTable[i - 1][j] && firstString[i - 1] == thirdString[i + j - 1]) ||\n                                           (dynamicProgrammingTable[i][j - 1] && secondString[j - 1] == thirdString[i + j - 1]);\n        }\n    }\n\n    return dynamicProgrammingTable[firstLength][secondLength];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nbool isValidBstHelper(TreeNode *currentNode, long minValue, long maxValue)\n{\n    if(currentNode == NULL)\n        return true;\n    if(currentNode->value <= minValue || currentNode->value >= maxValue)\n        return false;\n    return isValidBstHelper(currentNode->leftChild, minValue, currentNode->value) && isValidBstHelper(currentNode->rightChild, currentNode->value, maxValue);\n}\n\nbool isValidBst(TreeNode *rootNode)\n{\n    return isValidBstHelper(rootNode, LONG_MIN, LONG_MAX);\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nbool isValidBstHelper(TreeNode *currentNode, long minValue, long maxValue)\n{\n    if(currentNode == NULL)\n        return true;\n    if(currentNode->value <= minValue || currentNode->value >= maxValue)\n        return false;\n    return isValidBstHelper(currentNode->leftChild, minValue, currentNode->value) && isValidBstHelper(currentNode->rightChild, currentNode->value, maxValue);\n}\n\nbool isValidBst(TreeNode *rootNode)\n{\n    return isValidBstHelper(rootNode, LONG_MIN, LONG_MAX);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For std::swap\n\nusing namespace std;\n\nvoid inorderTraversal(TreeNode *currentNode, TreeNode *&firstNode, TreeNode *&secondNode, TreeNode *&previousNode)\n{\n    if(!currentNode)\n        return;\n    inorderTraversal(currentNode->left, firstNode, secondNode, previousNode);\n    if(previousNode && previousNode->val > currentNode->val)\n    {\n        if(!firstNode)\n            firstNode= previousNode;\n        secondNode= currentNode;\n    }\n    previousNode= currentNode;\n    inorderTraversal(currentNode->right, firstNode, secondNode, previousNode);\n}\n\nvoid recoverTree(TreeNode *rootNode)\n{\n    TreeNode *firstNode= NULL, *secondNode= NULL, *previousNode= NULL;\n    inorderTraversal(rootNode, firstNode, secondNode, previousNode);\n    swap(firstNode->val, secondNode->val);\n}",
    "output": "void inorderTraversal(TreeNode *currentNode, TreeNode *&firstNode, TreeNode *&secondNode, TreeNode *&previousNode)\n{\n    if(!currentNode)\n        return;\n    inorderTraversal(currentNode->left, firstNode, secondNode, previousNode);\n    if(previousNode && previousNode->val > currentNode->val)\n    {\n        if(!firstNode)\n            firstNode= previousNode;\n        secondNode= currentNode;\n    }\n    previousNode= currentNode;\n    inorderTraversal(currentNode->right, firstNode, secondNode, previousNode);\n}\n\nvoid recoverTree(TreeNode *rootNode)\n{\n    TreeNode *firstNode= NULL, *secondNode= NULL, *previousNode= NULL;\n    inorderTraversal(rootNode, firstNode, secondNode, previousNode);\n    std::swap(firstNode->val, secondNode->val);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nbool isSameTree(TreeNode *firstTree, TreeNode *secondTree)\n{\n    if(firstTree == NULL && secondTree == NULL)\n    {\n        return true;\n    }\n    if(firstTree == NULL || secondTree == NULL)\n    {\n        return false;\n    }\n    if(firstTree->value != secondTree->value)\n    {\n        return false;\n    }\n    return isSameTree(firstTree->leftChild, secondTree->leftChild) && isSameTree(firstTree->rightChild, secondTree->rightChild);\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nbool isSameTree(TreeNode *firstTree, TreeNode *secondTree)\n{\n    if(firstTree == NULL && secondTree == NULL)\n    {\n        return true;\n    }\n    if(firstTree == NULL || secondTree == NULL)\n    {\n        return false;\n    }\n    if(firstTree->value != secondTree->value)\n    {\n        return false;\n    }\n    return isSameTree(firstTree->leftChild, secondTree->leftChild) && isSameTree(firstTree->rightChild, secondTree->rightChild);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "bool isSymmetric(TreeNode *rootNode)\n{\n    return checkSymmetry(rootNode, rootNode);\n}\n\nbool checkSymmetry(TreeNode *leftNode, TreeNode *rightNode)\n{\n    if(!leftNode && !rightNode)\n        return true;\n    if(!leftNode || !rightNode)\n        return false;\n    return (leftNode->val == rightNode->val) && checkSymmetry(leftNode->right, rightNode->left) && checkSymmetry(leftNode->left, rightNode->right);\n}",
    "output": "bool isSymmetric(TreeNode *rootNode)\n{\n    return checkSymmetry(rootNode, rootNode);\n}\n\nbool checkSymmetry(TreeNode *leftNode, TreeNode *rightNode)\n{\n    if(!leftNode && !rightNode)\n        return true;\n    if(!leftNode || !rightNode)\n        return false;\n    return (leftNode->val == rightNode->val) && checkSymmetry(leftNode->right, rightNode->left) && checkSymmetry(leftNode->left, rightNode->right);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nvector<vector<int>> levelOrder(TreeNode *root)\n{\n    vector<vector<int>> result;\n    if(root == NULL)\n        return result;\n\n    queue<TreeNode *> nodeQueue;\n    nodeQueue.push(root);\n\n    while(!nodeQueue.empty())\n    {\n        int levelSize = nodeQueue.size();\n        vector<int> currentLevel;\n\n        for(int i = 0; i < levelSize; i++)\n        {\n            TreeNode *currentNode = nodeQueue.front();\n            currentLevel.push_back(currentNode->value);\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n\n            nodeQueue.pop();\n        }\n\n        result.push_back(currentLevel);\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nstd::vector<std::vector<int>> levelOrder(TreeNode *root)\n{\n    std::vector<std::vector<int>> result;\n    if(root == NULL)\n        return result;\n\n    std::queue<TreeNode *> nodeQueue;\n    nodeQueue.push(root);\n\n    while(!nodeQueue.empty())\n    {\n        int levelSize= nodeQueue.size();\n        std::vector<int> currentLevel;\n\n        for(int i= 0; i < levelSize; i++)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            currentLevel.push_back(currentNode->value);\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n\n            nodeQueue.pop();\n        }\n\n        result.push_back(currentLevel);\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nvector<vector<int>> zigzagLevelOrder(TreeNode *root)\n{\n    if(!root)\n        return {};\n\n    vector<vector<int>> result;\n    queue<TreeNode *> nodeQueue;\n    nodeQueue.push(root);\n    bool isZigzag= false;\n\n    while(!nodeQueue.empty())\n    {\n        int levelSize= nodeQueue.size();\n        vector<int> currentLevel(levelSize);\n\n        for(int index= 0; index < levelSize; index++)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n\n            int position= (isZigzag) ? (levelSize - 1 - index) : index;\n            currentLevel[position]= currentNode->value;\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n\n        isZigzag= !isZigzag;\n        result.push_back(move(currentLevel));\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nstd::vector<std::vector<int>> zigzagLevelOrder(TreeNode *root)\n{\n    if(!root)\n        return {};\n\n    std::vector<std::vector<int>> result;\n    std::queue<TreeNode *> nodeQueue;\n    nodeQueue.push(root);\n    bool isZigzag= false;\n\n    while(!nodeQueue.empty())\n    {\n        int levelSize= nodeQueue.size();\n        std::vector<int> currentLevel(levelSize);\n\n        for(int index= 0; index < levelSize; index++)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n\n            int position= (isZigzag) ? (levelSize - 1 - index) : index;\n            currentLevel[position]= currentNode->value;\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n\n        isZigzag= !isZigzag;\n        result.push_back(std::move(currentLevel));\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int maxDepth(TreeNode *root)\n{\n    if(root == NULL)\n    {\n        return 0;\n    }\n    return 1 + max(maxDepth(root->left), maxDepth(root->right));\n}",
    "output": "int maxDepth(TreeNode *root)\n{\n    if(root == NULL)\n    {\n        return 0;\n    }\n    return 1 + max(maxDepth(root->left), maxDepth(root->right));\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *buildTree(vector<int> &preorderTraversal, vector<int> &inorderTraversal, unordered_map<int, int> &inorderIndexMap, int &preorderIndex, int inorderLeft, int inorderRight)\n{\n    if(inorderLeft > inorderRight)\n        return NULL;\n\n    int rootValue= preorderTraversal[preorderIndex];\n    TreeNode *rootNode= new TreeNode(rootValue);\n    int index= inorderIndexMap[rootValue];\n\n    preorderIndex++;\n    rootNode->leftChild= buildTree(preorderTraversal, inorderTraversal, inorderIndexMap, preorderIndex, inorderLeft, index - 1);\n    rootNode->rightChild= buildTree(preorderTraversal, inorderTraversal, inorderIndexMap, preorderIndex, index + 1, inorderRight);\n\n    return rootNode;\n}\n\nTreeNode *buildTree(vector<int> &preorderTraversal, vector<int> &inorderTraversal)\n{\n    unordered_map<int, int> inorderIndexMap;\n    int preorderIndex= 0;\n    for(int i= 0; i < inorderTraversal.size(); i++)\n    {\n        inorderIndexMap[inorderTraversal[i]]= i;\n    }\n    return buildTree(preorderTraversal, inorderTraversal, inorderIndexMap, preorderIndex, 0, inorderTraversal.size() - 1);\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *buildTree(std::vector<int> &preorderTraversal, std::vector<int> &inorderTraversal, std::unordered_map<int, int> &inorderIndexMap, int &preorderIndex, int inorderLeft, int inorderRight)\n{\n    if(inorderLeft > inorderRight)\n        return NULL;\n\n    int rootValue= preorderTraversal[preorderIndex];\n    TreeNode *rootNode= new TreeNode(rootValue);\n    int index= inorderIndexMap[rootValue];\n\n    preorderIndex++;\n    rootNode->leftChild= buildTree(preorderTraversal, inorderTraversal, inorderIndexMap, preorderIndex, inorderLeft, index - 1);\n    rootNode->rightChild= buildTree(preorderTraversal, inorderTraversal, inorderIndexMap, preorderIndex, index + 1, inorderRight);\n\n    return rootNode;\n}\n\nTreeNode *buildTree(std::vector<int> &preorderTraversal, std::vector<int> &inorderTraversal)\n{\n    std::unordered_map<int, int> inorderIndexMap;\n    int preorderIndex= 0;\n    for(int i= 0; i < inorderTraversal.size(); i++)\n    {\n        inorderIndexMap[inorderTraversal[i]]= i;\n    }\n    return buildTree(preorderTraversal, inorderTraversal, inorderIndexMap, preorderIndex, 0, inorderTraversal.size() - 1);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass Solution\n{\n    unordered_map<int, int> indexMap;\n\n    TreeNode *buildTree(vector<int> &inorderTraversal, vector<int> &postorderTraversal, int inLeft, int inRight, int postRootIndex)\n    {\n        if(inLeft > inRight)\n            return NULL;\n\n        TreeNode *rootNode= new TreeNode(postorderTraversal[postRootIndex]);\n\n        int inorderRootIndex= indexMap[rootNode->value];\n        int leftTreeSize= inorderRootIndex - inLeft;\n\n        rootNode->leftChild= buildTree(inorderTraversal, postorderTraversal, inLeft, inorderRootIndex - 1, postRootIndex - 1 - inRight + inorderRootIndex);\n        rootNode->rightChild= buildTree(inorderTraversal, postorderTraversal, inorderRootIndex + 1, inRight, postRootIndex - 1);\n\n        return rootNode;\n    }\n\n  public:\n    TreeNode *buildTree(vector<int> &inorderTraversal, vector<int> &postorderTraversal)\n    {\n        int treeSize= inorderTraversal.size();\n        for(int i= 0; i < treeSize; ++i)\n        {\n            indexMap[inorderTraversal[i]]= i;\n        }\n        return buildTree(inorderTraversal, postorderTraversal, 0, treeSize - 1, treeSize - 1);\n    }\n};",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass Solution\n{\n    std::unordered_map<int, int> indexMap;\n\n    TreeNode *buildTree(std::vector<int> &inorderTraversal, std::vector<int> &postorderTraversal, int inLeft, int inRight, int postRootIndex)\n    {\n        if(inLeft > inRight)\n            return NULL;\n\n        TreeNode *rootNode = new TreeNode(postorderTraversal[postRootIndex]);\n\n        int inorderRootIndex = indexMap[rootNode->value];\n        int leftTreeSize = inorderRootIndex - inLeft;\n\n        rootNode->leftChild = buildTree(inorderTraversal, postorderTraversal, inLeft, inorderRootIndex - 1, postRootIndex - 1 - inRight + inorderRootIndex);\n        rootNode->rightChild = buildTree(inorderTraversal, postorderTraversal, inorderRootIndex + 1, inRight, postRootIndex - 1);\n\n        return rootNode;\n    }\n\n  public:\n    TreeNode *buildTree(std::vector<int> &inorderTraversal, std::vector<int> &postorderTraversal)\n    {\n        int treeSize = inorderTraversal.size();\n        for(int i = 0; i < treeSize; ++i)\n        {\n            indexMap[inorderTraversal[i]] = i;\n        }\n        return buildTree(inorderTraversal, postorderTraversal, 0, treeSize - 1, treeSize - 1);\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nvector<vector<int>> levelOrderBottom(TreeNode *root)\n{\n    vector<vector<int>> result;\n    if(root == NULL)\n        return result;\n\n    queue<TreeNode *> nodeQueue;\n    nodeQueue.push(root);\n\n    while(!nodeQueue.empty())\n    {\n        vector<int> level;\n        int size = nodeQueue.size();\n\n        for(int index = 0; index < size; index++)\n        {\n            TreeNode *currentNode = nodeQueue.front();\n            nodeQueue.pop();\n            level.push_back(currentNode->value);\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n        result.insert(result.begin(), level);\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nstd::vector<std::vector<int>> levelOrderBottom(TreeNode *root)\n{\n    std::vector<std::vector<int>> result;\n    if(root == NULL)\n        return result;\n\n    std::queue<TreeNode *> nodeQueue;\n    nodeQueue.push(root);\n\n    while(!nodeQueue.empty())\n    {\n        std::vector<int> level;\n        int size= nodeQueue.size();\n\n        for(int index= 0; index < size; index++)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n            level.push_back(currentNode->value);\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n        result.insert(result.begin(), level);\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nTreeNode *sortedArrayToBST(vector<int> &numbers, int startIndex, int endIndex)\n{\n    if(startIndex > endIndex)\n        return NULL;\n\n    int midIndex= startIndex + (endIndex - startIndex) / 2;\n    TreeNode *currentNode= new TreeNode(numbers[midIndex]);\n    currentNode->leftChild= sortedArrayToBST(numbers, startIndex, midIndex - 1);\n    currentNode->rightChild= sortedArrayToBST(numbers, midIndex + 1, endIndex);\n\n    return currentNode;\n}\n\nTreeNode *sortedArrayToBST(vector<int> &numbers)\n{\n    return sortedArrayToBST(numbers, 0, numbers.size() - 1);\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nTreeNode *sortedArrayToBST(std::vector<int> &numbers, int startIndex, int endIndex)\n{\n    if(startIndex > endIndex)\n        return NULL;\n\n    int midIndex= startIndex + (endIndex - startIndex) / 2;\n    TreeNode *currentNode= new TreeNode(numbers[midIndex]);\n    currentNode->leftChild= sortedArrayToBST(numbers, startIndex, midIndex - 1);\n    currentNode->rightChild= sortedArrayToBST(numbers, midIndex + 1, endIndex);\n\n    return currentNode;\n}\n\nTreeNode *sortedArrayToBST(std::vector<int> &numbers)\n{\n    return sortedArrayToBST(numbers, 0, numbers.size() - 1);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass ListNode\n{\n  public:\n    int value;\n    ListNode *nextNode;\n    ListNode(int x) : value(x), nextNode(NULL) {}\n};\n\nTreeNode *sortedListToBST(ListNode *head)\n{\n    if(!head)\n        return NULL;\n    if(!head->nextNode)\n        return new TreeNode(head->value);\n    ListNode *slowPtr= head;\n    ListNode *fastPtr= head;\n    ListNode *prevPtr= NULL;\n\n    while(fastPtr && fastPtr->nextNode)\n    {\n        prevPtr= slowPtr;\n        slowPtr= slowPtr->nextNode;\n        fastPtr= fastPtr->nextNode->nextNode;\n    }\n\n    prevPtr->nextNode= NULL;\n\n    TreeNode *rootNode= new TreeNode(slowPtr->value);\n    rootNode->leftChild= sortedListToBST(head);\n    rootNode->rightChild= sortedListToBST(slowPtr->nextNode);\n    return rootNode;\n}",
    "output": "class TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass ListNode\n{\n  public:\n    int value;\n    ListNode *nextNode;\n    ListNode(int x) : value(x), nextNode(NULL) {}\n};\n\nTreeNode *sortedListToBST(ListNode *head)\n{\n    if(!head)\n        return NULL;\n    if(!head->nextNode)\n        return new TreeNode(head->value);\n    ListNode *slowPtr= head;\n    ListNode *fastPtr= head;\n    ListNode *prevPtr= NULL;\n\n    while(fastPtr && fastPtr->nextNode)\n    {\n        prevPtr= slowPtr;\n        slowPtr= slowPtr->nextNode;\n        fastPtr= fastPtr->nextNode->nextNode;\n    }\n\n    prevPtr->nextNode= NULL;\n\n    TreeNode *rootNode= new TreeNode(slowPtr->value);\n    rootNode->leftChild= sortedListToBST(head);\n    rootNode->rightChild= sortedListToBST(slowPtr->nextNode);\n    return rootNode;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nint getHeight(TreeNode *currentNode)\n{\n    if(!currentNode)\n        return 0;\n    int leftHeight= getHeight(currentNode->leftChild);\n    int rightHeight= getHeight(currentNode->rightChild);\n    if(leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) > 1)\n        return -1;\n    return 1 + max(leftHeight, rightHeight);\n}\n\nbool isBalanced(TreeNode *rootNode)\n{\n    return getHeight(rootNode) != -1;\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nint getHeight(TreeNode *currentNode)\n{\n    if(!currentNode)\n        return 0;\n    int leftHeight= getHeight(currentNode->leftChild);\n    int rightHeight= getHeight(currentNode->rightChild);\n    if(leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) > 1)\n        return -1;\n    return 1 + max(leftHeight, rightHeight);\n}\n\nbool isBalanced(TreeNode *rootNode)\n{\n    return getHeight(rootNode) != -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int minDepth(TreeNode *root)\n{\n    if(!root)\n        return 0;\n    int leftDepth= minDepth(root->left);\n    int rightDepth= minDepth(root->right);\n    return (leftDepth == 0 || rightDepth == 0) ? leftDepth + rightDepth + 1 : min(leftDepth, rightDepth) + 1;\n}",
    "output": "int minDepth(TreeNode *root)\n{\n    if(!root)\n        return 0;\n    int leftDepth= minDepth(root->left);\n    int rightDepth= minDepth(root->right);\n    return (leftDepth == 0 || rightDepth == 0) ? leftDepth + rightDepth + 1 : min(leftDepth, rightDepth) + 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nbool hasPathSum(TreeNode *rootNode, int targetSum)\n{\n    if(!rootNode)\n        return false;\n    if(!rootNode->leftChild && !rootNode->rightChild)\n        return targetSum - rootNode->value == 0;\n    return hasPathSum(rootNode->leftChild, targetSum - rootNode->value) || hasPathSum(rootNode->rightChild, targetSum - rootNode->value);\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nbool hasPathSum(TreeNode *rootNode, int targetSum)\n{\n    if(!rootNode)\n        return false;\n    if(!rootNode->leftChild && !rootNode->rightChild)\n        return targetSum - rootNode->value == 0;\n    return hasPathSum(rootNode->leftChild, targetSum - rootNode->value) || hasPathSum(rootNode->rightChild, targetSum - rootNode->value);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nvoid findPaths(TreeNode *currentNode, int targetSum, vector<int> &currentPath, vector<vector<int>> &resultPaths)\n{\n    if(!currentNode)\n        return;\n    currentPath.push_back(currentNode->value);\n    if(!currentNode->leftChild && !currentNode->rightChild && targetSum == currentNode->value)\n    {\n        resultPaths.push_back(currentPath);\n    }\n    findPaths(currentNode->leftChild, targetSum - currentNode->value, currentPath, resultPaths);\n    findPaths(currentNode->rightChild, targetSum - currentNode->value, currentPath, resultPaths);\n    currentPath.pop_back();\n}\n\nvector<vector<int>> pathSum(TreeNode *rootNode, int targetSum)\n{\n    vector<vector<int>> resultPaths;\n    vector<int> currentPath;\n    findPaths(rootNode, targetSum, currentPath, resultPaths);\n    return resultPaths;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nvoid findPaths(TreeNode *currentNode, int targetSum, std::vector<int> &currentPath, std::vector<std::vector<int>> &resultPaths)\n{\n    if(!currentNode)\n        return;\n    currentPath.push_back(currentNode->value);\n    if(!currentNode->leftChild && !currentNode->rightChild && targetSum == currentNode->value)\n    {\n        resultPaths.push_back(currentPath);\n    }\n    findPaths(currentNode->leftChild, targetSum - currentNode->value, currentPath, resultPaths);\n    findPaths(currentNode->rightChild, targetSum - currentNode->value, currentPath, resultPaths);\n    currentPath.pop_back();\n}\n\nstd::vector<std::vector<int>> pathSum(TreeNode *rootNode, int targetSum)\n{\n    std::vector<std::vector<int>> resultPaths;\n    std::vector<int> currentPath;\n    findPaths(rootNode, targetSum, currentPath, resultPaths);\n    return resultPaths;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "void flatten(TreeNode *rootNode)\n{\n    if(!rootNode)\n        return;\n    flatten(rootNode->left);\n    flatten(rootNode->right);\n    if(rootNode->left)\n    {\n        TreeNode *rightSubtree= rootNode->right;\n        rootNode->right= rootNode->left;\n        rootNode->left= NULL;\n        while(rootNode->right)\n            rootNode= rootNode->right;\n        rootNode->right= rightSubtree;\n    }\n}",
    "output": "void flatten(TreeNode *rootNode)\n{\n    if(!rootNode)\n        return;\n    flatten(rootNode->left);\n    flatten(rootNode->right);\n    if(rootNode->left)\n    {\n        TreeNode *rightSubtree= rootNode->right;\n        rootNode->right= rootNode->left;\n        rootNode->left= NULL;\n        while(rootNode->right)\n            rootNode= rootNode->right;\n        rootNode->right= rightSubtree;\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countDistinctSubsequences(string sourceString, string targetString)\n{\n    int sourceLength= sourceString.size(), targetLength= targetString.size();\n    vector<vector<unsigned int>> dpTable(sourceLength + 1, vector<unsigned int>(targetLength + 1, 0));\n\n    for(int i= 0; i <= sourceLength; i++)\n    {\n        dpTable[i][0]= 1;\n    }\n\n    for(int i= 1; i <= sourceLength; i++)\n    {\n        for(int j= 1; j <= targetLength; j++)\n        {\n            if(sourceString[i - 1] == targetString[j - 1])\n            {\n                dpTable[i][j]= dpTable[i - 1][j - 1] + dpTable[i - 1][j];\n            }\n            else\n            {\n                dpTable[i][j]= dpTable[i - 1][j];\n            }\n        }\n    }\n\n    return dpTable[sourceLength][targetLength];\n}",
    "output": "#include <bits/stdc++.h>\nint countDistinctSubsequences(std::string sourceString, std::string targetString)\n{\n    int sourceLength= sourceString.size(), targetLength= targetString.size();\n    std::vector<std::vector<unsigned int>> dpTable(sourceLength + 1, std::vector<unsigned int>(targetLength + 1, 0));\n\n    for(int i= 0; i <= sourceLength; i++)\n    {\n        dpTable[i][0]= 1;\n    }\n\n    for(int i= 1; i <= sourceLength; i++)\n    {\n        for(int j= 1; j <= targetLength; j++)\n        {\n            if(sourceString[i - 1] == targetString[j - 1])\n            {\n                dpTable[i][j]= dpTable[i - 1][j - 1] + dpTable[i - 1][j];\n            }\n            else\n            {\n                dpTable[i][j]= dpTable[i - 1][j];\n            }\n        }\n    }\n\n    return dpTable[sourceLength][targetLength];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "void connect(Node *rootNode)\n{\n    if(!rootNode)\n        return;\n    if(rootNode->left)\n    {\n        rootNode->left->next= rootNode->right;\n        if(rootNode->next)\n        {\n            rootNode->right->next= rootNode->next->left;\n        }\n    }\n    connect(rootNode->left);\n    connect(rootNode->right);\n}",
    "output": "void connect(Node *rootNode)\n{\n    if(!rootNode)\n        return;\n    if(rootNode->left)\n    {\n        rootNode->left->next= rootNode->right;\n        if(rootNode->next)\n        {\n            rootNode->right->next= rootNode->next->left;\n        }\n    }\n    connect(rootNode->left);\n    connect(rootNode->right);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Node\n{\n  public:\n    int value;\n    Node *leftChild;\n    Node *rightChild;\n    Node *nextNode;\n\n    Node(int valueIn) : value(valueIn), leftChild(NULL), rightChild(NULL), nextNode(NULL) {}\n};\n\nNode *connect(Node *rootNode)\n{\n    if(!rootNode)\n        return NULL;\n\n    queue<Node *> nodeQueue;\n    nodeQueue.push(rootNode);\n\n    while(!nodeQueue.empty())\n    {\n        int levelSize= nodeQueue.size();\n        Node *previousNode= NULL;\n\n        for(int i= 0; i < levelSize; ++i)\n        {\n            Node *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n\n            if(previousNode)\n                previousNode->nextNode= currentNode;\n            previousNode= currentNode;\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n    }\n\n    return rootNode;\n}",
    "output": "#include <bits/stdc++.h>\nclass Node\n{\n  public:\n    int value;\n    Node *leftChild;\n    Node *rightChild;\n    Node *nextNode;\n\n    Node(int valueIn) : value(valueIn), leftChild(NULL), rightChild(NULL), nextNode(NULL) {}\n};\n\nNode *connect(Node *rootNode)\n{\n    if(!rootNode)\n        return NULL;\n\n    std::queue<Node *> nodeQueue;\n    nodeQueue.push(rootNode);\n\n    while(!nodeQueue.empty())\n    {\n        int levelSize= nodeQueue.size();\n        Node *previousNode= NULL;\n\n        for(int i= 0; i < levelSize; ++i)\n        {\n            Node *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n\n            if(previousNode)\n                previousNode->nextNode= currentNode;\n            previousNode= currentNode;\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n    }\n\n    return rootNode;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> generate(int numberOfRows)\n{\n    vector<vector<int>> pascalTriangle(numberOfRows);\n    for(int rowIndex= 0; rowIndex < numberOfRows; rowIndex++)\n    {\n        pascalTriangle[rowIndex].resize(rowIndex + 1);\n        pascalTriangle[rowIndex][0]= pascalTriangle[rowIndex][rowIndex]= 1;\n        for(int columnIndex= 1; columnIndex < rowIndex; columnIndex++)\n        {\n            pascalTriangle[rowIndex][columnIndex]= pascalTriangle[rowIndex - 1][columnIndex - 1] + pascalTriangle[rowIndex - 1][columnIndex];\n        }\n    }\n    return pascalTriangle;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> generate(int numberOfRows)\n{\n    std::vector<std::vector<int>> pascalTriangle(numberOfRows);\n    for(int rowIndex= 0; rowIndex < numberOfRows; rowIndex++)\n    {\n        pascalTriangle[rowIndex].resize(rowIndex + 1);\n        pascalTriangle[rowIndex][0]= pascalTriangle[rowIndex][rowIndex]= 1;\n        for(int columnIndex= 1; columnIndex < rowIndex; columnIndex++)\n        {\n            pascalTriangle[rowIndex][columnIndex]= pascalTriangle[rowIndex - 1][columnIndex - 1] + pascalTriangle[rowIndex - 1][columnIndex];\n        }\n    }\n    return pascalTriangle;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> getRow(int rowIndex)\n{\n    vector<int> row(rowIndex + 1, 1);\n    for(int currentRow= 1; currentRow <= rowIndex; currentRow++)\n    {\n        for(int columnIndex= currentRow - 1; columnIndex > 0; columnIndex--)\n        {\n            row[columnIndex]+= row[columnIndex - 1];\n        }\n    }\n    return row;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> getRow(int rowIndex)\n{\n    std::vector<int> row(rowIndex + 1, 1);\n    for(int currentRow= 1; currentRow <= rowIndex; currentRow++)\n    {\n        for(int columnIndex= currentRow - 1; columnIndex > 0; columnIndex--)\n        {\n            row[columnIndex]+= row[columnIndex - 1];\n        }\n    }\n    return row;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTotal(vector<vector<int>> &triangle)\n{\n    for(int currentRow= triangle.size() - 2; currentRow >= 0; currentRow--)\n    {\n        for(int currentCol= 0; currentCol < triangle[currentRow].size(); currentCol++)\n        {\n            triangle[currentRow][currentCol]+= min(triangle[currentRow + 1][currentCol], triangle[currentRow + 1][currentCol + 1]);\n        }\n    }\n    return triangle[0][0];\n}",
    "output": "#include <bits/stdc++.h>\nint minimumTotal(std::vector<std::vector<int>> &triangle)\n{\n    for(int currentRow= triangle.size() - 2; currentRow >= 0; currentRow--)\n    {\n        for(int currentCol= 0; currentCol < triangle[currentRow].size(); currentCol++)\n        {\n            triangle[currentRow][currentCol]+= std::min(triangle[currentRow + 1][currentCol], triangle[currentRow + 1][currentCol + 1]);\n        }\n    }\n    return triangle[0][0];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxProfit(vector<int> &prices)\n{\n    int minPrice = INT_MAX;\n    int maxProfit = 0;\n    for (int i = 0; i < prices.size(); ++i)\n    {\n        int currentPrice = prices[i];\n        minPrice = min(minPrice, currentPrice);\n        maxProfit = max(maxProfit, currentPrice - minPrice);\n    }\n    return maxProfit;\n}",
    "output": "#include <bits/stdc++.h>\nint maxProfit(std::vector<int> &prices)\n{\n    int minPrice = std::numeric_limits<int>::max();\n    int maxProfit = 0;\n    for(int currentPrice : prices)\n    {\n        minPrice = std::min(minPrice, currentPrice);\n        maxProfit = std::max(maxProfit, currentPrice - minPrice);\n    }\n    return maxProfit;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxProfit(vector<int> &stockPrices)\n{\n    int totalMaxProfit= 0;\n    for(int currentDay= 1; currentDay < stockPrices.size(); currentDay++)\n    {\n        if(stockPrices[currentDay] > stockPrices[currentDay - 1])\n        {\n            totalMaxProfit+= stockPrices[currentDay] - stockPrices[currentDay - 1];\n        }\n    }\n    return totalMaxProfit;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMaxProfit(std::vector<int> &stockPrices)\n{\n    int totalMaxProfit= 0;\n    for(int currentDay= 1; currentDay < stockPrices.size(); currentDay++)\n    {\n        if(stockPrices[currentDay] > stockPrices[currentDay - 1])\n        {\n            totalMaxProfit+= stockPrices[currentDay] - stockPrices[currentDay - 1];\n        }\n    }\n    return totalMaxProfit;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For INT_MAX\n // For min and max\nusing namespace std;\n\nint calculateMaxProfit(vector<int> &stockPrices)\n{\n    int firstBuyPrice = INT_MAX, secondBuyPrice = INT_MAX;\n    int firstProfit = 0, secondProfit = 0;\n\n    for (int i = 0; i < stockPrices.size(); ++i)\n    {\n        int currentPrice = stockPrices[i];\n        firstBuyPrice = min(firstBuyPrice, currentPrice);\n        firstProfit = max(firstProfit, currentPrice - firstBuyPrice);\n        secondBuyPrice = min(secondBuyPrice, currentPrice - firstProfit);\n        secondProfit = max(secondProfit, currentPrice - secondBuyPrice);\n    }\n\n    return secondProfit;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMaxProfit(std::vector<int> &stockPrices)\n{\n    int firstBuyPrice= std::numeric_limits<int>::max(), secondBuyPrice= std::numeric_limits<int>::max();\n    int firstProfit= 0, secondProfit= 0;\n\n    for(int currentPrice : stockPrices)\n    {\n        firstBuyPrice= std::min(firstBuyPrice, currentPrice);\n        firstProfit= std::max(firstProfit, currentPrice - firstBuyPrice);\n        secondBuyPrice= std::min(secondBuyPrice, currentPrice - firstProfit);\n        secondProfit= std::max(secondProfit, currentPrice - secondBuyPrice);\n    }\n\n    return secondProfit;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nint calculateMaxPathSum(TreeNode *currentNode, int &maximumSum)\n{\n    if(!currentNode)\n        return 0;\n\n    int leftMax= max(0, calculateMaxPathSum(currentNode->leftChild, maximumSum));\n    int rightMax= max(0, calculateMaxPathSum(currentNode->rightChild, maximumSum));\n\n    maximumSum= max(maximumSum, leftMax + rightMax + currentNode->value);\n\n    return max(leftMax, rightMax) + currentNode->value;\n}\n\nint getMaxPathSum(TreeNode *rootNode)\n{\n    int maximumSum= INT_MIN;\n    calculateMaxPathSum(rootNode, maximumSum);\n    return maximumSum;\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nint calculateMaxPathSum(TreeNode *currentNode, int &maximumSum)\n{\n    if(!currentNode)\n        return 0;\n\n    int leftMax= max(0, calculateMaxPathSum(currentNode->leftChild, maximumSum));\n    int rightMax= max(0, calculateMaxPathSum(currentNode->rightChild, maximumSum));\n\n    maximumSum= max(maximumSum, leftMax + rightMax + currentNode->value);\n\n    return max(leftMax, rightMax) + currentNode->value;\n}\n\nint getMaxPathSum(TreeNode *rootNode)\n{\n    int maximumSum= INT_MIN;\n    calculateMaxPathSum(rootNode, maximumSum);\n    return maximumSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPalindrome(string inputString)\n{\n    inputString.erase(remove_if(inputString.begin(), inputString.end(), [](char character)\n                                  { return !isalnum(character); }),\n                       inputString.end());\n    transform(inputString.begin(), inputString.end(), inputString.begin(), ::tolower);\n    int leftIndex = 0, rightIndex = inputString.size() - 1;\n    while (leftIndex < rightIndex)\n    {\n        if (inputString[leftIndex++] != inputString[rightIndex--])\n            return false;\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isPalindrome(std::string inputString)\n{\n    inputString.erase(std::remove_if(inputString.begin(), inputString.end(), [](char character)\n                                     { return !std::isalnum(character); }),\n                      inputString.end());\n    std::transform(inputString.begin(), inputString.end(), inputString.begin(), ::tolower);\n    int leftIndex= 0, rightIndex= inputString.size() - 1;\n    while(leftIndex < rightIndex)\n    {\n        if(inputString[leftIndex++] != inputString[rightIndex--])\n            return false;\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<string>> findLadders(string startWord, string targetWord, vector<string> &wordList)\n{\n    unordered_set<string> wordDictionary(wordList.begin(), wordList.end());\n    if(wordDictionary.find(targetWord) == wordDictionary.end())\n    {\n        return {};\n    }\n    unordered_map<string, vector<string>> adjacentWords;\n    unordered_map<string, int> wordDistance;\n\n    auto getNeighbors = [&](const string &currentWord)\n    {\n        vector<string> result;\n        string tempWord = currentWord;\n        for(char &character : tempWord)\n        {\n            char originalCharacter = character;\n            for(int i = 'a'; i <= 'z'; ++i)\n            {\n                character = i;\n                if(wordDictionary.count(tempWord) && tempWord != currentWord)\n                {\n                    result.push_back(tempWord);\n                }\n            }\n            character = originalCharacter;\n        }\n        return result;\n    };\n\n    queue<string> queue;\n    queue.push(startWord);\n    wordDistance[startWord] = 0;\n\n    while(!queue.empty())\n    {\n        string currentWord = queue.front();\n        queue.pop();\n        if(currentWord == targetWord)\n        {\n            break;\n        }\n        for (const string &neighborWord : getNeighbors(currentWord))\n        {\n            if(!wordDistance.count(neighborWord))\n            {\n                wordDistance[neighborWord] = wordDistance[currentWord] + 1;\n                queue.push(neighborWord);\n            }\n            if(wordDistance[neighborWord] == wordDistance[currentWord] + 1)\n            {\n                adjacentWords[currentWord].push_back(neighborWord);\n            }\n        }\n    }\n\n    vector<vector<string>> result;\n    vector<string> path = {startWord};\n    function<void(const string &)> backtrack = [&](const string &currentWord)\n    {\n        if(currentWord == targetWord)\n        {\n            result.push_back(path);\n            return;\n        }\n        for (const string &nextWord : adjacentWords[currentWord])\n        {\n            path.push_back(nextWord);\n            backtrack(nextWord);\n            path.pop_back();\n        }\n    };\n\n    backtrack(startWord);\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<std::string>> findLadders(std::string startWord, std::string targetWord, std::vector<std::string> &wordList)\n{\n    std::unordered_set<std::string> wordDictionary(wordList.begin(), wordList.end());\n    if(wordDictionary.find(targetWord) == wordDictionary.end())\n    {\n        return {};\n    }\n    std::unordered_map<std::string, std::vector<std::string>> adjacentWords;\n    std::unordered_map<std::string, int> wordDistance;\n\n    auto getNeighbors= [&](const std::string &currentWord)\n    {\n        std::vector<std::string> result;\n        std::string tempWord= currentWord;\n        for(char &character : tempWord)\n        {\n            char originalCharacter= character;\n            for(int i= 'a'; i <= 'z'; ++i)\n            {\n                character= i;\n                if(wordDictionary.count(tempWord) && tempWord != currentWord)\n                {\n                    result.push_back(tempWord);\n                }\n            }\n            character= originalCharacter;\n        }\n        return result;\n    };\n\n    std::queue<std::string> queue;\n    queue.push(startWord);\n    wordDistance[startWord]= 0;\n\n    while(!queue.empty())\n    {\n        std::string currentWord= queue.front();\n        queue.pop();\n        if(currentWord == targetWord)\n        {\n            break;\n        }\n        for(const std::string &neighborWord : getNeighbors(currentWord))\n        {\n            if(!wordDistance.count(neighborWord))\n            {\n                wordDistance[neighborWord]= wordDistance[currentWord] + 1;\n                queue.push(neighborWord);\n            }\n            if(wordDistance[neighborWord] == wordDistance[currentWord] + 1)\n            {\n                adjacentWords[currentWord].push_back(neighborWord);\n            }\n        }\n    }\n\n    std::vector<std::vector<std::string>> result;\n    std::vector<std::string> path= {startWord};\n    std::function<void(const std::string &)> backtrack= [&](const std::string &currentWord)\n    {\n        if(currentWord == targetWord)\n        {\n            result.push_back(path);\n            return;\n        }\n        for(const std::string &nextWord : adjacentWords[currentWord])\n        {\n            path.push_back(nextWord);\n            backtrack(nextWord);\n            path.pop_back();\n        }\n    };\n\n    backtrack(startWord);\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint ladderLength(string startWord, string targetWord, vector<string> &wordList)\n{\n    unordered_set<string> dictionary(wordList.begin(), wordList.end());\n    if(!dictionary.count(targetWord))\n        return 0;\n\n    queue<string> wordQueue;\n    wordQueue.push(startWord);\n    int numberOfSteps = 1;\n\n    while(!wordQueue.empty())\n    {\n        int currentLevelSize = wordQueue.size();\n        for(int i = 0; i < currentLevelSize; ++i)\n        {\n            string currentWord = wordQueue.front();\n            wordQueue.pop();\n            if(currentWord == targetWord)\n                return numberOfSteps;\n\n            for(int j = 0; j < currentWord.size(); ++j)\n            {\n                char originalCharacter = currentWord[j];\n                for(int k = 0; k < 26; ++k)\n                {\n                    currentWord[j] = 'a' + k;\n                    if(dictionary.count(currentWord))\n                    {\n                        wordQueue.push(currentWord);\n                        dictionary.erase(currentWord);\n                    }\n                }\n                currentWord[j] = originalCharacter;\n            }\n        }\n        ++numberOfSteps;\n    }\n    return 0;\n}",
    "output": "#include <bits/stdc++.h>\nint ladderLength(std::string startWord, std::string targetWord, std::vector<std::string> &wordList)\n{\n    std::unordered_set<std::string> dictionary(wordList.begin(), wordList.end());\n    if(!dictionary.count(targetWord))\n        return 0;\n\n    std::queue<std::string> wordQueue;\n    wordQueue.push(startWord);\n    int numberOfSteps= 1;\n\n    while(!wordQueue.empty())\n    {\n        int currentLevelSize= wordQueue.size();\n        for(int i= 0; i < currentLevelSize; ++i)\n        {\n            std::string currentWord= wordQueue.front();\n            wordQueue.pop();\n            if(currentWord == targetWord)\n                return numberOfSteps;\n\n            for(char &character : currentWord)\n            {\n                char originalCharacter= character;\n                for(int j= 0; j < 26; ++j)\n                {\n                    character= 'a' + j;\n                    if(dictionary.count(currentWord))\n                    {\n                        wordQueue.push(currentWord);\n                        dictionary.erase(currentWord);\n                    }\n                }\n                character= originalCharacter;\n            }\n        }\n        ++numberOfSteps;\n    }\n    return 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint longestConsecutiveSequence(vector<int> &numbers)\n{\n    unordered_set<int> uniqueElements(numbers.begin(), numbers.end());\n    int longestSequence = 0;\n\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        if (uniqueElements.find(currentNumber - 1) == uniqueElements.end())\n        {\n            int tempNumber = currentNumber;\n            int currentSequence = 1;\n\n            while (uniqueElements.find(tempNumber + 1) != uniqueElements.end())\n            {\n                tempNumber += 1;\n                currentSequence += 1;\n            }\n\n            longestSequence = max(longestSequence, currentSequence);\n        }\n    }\n    return longestSequence;\n}",
    "output": "#include <bits/stdc++.h>\nint longestConsecutiveSequence(std::vector<int> &numbers)\n{\n    std::unordered_set<int> uniqueElements(numbers.begin(), numbers.end());\n    int longestSequence= 0;\n\n    for(int currentNumber : numbers)\n    {\n        if(uniqueElements.find(currentNumber - 1) == uniqueElements.end())\n        {\n            int tempNumber= currentNumber;\n            int currentSequence= 1;\n\n            while(uniqueElements.find(tempNumber + 1) != uniqueElements.end())\n            {\n                tempNumber+= 1;\n                currentSequence+= 1;\n            }\n\n            longestSequence= std::max(longestSequence, currentSequence);\n        }\n    }\n    return longestSequence;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int sumNumbers(TreeNode *rootNode, int currentSum= 0)\n{\n    if(!rootNode)\n        return 0;\n    currentSum= currentSum * 10 + rootNode->val;\n    if(!rootNode->left && !rootNode->right)\n        return currentSum;\n    return sumNumbers(rootNode->left, currentSum) + sumNumbers(rootNode->right, currentSum);\n}",
    "output": "int sumNumbers(TreeNode *rootNode, int currentSum= 0)\n{\n    if(!rootNode)\n        return 0;\n    currentSum= currentSum * 10 + rootNode->val;\n    if(!rootNode->left && !rootNode->right)\n        return currentSum;\n    return sumNumbers(rootNode->left, currentSum) + sumNumbers(rootNode->right, currentSum);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(vector<vector<char>> &gameBoard, int row, int column)\n{\n    if(row < 0 || row >= gameBoard.size() || column < 0 || column >= gameBoard[0].size() || gameBoard[row][column] != 'O')\n    {\n        return;\n    }\n    gameBoard[row][column]= '#';\n    depthFirstSearch(gameBoard, row - 1, column);\n    depthFirstSearch(gameBoard, row + 1, column);\n    depthFirstSearch(gameBoard, row, column - 1);\n    depthFirstSearch(gameBoard, row, column + 1);\n}\n\nvoid solveBoard(vector<vector<char>> &gameBoard)\n{\n    if(gameBoard.empty())\n        return;\n    int numberOfRows= gameBoard.size(), numberOfColumns= gameBoard[0].size();\n\n    for(int row= 0; row < numberOfRows; ++row)\n    {\n        depthFirstSearch(gameBoard, row, 0);\n        depthFirstSearch(gameBoard, row, numberOfColumns - 1);\n    }\n    for(int column= 0; column < numberOfColumns; ++column)\n    {\n        depthFirstSearch(gameBoard, 0, column);\n        depthFirstSearch(gameBoard, numberOfRows - 1, column);\n    }\n    for(int row= 0; row < numberOfRows; ++row)\n    {\n        for(int column= 0; column < numberOfColumns; ++column)\n        {\n            if(gameBoard[row][column] == '#')\n                gameBoard[row][column]= 'O';\n            else if(gameBoard[row][column] == 'O')\n                gameBoard[row][column]= 'X';\n        }\n    }\n}",
    "output": "#include <bits/stdc++.h>\nvoid depthFirstSearch(std::vector<std::vector<char>> &gameBoard, int row, int column)\n{\n    if(row < 0 || row >= gameBoard.size() || column < 0 || column >= gameBoard[0].size() || gameBoard[row][column] != 'O')\n    {\n        return;\n    }\n    gameBoard[row][column]= '#';\n    depthFirstSearch(gameBoard, row - 1, column);\n    depthFirstSearch(gameBoard, row + 1, column);\n    depthFirstSearch(gameBoard, row, column - 1);\n    depthFirstSearch(gameBoard, row, column + 1);\n}\n\nvoid solveBoard(std::vector<std::vector<char>> &gameBoard)\n{\n    if(gameBoard.empty())\n        return;\n    int numberOfRows= gameBoard.size(), numberOfColumns= gameBoard[0].size();\n\n    for(int row= 0; row < numberOfRows; ++row)\n    {\n        depthFirstSearch(gameBoard, row, 0);\n        depthFirstSearch(gameBoard, row, numberOfColumns - 1);\n    }\n    for(int column= 0; column < numberOfColumns; ++column)\n    {\n        depthFirstSearch(gameBoard, 0, column);\n        depthFirstSearch(gameBoard, numberOfRows - 1, column);\n    }\n    for(int row= 0; row < numberOfRows; ++row)\n    {\n        for(int column= 0; column < numberOfColumns; ++column)\n        {\n            if(gameBoard[row][column] == '#')\n                gameBoard[row][column]= 'O';\n            else if(gameBoard[row][column] == 'O')\n                gameBoard[row][column]= 'X';\n        }\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPalindrome(const string &inputString, int startIndex, int endIndex)\n{\n    while(startIndex < endIndex)\n    {\n        if(inputString[startIndex++] != inputString[endIndex--])\n            return false;\n    }\n    return true;\n}\n\nvoid depthFirstSearch(const string &inputString, int startIndex, vector<vector<string>> &partitionResults, vector<string> currentPartition)\n{\n    if(startIndex == inputString.length())\n    {\n        partitionResults.push_back(currentPartition);\n        return;\n    }\n\n    for(int endIndex= startIndex; endIndex < inputString.length(); ++endIndex)\n    {\n        if(isPalindrome(inputString, startIndex, endIndex))\n        {\n            currentPartition.push_back(inputString.substr(startIndex, endIndex - startIndex + 1));\n            depthFirstSearch(inputString, endIndex + 1, partitionResults, currentPartition);\n            currentPartition.pop_back();\n        }\n    }\n}\n\nvector<vector<string>> partition(string inputString)\n{\n    vector<vector<string>> partitionResults;\n    vector<string> currentPartition;\n    depthFirstSearch(inputString, 0, partitionResults, currentPartition);\n    return partitionResults;\n}",
    "output": "#include <bits/stdc++.h>\nbool isPalindrome(const std::string &inputString, int startIndex, int endIndex)\n{\n    while(startIndex < endIndex)\n    {\n        if(inputString[startIndex++] != inputString[endIndex--])\n            return false;\n    }\n    return true;\n}\n\nvoid depthFirstSearch(const std::string &inputString, int startIndex, std::vector<std::vector<std::string>> &partitionResults, std::vector<std::string> currentPartition)\n{\n    if(startIndex == inputString.length())\n    {\n        partitionResults.push_back(currentPartition);\n        return;\n    }\n\n    for(int endIndex= startIndex; endIndex < inputString.length(); ++endIndex)\n    {\n        if(isPalindrome(inputString, startIndex, endIndex))\n        {\n            currentPartition.push_back(inputString.substr(startIndex, endIndex - startIndex + 1));\n            depthFirstSearch(inputString, endIndex + 1, partitionResults, currentPartition);\n            currentPartition.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<std::string>> partition(std::string inputString)\n{\n    std::vector<std::vector<std::string>> partitionResults;\n    std::vector<std::string> currentPartition;\n    depthFirstSearch(inputString, 0, partitionResults, currentPartition);\n    return partitionResults;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minCut(string inputString)\n{\n    int stringLength= inputString.size();\n    vector<int> cutCount(stringLength + 1, 0);\n    vector<vector<bool>> palindromeTable(stringLength, vector<bool>(stringLength, false));\n\n    for(int index= 0; index <= stringLength; index++)\n    {\n        cutCount[index]= index - 1;\n    }\n\n    for(int endIndex= 1; endIndex < stringLength; endIndex++)\n    {\n        for(int startIndex= endIndex; startIndex >= 0; startIndex--)\n        {\n            if(inputString[startIndex] == inputString[endIndex] && (endIndex - startIndex < 2 || palindromeTable[startIndex + 1][endIndex - 1]))\n            {\n                palindromeTable[startIndex][endIndex]= true;\n                cutCount[endIndex + 1]= min(cutCount[endIndex + 1], cutCount[startIndex] + 1);\n            }\n        }\n    }\n\n    return cutCount[stringLength];\n}",
    "output": "#include <bits/stdc++.h>\nint minCut(std::string inputString)\n{\n    int stringLength= inputString.size();\n    std::vector<int> cutCount(stringLength + 1, 0);\n    std::vector<std::vector<bool>> palindromeTable(stringLength, std::vector<bool>(stringLength, false));\n\n    for(int index= 0; index <= stringLength; index++)\n    {\n        cutCount[index]= index - 1;\n    }\n\n    for(int endIndex= 1; endIndex < stringLength; endIndex++)\n    {\n        for(int startIndex= endIndex; startIndex >= 0; startIndex--)\n        {\n            if(inputString[startIndex] == inputString[endIndex] && (endIndex - startIndex < 2 || palindromeTable[startIndex + 1][endIndex - 1]))\n            {\n                palindromeTable[startIndex][endIndex]= true;\n                cutCount[endIndex + 1]= std::min(cutCount[endIndex + 1], cutCount[startIndex] + 1);\n            }\n        }\n    }\n\n    return cutCount[stringLength];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass GraphNode\n{\n  public:\n    int value;\n    vector<GraphNode *> neighbors;\n\n    GraphNode(int valueIn)\n    {\n        value = valueIn;\n        neighbors = vector<GraphNode *>();\n    }\n};\n\nGraphNode *cloneGraph(GraphNode *originalNode, unordered_map<GraphNode *, GraphNode *> &visitedNodes)\n{\n    if(originalNode == NULL)\n    {\n        return NULL;\n    }\n\n    if(visitedNodes.find(originalNode) != visitedNodes.end())\n    {\n        return visitedNodes[originalNode];\n    }\n\n    GraphNode *clonedNode = new GraphNode(originalNode->value);\n    visitedNodes[originalNode] = clonedNode;\n\n    for (size_t i = 0; i < originalNode->neighbors.size(); ++i)\n    {\n        GraphNode *neighbor = originalNode->neighbors[i];\n        clonedNode->neighbors.push_back(cloneGraph(neighbor, visitedNodes));\n    }\n\n    return clonedNode;\n}\n\nGraphNode *cloneGraph(GraphNode *originalNode)\n{\n    unordered_map<GraphNode *, GraphNode *> visitedNodes;\n    return cloneGraph(originalNode, visitedNodes);\n}",
    "output": "#include <bits/stdc++.h>\nclass GraphNode\n{\n  public:\n    int value;\n    std::vector<GraphNode *> neighbors;\n\n    GraphNode(int valueIn)\n    {\n        value= valueIn;\n        neighbors= std::vector<GraphNode *>();\n    }\n};\n\nGraphNode *cloneGraph(GraphNode *originalNode, std::unordered_map<GraphNode *, GraphNode *> &visitedNodes)\n{\n    if(originalNode == NULL)\n    {\n        return NULL;\n    }\n\n    if(visitedNodes.find(originalNode) != visitedNodes.end())\n    {\n        return visitedNodes[originalNode];\n    }\n\n    GraphNode *clonedNode= new GraphNode(originalNode->value);\n    visitedNodes[originalNode]= clonedNode;\n\n    for(GraphNode *neighbor : originalNode->neighbors)\n    {\n        clonedNode->neighbors.push_back(cloneGraph(neighbor, visitedNodes));\n    }\n\n    return clonedNode;\n}\n\nGraphNode *cloneGraph(GraphNode *originalNode)\n{\n    std::unordered_map<GraphNode *, GraphNode *> visitedNodes;\n    return cloneGraph(originalNode, visitedNodes);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint canCompleteCircuit(vector<int> &gasStations, vector<int> &travelCosts)\n{\n    int totalGas= 0, totalCost= 0, startPoint= 0, gasTank= 0;\n    for(int i= 0; i < gasStations.size(); ++i)\n    {\n        totalGas+= gasStations[i];\n        totalCost+= travelCosts[i];\n        gasTank+= gasStations[i] - travelCosts[i];\n        if(gasTank < 0)\n        {\n            startPoint= i + 1;\n            gasTank= 0;\n        }\n    }\n    return (totalGas < totalCost) ? -1 : startPoint;\n}",
    "output": "#include <bits/stdc++.h>\nint canCompleteCircuit(std::vector<int> &gasStations, std::vector<int> &travelCosts)\n{\n    int totalGas= 0, totalCost= 0, startPoint= 0, gasTank= 0;\n    for(int i= 0; i < gasStations.size(); ++i)\n    {\n        totalGas+= gasStations[i];\n        totalCost+= travelCosts[i];\n        gasTank+= gasStations[i] - travelCosts[i];\n        if(gasTank < 0)\n        {\n            startPoint= i + 1;\n            gasTank= 0;\n        }\n    }\n    return (totalGas < totalCost) ? -1 : startPoint;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minCandies(vector<int> &ratings)\n{\n    int numberOfChildren = ratings.size();\n    vector<int> candies(numberOfChildren, 1);\n\n    for (int childIndex = 1; childIndex < numberOfChildren; childIndex++)\n    {\n        if (ratings[childIndex] > ratings[childIndex - 1])\n            candies[childIndex] = candies[childIndex - 1] + 1;\n    }\n    for (int childIndex = numberOfChildren - 2; childIndex >= 0; childIndex--)\n    {\n        if (ratings[childIndex] > ratings[childIndex + 1])\n            candies[childIndex] = max(candies[childIndex], candies[childIndex + 1] + 1);\n    }\n\n    int totalCandies = 0;\n    for (int i = 0; i < candies.size(); ++i) // Changed to traditional for loop\n        totalCandies += candies[i];\n\n    return totalCandies;\n}",
    "output": "#include <bits/stdc++.h>\nint minCandies(std::vector<int> &ratings)\n{\n    int numberOfChildren = ratings.size();\n    std::vector<int> candies(numberOfChildren, 1);\n\n    for(int childIndex = 1; childIndex < numberOfChildren; childIndex++)\n    {\n        if(ratings[childIndex] > ratings[childIndex - 1])\n            candies[childIndex] = candies[childIndex - 1] + 1;\n    }\n    for(int childIndex = numberOfChildren - 2; childIndex >= 0; childIndex--)\n    {\n        if(ratings[childIndex] > ratings[childIndex + 1])\n            candies[childIndex] = std::max(candies[childIndex], candies[childIndex + 1] + 1);\n    }\n\n    int totalCandies = 0;\n    for(int candyCount : candies)\n        totalCandies += candyCount;\n\n    return totalCandies;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findSingleNumber(vector<int> &numberList)\n{\n    int uniqueNumber = 0;\n    for (int i = 0; i < numberList.size(); ++i)\n    {\n        int currentNumber = numberList[i];\n        uniqueNumber ^= currentNumber;\n    }\n    return uniqueNumber;\n}",
    "output": "#include <bits/stdc++.h>\nint findSingleNumber(std::vector<int> &numberList)\n{\n    int uniqueNumber= 0;\n    for(int currentNumber : numberList)\n    {\n        uniqueNumber^= currentNumber;\n    }\n    return uniqueNumber;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findSingleNumber(vector<int> &numberList)\n{\n    int uniqueCount = 0, duplicateCount = 0;\n    for (int i = 0; i < numberList.size(); ++i)\n    {\n        int currentNumber = numberList[i];\n        uniqueCount = (uniqueCount ^ currentNumber) & ~duplicateCount;\n        duplicateCount = (duplicateCount ^ currentNumber) & ~uniqueCount;\n    }\n    return uniqueCount;\n}",
    "output": "#include <bits/stdc++.h>\nint findSingleNumber(std::vector<int> &numberList)\n{\n    int uniqueCount= 0, duplicateCount= 0;\n    for(int currentNumber : numberList)\n    {\n        uniqueCount= (uniqueCount ^ currentNumber) & ~duplicateCount;\n        duplicateCount= (duplicateCount ^ currentNumber) & ~uniqueCount;\n    }\n    return uniqueCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For input/output operations (if needed)\nusing namespace std;\n\nclass Node\n{\n  public:\n    int value;\n    Node *next;\n    Node *random;\n\n    Node(int valueIn)\n    {\n        value = valueIn;\n        next = NULL;\n        random = NULL;\n    }\n};\n\nNode *copyRandomList(Node *head)\n{\n    if (!head)\n        return NULL;\n\n    Node *currentNode = head;\n    while (currentNode)\n    {\n        Node *newNode = new Node(currentNode->value);\n        newNode->next = currentNode->next;\n        currentNode->next = newNode;\n        currentNode = currentNode->next->next;\n    }\n\n    currentNode = head;\n    while (currentNode)\n    {\n        if (currentNode->random)\n        {\n            currentNode->next->random = currentNode->random->next;\n        }\n        currentNode = currentNode->next->next;\n    }\n\n    Node *originalNode = head;\n    Node *copyNode = head->next;\n    Node *copyHead = copyNode;\n\n    while (originalNode && copyNode)\n    {\n        originalNode->next = copyNode->next;\n        originalNode = originalNode->next;\n        if (originalNode)\n        {\n            copyNode->next = originalNode->next;\n            copyNode = copyNode->next;\n        }\n    }\n\n    return copyHead;\n}",
    "output": "#include <bits/stdc++.h>\n// For std::NULL_t\n // For standard input/output (if needed)\n\nclass Node\n{\n  public:\n    int value;\n    Node *next;\n    Node *random;\n\n    Node(int valueIn)\n    {\n        value= valueIn;\n        next= NULL;\n        random= NULL;\n    }\n};\n\nNode *copyRandomList(Node *head)\n{\n    if(!head)\n        return NULL;\n\n    Node *currentNode= head;\n    while(currentNode)\n    {\n        Node *newNode= new Node(currentNode->value);\n        newNode->next= currentNode->next;\n        currentNode->next= newNode;\n        currentNode= currentNode->next->next;\n    }\n\n    currentNode= head;\n    while(currentNode)\n    {\n        if(currentNode->random)\n        {\n            currentNode->next->random= currentNode->random->next;\n        }\n        currentNode= currentNode->next->next;\n    }\n\n    Node *originalNode= head;\n    Node *copyNode= head->next;\n    Node *copyHead= copyNode;\n\n    while(originalNode && copyNode)\n    {\n        originalNode->next= copyNode->next;\n        originalNode= originalNode->next;\n        if(originalNode)\n        {\n            copyNode->next= originalNode->next;\n            copyNode= copyNode->next;\n        }\n    }\n\n    return copyHead;\n}\n"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool wordBreak(string inputString, vector<string> &wordDictionary)\n{\n    unordered_set<string> wordSet(wordDictionary.begin(), wordDictionary.end());\n    vector<bool> canBreak(inputString.size() + 1, false);\n    canBreak[0] = true;\n    for(size_t currentIndex = 1; currentIndex <= inputString.size(); ++currentIndex)\n    {\n        for(size_t previousIndex = 0; previousIndex < currentIndex; ++previousIndex)\n        {\n            if(canBreak[previousIndex] && wordSet.find(inputString.substr(previousIndex, currentIndex - previousIndex)) != wordSet.end())\n            {\n                canBreak[currentIndex] = true;\n                break;\n            }\n        }\n    }\n    return canBreak[inputString.size()];\n}",
    "output": "#include <bits/stdc++.h>\nbool wordBreak(std::string inputString, std::vector<std::string> &wordDictionary)\n{\n    std::unordered_set<std::string> wordSet(wordDictionary.begin(), wordDictionary.end());\n    std::vector<bool> canBreak(inputString.size() + 1, false);\n    canBreak[0]= true;\n    for(size_t currentIndex= 1; currentIndex <= inputString.size(); ++currentIndex)\n    {\n        for(size_t previousIndex= 0; previousIndex < currentIndex; ++previousIndex)\n        {\n            if(canBreak[previousIndex] && wordSet.find(inputString.substr(previousIndex, currentIndex - previousIndex)) != wordSet.end())\n            {\n                canBreak[currentIndex]= true;\n                break;\n            }\n        }\n    }\n    return canBreak[inputString.size()];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> segmentWords(const string &inputString, const unordered_set<string> &wordSet, unordered_map<string, vector<string>> &memoization)\n{\n    if(memoization.count(inputString))\n        return memoization[inputString];\n\n    vector<string> result;\n    if(wordSet.count(inputString))\n        result.push_back(inputString);\n\n    for(int index = 1; index < inputString.size(); ++index)\n    {\n        string prefix = inputString.substr(0, index);\n        if(!wordSet.count(prefix))\n            continue;\n        string suffix = inputString.substr(index);\n        auto tempResults = segmentWords(suffix, wordSet, memoization);\n        for(int i = 0; i < tempResults.size(); ++i)\n        {\n            const auto &temp = tempResults[i];\n            result.push_back(prefix + \" \" + temp);\n        }\n    }\n    memoization[inputString] = result;\n    return result;\n}\n\nvector<string> wordBreak(string inputString, vector<string> &wordDictionary)\n{\n    unordered_set<string> wordSet(wordDictionary.begin(), wordDictionary.end());\n    unordered_map<string, vector<string>> memoization;\n    return segmentWords(inputString, wordSet, memoization);\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> segmentWords(const std::string &inputString, const std::unordered_set<std::string> &wordSet, std::unordered_map<std::string, std::vector<std::string>> &memoization)\n{\n    if(memoization.count(inputString))\n        return memoization[inputString];\n\n    std::vector<std::string> result;\n    if(wordSet.count(inputString))\n        result.push_back(inputString);\n\n    for(int index= 1; index < inputString.size(); ++index)\n    {\n        std::string prefix= inputString.substr(0, index);\n        if(!wordSet.count(prefix))\n            continue;\n        std::string suffix= inputString.substr(index);\n        auto tempResults= segmentWords(suffix, wordSet, memoization);\n        for(const auto &temp : tempResults)\n        {\n            result.push_back(prefix + \" \" + temp);\n        }\n    }\n    memoization[inputString]= result;\n    return result;\n}\n\nstd::vector<std::string> wordBreak(std::string inputString, std::vector<std::string> &wordDictionary)\n{\n    std::unordered_set<std::string> wordSet(wordDictionary.begin(), wordDictionary.end());\n    std::unordered_map<std::string, std::vector<std::string>> memoization;\n    return segmentWords(inputString, wordSet, memoization);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "bool hasCycle(ListNode *head)\n{\n    ListNode *slowPointer= head, *fastPointer= head;\n    while(fastPointer != NULL && fastPointer->next != NULL)\n    {\n        slowPointer= slowPointer->next;\n        fastPointer= fastPointer->next->next;\n        if(slowPointer == fastPointer)\n        {\n            return true;\n        }\n    }\n    return false;\n}",
    "output": "bool hasCycle(ListNode *head)\n{\n    ListNode *slowPointer= head, *fastPointer= head;\n    while(fastPointer != NULL && fastPointer->next != NULL)\n    {\n        slowPointer= slowPointer->next;\n        fastPointer= fastPointer->next->next;\n        if(slowPointer == fastPointer)\n        {\n            return true;\n        }\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class ListNode\n{\n  public:\n    int value;\n    ListNode *nextNode;\n};\n\nListNode *detectCycle(ListNode *head)\n{\n    ListNode *slowPointer= head;\n    ListNode *fastPointer= head;\n\n    while(fastPointer != NULL && fastPointer->nextNode != NULL)\n    {\n        slowPointer= slowPointer->nextNode;\n        fastPointer= fastPointer->nextNode->nextNode;\n\n        if(slowPointer == fastPointer)\n        {\n            ListNode *cycleStart= head;\n            while(cycleStart != slowPointer)\n            {\n                cycleStart= cycleStart->nextNode;\n                slowPointer= slowPointer->nextNode;\n            }\n            return cycleStart;\n        }\n    }\n\n    return NULL;\n}",
    "output": "class ListNode\n{\n  public:\n    int value;\n    ListNode *nextNode;\n};\n\nListNode *detectCycle(ListNode *head)\n{\n    ListNode *slowPointer= head;\n    ListNode *fastPointer= head;\n\n    while(fastPointer != NULL && fastPointer->nextNode != NULL)\n    {\n        slowPointer= slowPointer->nextNode;\n        fastPointer= fastPointer->nextNode->nextNode;\n\n        if(slowPointer == fastPointer)\n        {\n            ListNode *cycleStart= head;\n            while(cycleStart != slowPointer)\n            {\n                cycleStart= cycleStart->nextNode;\n                slowPointer= slowPointer->nextNode;\n            }\n            return cycleStart;\n        }\n    }\n\n    return NULL;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nvoid reorderList(ListNode *head)\n{\n    if(!head || !head->next || !head->next->next)\n        return;\n\n    // Find the middle node\n    ListNode *slowPointer= head;\n    ListNode *fastPointer= head;\n    while(fastPointer->next && fastPointer->next->next)\n    {\n        slowPointer= slowPointer->next;\n        fastPointer= fastPointer->next->next;\n    }\n\n    // Reverse the second half\n    ListNode *previousNode= NULL;\n    ListNode *currentNode= slowPointer->next;\n    ListNode *nextNode;\n    while(currentNode)\n    {\n        nextNode= currentNode->next;\n        currentNode->next= previousNode;\n        previousNode= currentNode;\n        currentNode= nextNode;\n    }\n    slowPointer->next= NULL;\n\n    // Merge two halves\n    ListNode *firstHalf= head;\n    ListNode *secondHalf= previousNode;\n    while(secondHalf)\n    {\n        nextNode= firstHalf->next;\n        firstHalf->next= secondHalf;\n        firstHalf= firstHalf->next;\n        secondHalf= nextNode;\n    }\n}",
    "output": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nvoid reorderList(ListNode *head)\n{\n    if(!head || !head->next || !head->next->next)\n        return;\n\n    // Find the middle node\n    ListNode *slowPointer= head;\n    ListNode *fastPointer= head;\n    while(fastPointer->next && fastPointer->next->next)\n    {\n        slowPointer= slowPointer->next;\n        fastPointer= fastPointer->next->next;\n    }\n\n    // Reverse the second half\n    ListNode *previousNode= NULL;\n    ListNode *currentNode= slowPointer->next;\n    ListNode *nextNode;\n    while(currentNode)\n    {\n        nextNode= currentNode->next;\n        currentNode->next= previousNode;\n        previousNode= currentNode;\n        currentNode= nextNode;\n    }\n    slowPointer->next= NULL;\n\n    // Merge two halves\n    ListNode *firstHalf= head;\n    ListNode *secondHalf= previousNode;\n    while(secondHalf)\n    {\n        nextNode= firstHalf->next;\n        firstHalf->next= secondHalf;\n        firstHalf= firstHalf->next;\n        secondHalf= nextNode;\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nvector<int> preorderTraversal(TreeNode *root)\n{\n    vector<int> traversalResult;\n    if(root == NULL)\n    {\n        return traversalResult;\n    }\n\n    traversalResult.push_back(root->value);\n    vector<int> leftTraversal = preorderTraversal(root->leftChild);\n    vector<int> rightTraversal = preorderTraversal(root->rightChild);\n\n    traversalResult.insert(traversalResult.end(), leftTraversal.begin(), leftTraversal.end());\n    traversalResult.insert(traversalResult.end(), rightTraversal.begin(), rightTraversal.end());\n\n    return traversalResult;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nstd::vector<int> preorderTraversal(TreeNode *root)\n{\n    std::vector<int> traversalResult;\n    if(root == NULL)\n    {\n        return traversalResult;\n    }\n\n    traversalResult.push_back(root->value);\n    std::vector<int> leftTraversal= preorderTraversal(root->leftChild);\n    std::vector<int> rightTraversal= preorderTraversal(root->rightChild);\n\n    traversalResult.insert(traversalResult.end(), leftTraversal.begin(), leftTraversal.end());\n    traversalResult.insert(traversalResult.end(), rightTraversal.begin(), rightTraversal.end());\n\n    return traversalResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int Value;\n    TreeNode *LeftChild;\n    TreeNode *RightChild;\n    TreeNode(int x) : Value(x), LeftChild(NULL), RightChild(NULL) {}\n};\n\nvector<int> postorderTraversal(TreeNode *rootNode)\n{\n    vector<int> traversalResult;\n    stack<TreeNode *> nodeStack;\n\n    if(!rootNode)\n        return traversalResult;\n\n    nodeStack.push(rootNode);\n    while(!nodeStack.empty())\n    {\n        TreeNode *currentNode= nodeStack.top();\n        nodeStack.pop();\n        traversalResult.insert(traversalResult.begin(), currentNode->Value);\n        if(currentNode->LeftChild)\n            nodeStack.push(currentNode->LeftChild);\n        if(currentNode->RightChild)\n            nodeStack.push(currentNode->RightChild);\n    }\n\n    return traversalResult;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int Value;\n    TreeNode *LeftChild;\n    TreeNode *RightChild;\n    TreeNode(int x) : Value(x), LeftChild(NULL), RightChild(NULL) {}\n};\n\nstd::vector<int> postorderTraversal(TreeNode *rootNode)\n{\n    std::vector<int> traversalResult;\n    std::stack<TreeNode *> nodeStack;\n\n    if(!rootNode)\n        return traversalResult;\n\n    nodeStack.push(rootNode);\n    while(!nodeStack.empty())\n    {\n        TreeNode *currentNode= nodeStack.top();\n        nodeStack.pop();\n        traversalResult.insert(traversalResult.begin(), currentNode->Value);\n        if(currentNode->LeftChild)\n            nodeStack.push(currentNode->LeftChild);\n        if(currentNode->RightChild)\n            nodeStack.push(currentNode->RightChild);\n    }\n\n    return traversalResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass LRUCache\n{\n    int capacity;\n    list<pair<int, int>> lruList;\n    unordered_map<int, list<pair<int, int>>::iterator> cacheMap;\n\n  public:\n    LRUCache(int cap) : capacity(cap) {}\n\n    int get(int key)\n    {\n        auto iterator= cacheMap.find(key);\n        if(iterator == cacheMap.end())\n        {\n            return -1;\n        }\n        lruList.splice(lruList.begin(), lruList, iterator->second);\n        return iterator->second->second;\n    }\n\n    void put(int key, int value)\n    {\n        auto iterator= cacheMap.find(key);\n        if(iterator != cacheMap.end())\n        {\n            lruList.erase(iterator->second);\n        }\n        else if(lruList.size() == (size_t)capacity)\n        {\n            cacheMap.erase(lruList.rbegin()->first);\n            lruList.pop_back();\n        }\n        lruList.emplace_front(key, value);\n        cacheMap[key]= lruList.begin();\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass LRUCache\n{\n    int capacity;\n    std::list<std::pair<int, int>> lruList;\n    std::unordered_map<int, std::list<std::pair<int, int>>::iterator> cacheMap;\n\n  public:\n    LRUCache(int cap) : capacity(cap) {}\n\n    int get(int key)\n    {\n        auto iterator= cacheMap.find(key);\n        if(iterator == cacheMap.end())\n        {\n            return -1;\n        }\n        lruList.splice(lruList.begin(), lruList, iterator->second);\n        return iterator->second->second;\n    }\n\n    void put(int key, int value)\n    {\n        auto iterator= cacheMap.find(key);\n        if(iterator != cacheMap.end())\n        {\n            lruList.erase(iterator->second);\n        }\n        else if(lruList.size() == (size_t)capacity)\n        {\n            cacheMap.erase(lruList.rbegin()->first);\n            lruList.pop_back();\n        }\n        lruList.emplace_front(key, value);\n        cacheMap[key]= lruList.begin();\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n};\n\nListNode *insertionSortList(ListNode *head)\n{\n    ListNode dummyNode(0);\n    ListNode *currentNode;\n\n    while(head)\n    {\n        currentNode= &dummyNode;\n        while(currentNode->next && currentNode->next->value < head->value)\n            currentNode= currentNode->next;\n\n        ListNode *tempNode= head->next;\n        head->next= currentNode->next;\n        currentNode->next= head;\n        head= tempNode;\n    }\n\n    return dummyNode.next;\n}",
    "output": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n};\n\nListNode *insertionSortList(ListNode *head)\n{\n    ListNode dummyNode(0);\n    ListNode *currentNode;\n\n    while(head)\n    {\n        currentNode= &dummyNode;\n        while(currentNode->next && currentNode->next->value < head->value)\n            currentNode= currentNode->next;\n\n        ListNode *tempNode= head->next;\n        head->next= currentNode->next;\n        currentNode->next= head;\n        head= tempNode;\n    }\n\n    return dummyNode.next;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *merge(ListNode *left, ListNode *right)\n{\n    if(left == NULL)\n        return right;\n    if(right == NULL)\n        return left;\n    if(left->value < right->value)\n    {\n        left->next= merge(left->next, right);\n        return left;\n    }\n    else\n    {\n        right->next= merge(left, right->next);\n        return right;\n    }\n}\n\nListNode *sortList(ListNode *head)\n{\n    if(head == NULL || head->next == NULL)\n        return head;\n\n    ListNode *slow= head;\n    ListNode *fast= head->next;\n    while(fast != NULL && fast->next != NULL)\n    {\n        slow= slow->next;\n        fast= fast->next->next;\n    }\n\n    ListNode *mid= slow->next;\n    slow->next= NULL;\n\n    return merge(sortList(head), sortList(mid));\n}",
    "output": "#include <bits/stdc++.h>\nstruct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *merge(ListNode *left, ListNode *right)\n{\n    if(left == NULL)\n        return right;\n    if(right == NULL)\n        return left;\n    if(left->value < right->value)\n    {\n        left->next= merge(left->next, right);\n        return left;\n    }\n    else\n    {\n        right->next= merge(left, right->next);\n        return right;\n    }\n}\n\nListNode *sortList(ListNode *head)\n{\n    if(head == NULL || head->next == NULL)\n        return head;\n\n    ListNode *slow= head;\n    ListNode *fast= head->next;\n    while(fast != NULL && fast->next != NULL)\n    {\n        slow= slow->next;\n        fast= fast->next->next;\n    }\n\n    ListNode *mid= slow->next;\n    slow->next= NULL;\n\n    return merge(sortList(head), sortList(mid));\n}\n"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPoints(vector<vector<int>> &points)\n{\n    int numberOfPoints = points.size();\n    if(numberOfPoints <= 2)\n        return numberOfPoints;\n    int maxCount = 0;\n\n    for(int currentPointIndex = 0; currentPointIndex < numberOfPoints; currentPointIndex++)\n    {\n        unordered_map<string, int> slopeMap;\n        int duplicatePoints = 0, localMax = 0;\n\n        for(int nextPointIndex = currentPointIndex + 1; nextPointIndex < numberOfPoints; nextPointIndex++)\n        {\n            int deltaX = points[nextPointIndex][0] - points[currentPointIndex][0];\n            int deltaY = points[nextPointIndex][1] - points[currentPointIndex][1];\n\n            if(deltaX == 0 && deltaY == 0)\n            {\n                duplicatePoints++;\n                continue;\n            }\n\n            int gcd = std::__gcd(deltaX, deltaY);\n            deltaX /= gcd;\n            deltaY /= gcd;\n\n            string slopeKey = to_string(deltaX) + \"_\" + to_string(deltaY);\n            slopeMap[slopeKey]++;\n            localMax = max(localMax, slopeMap[slopeKey]);\n        }\n        maxCount = max(maxCount, localMax + duplicatePoints + 1);\n    }\n\n    return maxCount;\n}",
    "output": "#include <bits/stdc++.h>\nint maxPoints(vector<vector<int>> &points)\n{\n    int numberOfPoints= points.size();\n    if(numberOfPoints <= 2)\n        return numberOfPoints;\n    int maxCount= 0;\n\n    for(int currentPointIndex= 0; currentPointIndex < numberOfPoints; currentPointIndex++)\n    {\n        std::unordered_map<string, int> slopeMap;\n        int duplicatePoints= 0, localMax= 0;\n\n        for(int nextPointIndex= currentPointIndex + 1; nextPointIndex < numberOfPoints; nextPointIndex++)\n        {\n            int deltaX= points[nextPointIndex][0] - points[currentPointIndex][0];\n            int deltaY= points[nextPointIndex][1] - points[currentPointIndex][1];\n\n            if(deltaX == 0 && deltaY == 0)\n            {\n                duplicatePoints++;\n                continue;\n            }\n\n            int gcd= std::gcd(deltaX, deltaY);\n            deltaX/= gcd;\n            deltaY/= gcd;\n\n            string slopeKey= to_string(deltaX) + \"_\" + to_string(deltaY);\n            slopeMap[slopeKey]++;\n            localMax= max(localMax, slopeMap[slopeKey]);\n        }\n        maxCount= max(maxCount, localMax + duplicatePoints + 1);\n    }\n\n    return maxCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint evalRpn(vector<string> &expressionTokens)\n{\n    stack<int> operandStack;\n    for (int i = 0; i < expressionTokens.size(); ++i)\n    {\n        const string &currentToken = expressionTokens[i];\n        if (currentToken == \"+\" || currentToken == \"-\" || currentToken == \"*\" || currentToken == \"/\")\n        {\n            int secondOperand = operandStack.top();\n            operandStack.pop();\n            int firstOperand = operandStack.top();\n            operandStack.pop();\n            if (currentToken == \"+\")\n                operandStack.push(firstOperand + secondOperand);\n            else if (currentToken == \"-\")\n                operandStack.push(firstOperand - secondOperand);\n            else if (currentToken == \"*\")\n                operandStack.push(firstOperand * secondOperand);\n            else\n                operandStack.push(firstOperand / secondOperand);\n        }\n        else\n        {\n            operandStack.push(stoi(currentToken));\n        }\n    }\n    return operandStack.top();\n}",
    "output": "#include <bits/stdc++.h>\nint evalRpn(std::vector<std::string> &expressionTokens)\n{\n    std::stack<int> operandStack;\n    for(const std::string &currentToken : expressionTokens)\n    {\n        if(currentToken == \"+\" || currentToken == \"-\" || currentToken == \"*\" || currentToken == \"/\")\n        {\n            int secondOperand= operandStack.top();\n            operandStack.pop();\n            int firstOperand= operandStack.top();\n            operandStack.pop();\n            if(currentToken == \"+\")\n                operandStack.push(firstOperand + secondOperand);\n            else if(currentToken == \"-\")\n                operandStack.push(firstOperand - secondOperand);\n            else if(currentToken == \"*\")\n                operandStack.push(firstOperand * secondOperand);\n            else\n                operandStack.push(firstOperand / secondOperand);\n        }\n        else\n        {\n            operandStack.push(std::stoi(currentToken));\n        }\n    }\n    return operandStack.top();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring reverseWords(string inputString)\n{\n    stringstream stringStream(inputString);\n    vector<string> wordList;\n    string currentWord;\n\n    while(stringStream >> currentWord)\n    {\n        wordList.push_back(currentWord);\n    }\n\n    reverse(wordList.begin(), wordList.end());\n\n    string reversedString;\n    for(size_t index= 0; index < wordList.size(); ++index)\n    {\n        reversedString += wordList[index] + (index < wordList.size() - 1 ? \" \" : \"\");\n    }\n\n    return reversedString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string reverseWords(std::string inputString)\n{\n    std::stringstream stringStream(inputString);\n    std::vector<std::string> wordList;\n    std::string currentWord;\n\n    while(stringStream >> currentWord)\n    {\n        wordList.push_back(currentWord);\n    }\n\n    std::reverse(wordList.begin(), wordList.end());\n\n    std::string reversedString;\n    for(size_t index= 0; index < wordList.size(); ++index)\n    {\n        reversedString+= wordList[index] + (index < wordList.size() - 1 ? \" \" : \"\");\n    }\n\n    return reversedString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxProduct(vector<int> &numberList)\n{\n    int maxSoFar= numberList[0];\n    int minSoFar= numberList[0];\n    int result= numberList[0];\n\n    for(int index= 1; index < numberList.size(); index++)\n    {\n        if(numberList[index] < 0)\n            swap(maxSoFar, minSoFar);\n\n        maxSoFar= max(numberList[index], maxSoFar * numberList[index]);\n        minSoFar= min(numberList[index], minSoFar * numberList[index]);\n        result= max(result, maxSoFar);\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nint maxProduct(std::vector<int> &numberList)\n{\n    int maxSoFar= numberList[0];\n    int minSoFar= numberList[0];\n    int result= numberList[0];\n\n    for(int index= 1; index < numberList.size(); index++)\n    {\n        if(numberList[index] < 0)\n            std::swap(maxSoFar, minSoFar);\n\n        maxSoFar= std::max(numberList[index], maxSoFar * numberList[index]);\n        minSoFar= std::min(numberList[index], minSoFar * numberList[index]);\n        result= std::max(result, maxSoFar);\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMin(vector<int> &numArray)\n{\n    int leftIndex= 0, rightIndex= numArray.size() - 1;\n\n    while(leftIndex < rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(numArray[midIndex] > numArray[rightIndex])\n        {\n            leftIndex= midIndex + 1;\n        }\n        else\n        {\n            rightIndex= midIndex;\n        }\n    }\n    return numArray[leftIndex];\n}",
    "output": "#include <bits/stdc++.h>\nint findMin(std::vector<int> &numArray)\n{\n    int leftIndex= 0, rightIndex= numArray.size() - 1;\n\n    while(leftIndex < rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(numArray[midIndex] > numArray[rightIndex])\n        {\n            leftIndex= midIndex + 1;\n        }\n        else\n        {\n            rightIndex= midIndex;\n        }\n    }\n    return numArray[leftIndex];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMin(vector<int> &numArray)\n{\n    int lowIndex= 0, highIndex= numArray.size() - 1;\n\n    while(lowIndex < highIndex)\n    {\n        int midIndex= lowIndex + (highIndex - lowIndex) / 2;\n        if(numArray[midIndex] > numArray[highIndex])\n        {\n            lowIndex= midIndex + 1;\n        }\n        else if(numArray[midIndex] < numArray[highIndex])\n        {\n            highIndex= midIndex;\n        }\n        else\n        {\n            highIndex--;\n        }\n    }\n    return numArray[lowIndex];\n}",
    "output": "#include <bits/stdc++.h>\nint findMin(std::vector<int> &numArray)\n{\n    int lowIndex= 0, highIndex= numArray.size() - 1;\n\n    while(lowIndex < highIndex)\n    {\n        int midIndex= lowIndex + (highIndex - lowIndex) / 2;\n        if(numArray[midIndex] > numArray[highIndex])\n        {\n            lowIndex= midIndex + 1;\n        }\n        else if(numArray[midIndex] < numArray[highIndex])\n        {\n            highIndex= midIndex;\n        }\n        else\n        {\n            highIndex--;\n        }\n    }\n    return numArray[lowIndex];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass MinStack\n{\n    stack<int> mainStack;\n    stack<int> minStack;\n\n  public:\n    void push(int value)\n    {\n        mainStack.push(value);\n        if(minStack.empty() || value <= minStack.top())\n            minStack.push(value);\n    }\n\n    void pop()\n    {\n        if(mainStack.top() == minStack.top())\n            minStack.pop();\n        mainStack.pop();\n    }\n\n    int top()\n    {\n        return mainStack.top();\n    }\n\n    int getMin()\n    {\n        return minStack.top();\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass MinStack\n{\n    std::stack<int> mainStack;\n    std::stack<int> minStack;\n\n  public:\n    void push(int value)\n    {\n        mainStack.push(value);\n        if(minStack.empty() || value <= minStack.top())\n            minStack.push(value);\n    }\n\n    void pop()\n    {\n        if(mainStack.top() == minStack.top())\n            minStack.pop();\n        mainStack.pop();\n    }\n\n    int top()\n    {\n        return mainStack.top();\n    }\n\n    int getMin()\n    {\n        return minStack.top();\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nTreeNode *upsideDownBinaryTree(TreeNode *root)\n{\n    if(root == NULL || root->leftChild == NULL)\n    {\n        return root;\n    }\n    TreeNode *newRoot= upsideDownBinaryTree(root->leftChild);\n    root->leftChild->rightChild= root;\n    root->leftChild->leftChild= root->rightChild;\n    root->leftChild= NULL;\n    root->rightChild= NULL;\n    return newRoot;\n}",
    "output": "class TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nTreeNode *upsideDownBinaryTree(TreeNode *root)\n{\n    if(root == NULL || root->leftChild == NULL)\n    {\n        return root;\n    }\n    TreeNode *newRoot= upsideDownBinaryTree(root->leftChild);\n    root->leftChild->rightChild= root;\n    root->leftChild->leftChild= root->rightChild;\n    root->leftChild= NULL;\n    root->rightChild= NULL;\n    return newRoot;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int read4(char *buffer4);\n\nint read(char *buffer, int maxBytes)\n{\n    int bytesRead= 0;\n    char tempBuffer[4];\n\n    while(bytesRead < maxBytes)\n    {\n        int read4Count= read4(tempBuffer);\n        for(int index= 0; index < read4Count && bytesRead < maxBytes; ++index)\n        {\n            buffer[bytesRead++]= tempBuffer[index];\n        }\n        if(read4Count < 4)\n            break;\n    }\n\n    return bytesRead;\n}",
    "output": "int read4(char *buffer4);\n\nint read(char *buffer, int maxBytes)\n{\n    int bytesRead= 0;\n    char tempBuffer[4];\n\n    while(bytesRead < maxBytes)\n    {\n        int read4Count= read4(tempBuffer);\n        for(int index= 0; index < read4Count && bytesRead < maxBytes; ++index)\n        {\n            buffer[bytesRead++]= tempBuffer[index];\n        }\n        if(read4Count < 4)\n            break;\n    }\n\n    return bytesRead;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class Solution\n{\n    int bufferIndex= 0;\n    int bufferLength= 0;\n    char buffer4[4];\n\n  public:\n    int read(char *outputBuffer, int maxBytes)\n    {\n        int count= 0;\n        while(count < maxBytes)\n        {\n            if(bufferIndex == bufferLength)\n            {\n                bufferLength= read4(buffer4);\n                bufferIndex= 0;\n            }\n            if(bufferLength == 0)\n                break;\n            while(count < maxBytes && bufferIndex < bufferLength)\n            {\n                outputBuffer[count++]= buffer4[bufferIndex++];\n            }\n        }\n        return count;\n    }\n};",
    "output": "class Solution\n{\n    int bufferIndex= 0;\n    int bufferLength= 0;\n    char buffer4[4];\n\n  public:\n    int read(char *outputBuffer, int maxBytes)\n    {\n        int count= 0;\n        while(count < maxBytes)\n        {\n            if(bufferIndex == bufferLength)\n            {\n                bufferLength= read4(buffer4);\n                bufferIndex= 0;\n            }\n            if(bufferLength == 0)\n                break;\n            while(count < maxBytes && bufferIndex < bufferLength)\n            {\n                outputBuffer[count++]= buffer4[bufferIndex++];\n            }\n        }\n        return count;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint lengthOfLongestSubstringTwoDistinct(string inputString)\n{\n    int leftPointer= 0, rightPointer= 0, maxLength= 0, currentLength= 0;\n    unordered_map<char, int> characterCount;\n\n    while(rightPointer < inputString.length())\n    {\n        characterCount[inputString[rightPointer]]++;\n        if(characterCount.size() <= 2)\n        {\n            currentLength++;\n        }\n        else\n        {\n            while(characterCount.size() > 2 && leftPointer <= rightPointer)\n            {\n                characterCount[inputString[leftPointer]]--;\n                if(characterCount[inputString[leftPointer]] == 0)\n                {\n                    characterCount.erase(inputString[leftPointer]);\n                }\n                leftPointer++;\n                currentLength--;\n            }\n            currentLength++;\n        }\n        maxLength= max(maxLength, currentLength);\n        rightPointer++;\n    }\n    return maxLength;\n}",
    "output": "#include <bits/stdc++.h>\nint lengthOfLongestSubstringTwoDistinct(std::string inputString)\n{\n    int leftPointer= 0, rightPointer= 0, maxLength= 0, currentLength= 0;\n    std::unordered_map<char, int> characterCount;\n\n    while(rightPointer < inputString.length())\n    {\n        characterCount[inputString[rightPointer]]++;\n        if(characterCount.size() <= 2)\n        {\n            currentLength++;\n        }\n        else\n        {\n            while(characterCount.size() > 2 && leftPointer <= rightPointer)\n            {\n                characterCount[inputString[leftPointer]]--;\n                if(characterCount[inputString[leftPointer]] == 0)\n                {\n                    characterCount.erase(inputString[leftPointer]);\n                }\n                leftPointer++;\n                currentLength--;\n            }\n            currentLength++;\n        }\n        maxLength= std::max(maxLength, currentLength);\n        rightPointer++;\n    }\n    return maxLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB)\n{\n    ListNode *pointerA= headA, *pointerB= headB;\n    while(pointerA != pointerB)\n    {\n        pointerA= pointerA ? pointerA->next : headB;\n        pointerB= pointerB ? pointerB->next : headA;\n    }\n    return pointerA;\n}",
    "output": "struct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB)\n{\n    ListNode *pointerA= headA, *pointerB= headB;\n    while(pointerA != pointerB)\n    {\n        pointerA= pointerA ? pointerA->next : headB;\n        pointerB= pointerB ? pointerB->next : headA;\n    }\n    return pointerA;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isOneEditDistance(string sourceString, string targetString)\n{\n    int sourceLength= sourceString.length(), targetLength= targetString.length();\n    if(sourceLength > targetLength)\n    {\n        return isOneEditDistance(targetString, sourceString);\n    }\n    if(targetLength - sourceLength > 1)\n    {\n        return false;\n    }\n    bool isEditFound= false;\n    for(int index= 0; index < sourceLength; ++index)\n    {\n        if(sourceString[index] != targetString[index])\n        {\n            if(sourceLength < targetLength)\n            {\n                return sourceString.substr(index) == targetString.substr(index + 1);\n            }\n            else\n            {\n                return sourceString.substr(index + 1) == targetString.substr(index + 1);\n            }\n        }\n    }\n    return sourceLength + 1 == targetLength;\n}",
    "output": "#include <bits/stdc++.h>\nbool isOneEditDistance(std::string sourceString, std::string targetString)\n{\n    int sourceLength= sourceString.length(), targetLength= targetString.length();\n    if(sourceLength > targetLength)\n    {\n        return isOneEditDistance(targetString, sourceString);\n    }\n    if(targetLength - sourceLength > 1)\n    {\n        return false;\n    }\n    bool isEditFound= false;\n    for(int index= 0; index < sourceLength; ++index)\n    {\n        if(sourceString[index] != targetString[index])\n        {\n            if(sourceLength < targetLength)\n            {\n                return sourceString.substr(index) == targetString.substr(index + 1);\n            }\n            else\n            {\n                return sourceString.substr(index + 1) == targetString.substr(index + 1);\n            }\n        }\n    }\n    return sourceLength + 1 == targetLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findPeakElement(vector<int> &numArray)\n{\n    int leftIndex= 0, rightIndex= numArray.size() - 1;\n    while(leftIndex < rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(numArray[midIndex] < numArray[midIndex + 1])\n        {\n            leftIndex= midIndex + 1;\n        }\n        else\n        {\n            rightIndex= midIndex;\n        }\n    }\n    return leftIndex;\n}",
    "output": "#include <bits/stdc++.h>\nint findPeakElement(std::vector<int> &numArray)\n{\n    int leftIndex= 0, rightIndex= numArray.size() - 1;\n    while(leftIndex < rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(numArray[midIndex] < numArray[midIndex + 1])\n        {\n            leftIndex= midIndex + 1;\n        }\n        else\n        {\n            rightIndex= midIndex;\n        }\n    }\n    return leftIndex;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> findMissingRanges(vector<int> &sortedNumbers, int rangeLower, int rangeUpper)\n{\n    vector<string> missingRanges;\n    long previousNumber= (long)rangeLower - 1;\n\n    for(int index= 0; index <= sortedNumbers.size(); ++index)\n    {\n        long currentNumber= (index == sortedNumbers.size()) ? (long)rangeUpper + 1 : sortedNumbers[index];\n        if(currentNumber - previousNumber >= 2)\n        {\n            missingRanges.push_back(to_string(previousNumber + 1) + (currentNumber - previousNumber == 2 ? \"\" : \"->\") + to_string(currentNumber - 1));\n        }\n        previousNumber= currentNumber;\n    }\n\n    return missingRanges;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> findMissingRanges(std::vector<int> &sortedNumbers, int rangeLower, int rangeUpper)\n{\n    std::vector<std::string> missingRanges;\n    long previousNumber= (long)rangeLower - 1;\n\n    for(int index= 0; index <= sortedNumbers.size(); ++index)\n    {\n        long currentNumber= (index == sortedNumbers.size()) ? (long)rangeUpper + 1 : sortedNumbers[index];\n        if(currentNumber - previousNumber >= 2)\n        {\n            missingRanges.push_back(std::to_string(previousNumber + 1) + (currentNumber - previousNumber == 2 ? \"\" : \"->\") + std::to_string(currentNumber - 1));\n        }\n        previousNumber= currentNumber;\n    }\n\n    return missingRanges;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maximumGap(vector<int> &numbers)\n{\n    if(numbers.size() < 2)\n        return 0;\n\n    int minimumValue = *min_element(numbers.begin(), numbers.end());\n    int maximumValue = *max_element(numbers.begin(), numbers.end());\n    int length = numbers.size();\n    int bucketSize = max(1, (maximumValue - minimumValue) / (length - 1));\n    int bucketCount = (maximumValue - minimumValue) / bucketSize + 1;\n    vector<pair<int, int>> buckets(bucketCount, {INT_MAX, INT_MIN});\n\n    for(int number : numbers)\n    {\n        int index = (number - minimumValue) / bucketSize;\n        buckets[index].first = min(buckets[index].first, number);\n        buckets[index].second = max(buckets[index].second, number);\n    }\n\n    int maximumGap = 0, previousMax = minimumValue;\n    for(int i = 0; i < buckets.size(); ++i)\n    {\n        auto &bucket = buckets[i];\n        if(bucket.first == INT_MAX)\n            continue;\n        maximumGap = max(maximumGap, bucket.first - previousMax);\n        previousMax = bucket.second;\n    }\n    return maximumGap;\n}",
    "output": "#include <bits/stdc++.h>\nint maximumGap(std::vector<int> &numbers)\n{\n    if(numbers.size() < 2)\n        return 0;\n\n    int minimumValue= *std::min_element(numbers.begin(), numbers.end());\n    int maximumValue= *std::max_element(numbers.begin(), numbers.end());\n    int length= numbers.size();\n    int bucketSize= std::max(1, (maximumValue - minimumValue) / (length - 1));\n    int bucketCount= (maximumValue - minimumValue) / bucketSize + 1;\n    std::vector<std::pair<int, int>> buckets(bucketCount, {INT_MAX, INT_MIN});\n\n    for(int number : numbers)\n    {\n        int index= (number - minimumValue) / bucketSize;\n        buckets[index].first= std::min(buckets[index].first, number);\n        buckets[index].second= std::max(buckets[index].second, number);\n    }\n\n    int maximumGap= 0, previousMax= minimumValue;\n    for(auto &bucket : buckets)\n    {\n        if(bucket.first == INT_MAX)\n            continue;\n        maximumGap= std::max(maximumGap, bucket.first - previousMax);\n        previousMax= bucket.second;\n    }\n    return maximumGap;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint compareVersion(string version1, string version2)\n{\n    int index1= 0, index2= 0;\n    while(index1 < version1.size() || index2 < version2.size())\n    {\n        int number1= 0, number2= 0;\n        while(index1 < version1.size() && version1[index1] != '.')\n        {\n            number1= number1 * 10 + (version1[index1++] - '0');\n        }\n        while(index2 < version2.size() && version2[index2] != '.')\n        {\n            number2= number2 * 10 + (version2[index2++] - '0');\n        }\n        if(number1 < number2)\n            return -1;\n        if(number1 > number2)\n            return 1;\n        index1++;\n        index2++;\n    }\n    return 0;\n}",
    "output": "#include <bits/stdc++.h>\nint compareVersion(std::string version1, std::string version2)\n{\n    int index1= 0, index2= 0;\n    while(index1 < version1.size() || index2 < version2.size())\n    {\n        int number1= 0, number2= 0;\n        while(index1 < version1.size() && version1[index1] != '.')\n        {\n            number1= number1 * 10 + (version1[index1++] - '0');\n        }\n        while(index2 < version2.size() && version2[index2] != '.')\n        {\n            number2= number2 * 10 + (version2[index2++] - '0');\n        }\n        if(number1 < number2)\n            return -1;\n        if(number1 > number2)\n            return 1;\n        index1++;\n        index2++;\n    }\n    return 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring fractionToDecimal(int numerator, int denominator)\n{\n    if(numerator == 0)\n        return \"0\";\n    string result;\n    if((numerator > 0) ^ (denominator > 0))\n        result+= '-';\n    long absoluteNumerator= abs((long)numerator), absoluteDenominator= abs((long)denominator);\n    result+= to_string(absoluteNumerator / absoluteDenominator);\n    absoluteNumerator%= absoluteDenominator;\n    if(absoluteNumerator == 0)\n        return result;\n    result+= '.';\n    unordered_map<int, int> remainderMap;\n    while(absoluteNumerator)\n    {\n        if(remainderMap.find(absoluteNumerator) != remainderMap.end())\n        {\n            result.insert(remainderMap[absoluteNumerator], \"(\");\n            result+= \")\";\n            break;\n        }\n        remainderMap[absoluteNumerator]= result.size();\n        absoluteNumerator*= 10;\n        result+= to_string(absoluteNumerator / absoluteDenominator);\n        absoluteNumerator%= absoluteDenominator;\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string fractionToDecimal(int numerator, int denominator)\n{\n    if(numerator == 0)\n        return \"0\";\n    std::string result;\n    if((numerator > 0) ^ (denominator > 0))\n        result+= '-';\n    long absoluteNumerator= std::abs((long)numerator), absoluteDenominator= std::abs((long)denominator);\n    result+= std::to_string(absoluteNumerator / absoluteDenominator);\n    absoluteNumerator%= absoluteDenominator;\n    if(absoluteNumerator == 0)\n        return result;\n    result+= '.';\n    std::unordered_map<int, int> remainderMap;\n    while(absoluteNumerator)\n    {\n        if(remainderMap.find(absoluteNumerator) != remainderMap.end())\n        {\n            result.insert(remainderMap[absoluteNumerator], \"(\");\n            result+= \")\";\n            break;\n        }\n        remainderMap[absoluteNumerator]= result.size();\n        absoluteNumerator*= 10;\n        result+= std::to_string(absoluteNumerator / absoluteDenominator);\n        absoluteNumerator%= absoluteDenominator;\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> twoSum(vector<int> &numberList, int targetSum)\n{\n    int leftIndex= 0, rightIndex= numberList.size() - 1;\n    while(leftIndex < rightIndex)\n    {\n        int currentSum= numberList[leftIndex] + numberList[rightIndex];\n        if(currentSum == targetSum)\n        {\n            return {leftIndex + 1, rightIndex + 1};\n        }\n        else if(currentSum < targetSum)\n        {\n            leftIndex++;\n        }\n        else\n        {\n            rightIndex--;\n        }\n    }\n    return {};\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> twoSum(std::vector<int> &numberList, int targetSum)\n{\n    int leftIndex= 0, rightIndex= numberList.size() - 1;\n    while(leftIndex < rightIndex)\n    {\n        int currentSum= numberList[leftIndex] + numberList[rightIndex];\n        if(currentSum == targetSum)\n        {\n            return {leftIndex + 1, rightIndex + 1};\n        }\n        else if(currentSum < targetSum)\n        {\n            leftIndex++;\n        }\n        else\n        {\n            rightIndex--;\n        }\n    }\n    return {};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring convertToTitle(int columnNumber)\n{\n    string titleResult= \"\";\n    while(columnNumber)\n    {\n        columnNumber--;\n        titleResult= (char)(columnNumber % 26 + 'A') + titleResult;\n        columnNumber/= 26;\n    }\n    return titleResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string convertToTitle(int columnNumber)\n{\n    std::string titleResult= \"\";\n    while(columnNumber)\n    {\n        columnNumber--;\n        titleResult= (char)(columnNumber % 26 + 'A') + titleResult;\n        columnNumber/= 26;\n    }\n    return titleResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint majorityElement(vector<int> &numberList)\n{\n    int elementCount = 0;\n    int majorityCandidate;\n\n    for (int i = 0; i < numberList.size(); ++i)\n    {\n        int currentNumber = numberList[i];\n        if (elementCount == 0)\n        {\n            majorityCandidate = currentNumber;\n        }\n        elementCount += (currentNumber == majorityCandidate) ? 1 : -1;\n    }\n\n    return majorityCandidate;\n}",
    "output": "#include <bits/stdc++.h>\nint majorityElement(std::vector<int> &numberList)\n{\n    int elementCount= 0;\n    int majorityCandidate;\n\n    for(int currentNumber : numberList)\n    {\n        if(elementCount == 0)\n        {\n            majorityCandidate= currentNumber;\n        }\n        elementCount+= (currentNumber == majorityCandidate) ? 1 : -1;\n    }\n\n    return majorityCandidate;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TwoSum\n{\n  public:\n    unordered_map<int, int> numberCountMap;\n\n    TwoSum()\n    {\n    }\n\n    void add(int number)\n    {\n        numberCountMap[number]++;\n    }\n\n    bool find(int targetValue)\n    {\n        for (auto it = numberCountMap.begin(); it != numberCountMap.end(); ++it)\n        {\n            int firstNumber = it->first;\n            int secondNumber = targetValue - firstNumber;\n            if (firstNumber == secondNumber && it->second > 1 || firstNumber != secondNumber && numberCountMap.count(secondNumber))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass TwoSum\n{\n  public:\n    std::unordered_map<int, int> numberCountMap;\n\n    TwoSum()\n    {\n    }\n\n    void add(int number)\n    {\n        numberCountMap[number]++;\n    }\n\n    bool find(int targetValue)\n    {\n        for(auto &numberPair : numberCountMap)\n        {\n            int firstNumber= numberPair.first;\n            int secondNumber= targetValue - firstNumber;\n            if(firstNumber == secondNumber && numberPair.second > 1 || firstNumber != secondNumber && numberCountMap.count(secondNumber))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint titleToNumber(string columnTitle)\n{\n    int columnNumber = 0;\n    for (int i = 0; i < columnTitle.size(); ++i)\n    {\n        char character = columnTitle[i];\n        columnNumber = columnNumber * 26 + (character - 'A' + 1);\n    }\n    return columnNumber;\n}",
    "output": "#include <bits/stdc++.h>\nint titleToNumber(std::string columnTitle)\n{\n    int columnNumber= 0;\n    for(char character : columnTitle)\n    {\n        columnNumber= columnNumber * 26 + (character - 'A' + 1);\n    }\n    return columnNumber;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int countTrailingZeroes(int number)\n{\n    int zeroCount= 0;\n    while(number > 0)\n    {\n        number/= 5;\n        zeroCount+= number;\n    }\n    return zeroCount;\n}",
    "output": "int countTrailingZeroes(int number)\n{\n    int zeroCount= 0;\n    while(number > 0)\n    {\n        number/= 5;\n        zeroCount+= number;\n    }\n    return zeroCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode { // Assuming the TreeNode structure is defined like this\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n\n    TreeNode(int value) : val(value), left(NULL), right(NULL) {}\n};\n\nclass BSTIterator\n{\n  public:\n    stack<TreeNode *> nodeStack;\n\n    BSTIterator(TreeNode *rootNode)\n    {\n        pushLeft(rootNode);\n    }\n\n    int next()\n    {\n        TreeNode *topNode= nodeStack.top();\n        nodeStack.pop();\n        pushLeft(topNode->right);\n        return topNode->val;\n    }\n\n    bool hasNext()\n    {\n        return !nodeStack.empty();\n    }\n\n  private:\n    void pushLeft(TreeNode *currentNode)\n    {\n        while(currentNode)\n        {\n            nodeStack.push(currentNode);\n            currentNode= currentNode->left;\n        }\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass BSTIterator\n{\n  public:\n    std::stack<TreeNode *> nodeStack;\n\n    BSTIterator(TreeNode *rootNode)\n    {\n        pushLeft(rootNode);\n    }\n\n    int next()\n    {\n        TreeNode *topNode= nodeStack.top();\n        nodeStack.pop();\n        pushLeft(topNode->right);\n        return topNode->val;\n    }\n\n    bool hasNext()\n    {\n        return !nodeStack.empty();\n    }\n\n  private:\n    void pushLeft(TreeNode *currentNode)\n    {\n        while(currentNode)\n        {\n            nodeStack.push(currentNode);\n            currentNode= currentNode->left;\n        }\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumHp(vector<vector<int>> &dungeon)\n{\n    int rows= dungeon.size(), columns= dungeon[0].size();\n    vector<vector<int>> health(rows, vector<int>(columns));\n\n    for(int row= rows - 1; row >= 0; row--)\n    {\n        for(int column= columns - 1; column >= 0; column--)\n        {\n            if(row == rows - 1 && column == columns - 1)\n            {\n                health[row][column]= min(0, dungeon[row][column]);\n            }\n            else if(row == rows - 1)\n            {\n                health[row][column]= min(0, health[row][column + 1] + dungeon[row][column]);\n            }\n            else if(column == columns - 1)\n            {\n                health[row][column]= min(0, health[row + 1][column] + dungeon[row][column]);\n            }\n            else\n            {\n                health[row][column]= min(0, max(health[row + 1][column], health[row][column + 1]) + dungeon[row][column]);\n            }\n        }\n    }\n\n    return abs(health[0][0]) + 1;\n}",
    "output": "#include <bits/stdc++.h>\n// Needed for std::min and std::max\n\nint calculateMinimumHp(std::vector<std::vector<int>> &dungeon)\n{\n    int rows = dungeon.size(), columns = dungeon[0].size();\n    std::vector<std::vector<int>> health(rows, std::vector<int>(columns));\n\n    for(int row = rows - 1; row >= 0; row--)\n    {\n        for(int column = columns - 1; column >= 0; column--)\n        {\n            if(row == rows - 1 && column == columns - 1)\n            {\n                health[row][column] = std::min(0, dungeon[row][column]);\n            }\n            else if(row == rows - 1)\n            {\n                health[row][column] = std::min(0, health[row][column + 1] + dungeon[row][column]);\n            }\n            else if(column == columns - 1)\n            {\n                health[row][column] = std::min(0, health[row + 1][column] + dungeon[row][column]);\n            }\n            else\n            {\n                health[row][column] = std::min(0, std::max(health[row + 1][column], health[row][column + 1]) + dungeon[row][column]);\n            }\n        }\n    }\n\n    return abs(health[0][0]) + 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool compare(string firstString, string secondString)\n{\n    return firstString + secondString > secondString + firstString;\n}\n\nstring largestNumber(vector<int> &numberList)\n{\n    vector<string> numberStrings;\n    for (int i = 0; i < numberList.size(); ++i)\n        numberStrings.push_back(to_string(numberList[i]));\n    sort(numberStrings.begin(), numberStrings.end(), compare);\n    string result;\n    for (int i = 0; i < numberStrings.size(); ++i)\n        result += numberStrings[i];\n    return result[0] == '0' ? \"0\" : result;\n}",
    "output": "#include <bits/stdc++.h>\nbool compare(std::string firstString, std::string secondString)\n{\n    return firstString + secondString > secondString + firstString;\n}\n\nstd::string largestNumber(std::vector<int> &numberList)\n{\n    std::vector<std::string> numberStrings;\n    for(int currentNumber : numberList)\n        numberStrings.push_back(std::to_string(currentNumber));\n    std::sort(numberStrings.begin(), numberStrings.end(), compare);\n    std::string result;\n    for(std::string numberString : numberStrings)\n        result+= numberString;\n    return result[0] == '0' ? \"0\" : result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid reverseWords(vector<char> &inputString)\n{\n    reverse(inputString.begin(), inputString.end());\n    int wordStartIndex= 0, wordEndIndex;\n    while((wordEndIndex= find(inputString.begin() + wordStartIndex, inputString.end(), ' ') - inputString.begin()) < inputString.size())\n    {\n        reverse(inputString.begin() + wordStartIndex, inputString.begin() + wordEndIndex);\n        wordStartIndex= wordEndIndex + 1;\n    }\n    reverse(inputString.begin() + wordStartIndex, inputString.end());\n}",
    "output": "#include <bits/stdc++.h>\nvoid reverseWords(std::vector<char> &inputString)\n{\n    std::reverse(inputString.begin(), inputString.end());\n    int wordStartIndex= 0, wordEndIndex;\n    while((wordEndIndex= std::find(inputString.begin() + wordStartIndex, inputString.end(), ' ') - inputString.begin()) < inputString.size())\n    {\n        std::reverse(inputString.begin() + wordStartIndex, inputString.begin() + wordEndIndex);\n        wordStartIndex= wordEndIndex + 1;\n    }\n    std::reverse(inputString.begin() + wordStartIndex, inputString.end());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> findRepeatedDnaSequences(string dnaSequence)\n{\n    vector<string> repeatedSequences;\n    unordered_map<string, int> dnaCounter;\n\n    for(size_t index= 0; index <= dnaSequence.length() - 10; ++index)\n    {\n        string subSequence= dnaSequence.substr(index, 10);\n        dnaCounter[subSequence]++;\n        if(dnaCounter[subSequence] == 2)\n        {\n            repeatedSequences.push_back(subSequence);\n        }\n    }\n\n    return repeatedSequences;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> findRepeatedDnaSequences(std::string dnaSequence)\n{\n    std::vector<std::string> repeatedSequences;\n    std::unordered_map<std::string, int> dnaCounter;\n\n    for(size_t index= 0; index <= dnaSequence.length() - 10; ++index)\n    {\n        std::string subSequence= dnaSequence.substr(index, 10);\n        dnaCounter[subSequence]++;\n        if(dnaCounter[subSequence] == 2)\n        {\n            repeatedSequences.push_back(subSequence);\n        }\n    }\n\n    return repeatedSequences;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxProfit(int transactionLimit, vector<int> &stockPrices)\n{\n    int numberOfPrices= stockPrices.size();\n    if(transactionLimit > numberOfPrices / 2)\n    {\n        int totalProfit= 0;\n        for(int priceIndex= 1; priceIndex < numberOfPrices; ++priceIndex)\n            totalProfit+= max(stockPrices[priceIndex] - stockPrices[priceIndex - 1], 0);\n        return totalProfit;\n    }\n\n    vector<vector<int>> profitTable(transactionLimit + 1, vector<int>(numberOfPrices, 0));\n    for(int transactionIndex= 1; transactionIndex <= transactionLimit; ++transactionIndex)\n    {\n        int maxDifference= -stockPrices[0];\n        for(int priceIndex= 1; priceIndex < numberOfPrices; ++priceIndex)\n        {\n            profitTable[transactionIndex][priceIndex]= max(profitTable[transactionIndex][priceIndex - 1], stockPrices[priceIndex] + maxDifference);\n            maxDifference= max(maxDifference, profitTable[transactionIndex - 1][priceIndex] - stockPrices[priceIndex]);\n        }\n    }\n    return profitTable[transactionLimit][numberOfPrices - 1];\n}",
    "output": "#include <bits/stdc++.h>\nint maxProfit(int transactionLimit, std::vector<int> &stockPrices)\n{\n    int numberOfPrices= stockPrices.size();\n    if(transactionLimit > numberOfPrices / 2)\n    {\n        int totalProfit= 0;\n        for(int priceIndex= 1; priceIndex < numberOfPrices; ++priceIndex)\n            totalProfit+= std::max(stockPrices[priceIndex] - stockPrices[priceIndex - 1], 0);\n        return totalProfit;\n    }\n\n    std::vector<std::vector<int>> profitTable(transactionLimit + 1, std::vector<int>(numberOfPrices, 0));\n    for(int transactionIndex= 1; transactionIndex <= transactionLimit; ++transactionIndex)\n    {\n        int maxDifference= -stockPrices[0];\n        for(int priceIndex= 1; priceIndex < numberOfPrices; ++priceIndex)\n        {\n            profitTable[transactionIndex][priceIndex]= std::max(profitTable[transactionIndex][priceIndex - 1], stockPrices[priceIndex] + maxDifference);\n            maxDifference= std::max(maxDifference, profitTable[transactionIndex - 1][priceIndex] - stockPrices[priceIndex]);\n        }\n    }\n    return profitTable[transactionLimit][numberOfPrices - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid rotate(vector<int> &numArray, int rotateCount)\n{\n    int arraySize= numArray.size();\n    rotateCount%= arraySize;\n    reverse(numArray.begin(), numArray.end());\n    reverse(numArray.begin(), numArray.begin() + rotateCount);\n    reverse(numArray.begin() + rotateCount, numArray.end());\n}",
    "output": "#include <bits/stdc++.h>\nvoid rotate(std::vector<int> &numArray, int rotateCount)\n{\n    int arraySize = numArray.size();\n    rotateCount %= arraySize;\n    std::reverse(numArray.begin(), numArray.end());\n    std::reverse(numArray.begin(), numArray.begin() + rotateCount);\n    std::reverse(numArray.begin() + rotateCount, numArray.end());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "unsigned int reverseBits(unsigned int inputNumber)\n{\n    unsigned int reversedNumber= 0;\n    for(int bitPosition= 0; bitPosition < 32; ++bitPosition)\n    {\n        reversedNumber<<= 1;\n        reversedNumber|= inputNumber & 1;\n        inputNumber>>= 1;\n    }\n    return reversedNumber;\n}",
    "output": "unsigned int reverseBits(unsigned int inputNumber)\n{\n    unsigned int reversedNumber= 0;\n    for(int bitPosition= 0; bitPosition < 32; ++bitPosition)\n    {\n        reversedNumber<<= 1;\n        reversedNumber|= inputNumber & 1;\n        inputNumber>>= 1;\n    }\n    return reversedNumber;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int hammingWeight(uint32_t number)\n{\n    int bitCount= 0;\n    while(number != 0)\n    {\n        bitCount+= number & 1;\n        number>>= 1;\n    }\n    return bitCount;\n}",
    "output": "int hammingWeight(uint32_t number)\n{\n    int bitCount= 0;\n    while(number != 0)\n    {\n        bitCount+= number & 1;\n        number>>= 1;\n    }\n    return bitCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> transpose(vector<string> &inputContent)\n{\n    vector<vector<string>> parsedData;\n    for (size_t i = 0; i < inputContent.size(); ++i)\n    {\n        const string &line = inputContent[i];\n        vector<string> row;\n        stringstream stringStream(line);\n        string word;\n        while (stringStream >> word)\n            row.push_back(word);\n        parsedData.push_back(row);\n    }\n\n    vector<string> result(parsedData[0].size(), \"\");\n    for (size_t columnIndex = 0; columnIndex < parsedData[0].size(); ++columnIndex)\n    {\n        for (size_t rowIndex = 0; rowIndex < parsedData.size(); ++rowIndex)\n        {\n            result[columnIndex] += parsedData[rowIndex][columnIndex];\n            if (rowIndex < parsedData.size() - 1)\n                result[columnIndex] += \" \";\n        }\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> transpose(std::vector<std::string> &inputContent)\n{\n    std::vector<std::vector<std::string>> parsedData;\n    for(const std::string &line : inputContent)\n    {\n        std::vector<std::string> row;\n        std::stringstream stringStream(line);\n        std::string word;\n        while(stringStream >> word)\n            row.push_back(word);\n        parsedData.push_back(row);\n    }\n\n    std::vector<std::string> result(parsedData[0].size(), \"\");\n    for(size_t columnIndex= 0; columnIndex < parsedData[0].size(); ++columnIndex)\n    {\n        for(size_t rowIndex= 0; rowIndex < parsedData.size(); ++rowIndex)\n        {\n            result[columnIndex]+= parsedData[rowIndex][columnIndex];\n            if(rowIndex < parsedData.size() - 1)\n                result[columnIndex]+= \" \";\n        }\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint rob(vector<int> &houseValues)\n{\n    int previousMax = 0, currentMax = 0;\n    for (int i = 0; i < houseValues.size(); ++i)\n    {\n        int houseValue = houseValues[i];\n        int tempValue = previousMax;\n        previousMax = max(currentMax + houseValue, previousMax);\n        currentMax = tempValue;\n    }\n    return previousMax;\n}",
    "output": "#include <bits/stdc++.h>\nint rob(std::vector<int> &houseValues)\n{\n    int previousMax= 0, currentMax= 0;\n    for(const auto &houseValue : houseValues)\n    {\n        int tempValue= previousMax;\n        previousMax= std::max(currentMax + houseValue, previousMax);\n        currentMax= tempValue;\n    }\n    return previousMax;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int valueIn) : value(valueIn), leftChild(NULL), rightChild(NULL) {}\n};\n\nvector<int> rightSideView(TreeNode *root)\n{\n    if(!root)\n        return {};\n\n    vector<int> viewResult;\n    queue<TreeNode *> nodeQueue;\n    nodeQueue.push(root);\n\n    while(!nodeQueue.empty())\n    {\n        int levelSize= nodeQueue.size();\n\n        for(int index= 0; index < levelSize; ++index)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n\n            if(index == levelSize - 1)\n                viewResult.push_back(currentNode->value);\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n    }\n\n    return viewResult;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int valueIn) : value(valueIn), leftChild(NULL), rightChild(NULL) {}\n};\n\nstd::vector<int> rightSideView(TreeNode *root)\n{\n    if(!root)\n        return {};\n\n    std::vector<int> viewResult;\n    std::queue<TreeNode *> nodeQueue;\n    nodeQueue.push(root);\n\n    while(!nodeQueue.empty())\n    {\n        int levelSize= nodeQueue.size();\n\n        for(int index= 0; index < levelSize; ++index)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n\n            if(index == levelSize - 1)\n                viewResult.push_back(currentNode->value);\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n    }\n\n    return viewResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(vector<vector<char>> &grid, int rowIndex, int columnIndex)\n{\n    if(rowIndex < 0 || rowIndex >= grid.size() || columnIndex < 0 || columnIndex >= grid[0].size() || grid[rowIndex][columnIndex] == '0')\n        return;\n\n    grid[rowIndex][columnIndex]= '0';\n    depthFirstSearch(grid, rowIndex + 1, columnIndex);\n    depthFirstSearch(grid, rowIndex - 1, columnIndex);\n    depthFirstSearch(grid, rowIndex, columnIndex + 1);\n    depthFirstSearch(grid, rowIndex, columnIndex - 1);\n}\n\nint countIslands(vector<vector<char>> &grid)\n{\n    int islandCount= 0;\n    for(int rowIndex= 0; rowIndex < grid.size(); rowIndex++)\n    {\n        for(int columnIndex= 0; columnIndex < grid[0].size(); columnIndex++)\n        {\n            if(grid[rowIndex][columnIndex] == '1')\n            {\n                islandCount++;\n                depthFirstSearch(grid, rowIndex, columnIndex);\n            }\n        }\n    }\n    return islandCount;\n}",
    "output": "#include <bits/stdc++.h>\nvoid depthFirstSearch(std::vector<std::vector<char>> &grid, int rowIndex, int columnIndex)\n{\n    if(rowIndex < 0 || rowIndex >= grid.size() || columnIndex < 0 || columnIndex >= grid[0].size() || grid[rowIndex][columnIndex] == '0')\n        return;\n\n    grid[rowIndex][columnIndex]= '0';\n    depthFirstSearch(grid, rowIndex + 1, columnIndex);\n    depthFirstSearch(grid, rowIndex - 1, columnIndex);\n    depthFirstSearch(grid, rowIndex, columnIndex + 1);\n    depthFirstSearch(grid, rowIndex, columnIndex - 1);\n}\n\nint countIslands(std::vector<std::vector<char>> &grid)\n{\n    int islandCount= 0;\n    for(int rowIndex= 0; rowIndex < grid.size(); rowIndex++)\n    {\n        for(int columnIndex= 0; columnIndex < grid[0].size(); columnIndex++)\n        {\n            if(grid[rowIndex][columnIndex] == '1')\n            {\n                islandCount++;\n                depthFirstSearch(grid, rowIndex, columnIndex);\n            }\n        }\n    }\n    return islandCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int rangeBitwiseAnd(int left, int right)\n{\n    int shiftCount= 0;\n    while(left != right)\n    {\n        left>>= 1;\n        right>>= 1;\n        ++shiftCount;\n    }\n    return left << shiftCount;\n}",
    "output": "int rangeBitwiseAnd(int left, int right)\n{\n    int shiftCount= 0;\n    while(left != right)\n    {\n        left>>= 1;\n        right>>= 1;\n        ++shiftCount;\n    }\n    return left << shiftCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int getNext(int number)\n{\n    int sumOfSquares= 0;\n    while(number > 0)\n    {\n        int currentDigit= number % 10;\n        sumOfSquares+= currentDigit * currentDigit;\n        number/= 10;\n    }\n    return sumOfSquares;\n}\n\nbool isHappy(int number)\n{\n    int slowPointer= number, fastPointer= getNext(number);\n    while(fastPointer != 1 && slowPointer != fastPointer)\n    {\n        slowPointer= getNext(slowPointer);\n        fastPointer= getNext(getNext(fastPointer));\n    }\n    return fastPointer == 1;\n}",
    "output": "int getNext(int number)\n{\n    int sumOfSquares= 0;\n    while(number > 0)\n    {\n        int currentDigit= number % 10;\n        sumOfSquares+= currentDigit * currentDigit;\n        number/= 10;\n    }\n    return sumOfSquares;\n}\n\nbool isHappy(int number)\n{\n    int slowPointer= number, fastPointer= getNext(number);\n    while(fastPointer != 1 && slowPointer != fastPointer)\n    {\n        slowPointer= getNext(slowPointer);\n        fastPointer= getNext(getNext(fastPointer));\n    }\n    return fastPointer == 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *removeElements(ListNode *head, int valueToRemove)\n{\n    ListNode **current= &head;\n\n    while(*current != NULL)\n    {\n        if((*current)->value == valueToRemove)\n        {\n            ListNode *nextNode= (*current)->next;\n            delete *current;\n            *current= nextNode;\n        }\n        else\n        {\n            current= &(*current)->next;\n        }\n    }\n\n    return head;\n}",
    "output": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *removeElements(ListNode *head, int valueToRemove)\n{\n    ListNode **current= &head;\n\n    while(*current != NULL)\n    {\n        if((*current)->value == valueToRemove)\n        {\n            ListNode *nextNode= (*current)->next;\n            delete *current;\n            *current= nextNode;\n        }\n        else\n        {\n            current= &(*current)->next;\n        }\n    }\n\n    return head;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countPrimes(int upperLimit)\n{\n    if(upperLimit <= 2)\n        return 0;\n    vector<bool> isPrime(upperLimit, true);\n    isPrime[0]= isPrime[1]= false;\n    for(int currentNumber= 2; currentNumber * currentNumber < upperLimit; ++currentNumber)\n    {\n        if(isPrime[currentNumber])\n        {\n            for(int multiple= currentNumber * currentNumber; multiple < upperLimit; multiple+= currentNumber)\n            {\n                isPrime[multiple]= false;\n            }\n        }\n    }\n    return count(isPrime.begin(), isPrime.end(), true);\n}",
    "output": "#include <bits/stdc++.h>\nint countPrimes(int upperLimit)\n{\n    if(upperLimit <= 2)\n        return 0;\n    std::vector<bool> isPrime(upperLimit, true);\n    isPrime[0]= isPrime[1]= false;\n    for(int currentNumber= 2; currentNumber * currentNumber < upperLimit; ++currentNumber)\n    {\n        if(isPrime[currentNumber])\n        {\n            for(int multiple= currentNumber * currentNumber; multiple < upperLimit; multiple+= currentNumber)\n            {\n                isPrime[multiple]= false;\n            }\n        }\n    }\n    return std::count(isPrime.begin(), isPrime.end(), true);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isIsomorphic(string sourceString, string targetString)\n{\n    unordered_map<char, char> sourceToTargetMap, targetToSourceMap;\n    for(size_t index= 0; index < sourceString.size(); ++index)\n    {\n        if(sourceToTargetMap.find(sourceString[index]) == sourceToTargetMap.end())\n        {\n            sourceToTargetMap[sourceString[index]]= targetString[index];\n        }\n        if(targetToSourceMap.find(targetString[index]) == targetToSourceMap.end())\n        {\n            targetToSourceMap[targetString[index]]= sourceString[index];\n        }\n        if(sourceToTargetMap[sourceString[index]] != targetString[index] ||\n           targetToSourceMap[targetString[index]] != sourceString[index])\n        {\n            return false;\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isIsomorphic(std::string sourceString, std::string targetString)\n{\n    std::unordered_map<char, char> sourceToTargetMap, targetToSourceMap;\n    for(size_t index= 0; index < sourceString.size(); ++index)\n    {\n        if(sourceToTargetMap.find(sourceString[index]) == sourceToTargetMap.end())\n        {\n            sourceToTargetMap[sourceString[index]]= targetString[index];\n        }\n        if(targetToSourceMap.find(targetString[index]) == targetToSourceMap.end())\n        {\n            targetToSourceMap[targetString[index]]= sourceString[index];\n        }\n        if(sourceToTargetMap[sourceString[index]] != targetString[index] ||\n           targetToSourceMap[targetString[index]] != sourceString[index])\n        {\n            return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n};\n\nListNode *reverseList(ListNode *head)\n{\n    ListNode *previous= NULL;\n    ListNode *current= head;\n    ListNode *nextNode= NULL;\n    while(current != NULL)\n    {\n        nextNode= current->next;\n        current->next= previous;\n        previous= current;\n        current= nextNode;\n    }\n    return previous;\n}",
    "output": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n};\n\nListNode *reverseList(ListNode *head)\n{\n    ListNode *previous= NULL;\n    ListNode *current= head;\n    ListNode *nextNode= NULL;\n    while(current != NULL)\n    {\n        nextNode= current->next;\n        current->next= previous;\n        previous= current;\n        current= nextNode;\n    }\n    return previous;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canFinish(int totalCourses, vector<vector<int>> &coursePrerequisites)\n{\n    vector<vector<int>> adjacencyList(totalCourses);\n    vector<int> inDegree(totalCourses, 0);\n\n    for (auto &prerequisite : coursePrerequisites)\n    {\n        adjacencyList[prerequisite[1]].push_back(prerequisite[0]);\n        inDegree[prerequisite[0]]++;\n    }\n\n    queue<int> courseQueue;\n    for (int i = 0; i < totalCourses; i++)\n    {\n        if (inDegree[i] == 0)\n            courseQueue.push(i);\n    }\n\n    while (!courseQueue.empty())\n    {\n        int currentCourse = courseQueue.front();\n        courseQueue.pop();\n        totalCourses--;\n\n        for (int j = 0; j < adjacencyList[currentCourse].size(); j++)\n        {\n            int nextCourse = adjacencyList[currentCourse][j];\n            inDegree[nextCourse]--;\n            if (inDegree[nextCourse] == 0)\n                courseQueue.push(nextCourse);\n        }\n    }\n\n    return totalCourses == 0;\n}",
    "output": "#include <bits/stdc++.h>\nbool canFinish(int totalCourses, std::vector<std::vector<int>> &coursePrerequisites)\n{\n    std::vector<std::vector<int>> adjacencyList(totalCourses);\n    std::vector<int> inDegree(totalCourses, 0);\n\n    for(auto &prerequisite : coursePrerequisites)\n    {\n        adjacencyList[prerequisite[1]].push_back(prerequisite[0]);\n        inDegree[prerequisite[0]]++;\n    }\n\n    std::queue<int> courseQueue;\n    for(int i= 0; i < totalCourses; i++)\n    {\n        if(inDegree[i] == 0)\n            courseQueue.push(i);\n    }\n\n    while(!courseQueue.empty())\n    {\n        int currentCourse= courseQueue.front();\n        courseQueue.pop();\n        totalCourses--;\n\n        for(int nextCourse : adjacencyList[currentCourse])\n        {\n            inDegree[nextCourse]--;\n            if(inDegree[nextCourse] == 0)\n                courseQueue.push(nextCourse);\n        }\n    }\n\n    return totalCourses == 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Trie\n{\n    struct TrieNode\n    {\n        unordered_map<char, TrieNode *> children;\n        bool isEndOfWord;\n    };\n\n    TrieNode *root;\n\n  public:\n    Trie()\n    {\n        root = new TrieNode();\n        root->isEndOfWord = false;\n    }\n\n    void insert(string word)\n    {\n        TrieNode *currentNode = root;\n        for (int i = 0; i < word.size(); ++i)\n        {\n            char character = word[i];\n            if (currentNode->children.find(character) == currentNode->children.end())\n            {\n                currentNode->children[character] = new TrieNode();\n            }\n            currentNode = currentNode->children[character];\n        }\n        currentNode->isEndOfWord = true;\n    }\n\n    bool search(string word)\n    {\n        TrieNode *currentNode = root;\n        for (int i = 0; i < word.size(); ++i)\n        {\n            char character = word[i];\n            if (currentNode->children.find(character) == currentNode->children.end())\n            {\n                return false;\n            }\n            currentNode = currentNode->children[character];\n        }\n        return currentNode->isEndOfWord;\n    }\n\n    bool startsWith(string prefix)\n    {\n        TrieNode *currentNode = root;\n        for (int i = 0; i < prefix.size(); ++i)\n        {\n            char character = prefix[i];\n            if (currentNode->children.find(character) == currentNode->children.end())\n            {\n                return false;\n            }\n            currentNode = currentNode->children[character];\n        }\n        return true;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Trie\n{\n    struct TrieNode\n    {\n        std::unordered_map<char, TrieNode *> children;\n        bool isEndOfWord;\n    };\n\n    TrieNode *root;\n\n  public:\n    Trie()\n    {\n        root= new TrieNode();\n        root->isEndOfWord= false;\n    }\n\n    void insert(std::string word)\n    {\n        TrieNode *currentNode= root;\n        for(char character : word)\n        {\n            if(currentNode->children.find(character) == currentNode->children.end())\n            {\n                currentNode->children[character]= new TrieNode();\n            }\n            currentNode= currentNode->children[character];\n        }\n        currentNode->isEndOfWord= true;\n    }\n\n    bool search(std::string word)\n    {\n        TrieNode *currentNode= root;\n        for(char character : word)\n        {\n            if(currentNode->children.find(character) == currentNode->children.end())\n            {\n                return false;\n            }\n            currentNode= currentNode->children[character];\n        }\n        return currentNode->isEndOfWord;\n    }\n\n    bool startsWith(std::string prefix)\n    {\n        TrieNode *currentNode= root;\n        for(char character : prefix)\n        {\n            if(currentNode->children.find(character) == currentNode->children.end())\n            {\n                return false;\n            }\n            currentNode= currentNode->children[character];\n        }\n        return true;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minSubArrayLen(int targetSum, vector<int> &numArray)\n{\n    int leftIndex= 0, currentSum= 0, minimumLength= INT_MAX;\n    for(int rightIndex= 0; rightIndex < numArray.size(); rightIndex++)\n    {\n        currentSum+= numArray[rightIndex];\n        while(currentSum >= targetSum)\n        {\n            minimumLength= min(minimumLength, rightIndex - leftIndex + 1);\n            currentSum-= numArray[leftIndex++];\n        }\n    }\n    return minimumLength == INT_MAX ? 0 : minimumLength;\n}",
    "output": "#include <bits/stdc++.h>\nint minSubArrayLen(int targetSum, std::vector<int> &numArray)\n{\n    int leftIndex= 0, currentSum= 0, minimumLength= INT_MAX;\n    for(int rightIndex= 0; rightIndex < numArray.size(); rightIndex++)\n    {\n        currentSum+= numArray[rightIndex];\n        while(currentSum >= targetSum)\n        {\n            minimumLength= std::min(minimumLength, rightIndex - leftIndex + 1);\n            currentSum-= numArray[leftIndex++];\n        }\n    }\n    return minimumLength == INT_MAX ? 0 : minimumLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findOrder(int totalCourses, vector<vector<int>> &coursePrerequisites)\n{\n    vector<int> inDegree(totalCourses, 0);\n    vector<vector<int>> adjacencyList(totalCourses);\n\n    for (const auto &prerequisite : coursePrerequisites)\n    {\n        adjacencyList[prerequisite[1]].push_back(prerequisite[0]);\n        inDegree[prerequisite[0]]++;\n    }\n\n    queue<int> courseQueue;\n    for (int i = 0; i < totalCourses; i++)\n    {\n        if (inDegree[i] == 0)\n        {\n            courseQueue.push(i);\n        }\n    }\n\n    vector<int> courseOrder;\n\n    while (!courseQueue.empty())\n    {\n        int currentCourse = courseQueue.front();\n        courseQueue.pop();\n        courseOrder.push_back(currentCourse);\n        for (int j = 0; j < adjacencyList[currentCourse].size(); j++)\n        {\n            int nextCourse = adjacencyList[currentCourse][j];\n            if (--inDegree[nextCourse] == 0)\n            {\n                courseQueue.push(nextCourse);\n            }\n        }\n    }\n\n    return (courseOrder.size() == totalCourses) ? courseOrder : vector<int>();\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findOrder(int totalCourses, std::vector<std::vector<int>> &coursePrerequisites)\n{\n    std::vector<int> inDegree(totalCourses, 0);\n    std::vector<std::vector<int>> adjacencyList(totalCourses);\n\n    for(auto &prerequisite : coursePrerequisites)\n    {\n        adjacencyList[prerequisite[1]].push_back(prerequisite[0]);\n        inDegree[prerequisite[0]]++;\n    }\n\n    std::queue<int> courseQueue;\n    for(int i= 0; i < totalCourses; i++)\n    {\n        if(inDegree[i] == 0)\n        {\n            courseQueue.push(i);\n        }\n    }\n\n    std::vector<int> courseOrder;\n\n    while(!courseQueue.empty())\n    {\n        int currentCourse= courseQueue.front();\n        courseQueue.pop();\n        courseOrder.push_back(currentCourse);\n        for(auto nextCourse : adjacencyList[currentCourse])\n        {\n            if(--inDegree[nextCourse] == 0)\n            {\n                courseQueue.push(nextCourse);\n            }\n        }\n    }\n\n    return (courseOrder.size() == totalCourses) ? courseOrder : std::vector<int>();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass WordDictionary\n{\n  public:\n    struct TrieNode\n    {\n        TrieNode *children[26];\n        bool isWord;\n        \n        TrieNode() : isWord(false) {\n            for (int i = 0; i < 26; i++) {\n                children[i] = NULL;\n            }\n        }\n    };\n\n    TrieNode *root;\n\n    WordDictionary()\n    {\n        root = new TrieNode();\n    }\n\n    void addWord(string word)\n    {\n        TrieNode *currentNode = root;\n        for (int i = 0; i < word.length(); i++)\n        {\n            char character = word[i];\n            if (currentNode->children[character - 'a'] == NULL)\n            {\n                currentNode->children[character - 'a'] = new TrieNode();\n            }\n            currentNode = currentNode->children[character - 'a'];\n        }\n        currentNode->isWord = true;\n    }\n\n    bool search(string word)\n    {\n        return searchHelper(root, word, 0);\n    }\n\n    bool searchHelper(TrieNode *node, string &word, int index)\n    {\n        if (index == word.length())\n        {\n            return node->isWord;\n        }\n\n        if (word[index] == '.')\n        {\n            for (int i = 0; i < 26; i++)\n            {\n                if (node->children[i] != NULL && searchHelper(node->children[i], word, index + 1))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n        else\n        {\n            if (node->children[word[index] - 'a'] == NULL)\n            {\n                return false;\n            }\n            return searchHelper(node->children[word[index] - 'a'], word, index + 1);\n        }\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass WordDictionary\n{\n  public:\n    struct TrieNode\n    {\n        TrieNode *children[26];\n        bool isWord;\n    };\n\n    TrieNode *root;\n\n    WordDictionary()\n    {\n        root= new TrieNode();\n    }\n\n    void addWord(std::string word)\n    {\n        TrieNode *currentNode= root;\n        for(char character : word)\n        {\n            if(currentNode->children[character - 'a'] == NULL)\n            {\n                currentNode->children[character - 'a']= new TrieNode();\n            }\n            currentNode= currentNode->children[character - 'a'];\n        }\n        currentNode->isWord= true;\n    }\n\n    bool search(std::string word)\n    {\n        return searchHelper(root, word, 0);\n    }\n\n    bool searchHelper(TrieNode *node, std::string &word, int index)\n    {\n        if(index == word.length())\n        {\n            return node->isWord;\n        }\n\n        if(word[index] == '.')\n        {\n            for(int i= 0; i < 26; i++)\n            {\n                if(node->children[i] != NULL && searchHelper(node->children[i], word, index + 1))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n        else\n        {\n            if(node->children[word[index] - 'a'] == NULL)\n            {\n                return false;\n            }\n            return searchHelper(node->children[word[index] - 'a'], word, index + 1);\n        }\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(const vector<vector<char>> &board, const string &targetWord, int charIndex, int row, int col, vector<vector<bool>> &visitedCells, bool &isFound)\n{\n    if(charIndex == targetWord.length())\n    {\n        isFound = true;\n        return;\n    }\n    if(row < 0 || col < 0 || row >= board.size() || col >= board[0].size() || visitedCells[row][col] || board[row][col] != targetWord[charIndex])\n    {\n        return;\n    }\n    visitedCells[row][col] = true;\n    depthFirstSearch(board, targetWord, charIndex + 1, row - 1, col, visitedCells, isFound);\n    depthFirstSearch(board, targetWord, charIndex + 1, row + 1, col, visitedCells, isFound);\n    depthFirstSearch(board, targetWord, charIndex + 1, row, col - 1, visitedCells, isFound);\n    depthFirstSearch(board, targetWord, charIndex + 1, row, col + 1, visitedCells, isFound);\n    visitedCells[row][col] = false;\n}\n\nvector<string> findWords(vector<vector<char>> &board, vector<string> &wordList)\n{\n    vector<string> foundWords;\n    for(int i = 0; i < wordList.size(); ++i)\n    {\n        const auto &targetWord = wordList[i];\n        bool isFound = false;\n        vector<vector<bool>> visitedCells(board.size(), vector<bool>(board[0].size(), false));\n        for(int row = 0; row < board.size() && !isFound; ++row)\n        {\n            for(int col = 0; col < board[0].size() && !isFound; ++col)\n            {\n                depthFirstSearch(board, targetWord, 0, row, col, visitedCells, isFound);\n            }\n        }\n        if(isFound)\n        {\n            foundWords.push_back(targetWord);\n        }\n    }\n    return foundWords;\n}",
    "output": "#include <bits/stdc++.h>\nvoid depthFirstSearch(const std::vector<std::vector<char>> &board, const std::string &targetWord, int charIndex, int row, int col, std::vector<std::vector<bool>> &visitedCells, bool &isFound)\n{\n    if(charIndex == targetWord.length())\n    {\n        isFound= true;\n        return;\n    }\n    if(row < 0 || col < 0 || row >= board.size() || col >= board[0].size() || visitedCells[row][col] || board[row][col] != targetWord[charIndex])\n    {\n        return;\n    }\n    visitedCells[row][col]= true;\n    depthFirstSearch(board, targetWord, charIndex + 1, row - 1, col, visitedCells, isFound);\n    depthFirstSearch(board, targetWord, charIndex + 1, row + 1, col, visitedCells, isFound);\n    depthFirstSearch(board, targetWord, charIndex + 1, row, col - 1, visitedCells, isFound);\n    depthFirstSearch(board, targetWord, charIndex + 1, row, col + 1, visitedCells, isFound);\n    visitedCells[row][col]= false;\n}\n\nstd::vector<std::string> findWords(std::vector<std::vector<char>> &board, std::vector<std::string> &wordList)\n{\n    std::vector<std::string> foundWords;\n    for(const auto &targetWord : wordList)\n    {\n        bool isFound= false;\n        std::vector<std::vector<bool>> visitedCells(board.size(), std::vector<bool>(board[0].size(), false));\n        for(int row= 0; row < board.size() && !isFound; ++row)\n        {\n            for(int col= 0; col < board[0].size() && !isFound; ++col)\n            {\n                depthFirstSearch(board, targetWord, 0, row, col, visitedCells, isFound);\n            }\n        }\n        if(isFound)\n        {\n            foundWords.push_back(targetWord);\n        }\n    }\n    return foundWords;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint rob(vector<int> &houseValues)\n{\n    if(houseValues.size() == 1)\n        return houseValues[0];\n    int previousMax= 0, currentMax= 0;\n    for(int i= 0; i < houseValues.size() - 1; i++)\n    {\n        int tempMax= max(currentMax, previousMax + houseValues[i]);\n        previousMax= currentMax;\n        currentMax= tempMax;\n    }\n    int result= currentMax;\n    previousMax= 0;\n    currentMax= 0;\n    for(int i= 1; i < houseValues.size(); i++)\n    {\n        int tempMax= max(currentMax, previousMax + houseValues[i]);\n        previousMax= currentMax;\n        currentMax= tempMax;\n    }\n    return max(result, currentMax);\n}",
    "output": "#include <bits/stdc++.h>\nint rob(std::vector<int> &houseValues)\n{\n    if(houseValues.size() == 1)\n        return houseValues[0];\n    int previousMax= 0, currentMax= 0;\n    for(int i= 0; i < houseValues.size() - 1; i++)\n    {\n        int tempMax= std::max(currentMax, previousMax + houseValues[i]);\n        previousMax= currentMax;\n        currentMax= tempMax;\n    }\n    int result= currentMax;\n    previousMax= 0;\n    currentMax= 0;\n    for(int i= 1; i < houseValues.size(); i++)\n    {\n        int tempMax= std::max(currentMax, previousMax + houseValues[i]);\n        previousMax= currentMax;\n        currentMax= tempMax;\n    }\n    return std::max(result, currentMax);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring shortestPalindrome(string inputString)\n{\n    int stringLength = inputString.size();\n    string reversedString = inputString;\n    reverse(reversedString.begin(), reversedString.end());\n\n    for(int index = 0; index < stringLength; ++index)\n    {\n        if(inputString.substr(0, stringLength - index) == reversedString.substr(index))\n            return reversedString.substr(0, index) + inputString;\n    }\n    return \"\";\n}",
    "output": "#include <bits/stdc++.h>\nstd::string shortestPalindrome(std::string inputString)\n{\n    int stringLength= inputString.size();\n    std::string reversedString= inputString;\n    std::reverse(reversedString.begin(), reversedString.end());\n\n    for(int index= 0; index < stringLength; ++index)\n    {\n        if(inputString.substr(0, stringLength - index) == reversedString.substr(index))\n            return reversedString.substr(0, index) + inputString;\n    }\n    return \"\";\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findKthLargest(vector<int> &numberList, int k)\n{\n    sort(numberList.begin(), numberList.end(), greater<int>());\n    return numberList[k - 1];\n}",
    "output": "#include <bits/stdc++.h>\nint findKthLargest(std::vector<int> &numberList, int k)\n{\n    std::sort(numberList.begin(), numberList.end(), std::greater<int>());\n    return numberList[k - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid findCombinations(int remainingCount, int remainingSum, int lastNumber, vector<int> &currentCombination, vector<vector<int>> &combinations)\n{\n    if(remainingCount == 0 && remainingSum == 0)\n    {\n        combinations.push_back(currentCombination);\n    }\n    else if(remainingCount > 0 && remainingSum > 0)\n    {\n        for(int nextNumber= lastNumber + 1; nextNumber <= 9; ++nextNumber)\n        {\n            currentCombination.push_back(nextNumber);\n            findCombinations(remainingCount - 1, remainingSum - nextNumber, nextNumber, currentCombination, combinations);\n            currentCombination.pop_back();\n        }\n    }\n}\n\nvector<vector<int>> combinationSum3(int k, int n)\n{\n    vector<vector<int>> combinations;\n    vector<int> currentCombination;\n    findCombinations(k, n, 0, currentCombination, combinations);\n    return combinations;\n}",
    "output": "#include <bits/stdc++.h>\nvoid findCombinations(int remainingCount, int remainingSum, int lastNumber, std::vector<int> &currentCombination, std::vector<std::vector<int>> &combinations)\n{\n    if(remainingCount == 0 && remainingSum == 0)\n    {\n        combinations.push_back(currentCombination);\n    }\n    else if(remainingCount > 0 && remainingSum > 0)\n    {\n        for(int nextNumber= lastNumber + 1; nextNumber <= 9; ++nextNumber)\n        {\n            currentCombination.push_back(nextNumber);\n            findCombinations(remainingCount - 1, remainingSum - nextNumber, nextNumber, currentCombination, combinations);\n            currentCombination.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<int>> combinationSum3(int k, int n)\n{\n    std::vector<std::vector<int>> combinations;\n    std::vector<int> currentCombination;\n    findCombinations(k, n, 0, currentCombination, combinations);\n    return combinations;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool containsDuplicate(vector<int> &numbers)\n{\n    unordered_set<int> uniqueNumbersSet;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        if (uniqueNumbersSet.find(currentNumber) != uniqueNumbersSet.end())\n        {\n            return true;\n        }\n        uniqueNumbersSet.insert(currentNumber);\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool containsDuplicate(std::vector<int> &numbers)\n{\n    std::unordered_set<int> uniqueNumbersSet;\n    for(int currentNumber : numbers)\n    {\n        if(uniqueNumbersSet.find(currentNumber) != uniqueNumbersSet.end())\n        {\n            return true;\n        }\n        uniqueNumbersSet.insert(currentNumber);\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> getSkyline(vector<vector<int>> &buildings)\n{\n    vector<pair<int, int>> points;\n    for (const auto &building : buildings)\n    {\n        points.emplace_back(building[0], -building[2]);\n        points.emplace_back(building[1], building[2]);\n    }\n    sort(points.begin(), points.end());\n    multiset<int> heights = {0};\n    int previousHeight = 0;\n    vector<vector<int>> skyline;\n    \n    for (int i = 0; i < points.size(); ++i)\n    {\n        auto [coordinateX, height] = points[i];\n        if (height < 0)\n            heights.insert(-height);\n        else\n            heights.erase(heights.find(height));\n        int currentHeight = *heights.rbegin();\n        if (currentHeight != previousHeight)\n        {\n            skyline.push_back({coordinateX, currentHeight});\n            previousHeight = currentHeight;\n        }\n    }\n    return skyline;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> getSkyline(std::vector<std::vector<int>> &buildings)\n{\n    std::vector<std::pair<int, int>> points;\n    for(const auto &building : buildings)\n    {\n        points.emplace_back(building[0], -building[2]);\n        points.emplace_back(building[1], building[2]);\n    }\n    std::sort(points.begin(), points.end());\n    std::multiset<int> heights= {0};\n    int previousHeight= 0;\n    std::vector<std::vector<int>> skyline;\n    for(const auto &[coordinateX, height] : points)\n    {\n        if(height < 0)\n            heights.insert(-height);\n        else\n            heights.erase(heights.find(height));\n        int currentHeight= *heights.rbegin();\n        if(currentHeight != previousHeight)\n        {\n            skyline.push_back({coordinateX, currentHeight});\n            previousHeight= currentHeight;\n        }\n    }\n    return skyline;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool containsNearbyDuplicate(vector<int> &numberList, int maxIndexDifference)\n{\n    unordered_map<int, int> valueIndexMap;\n    for(int currentIndex= 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        if(valueIndexMap.find(numberList[currentIndex]) != valueIndexMap.end() && currentIndex - valueIndexMap[numberList[currentIndex]] <= maxIndexDifference)\n        {\n            return true;\n        }\n        valueIndexMap[numberList[currentIndex]]= currentIndex;\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool containsNearbyDuplicate(std::vector<int> &numberList, int maxIndexDifference)\n{\n    std::unordered_map<int, int> valueIndexMap;\n    for(int currentIndex= 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        if(valueIndexMap.find(numberList[currentIndex]) != valueIndexMap.end() && currentIndex - valueIndexMap[numberList[currentIndex]] <= maxIndexDifference)\n        {\n            return true;\n        }\n        valueIndexMap[numberList[currentIndex]]= currentIndex;\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool containsNearbyAlmostDuplicate(vector<int> &numberList, int indexDifference, int valueDifference)\n{\n    set<long> slidingWindow;\n    for(int currentIndex= 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        if(currentIndex > indexDifference)\n        {\n            slidingWindow.erase(numberList[currentIndex - indexDifference - 1]);\n        }\n        auto position= slidingWindow.lower_bound((long)numberList[currentIndex] - valueDifference);\n        if(position != slidingWindow.end() && *position - numberList[currentIndex] <= valueDifference)\n        {\n            return true;\n        }\n        slidingWindow.insert(numberList[currentIndex]);\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool containsNearbyAlmostDuplicate(std::vector<int> &numberList, int indexDifference, int valueDifference)\n{\n    std::set<long> slidingWindow;\n    for(int currentIndex= 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        if(currentIndex > indexDifference)\n        {\n            slidingWindow.erase(numberList[currentIndex - indexDifference - 1]);\n        }\n        auto position= slidingWindow.lower_bound((long)numberList[currentIndex] - valueDifference);\n        if(position != slidingWindow.end() && *position - numberList[currentIndex] <= valueDifference)\n        {\n            return true;\n        }\n        slidingWindow.insert(numberList[currentIndex]);\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maximalSquare(vector<vector<char>> &matrix)\n{\n    int rowCount= matrix.size();\n    int colCount= matrix[0].size();\n    vector<vector<int>> dynamicProgramming(rowCount + 1, vector<int>(colCount + 1, 0));\n    int maximumSize= 0;\n\n    for(int rowIndex= 1; rowIndex <= rowCount; rowIndex++)\n    {\n        for(int colIndex= 1; colIndex <= colCount; colIndex++)\n        {\n            if(matrix[rowIndex - 1][colIndex - 1] == '1')\n            {\n                dynamicProgramming[rowIndex][colIndex]= min({dynamicProgramming[rowIndex - 1][colIndex], dynamicProgramming[rowIndex][colIndex - 1], dynamicProgramming[rowIndex - 1][colIndex - 1]}) + 1;\n                maximumSize= max(maximumSize, dynamicProgramming[rowIndex][colIndex]);\n            }\n        }\n    }\n\n    return maximumSize * maximumSize;\n}",
    "output": "#include <bits/stdc++.h>\nint maximalSquare(std::vector<std::vector<char>> &matrix)\n{\n    int rowCount = matrix.size();\n    int colCount = matrix[0].size();\n    std::vector<std::vector<int>> dynamicProgramming(rowCount + 1, std::vector<int>(colCount + 1, 0));\n    int maximumSize = 0;\n\n    for(int rowIndex = 1; rowIndex <= rowCount; rowIndex++)\n    {\n        for(int colIndex = 1; colIndex <= colCount; colIndex++)\n        {\n            if(matrix[rowIndex - 1][colIndex - 1] == '1')\n            {\n                dynamicProgramming[rowIndex][colIndex] = std::min({dynamicProgramming[rowIndex - 1][colIndex], dynamicProgramming[rowIndex][colIndex - 1], dynamicProgramming[rowIndex - 1][colIndex - 1]}) + 1;\n                maximumSize = std::max(maximumSize, dynamicProgramming[rowIndex][colIndex]);\n            }\n        }\n    }\n\n    return maximumSize * maximumSize;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class TreeNode\n{\n  public:\n    TreeNode *leftChild, *rightChild;\n};\n\nint countNodes(TreeNode *rootNode)\n{\n    if(!rootNode)\n        return 0;\n    int leftDepth= 0, rightDepth= 0;\n    TreeNode *leftTraversal= rootNode, *rightTraversal= rootNode;\n\n    while(leftTraversal)\n    {\n        leftTraversal= leftTraversal->leftChild;\n        leftDepth++;\n    }\n\n    while(rightTraversal)\n    {\n        rightTraversal= rightTraversal->rightChild;\n        rightDepth++;\n    }\n\n    if(leftDepth == rightDepth)\n        return (1 << leftDepth) - 1;\n    return 1 + countNodes(rootNode->leftChild) + countNodes(rootNode->rightChild);\n}",
    "output": "class TreeNode\n{\n  public:\n    TreeNode *leftChild, *rightChild;\n};\n\nint countNodes(TreeNode *rootNode)\n{\n    if(!rootNode)\n        return 0;\n    int leftDepth= 0, rightDepth= 0;\n    TreeNode *leftTraversal= rootNode, *rightTraversal= rootNode;\n\n    while(leftTraversal)\n    {\n        leftTraversal= leftTraversal->leftChild;\n        leftDepth++;\n    }\n\n    while(rightTraversal)\n    {\n        rightTraversal= rightTraversal->rightChild;\n        rightDepth++;\n    }\n\n    if(leftDepth == rightDepth)\n        return (1 << leftDepth) - 1;\n    return 1 + countNodes(rootNode->leftChild) + countNodes(rootNode->rightChild);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int calculateTotalArea(int rectangle1X1, int rectangle1Y1, int rectangle1X2, int rectangle1Y2, int rectangle2X1, int rectangle2Y1, int rectangle2X2, int rectangle2Y2)\n{\n    int area1= (rectangle1X2 - rectangle1X1) * (rectangle1Y2 - rectangle1Y1);\n    int area2= (rectangle2X2 - rectangle2X1) * (rectangle2Y2 - rectangle2Y1);\n\n    int overlapWidth= min(rectangle1X2, rectangle2X2) - max(rectangle1X1, rectangle2X1);\n    int overlapHeight= min(rectangle1Y2, rectangle2Y2) - max(rectangle1Y1, rectangle2Y1);\n\n    int overlapArea= max(overlapWidth, 0) * max(overlapHeight, 0);\n\n    return area1 + area2 - overlapArea;\n}",
    "output": "int calculateTotalArea(int rectangle1X1, int rectangle1Y1, int rectangle1X2, int rectangle1Y2, int rectangle2X1, int rectangle2Y1, int rectangle2X2, int rectangle2Y2)\n{\n    int area1= (rectangle1X2 - rectangle1X1) * (rectangle1Y2 - rectangle1Y1);\n    int area2= (rectangle2X2 - rectangle2X1) * (rectangle2Y2 - rectangle2Y1);\n\n    int overlapWidth= min(rectangle1X2, rectangle2X2) - max(rectangle1X1, rectangle2X1);\n    int overlapHeight= min(rectangle1Y2, rectangle2Y2) - max(rectangle1Y1, rectangle2Y1);\n\n    int overlapArea= max(overlapWidth, 0) * max(overlapHeight, 0);\n\n    return area1 + area2 - overlapArea;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculate(string expression)\n{\n    int totalResult = 0, currentSign = 1, currentNumber = 0;\n    stack<int> numberStack;\n    for (int i = 0; i < expression.size(); ++i)\n    {\n        char character = expression[i];\n        if (isdigit(character))\n        {\n            currentNumber = currentNumber * 10 + (character - '0');\n        }\n        else\n        {\n            totalResult += currentSign * currentNumber;\n            currentNumber = 0;\n            if (character == '+')\n            {\n                currentSign = 1;\n            }\n            else if (character == '-')\n            {\n                currentSign = -1;\n            }\n            else if (character == '(')\n            {\n                numberStack.push(totalResult);\n                numberStack.push(currentSign);\n                totalResult = 0;\n                currentSign = 1;\n            }\n            else if (character == ')')\n            {\n                int previousSign = numberStack.top();\n                numberStack.pop();\n                int previousResult = numberStack.top();\n                numberStack.pop();\n                totalResult = previousResult + previousSign * totalResult;\n            }\n        }\n    }\n    totalResult += currentSign * currentNumber;\n    return totalResult;\n}",
    "output": "#include <bits/stdc++.h>\nint calculate(std::string expression)\n{\n    int totalResult= 0, currentSign= 1, currentNumber= 0;\n    std::stack<int> numberStack;\n    for(char character : expression)\n    {\n        if(std::isdigit(character))\n        {\n            currentNumber= currentNumber * 10 + (character - '0');\n        }\n        else\n        {\n            totalResult += currentSign * currentNumber;\n            currentNumber = 0;\n            if(character == '+')\n            {\n                currentSign = 1;\n            }\n            else if(character == '-')\n            {\n                currentSign = -1;\n            }\n            else if(character == '(')\n            {\n                numberStack.push(totalResult);\n                numberStack.push(currentSign);\n                totalResult = 0;\n                currentSign = 1;\n            }\n            else if(character == ')')\n            {\n                int previousSign = numberStack.top();\n                numberStack.pop();\n                int previousResult = numberStack.top();\n                numberStack.pop();\n                totalResult = previousResult + previousSign * totalResult;\n            }\n        }\n    }\n    totalResult += currentSign * currentNumber;\n    return totalResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass MyStack\n{\n  public:\n    queue<int> primaryQueue, secondaryQueue;\n\n    void push(int newElement)\n    {\n        secondaryQueue.push(newElement);\n        while(!primaryQueue.empty())\n        {\n            secondaryQueue.push(primaryQueue.front());\n            primaryQueue.pop();\n        }\n        swap(primaryQueue, secondaryQueue);\n    }\n\n    int pop()\n    {\n        int topElement= primaryQueue.front();\n        primaryQueue.pop();\n        return topElement;\n    }\n\n    int top()\n    {\n        return primaryQueue.front();\n    }\n\n    bool isEmpty()\n    {\n        return primaryQueue.empty();\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass MyStack\n{\n  public:\n    std::queue<int> primaryQueue, secondaryQueue;\n\n    void push(int newElement)\n    {\n        secondaryQueue.push(newElement);\n        while(!primaryQueue.empty())\n        {\n            secondaryQueue.push(primaryQueue.front());\n            primaryQueue.pop();\n        }\n        std::swap(primaryQueue, secondaryQueue);\n    }\n\n    int pop()\n    {\n        int topElement= primaryQueue.front();\n        primaryQueue.pop();\n        return topElement;\n    }\n\n    int top()\n    {\n        return primaryQueue.front();\n    }\n\n    bool isEmpty()\n    {\n        return primaryQueue.empty();\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nTreeNode *invertTree(TreeNode *rootNode)\n{\n    if(rootNode == NULL)\n    {\n        return NULL;\n    }\n    TreeNode *tempNode= rootNode->leftChild;\n    rootNode->leftChild= invertTree(rootNode->rightChild);\n    rootNode->rightChild= invertTree(tempNode);\n    return rootNode;\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nTreeNode *invertTree(TreeNode *rootNode)\n{\n    if(rootNode == NULL)\n    {\n        return NULL;\n    }\n    TreeNode *tempNode= rootNode->leftChild;\n    rootNode->leftChild= invertTree(rootNode->rightChild);\n    rootNode->rightChild= invertTree(tempNode);\n    return rootNode;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculate(string expression)\n{\n    int total = 0, currentNumber = 0, currentSign = 1;\n    stack<int> valueStack;\n\n    for (int i = 0; i < expression.size(); ++i)\n    {\n        char character = expression[i];\n        if (isdigit(character))\n        {\n            currentNumber = currentNumber * 10 + (character - '0');\n        }\n        else if (character == '+')\n        {\n            total += currentSign * currentNumber;\n            currentNumber = 0;\n            currentSign = 1;\n        }\n        else if (character == '-')\n        {\n            total += currentSign * currentNumber;\n            currentNumber = 0;\n            currentSign = -1;\n        }\n        else if (character == '(')\n        {\n            valueStack.push(total);\n            valueStack.push(currentSign);\n            total = 0;\n            currentSign = 1;\n        }\n        else if (character == ')')\n        {\n            total += currentSign * currentNumber;\n            currentNumber = 0;\n            total *= valueStack.top();\n            valueStack.pop();\n            total += valueStack.top();\n            valueStack.pop();\n        }\n    }\n    if (currentNumber)\n        total += currentSign * currentNumber;\n    return total;\n}",
    "output": "#include <bits/stdc++.h>\nint calculate(std::string expression)\n{\n    int total= 0, currentNumber= 0, currentSign= 1;\n    std::stack<int> valueStack;\n\n    for(char character : expression)\n    {\n        if(std::isdigit(character))\n        {\n            currentNumber= currentNumber * 10 + (character - '0');\n        }\n        else if(character == '+')\n        {\n            total+= currentSign * currentNumber;\n            currentNumber= 0;\n            currentSign= 1;\n        }\n        else if(character == '-')\n        {\n            total+= currentSign * currentNumber;\n            currentNumber= 0;\n            currentSign= -1;\n        }\n        else if(character == '(')\n        {\n            valueStack.push(total);\n            valueStack.push(currentSign);\n            total= 0;\n            currentSign= 1;\n        }\n        else if(character == ')')\n        {\n            total+= currentSign * currentNumber;\n            currentNumber= 0;\n            total*= valueStack.top();\n            valueStack.pop();\n            total+= valueStack.top();\n            valueStack.pop();\n        }\n    }\n    if(currentNumber)\n        total+= currentSign * currentNumber;\n    return total;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> findRanges(vector<int> &numberList)\n{\n    vector<string> rangeResults;\n    int listSize= numberList.size();\n    if(listSize == 0)\n        return rangeResults;\n\n    int rangeStart= numberList[0];\n    for(int index= 1; index < listSize; ++index)\n    {\n        if(numberList[index] > numberList[index - 1] + 1)\n        {\n            if(rangeStart == numberList[index - 1])\n                rangeResults.push_back(to_string(rangeStart));\n            else\n                rangeResults.push_back(to_string(rangeStart) + \"->\" + to_string(numberList[index - 1]));\n            rangeStart= numberList[index];\n        }\n    }\n\n    if(rangeStart == numberList[listSize - 1])\n        rangeResults.push_back(to_string(rangeStart));\n    else\n        rangeResults.push_back(to_string(rangeStart) + \"->\" + to_string(numberList[listSize - 1]));\n\n    return rangeResults;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> findRanges(std::vector<int> &numberList)\n{\n    std::vector<std::string> rangeResults;\n    int listSize= numberList.size();\n    if(listSize == 0)\n        return rangeResults;\n\n    int rangeStart= numberList[0];\n    for(int index= 1; index < listSize; ++index)\n    {\n        if(numberList[index] > numberList[index - 1] + 1)\n        {\n            if(rangeStart == numberList[index - 1])\n                rangeResults.push_back(std::to_string(rangeStart));\n            else\n                rangeResults.push_back(std::to_string(rangeStart) + \"->\" + std::to_string(numberList[index - 1]));\n            rangeStart= numberList[index];\n        }\n    }\n\n    if(rangeStart == numberList[listSize - 1])\n        rangeResults.push_back(std::to_string(rangeStart));\n    else\n        rangeResults.push_back(std::to_string(rangeStart) + \"->\" + std::to_string(numberList[listSize - 1]));\n\n    return rangeResults;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> majorityElement(vector<int> &inputNumbers)\n{\n    int totalElements = inputNumbers.size();\n    unordered_map<int, int> elementCount;\n    vector<int> majorityElements;\n\n    for (int i = 0; i < inputNumbers.size(); ++i)\n    {\n        int currentNumber = inputNumbers[i];\n        if (elementCount.find(currentNumber) == elementCount.end())\n        {\n            elementCount[currentNumber] = 1;\n        }\n        else\n        {\n            elementCount[currentNumber]++;\n        }\n        if (elementCount[currentNumber] > totalElements / 3 && find(majorityElements.begin(), majorityElements.end(), currentNumber) == majorityElements.end())\n        {\n            majorityElements.push_back(currentNumber);\n        }\n    }\n    return majorityElements;\n}",
    "output": "#include <bits/stdc++.h>\n// Include this for std::find\n\nstd::vector<int> majorityElement(std::vector<int> &inputNumbers)\n{\n    int totalElements = inputNumbers.size();\n    std::unordered_map<int, int> elementCount;\n    std::vector<int> majorityElements;\n\n    for(int currentNumber : inputNumbers)\n    {\n        if(elementCount.find(currentNumber) == elementCount.end())\n        {\n            elementCount[currentNumber] = 1;\n        }\n        else\n        {\n            elementCount[currentNumber]++;\n        }\n        if(elementCount[currentNumber] > totalElements / 3 && std::find(majorityElements.begin(), majorityElements.end(), currentNumber) == majorityElements.end())\n        {\n            majorityElements.push_back(currentNumber);\n        }\n    }\n    return majorityElements;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nint kthSmallest(TreeNode *root, int k)\n{\n    stack<TreeNode *> nodeStack;\n    TreeNode *currentNode= root;\n\n    while(true)\n    {\n        while(currentNode)\n        {\n            nodeStack.push(currentNode);\n            currentNode= currentNode->leftChild;\n        }\n\n        currentNode= nodeStack.top();\n        nodeStack.pop();\n\n        if(--k == 0)\n            return currentNode->value;\n\n        currentNode= currentNode->rightChild;\n    }\n}",
    "output": "#include <bits/stdc++.h>\nclass TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nint kthSmallest(TreeNode *root, int k)\n{\n    std::stack<TreeNode *> nodeStack;\n    TreeNode *currentNode = root;\n\n    while(true)\n    {\n        while(currentNode)\n        {\n            nodeStack.push(currentNode);\n            currentNode = currentNode->leftChild;\n        }\n\n        currentNode = nodeStack.top();\n        nodeStack.pop();\n\n        if(--k == 0)\n            return currentNode->value;\n\n        currentNode = currentNode->rightChild;\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "bool isPowerOfTwo(int number)\n{\n    if(number <= 0)\n    {\n        return false;\n    }\n    return (number & (number - 1)) == 0;\n}",
    "output": "bool isPowerOfTwo(int number)\n{\n    if(number <= 0)\n    {\n        return false;\n    }\n    return (number & (number - 1)) == 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass MyQueue\n{\n  public:\n    stack<int> inputStack, outputStack;\n\n    MyQueue()\n    {\n    }\n\n    void push(int element)\n    {\n        inputStack.push(element);\n    }\n\n    int pop()\n    {\n        if(outputStack.empty())\n        {\n            while(!inputStack.empty())\n            {\n                outputStack.push(inputStack.top());\n                inputStack.pop();\n            }\n        }\n        int topElement= outputStack.top();\n        outputStack.pop();\n        return topElement;\n    }\n\n    int peek()\n    {\n        if(outputStack.empty())\n        {\n            while(!inputStack.empty())\n            {\n                outputStack.push(inputStack.top());\n                inputStack.pop();\n            }\n        }\n        return outputStack.top();\n    }\n\n    bool empty()\n    {\n        return inputStack.empty() && outputStack.empty();\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass MyQueue\n{\n  public:\n    std::stack<int> inputStack, outputStack;\n\n    MyQueue()\n    {\n    }\n\n    void push(int element)\n    {\n        inputStack.push(element);\n    }\n\n    int pop()\n    {\n        if(outputStack.empty())\n        {\n            while(!inputStack.empty())\n            {\n                outputStack.push(inputStack.top());\n                inputStack.pop();\n            }\n        }\n        int topElement= outputStack.top();\n        outputStack.pop();\n        return topElement;\n    }\n\n    int peek()\n    {\n        if(outputStack.empty())\n        {\n            while(!inputStack.empty())\n            {\n                outputStack.push(inputStack.top());\n                inputStack.pop();\n            }\n        }\n        return outputStack.top();\n    }\n\n    bool empty()\n    {\n        return inputStack.empty() && outputStack.empty();\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int countDigitOne(int number)\n{\n    int totalCount= 0;\n    for(long long digitPlace= 1; digitPlace <= number; digitPlace*= 10)\n    {\n        int divider= digitPlace * 10;\n        totalCount+= (number / divider) * digitPlace + min(max(number % divider - digitPlace + 1, 0LL), digitPlace);\n    }\n    return totalCount;\n}",
    "output": "int countDigitOne(int number)\n{\n    int totalCount= 0;\n    for(long long digitPlace= 1; digitPlace <= number; digitPlace*= 10)\n    {\n        int divider= digitPlace * 10;\n        totalCount+= (number / divider) * digitPlace + min(max(number % divider - digitPlace + 1, 0LL), digitPlace);\n    }\n    return totalCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nbool isPalindrome(ListNode *head)\n{\n    if(!head || !head->next)\n        return true;\n\n    ListNode *fastPointer= head, *slowPointer= head, *previousNode= NULL;\n    while(fastPointer && fastPointer->next)\n    {\n        fastPointer= fastPointer->next->next;\n        ListNode *tempNode= slowPointer->next;\n        slowPointer->next= previousNode;\n        previousNode= slowPointer;\n        slowPointer= tempNode;\n    }\n\n    if(fastPointer)\n        slowPointer= slowPointer->next;\n\n    while(previousNode && previousNode->value == slowPointer->value)\n    {\n        previousNode= previousNode->next;\n        slowPointer= slowPointer->next;\n    }\n\n    return previousNode == NULL;\n}",
    "output": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nbool isPalindrome(ListNode *head)\n{\n    if(!head || !head->next)\n        return true;\n\n    ListNode *fastPointer= head, *slowPointer= head, *previousNode= NULL;\n    while(fastPointer && fastPointer->next)\n    {\n        fastPointer= fastPointer->next->next;\n        ListNode *tempNode= slowPointer->next;\n        slowPointer->next= previousNode;\n        previousNode= slowPointer;\n        slowPointer= tempNode;\n    }\n\n    if(fastPointer)\n        slowPointer= slowPointer->next;\n\n    while(previousNode && previousNode->value == slowPointer->value)\n    {\n        previousNode= previousNode->next;\n        slowPointer= slowPointer->next;\n    }\n\n    return previousNode == NULL;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nTreeNode *findLowestCommonAncestor(TreeNode *root, TreeNode *firstNode, TreeNode *secondNode)\n{\n    if(root == NULL || root == firstNode || root == secondNode)\n    {\n        return root;\n    }\n\n    TreeNode *leftAncestor= findLowestCommonAncestor(root->leftChild, firstNode, secondNode);\n    TreeNode *rightAncestor= findLowestCommonAncestor(root->rightChild, firstNode, secondNode);\n\n    if(leftAncestor != NULL && rightAncestor != NULL)\n    {\n        return root;\n    }\n    else\n    {\n        return leftAncestor != NULL ? leftAncestor : rightAncestor;\n    }\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nTreeNode *findLowestCommonAncestor(TreeNode *root, TreeNode *firstNode, TreeNode *secondNode)\n{\n    if(root == NULL || root == firstNode || root == secondNode)\n    {\n        return root;\n    }\n\n    TreeNode *leftAncestor= findLowestCommonAncestor(root->leftChild, firstNode, secondNode);\n    TreeNode *rightAncestor= findLowestCommonAncestor(root->rightChild, firstNode, secondNode);\n\n    if(leftAncestor != NULL && rightAncestor != NULL)\n    {\n        return root;\n    }\n    else\n    {\n        return leftAncestor != NULL ? leftAncestor : rightAncestor;\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nTreeNode *findLowestCommonAncestor(TreeNode *rootNode, TreeNode *firstNode, TreeNode *secondNode)\n{\n    if(!rootNode || rootNode == firstNode || rootNode == secondNode)\n        return rootNode;\n    TreeNode *leftAncestor= findLowestCommonAncestor(rootNode->leftChild, firstNode, secondNode);\n    TreeNode *rightAncestor= findLowestCommonAncestor(rootNode->rightChild, firstNode, secondNode);\n    return !leftAncestor ? rightAncestor : (!rightAncestor ? leftAncestor : rootNode);\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nTreeNode *findLowestCommonAncestor(TreeNode *rootNode, TreeNode *firstNode, TreeNode *secondNode)\n{\n    if(!rootNode || rootNode == firstNode || rootNode == secondNode)\n        return rootNode;\n    TreeNode *leftAncestor= findLowestCommonAncestor(rootNode->leftChild, firstNode, secondNode);\n    TreeNode *rightAncestor= findLowestCommonAncestor(rootNode->rightChild, firstNode, secondNode);\n    return !leftAncestor ? rightAncestor : (!rightAncestor ? leftAncestor : rootNode);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "void deleteNode(ListNode *targetNode)\n{\n    ListNode *nextNode= targetNode->next;\n    *targetNode= *nextNode;\n    delete nextNode;\n}",
    "output": "void deleteNode(ListNode *targetNode)\n{\n    ListNode *nextNode= targetNode->next;\n    *targetNode= *nextNode;\n    delete nextNode;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> productExceptSelf(vector<int> &inputNumbers)\n{\n    int size= inputNumbers.size();\n    vector<int> productArray(size, 1);\n\n    int leftProduct= 1;\n    for(int index= 0; index < size; index++)\n    {\n        productArray[index]*= leftProduct;\n        leftProduct*= inputNumbers[index];\n    }\n\n    int rightProduct= 1;\n    for(int index= size - 1; index >= 0; index--)\n    {\n        productArray[index]*= rightProduct;\n        rightProduct*= inputNumbers[index];\n    }\n\n    return productArray;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> productExceptSelf(std::vector<int> &inputNumbers)\n{\n    int size= inputNumbers.size();\n    std::vector<int> productArray(size, 1);\n\n    int leftProduct= 1;\n    for(int index= 0; index < size; index++)\n    {\n        productArray[index]*= leftProduct;\n        leftProduct*= inputNumbers[index];\n    }\n\n    int rightProduct= 1;\n    for(int index= size - 1; index >= 0; index--)\n    {\n        productArray[index]*= rightProduct;\n        rightProduct*= inputNumbers[index];\n    }\n\n    return productArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> maxSlidingWindow(vector<int> &inputNumbers, int windowSize)\n{\n    vector<int> maxValues;\n    deque<int> indexDeque;\n\n    for(int currentIndex= 0; currentIndex < inputNumbers.size(); currentIndex++)\n    {\n        while(!indexDeque.empty() && indexDeque.front() < currentIndex - windowSize + 1)\n        {\n            indexDeque.pop_front();\n        }\n\n        while(!indexDeque.empty() && inputNumbers[indexDeque.back()] < inputNumbers[currentIndex])\n        {\n            indexDeque.pop_back();\n        }\n\n        indexDeque.push_back(currentIndex);\n\n        if(currentIndex >= windowSize - 1)\n        {\n            maxValues.push_back(inputNumbers[indexDeque.front()]);\n        }\n    }\n\n    return maxValues;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> maxSlidingWindow(std::vector<int> &inputNumbers, int windowSize)\n{\n    std::vector<int> maxValues;\n    std::deque<int> indexDeque;\n\n    for(int currentIndex= 0; currentIndex < inputNumbers.size(); currentIndex++)\n    {\n        while(!indexDeque.empty() && indexDeque.front() < currentIndex - windowSize + 1)\n        {\n            indexDeque.pop_front();\n        }\n\n        while(!indexDeque.empty() && inputNumbers[indexDeque.back()] < inputNumbers[currentIndex])\n        {\n            indexDeque.pop_back();\n        }\n\n        indexDeque.push_back(currentIndex);\n\n        if(currentIndex >= windowSize - 1)\n        {\n            maxValues.push_back(inputNumbers[indexDeque.front()]);\n        }\n    }\n\n    return maxValues;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool searchMatrix(vector<vector<int>> &matrix, int target)\n{\n    int lastRow= matrix.size() - 1, currentCol= 0;\n    while(lastRow >= 0 && currentCol < matrix[0].size())\n    {\n        if(matrix[lastRow][currentCol] > target)\n        {\n            lastRow--;\n        }\n        else if(matrix[lastRow][currentCol] < target)\n        {\n            currentCol++;\n        }\n        else\n        {\n            return true;\n        }\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool searchMatrix(std::vector<std::vector<int>> &matrix, int target)\n{\n    int lastRow= matrix.size() - 1, currentCol= 0;\n    while(lastRow >= 0 && currentCol < matrix[0].size())\n    {\n        if(matrix[lastRow][currentCol] > target)\n        {\n            lastRow--;\n        }\n        else if(matrix[lastRow][currentCol] < target)\n        {\n            currentCol++;\n        }\n        else\n        {\n            return true;\n        }\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> computeDifferentWays(string expression)\n{\n    vector<int> result;\n    for(int index = 0; index < expression.size(); index++)\n    {\n        char operatorChar = expression[index];\n        if(operatorChar == '+' || operatorChar == '-' || operatorChar == '*')\n        {\n            auto leftResults = computeDifferentWays(expression.substr(0, index));\n            auto rightResults = computeDifferentWays(expression.substr(index + 1));\n            for(int j = 0; j < leftResults.size(); j++)\n            {\n                int leftValue = leftResults[j];\n                for(int k = 0; k < rightResults.size(); k++)\n                {\n                    int rightValue = rightResults[k];\n                    if(operatorChar == '+')\n                        result.push_back(leftValue + rightValue);\n                    else if(operatorChar == '-')\n                        result.push_back(leftValue - rightValue);\n                    else if(operatorChar == '*')\n                        result.push_back(leftValue * rightValue);\n                }\n            }\n        }\n    }\n    if(result.empty())\n        result.push_back(stoi(expression));\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> computeDifferentWays(std::string expression)\n{\n    std::vector<int> result;\n    for(int index= 0; index < expression.size(); index++)\n    {\n        char operatorChar= expression[index];\n        if(operatorChar == '+' || operatorChar == '-' || operatorChar == '*')\n        {\n            auto leftResults= computeDifferentWays(expression.substr(0, index));\n            auto rightResults= computeDifferentWays(expression.substr(index + 1));\n            for(int leftValue : leftResults)\n            {\n                for(int rightValue : rightResults)\n                {\n                    if(operatorChar == '+')\n                        result.push_back(leftValue + rightValue);\n                    else if(operatorChar == '-')\n                        result.push_back(leftValue - rightValue);\n                    else if(operatorChar == '*')\n                        result.push_back(leftValue * rightValue);\n                }\n            }\n        }\n    }\n    if(result.empty())\n        result.push_back(std::stoi(expression));\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isAnagram(string sourceString, string targetString)\n{\n    if(sourceString.size() != targetString.size())\n        return false;\n\n    unordered_map<char, int> characterCounts;\n    for (int i = 0; i < sourceString.size(); ++i)\n        characterCounts[sourceString[i]]++;\n\n    for (int i = 0; i < targetString.size(); ++i)\n    {\n        char character = targetString[i];\n        if(characterCounts[character] == 0)\n            return false;\n        characterCounts[character]--;\n    }\n\n    return true;\n}",
    "output": "bool isAnagram(std::string sourceString, std::string targetString)\n{\n    if(sourceString.size() != targetString.size())\n        return false;\n\n    std::unordered_map<char, int> characterCounts;\n    for(char character : sourceString)\n        characterCounts[character]++;\n\n    for(char character : targetString)\n    {\n        if(characterCounts[character] == 0)\n            return false;\n        characterCounts[character]--;\n    }\n\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestDistance(vector<string> wordsDictionary, string firstWord, string secondWord)\n{\n    int firstWordIndex= -1, secondWordIndex= -1, minimumDistance= INT_MAX;\n    for(int i= 0; i < wordsDictionary.size(); i++)\n    {\n        if(wordsDictionary[i] == firstWord)\n            firstWordIndex= i;\n        if(wordsDictionary[i] == secondWord)\n            secondWordIndex= i;\n        if(firstWordIndex != -1 && secondWordIndex != -1)\n            minimumDistance= min(minimumDistance, abs(firstWordIndex - secondWordIndex));\n    }\n    return minimumDistance;\n}",
    "output": "#include <bits/stdc++.h>\nint shortestDistance(std::vector<std::string> wordsDictionary, std::string firstWord, std::string secondWord)\n{\n    int firstWordIndex= -1, secondWordIndex= -1, minimumDistance= INT_MAX;\n    for(int i= 0; i < wordsDictionary.size(); i++)\n    {\n        if(wordsDictionary[i] == firstWord)\n            firstWordIndex= i;\n        if(wordsDictionary[i] == secondWord)\n            secondWordIndex= i;\n        if(firstWordIndex != -1 && secondWordIndex != -1)\n            minimumDistance= std::min(minimumDistance, std::abs(firstWordIndex - secondWordIndex));\n    }\n    return minimumDistance;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass WordDistance\n{\n  public:\n    WordDistance(vector<string> &wordsDictionary)\n    {\n        for(int index= 0; index < wordsDictionary.size(); ++index)\n        {\n            wordIndexMap[wordsDictionary[index]].push_back(index);\n        }\n    }\n\n    int shortest(string firstWord, string secondWord)\n    {\n        vector<int> firstWordIndexes= wordIndexMap[firstWord];\n        vector<int> secondWordIndexes= wordIndexMap[secondWord];\n        int firstIndex= 0, secondIndex= 0, minimumDistance= INT_MAX;\n\n        while(firstIndex < firstWordIndexes.size() && secondIndex < secondWordIndexes.size())\n        {\n            minimumDistance= min(minimumDistance, abs(firstWordIndexes[firstIndex] - secondWordIndexes[secondIndex]));\n            if(firstWordIndexes[firstIndex] < secondWordIndexes[secondIndex])\n            {\n                ++firstIndex;\n            }\n            else\n            {\n                ++secondIndex;\n            }\n        }\n        return minimumDistance;\n    }\n\n  private:\n    unordered_map<string, vector<int>> wordIndexMap;\n};",
    "output": "#include <bits/stdc++.h>\nclass WordDistance\n{\n  public:\n    WordDistance(std::vector<std::string> &wordsDictionary)\n    {\n        for(int index= 0; index < wordsDictionary.size(); ++index)\n        {\n            wordIndexMap[wordsDictionary[index]].push_back(index);\n        }\n    }\n\n    int shortest(std::string firstWord, std::string secondWord)\n    {\n        std::vector<int> firstWordIndexes= wordIndexMap[firstWord];\n        std::vector<int> secondWordIndexes= wordIndexMap[secondWord];\n        int firstIndex= 0, secondIndex= 0, minimumDistance= INT_MAX;\n\n        while(firstIndex < firstWordIndexes.size() && secondIndex < secondWordIndexes.size())\n        {\n            minimumDistance= std::min(minimumDistance, abs(firstWordIndexes[firstIndex] - secondWordIndexes[secondIndex]));\n            if(firstWordIndexes[firstIndex] < secondWordIndexes[secondIndex])\n            {\n                ++firstIndex;\n            }\n            else\n            {\n                ++secondIndex;\n            }\n        }\n        return minimumDistance;\n    }\n\n  private:\n    std::unordered_map<std::string, std::vector<int>> wordIndexMap;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestDistance(vector<string> &wordsDictionary, string firstWord, string secondWord)\n{\n    int firstWordIndex= -1, secondWordIndex= -1, minimumDistance= numeric_limits<int>::max();\n    for(int i= 0; i < wordsDictionary.size(); ++i)\n    {\n        if(wordsDictionary[i] == firstWord)\n        {\n            firstWordIndex= i;\n        }\n        if(wordsDictionary[i] == secondWord)\n        {\n            secondWordIndex= i;\n        }\n        if(firstWordIndex != -1 && secondWordIndex != -1)\n        {\n            minimumDistance= min(minimumDistance, abs(firstWordIndex - secondWordIndex));\n        }\n    }\n    return minimumDistance;\n}",
    "output": "#include <bits/stdc++.h>\nint shortestDistance(std::vector<std::string> &wordsDictionary, std::string firstWord, std::string secondWord)\n{\n    int firstWordIndex= -1, secondWordIndex= -1, minimumDistance= std::numeric_limits<int>::max();\n    for(int i= 0; i < wordsDictionary.size(); ++i)\n    {\n        if(wordsDictionary[i] == firstWord)\n        {\n            firstWordIndex= i;\n        }\n        if(wordsDictionary[i] == secondWord)\n        {\n            secondWordIndex= i;\n        }\n        if(firstWordIndex != -1 && secondWordIndex != -1)\n        {\n            minimumDistance= std::min(minimumDistance, std::abs(firstWordIndex - secondWordIndex));\n        }\n    }\n    return minimumDistance;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isStrobogrammatic(string number)\n{\n    unordered_map<char, char> strobogrammaticLookup{{'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}};\n    int leftIndex= 0, rightIndex= number.size() - 1;\n    while(leftIndex <= rightIndex)\n    {\n        if(strobogrammaticLookup[number[leftIndex]] != number[rightIndex])\n            return false;\n        leftIndex++;\n        rightIndex--;\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isStrobogrammatic(std::string number)\n{\n    std::unordered_map<char, char> strobogrammaticLookup{{'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}};\n    int leftIndex= 0, rightIndex= number.size() - 1;\n    while(leftIndex <= rightIndex)\n    {\n        if(strobogrammaticLookup[number[leftIndex]] != number[rightIndex])\n            return false;\n        leftIndex++;\n        rightIndex--;\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> findStrobogrammatic(int length)\n{\n    return generateStrobogrammatic(length, length);\n}\n\nvector<string> generateStrobogrammatic(int currentLength, int totalLength)\n{\n    if(currentLength == 0)\n        return {\"\"};\n    if(currentLength == 1)\n        return {\"0\", \"1\", \"8\"};\n\n    vector<string> previousList = generateStrobogrammatic(currentLength - 2, totalLength);\n    vector<string> result;\n\n    for(int i = 0; i < previousList.size(); i++)\n    {\n        string strobogrammaticString = previousList[i];\n\n        if(currentLength != totalLength)\n            result.push_back(\"0\" + strobogrammaticString + \"0\");\n\n        result.push_back(\"1\" + strobogrammaticString + \"1\");\n        result.push_back(\"6\" + strobogrammaticString + \"9\");\n        result.push_back(\"8\" + strobogrammaticString + \"8\");\n        result.push_back(\"9\" + strobogrammaticString + \"6\");\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> findStrobogrammatic(int length)\n{\n    return generateStrobogrammatic(length, length);\n}\n\nstd::vector<std::string> generateStrobogrammatic(int currentLength, int totalLength)\n{\n    if(currentLength == 0)\n        return {\"\"};\n    if(currentLength == 1)\n        return {\"0\", \"1\", \"8\"};\n\n    std::vector<std::string> previousList= generateStrobogrammatic(currentLength - 2, totalLength);\n    std::vector<std::string> result;\n\n    for(int i= 0; i < previousList.size(); i++)\n    {\n        std::string strobogrammaticString= previousList[i];\n\n        if(currentLength != totalLength)\n            result.push_back(\"0\" + strobogrammaticString + \"0\");\n\n        result.push_back(\"1\" + strobogrammaticString + \"1\");\n        result.push_back(\"6\" + strobogrammaticString + \"9\");\n        result.push_back(\"8\" + strobogrammaticString + \"8\");\n        result.push_back(\"9\" + strobogrammaticString + \"6\");\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countStrobogrammaticNumbersInRange(string lowerBound, string upperBound)\n{\n    int totalCount = 0;\n    for (int currentLength = lowerBound.size(); currentLength <= upperBound.size(); ++currentLength)\n    {\n        totalCount += generateStrobogrammatic(currentLength, currentLength) <= upperBound ? \n                      generateStrobogrammatic(currentLength, currentLength) >= lowerBound ? 1 : 0 : 0;\n    }\n    return totalCount;\n}\n\nstring generateStrobogrammatic(int currentLength, int maxLength)\n{\n    if (currentLength == 0)\n        return \"\";\n    if (currentLength == 1)\n        return \"0 1 8\";\n    if (maxLength == 0)\n        return \"11 69 88 96\";\n    string result = \"\";\n    string strobogrammaticNumbers = generateStrobogrammatic(currentLength - 2, maxLength);\n    \n    // Using traditional for loop instead of range-based for loop\n    for (int i = 0; i < strobogrammaticNumbers.size(); ++i) \n    {\n        // Extract each strobogrammatic number separated by space\n        string strobogrammaticNumber;\n        while (i < strobogrammaticNumbers.size() && strobogrammaticNumbers[i] != ' ') {\n            strobogrammaticNumber += strobogrammaticNumbers[i];\n            i++;\n        }\n        // Skip the space\n        if (i < strobogrammaticNumbers.size())\n            i++;\n        \n        if (currentLength != maxLength)\n            result += strobogrammaticNumber + \"0\" + strobogrammaticNumber + \" \";\n        result += strobogrammaticNumber + \"1\" + strobogrammaticNumber + \" \";\n        result += strobogrammaticNumber + \"6\" + strobogrammaticNumber + \" \";\n        result += strobogrammaticNumber + \"8\" + strobogrammaticNumber + \" \";\n        result += strobogrammaticNumber + \"9\" + strobogrammaticNumber + \" \";\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nint countStrobogrammaticNumbersInRange(std::string lowerBound, std::string upperBound)\n{\n    int totalCount= 0;\n    for(int currentLength= lowerBound.size(); currentLength <= upperBound.size(); ++currentLength)\n    {\n        totalCount+= generateStrobogrammatic(currentLength, currentLength) <= upperBound ? generateStrobogrammatic(currentLength, currentLength) >= lowerBound ? 1 : 0 : 0;\n    }\n    return totalCount;\n}\n\nstd::string generateStrobogrammatic(int currentLength, int maxLength)\n{\n    if(currentLength == 0)\n        return \"\";\n    if(currentLength == 1)\n        return \"0 1 8\";\n    if(maxLength == 0)\n        return \"11 69 88 96\";\n    std::string result= \"\";\n    for(auto strobogrammaticNumber : generateStrobogrammatic(currentLength - 2, maxLength))\n    {\n        if(currentLength != maxLength)\n            result+= strobogrammaticNumber + \"0\" + strobogrammaticNumber;\n        result+= strobogrammaticNumber + \"1\" + strobogrammaticNumber;\n        result+= strobogrammaticNumber + \"6\" + strobogrammaticNumber;\n        result+= strobogrammaticNumber + \"8\" + strobogrammaticNumber;\n        result+= strobogrammaticNumber + \"9\" + strobogrammaticNumber;\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<string>> groupStrings(vector<string> &inputStrings)\n{\n    unordered_map<string, vector<string>> groupedStringsMap;\n\n    for (int i = 0; i < inputStrings.size(); ++i)\n    {\n        const auto &currentString = inputStrings[i];\n        string keyPattern;\n        for (int j = 0; j < currentString.size(); ++j)\n        {\n            char character = currentString[j];\n            keyPattern += to_string((character - currentString[0] + 26) % 26) + \",\";\n        }\n        groupedStringsMap[keyPattern].push_back(currentString);\n    }\n\n    vector<vector<string>> resultGroups;\n    for (auto &keyValue : groupedStringsMap)\n    {\n        resultGroups.push_back(keyValue.second);\n    }\n\n    return resultGroups;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<std::string>> groupStrings(std::vector<std::string> &inputStrings)\n{\n    std::unordered_map<std::string, std::vector<std::string>> groupedStringsMap;\n\n    for(const auto &currentString : inputStrings)\n    {\n        std::string keyPattern;\n        for(char character : currentString)\n        {\n            keyPattern+= std::to_string((character - currentString[0] + 26) % 26) + \",\";\n        }\n        groupedStringsMap[keyPattern].push_back(currentString);\n    }\n\n    std::vector<std::vector<std::string>> resultGroups;\n    for(auto &keyValue : groupedStringsMap)\n    {\n        resultGroups.push_back(keyValue.second);\n    }\n\n    return resultGroups;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nclass Solution\n{\n  public:\n    int countUnivalSubtrees(TreeNode *rootNode)\n    {\n        int subtreeCount= 0;\n        helper(rootNode, subtreeCount);\n        return subtreeCount;\n    }\n\n    bool helper(TreeNode *currentNode, int &subtreeCount)\n    {\n        if(!currentNode)\n            return true;\n\n        bool isLeftUnival= helper(currentNode->leftChild, subtreeCount);\n        bool isRightUnival= helper(currentNode->rightChild, subtreeCount);\n\n        if(isLeftUnival && isRightUnival)\n        {\n            if(currentNode->leftChild && currentNode->value != currentNode->leftChild->value)\n                return false;\n            if(currentNode->rightChild && currentNode->value != currentNode->rightChild->value)\n                return false;\n            subtreeCount++;\n            return true;\n        }\n\n        return false;\n    }\n};",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nclass Solution\n{\n  public:\n    int countUnivalSubtrees(TreeNode *rootNode)\n    {\n        int subtreeCount= 0;\n        helper(rootNode, subtreeCount);\n        return subtreeCount;\n    }\n\n    bool helper(TreeNode *currentNode, int &subtreeCount)\n    {\n        if(!currentNode)\n            return true;\n\n        bool isLeftUnival= helper(currentNode->leftChild, subtreeCount);\n        bool isRightUnival= helper(currentNode->rightChild, subtreeCount);\n\n        if(isLeftUnival && isRightUnival)\n        {\n            if(currentNode->leftChild && currentNode->value != currentNode->leftChild->value)\n                return false;\n            if(currentNode->rightChild && currentNode->value != currentNode->rightChild->value)\n                return false;\n            subtreeCount++;\n            return true;\n        }\n\n        return false;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Vector2D\n{\n  public:\n    vector<vector<int>>::iterator rowIterator, rowEndIterator;\n    int columnIndex= 0;\n\n    Vector2D(vector<vector<int>> &vec)\n    {\n        rowIterator= vec.begin();\n        rowEndIterator= vec.end();\n    }\n\n    int next()\n    {\n        hasNext();\n        return (*rowIterator)[columnIndex++];\n    }\n\n    bool hasNext()\n    {\n        while(rowIterator != rowEndIterator && columnIndex == (*rowIterator).size())\n        {\n            ++rowIterator;\n            columnIndex= 0;\n        }\n        return rowIterator != rowEndIterator;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Vector2D\n{\n  public:\n    std::vector<std::vector<int>>::iterator rowIterator, rowEndIterator;\n    int columnIndex= 0;\n\n    Vector2D(std::vector<std::vector<int>> &vec)\n    {\n        rowIterator= vec.begin();\n        rowEndIterator= vec.end();\n    }\n\n    int next()\n    {\n        hasNext();\n        return (*rowIterator)[columnIndex++];\n    }\n\n    bool hasNext()\n    {\n        while(rowIterator != rowEndIterator && columnIndex == (*rowIterator).size())\n        {\n            ++rowIterator;\n            columnIndex= 0;\n        }\n        return rowIterator != rowEndIterator;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canAttendMeetings(vector<vector<int>> &meetingIntervals)\n{\n    sort(meetingIntervals.begin(), meetingIntervals.end());\n\n    for(int currentIndex= 1; currentIndex < meetingIntervals.size(); ++currentIndex)\n    {\n        if(meetingIntervals[currentIndex][0] < meetingIntervals[currentIndex - 1][1])\n            return false;\n    }\n\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool canAttendMeetings(std::vector<std::vector<int>> &meetingIntervals)\n{\n    std::sort(meetingIntervals.begin(), meetingIntervals.end());\n\n    for(int currentIndex= 1; currentIndex < meetingIntervals.size(); ++currentIndex)\n    {\n        if(meetingIntervals[currentIndex][0] < meetingIntervals[currentIndex - 1][1])\n            return false;\n    }\n\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minMeetingRooms(vector<vector<int>> &meetingIntervals)\n{\n    if(meetingIntervals.empty())\n        return 0;\n\n    sort(meetingIntervals.begin(), meetingIntervals.end(),\n         [](const vector<int> &startEndA, const vector<int> &startEndB)\n         { return startEndA[0] < startEndB[0]; });\n\n    priority_queue<int, vector<int>, greater<int>> minHeap;\n    minHeap.push(meetingIntervals[0][1]);\n\n    for(int currentIntervalIndex= 1; currentIntervalIndex < meetingIntervals.size(); currentIntervalIndex++)\n    {\n        if(meetingIntervals[currentIntervalIndex][0] >= minHeap.top())\n        {\n            minHeap.pop();\n        }\n        minHeap.push(meetingIntervals[currentIntervalIndex][1]);\n    }\n\n    return minHeap.size();\n}",
    "output": "#include <bits/stdc++.h>\nint minMeetingRooms(std::vector<std::vector<int>> &meetingIntervals)\n{\n    if(meetingIntervals.empty())\n        return 0;\n\n    std::sort(meetingIntervals.begin(), meetingIntervals.end(),\n              [](const std::vector<int> &startEndA, const std::vector<int> &startEndB)\n              { return startEndA[0] < startEndB[0]; });\n\n    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;\n    minHeap.push(meetingIntervals[0][1]);\n\n    for(int currentIntervalIndex= 1; currentIntervalIndex < meetingIntervals.size(); currentIntervalIndex++)\n    {\n        if(meetingIntervals[currentIntervalIndex][0] >= minHeap.top())\n        {\n            minHeap.pop();\n        }\n        minHeap.push(meetingIntervals[currentIntervalIndex][1]);\n    }\n\n    return minHeap.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid findFactors(int targetNumber, int startFactor, vector<int> &currentPath, vector<vector<int>> &factorCombinations)\n{\n    if(targetNumber == 1)\n    {\n        if(currentPath.size() > 1)\n        {\n            factorCombinations.push_back(currentPath);\n        }\n        return;\n    }\n\n    for(int i = startFactor; i <= targetNumber; ++i)\n    {\n        if(targetNumber % i == 0)\n        {\n            currentPath.push_back(i);\n            findFactors(targetNumber / i, i, currentPath, factorCombinations);\n            currentPath.pop_back();\n        }\n    }\n}\n\nvector<vector<int>> getFactors(int targetNumber)\n{\n    vector<vector<int>> factorCombinations;\n    vector<int> currentPath;\n    findFactors(targetNumber, 2, currentPath, factorCombinations);\n    return factorCombinations;\n}",
    "output": "#include <bits/stdc++.h>\nvoid findFactors(int targetNumber, int startFactor, std::vector<int> &currentPath, std::vector<std::vector<int>> &factorCombinations)\n{\n    if(targetNumber == 1)\n    {\n        if(currentPath.size() > 1)\n        {\n            factorCombinations.push_back(currentPath);\n        }\n        return;\n    }\n\n    for(int i= startFactor; i <= targetNumber; ++i)\n    {\n        if(targetNumber % i == 0)\n        {\n            currentPath.push_back(i);\n            findFactors(targetNumber / i, i, currentPath, factorCombinations);\n            currentPath.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<int>> getFactors(int targetNumber)\n{\n    std::vector<std::vector<int>> factorCombinations;\n    std::vector<int> currentPath;\n    findFactors(targetNumber, 2, currentPath, factorCombinations);\n    return factorCombinations;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For INT_MIN\nusing namespace std;\n\nbool isValidPreorder(vector<int> &preorderSequence)\n{\n    stack<int> nodeStack;\n    int lowerBound = INT_MIN;\n    for (int i = 0; i < preorderSequence.size(); ++i)\n    {\n        int currentNumber = preorderSequence[i];\n        if (currentNumber < lowerBound)\n            return false;\n        while (!nodeStack.empty() && currentNumber > nodeStack.top())\n        {\n            lowerBound = nodeStack.top();\n            nodeStack.pop();\n        }\n        nodeStack.push(currentNumber);\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isValidPreorder(std::vector<int> &preorderSequence)\n{\n    std::stack<int> nodeStack;\n    int lowerBound = std::numeric_limits<int>::min();\n    for(int currentNumber : preorderSequence)\n    {\n        if(currentNumber < lowerBound)\n            return false;\n        while(!nodeStack.empty() && currentNumber > nodeStack.top())\n        {\n            lowerBound = nodeStack.top();\n            nodeStack.pop();\n        }\n        nodeStack.push(currentNumber);\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinCost(vector<vector<int>> &costMatrix)\n{\n    if(costMatrix.empty())\n        return 0;\n    for(int houseIndex= 1; houseIndex < costMatrix.size(); ++houseIndex)\n    {\n        costMatrix[houseIndex][0]+= min(costMatrix[houseIndex - 1][1], costMatrix[houseIndex - 1][2]);\n        costMatrix[houseIndex][1]+= min(costMatrix[houseIndex - 1][0], costMatrix[houseIndex - 1][2]);\n        costMatrix[houseIndex][2]+= min(costMatrix[houseIndex - 1][0], costMatrix[houseIndex - 1][1]);\n    }\n    return min(costMatrix.back()[0], min(costMatrix.back()[1], costMatrix.back()[2]));\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMinCost(std::vector<std::vector<int>> &costMatrix)\n{\n    if(costMatrix.empty())\n        return 0;\n    for(int houseIndex= 1; houseIndex < costMatrix.size(); ++houseIndex)\n    {\n        costMatrix[houseIndex][0]+= std::min(costMatrix[houseIndex - 1][1], costMatrix[houseIndex - 1][2]);\n        costMatrix[houseIndex][1]+= std::min(costMatrix[houseIndex - 1][0], costMatrix[houseIndex - 1][2]);\n        costMatrix[houseIndex][2]+= std::min(costMatrix[houseIndex - 1][0], costMatrix[houseIndex - 1][1]);\n    }\n    return std::min(costMatrix.back()[0], std::min(costMatrix.back()[1], costMatrix.back()[2]));\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nvector<string> getBinaryTreePaths(TreeNode *rootNode)\n{\n    vector<string> paths;\n    if(!rootNode)\n        return paths;\n    if(!rootNode->leftChild && !rootNode->rightChild)\n    {\n        paths.push_back(to_string(rootNode->value));\n        return paths;\n    }\n    \n    // First for loop modified to traditional for loop\n    vector<string> leftPaths = getBinaryTreePaths(rootNode->leftChild);\n    for (int i = 0; i < leftPaths.size(); ++i)\n    {\n        paths.push_back(to_string(rootNode->value) + \"->\" + leftPaths[i]);\n    }\n    \n    // Second for loop modified to traditional for loop\n    vector<string> rightPaths = getBinaryTreePaths(rootNode->rightChild);\n    for (int i = 0; i < rightPaths.size(); ++i)\n    {\n        paths.push_back(to_string(rootNode->value) + \"->\" + rightPaths[i]);\n    }\n\n    return paths;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nstd::vector<std::string> getBinaryTreePaths(TreeNode *rootNode)\n{\n    std::vector<std::string> paths;\n    if(!rootNode)\n        return paths;\n    if(!rootNode->leftChild && !rootNode->rightChild)\n    {\n        paths.push_back(std::to_string(rootNode->value));\n        return paths;\n    }\n    for(const std::string &path : getBinaryTreePaths(rootNode->leftChild))\n    {\n        paths.push_back(std::to_string(rootNode->value) + \"->\" + path);\n    }\n    for(const std::string &path : getBinaryTreePaths(rootNode->rightChild))\n    {\n        paths.push_back(std::to_string(rootNode->value) + \"->\" + path);\n    }\n    return paths;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int addDigits(int number)\n{\n    return 1 + (number - 1) % 9;\n}",
    "output": "int addDigits(int number)\n{\n    return 1 + (number - 1) % 9;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countThreeSumSmaller(vector<int> &numbers, int target)\n{\n    int count= 0;\n    sort(numbers.begin(), numbers.end());\n    for(int index= 0; index < numbers.size(); ++index)\n    {\n        int leftIndex= index + 1, rightIndex= numbers.size() - 1;\n        while(leftIndex < rightIndex)\n        {\n            if(numbers[index] + numbers[leftIndex] + numbers[rightIndex] < target)\n            {\n                count+= rightIndex - leftIndex;\n                ++leftIndex;\n            }\n            else\n            {\n                --rightIndex;\n            }\n        }\n    }\n    return count;\n}",
    "output": "#include <bits/stdc++.h>\nint countThreeSumSmaller(std::vector<int> &numbers, int target)\n{\n    int count= 0;\n    std::sort(numbers.begin(), numbers.end());\n    for(int index= 0; index < numbers.size(); ++index)\n    {\n        int leftIndex= index + 1, rightIndex= numbers.size() - 1;\n        while(leftIndex < rightIndex)\n        {\n            if(numbers[index] + numbers[leftIndex] + numbers[rightIndex] < target)\n            {\n                count+= rightIndex - leftIndex;\n                ++leftIndex;\n            }\n            else\n            {\n                --rightIndex;\n            }\n        }\n    }\n    return count;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> singleNumber(vector<int> &inputNumbers)\n{\n    int xorOfAllNumbers = 0;\n    for (int i = 0; i < inputNumbers.size(); ++i)\n    {\n        int currentNumber = inputNumbers[i];\n        xorOfAllNumbers ^= currentNumber;\n    }\n\n    int differentiatingBit = xorOfAllNumbers & (-xorOfAllNumbers);\n    int firstUniqueNumber = 0;\n    int secondUniqueNumber = 0;\n    for (int i = 0; i < inputNumbers.size(); ++i)\n    {\n        int currentNumber = inputNumbers[i];\n        if (currentNumber & differentiatingBit)\n        {\n            firstUniqueNumber ^= currentNumber;\n        }\n        else\n        {\n            secondUniqueNumber ^= currentNumber;\n        }\n    }\n\n    return vector<int>{firstUniqueNumber, secondUniqueNumber};\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> singleNumber(std::vector<int> &inputNumbers)\n{\n    int xorOfAllNumbers = 0;\n    for(int currentNumber : inputNumbers)\n    {\n        xorOfAllNumbers ^= currentNumber;\n    }\n\n    int differentiatingBit = xorOfAllNumbers & (-xorOfAllNumbers);\n    int firstUniqueNumber = 0;\n    int secondUniqueNumber = 0;\n    for(int currentNumber : inputNumbers)\n    {\n        if(currentNumber & differentiatingBit)\n        {\n            firstUniqueNumber ^= currentNumber;\n        }\n        else\n        {\n            secondUniqueNumber ^= currentNumber;\n        }\n    }\n\n    return std::vector<int>{firstUniqueNumber, secondUniqueNumber};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isTree(int nodeCount, vector<vector<int>> &edges)\n{\n    vector<vector<int>> neighbors(nodeCount);\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        const auto &edge = edges[i];\n        neighbors[edge[0]].push_back(edge[1]);\n        neighbors[edge[1]].push_back(edge[0]);\n    }\n    vector<bool> visited(nodeCount, false);\n    if (hasCycle(neighbors, visited, -1, 0))\n        return false;\n    for (int i = 0; i < visited.size(); ++i)\n        if (!visited[i])\n            return false;\n    return true;\n}\n\nbool hasCycle(const vector<vector<int>> &neighbors, vector<bool> &visited, int parent, int currentNode)\n{\n    visited[currentNode] = true;\n    for (int i = 0; i < neighbors[currentNode].size(); ++i)\n    {\n        const auto &neighbor = neighbors[currentNode][i];\n        if ((neighbor != parent && visited[neighbor]) || (!visited[neighbor] && hasCycle(neighbors, visited, currentNode, neighbor)))\n            return true;\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool isTree(int nodeCount, std::vector<std::vector<int>> &edges)\n{\n    std::vector<std::vector<int>> neighbors(nodeCount);\n    for(const auto &edge : edges)\n    {\n        neighbors[edge[0]].push_back(edge[1]);\n        neighbors[edge[1]].push_back(edge[0]);\n    }\n    std::vector<bool> visited(nodeCount, false);\n    if(hasCycle(neighbors, visited, -1, 0))\n        return false;\n    for(const auto &visit : visited)\n        if(!visit)\n            return false;\n    return true;\n}\n\nbool hasCycle(const std::vector<std::vector<int>> &neighbors, std::vector<bool> &visited, int parent, int currentNode)\n{\n    visited[currentNode]= true;\n    for(const auto &neighbor : neighbors[currentNode])\n        if((neighbor != parent && visited[neighbor]) || (!visited[neighbor] && hasCycle(neighbors, visited, currentNode, neighbor)))\n            return true;\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "bool isUgly(int number)\n{\n    if(number <= 0)\n        return false;\n    while(number % 2 == 0)\n        number/= 2;\n    while(number % 3 == 0)\n        number/= 3;\n    while(number % 5 == 0)\n        number/= 5;\n    return number == 1;\n}",
    "output": "bool isUgly(int number)\n{\n    if(number <= 0)\n        return false;\n    while(number % 2 == 0)\n        number/= 2;\n    while(number % 3 == 0)\n        number/= 3;\n    while(number % 5 == 0)\n        number/= 5;\n    return number == 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint getNthUglyNumber(int n)\n{\n    vector<int> uglyNumbers(n);\n    uglyNumbers[0]= 1;\n    int index2= 0, index3= 0, index5= 0;\n\n    for(int i= 1; i < n; i++)\n    {\n        uglyNumbers[i]= min({uglyNumbers[index2] * 2, uglyNumbers[index3] * 3, uglyNumbers[index5] * 5});\n        if(uglyNumbers[i] == uglyNumbers[index2] * 2)\n            index2++;\n        if(uglyNumbers[i] == uglyNumbers[index3] * 3)\n            index3++;\n        if(uglyNumbers[i] == uglyNumbers[index5] * 5)\n            index5++;\n    }\n\n    return uglyNumbers[n - 1];\n}",
    "output": "#include <bits/stdc++.h>\nint getNthUglyNumber(int n)\n{\n    std::vector<int> uglyNumbers(n);\n    uglyNumbers[0] = 1;\n    int index2 = 0, index3 = 0, index5 = 0;\n\n    for(int i = 1; i < n; i++)\n    {\n        uglyNumbers[i] = std::min({uglyNumbers[index2] * 2, uglyNumbers[index3] * 3, uglyNumbers[index5] * 5});\n        if(uglyNumbers[i] == uglyNumbers[index2] * 2)\n            index2++;\n        if(uglyNumbers[i] == uglyNumbers[index3] * 3)\n            index3++;\n        if(uglyNumbers[i] == uglyNumbers[index5] * 5)\n            index5++;\n    }\n\n    return uglyNumbers[n - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumCost(vector<vector<int>> &costMatrix)\n{\n    if(costMatrix.empty())\n        return 0;\n\n    int numberOfHouses= costMatrix.size();\n    int numberOfColors= costMatrix[0].size();\n\n    for(int houseIndex= 1; houseIndex < numberOfHouses; ++houseIndex)\n    {\n        for(int colorIndex= 0; colorIndex < numberOfColors; ++colorIndex)\n        {\n            int minimumCost= INT_MAX;\n            for(int previousColorIndex= 0; previousColorIndex < numberOfColors; ++previousColorIndex)\n            {\n                if(previousColorIndex == colorIndex)\n                    continue;\n                minimumCost= min(minimumCost, costMatrix[houseIndex - 1][previousColorIndex]);\n            }\n            costMatrix[houseIndex][colorIndex]+= minimumCost;\n        }\n    }\n    return *min_element(costMatrix[numberOfHouses - 1].begin(), costMatrix[numberOfHouses - 1].end());\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMinimumCost(std::vector<std::vector<int>> &costMatrix)\n{\n    if(costMatrix.empty())\n        return 0;\n\n    int numberOfHouses= costMatrix.size();\n    int numberOfColors= costMatrix[0].size();\n\n    for(int houseIndex= 1; houseIndex < numberOfHouses; ++houseIndex)\n    {\n        for(int colorIndex= 0; colorIndex < numberOfColors; ++colorIndex)\n        {\n            int minimumCost= INT_MAX;\n            for(int previousColorIndex= 0; previousColorIndex < numberOfColors; ++previousColorIndex)\n            {\n                if(previousColorIndex == colorIndex)\n                    continue;\n                minimumCost= std::min(minimumCost, costMatrix[houseIndex - 1][previousColorIndex]);\n            }\n            costMatrix[houseIndex][colorIndex]+= minimumCost;\n        }\n    }\n    return *std::min_element(costMatrix[numberOfHouses - 1].begin(), costMatrix[numberOfHouses - 1].end());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canPermutePalindrome(string inputString)\n{\n    unordered_map<char, int> characterCount;\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentChar = inputString[i];\n        characterCount[currentChar]++;\n    }\n    int oddCharacterCount = 0;\n    for (auto iterator = characterCount.begin(); iterator != characterCount.end(); ++iterator)\n    {\n        if (iterator->second % 2)\n        {\n            oddCharacterCount++;\n        }\n    }\n    return oddCharacterCount <= 1;\n}",
    "output": "#include <bits/stdc++.h>\nbool canPermutePalindrome(std::string inputString)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentChar : inputString)\n    {\n        characterCount[currentChar]++;\n    }\n    int oddCharacterCount= 0;\n    for(auto iterator= characterCount.begin(); iterator != characterCount.end(); ++iterator)\n    {\n        if(iterator->second % 2)\n        {\n            oddCharacterCount++;\n        }\n    }\n    return oddCharacterCount <= 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> generatePalindromes(string inputString)\n{\n    unordered_map<char, int> characterCount;\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentCharacter = inputString[i];\n        characterCount[currentCharacter]++;\n    }\n\n    int oddCount = 0;\n    string halfString = \"\", middleCharacter = \"\";\n    for (auto it = characterCount.begin(); it != characterCount.end(); ++it)\n    {\n        const auto &currentEntry = *it;\n        if (currentEntry.second % 2 == 1)\n        {\n            oddCount++;\n            middleCharacter = currentEntry.first;\n        }\n        halfString += string(currentEntry.second / 2, currentEntry.first);\n\n        if (oddCount > 1)\n        {\n            return {};\n        }\n    }\n\n    vector<string> palindromeResults;\n    sort(halfString.begin(), halfString.end());\n    do\n    {\n        string palindrome = halfString + middleCharacter + string(halfString.rbegin(), halfString.rend());\n        palindromeResults.push_back(palindrome);\n    } while (next_permutation(halfString.begin(), halfString.end()));\n\n    return palindromeResults;\n}",
    "output": "#include <bits/stdc++.h>\n// Include for std::sort and std::next_permutation\n\nstd::vector<std::string> generatePalindromes(std::string inputString)\n{\n    std::unordered_map<char, int> characterCount;\n    for(const char &currentCharacter : inputString)\n    {\n        characterCount[currentCharacter]++;\n    }\n\n    int oddCount= 0;\n    std::string halfString= \"\", middleCharacter= \"\";\n    for(const auto &currentEntry : characterCount)\n    {\n        if(currentEntry.second % 2 == 1)\n        {\n            oddCount++;\n            middleCharacter= currentEntry.first;\n        }\n        halfString+= std::string(currentEntry.second / 2, currentEntry.first);\n\n        if(oddCount > 1)\n        {\n            return {};\n        }\n    }\n\n    std::vector<std::string> palindromeResults;\n    std::sort(halfString.begin(), halfString.end());\n    do\n    {\n        std::string palindrome= halfString + middleCharacter + std::string(halfString.rbegin(), halfString.rend());\n        palindromeResults.push_back(palindrome);\n    } while(std::next_permutation(halfString.begin(), halfString.end()));\n\n    return palindromeResults;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint missingNumber(vector<int> &numberList)\n{\n    int listSize = numberList.size();\n    int expectedSum = (listSize * (listSize + 1)) / 2;\n    int actualSum = 0;\n    for (int i = 0; i < listSize; ++i)\n    {\n        int currentNumber = numberList[i];\n        actualSum += currentNumber;\n    }\n    return expectedSum - actualSum;\n}",
    "output": "#include <bits/stdc++.h>\nint missingNumber(std::vector<int> &numberList)\n{\n    int listSize = numberList.size();\n    int expectedSum = (listSize * (listSize + 1)) / 2;\n    int actualSum = 0;\n    for(int currentNumber : numberList)\n    {\n        actualSum += currentNumber;\n    }\n    return expectedSum - actualSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring alienOrder(vector<string> &words)\n{\n    unordered_map<char, unordered_set<char>> characterGraph;\n    unordered_map<char, int> inDegree;\n\n    for (int i = 0; i < words.size(); ++i)\n        for (int j = 0; j < words[i].size(); ++j)\n            inDegree[words[i][j]] = 0;\n\n    for (int index = 0; index < words.size() - 1; index++)\n    {\n        string currentWord = words[index], nextWord = words[index + 1];\n\n        bool isDifferent = false;\n        for (int charIndex = 0; charIndex < min(currentWord.size(), nextWord.size()); charIndex++)\n        {\n            char currentChar = currentWord[charIndex], nextChar = nextWord[charIndex];\n            if (currentChar != nextChar)\n            {\n                if (!characterGraph[currentChar].count(nextChar))\n                {\n                    characterGraph[currentChar].insert(nextChar);\n                    inDegree[nextChar]++;\n                }\n                isDifferent = true;\n                break;\n            }\n        }\n\n        if (!isDifferent && currentWord.size() > nextWord.size())\n            return \"\";\n    }\n\n    queue<char> charQueue;\n    for (auto &[character, degree] : inDegree)\n        if (degree == 0)\n            charQueue.push(character);\n\n    string result;\n    while (!charQueue.empty())\n    {\n        char currentChar = charQueue.front();\n        charQueue.pop();\n        result += currentChar;\n\n        for (const char &neighbor : characterGraph[currentChar])\n        {\n            inDegree[neighbor]--;\n            if (inDegree[neighbor] == 0)\n                charQueue.push(neighbor);\n        }\n    }\n\n    if (result.size() < inDegree.size())\n        return \"\";\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string alienOrder(std::vector<std::string> &words)\n{\n    std::unordered_map<char, std::unordered_set<char>> characterGraph;\n    std::unordered_map<char, int> inDegree;\n\n    for(const std::string &word : words)\n        for(char character : word)\n            inDegree[character]= 0;\n\n    for(int index= 0; index < words.size() - 1; index++)\n    {\n        std::string currentWord= words[index], nextWord= words[index + 1];\n\n        bool isDifferent= false;\n        for(int charIndex= 0; charIndex < std::min(currentWord.size(), nextWord.size()); charIndex++)\n        {\n            char currentChar= currentWord[charIndex], nextChar= nextWord[charIndex];\n            if(currentChar != nextChar)\n            {\n                if(!characterGraph[currentChar].count(nextChar))\n                {\n                    characterGraph[currentChar].insert(nextChar);\n                    inDegree[nextChar]++;\n                }\n                isDifferent= true;\n                break;\n            }\n        }\n\n        if(!isDifferent && currentWord.size() > nextWord.size())\n            return \"\";\n    }\n\n    std::queue<char> charQueue;\n    for(auto &[character, degree] : inDegree)\n        if(degree == 0)\n            charQueue.push(character);\n\n    std::string result;\n    while(!charQueue.empty())\n    {\n        char currentChar= charQueue.front();\n        charQueue.pop();\n        result+= currentChar;\n\n        for(char neighbor : characterGraph[currentChar])\n        {\n            inDegree[neighbor]--;\n            if(inDegree[neighbor] == 0)\n                charQueue.push(neighbor);\n        }\n    }\n\n    if(result.size() < inDegree.size())\n        return \"\";\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class Solution\n{\n  public:\n    int closestValue(TreeNode *rootNode, double targetValue)\n    {\n        int closestValue= rootNode->val;\n        while(rootNode != NULL)\n        {\n            if(abs(targetValue - closestValue) > abs(targetValue - rootNode->val))\n            {\n                closestValue= rootNode->val;\n            }\n            rootNode= targetValue < rootNode->val ? rootNode->left : rootNode->right;\n        }\n        return closestValue;\n    }\n};",
    "output": "class Solution\n{\n  public:\n    int closestValue(TreeNode *rootNode, double targetValue)\n    {\n        int closestValue= rootNode->val;\n        while(rootNode != NULL)\n        {\n            if(abs(targetValue - closestValue) > abs(targetValue - rootNode->val))\n            {\n                closestValue= rootNode->val;\n            }\n            rootNode= targetValue < rootNode->val ? rootNode->left : rootNode->right;\n        }\n        return closestValue;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring encode(const vector<string> &stringList)\n{\n    string encodedString;\n    for (int i = 0; i < stringList.size(); ++i)\n    {\n        const auto &currentString = stringList[i];\n        encodedString += to_string(currentString.length()) + \"#\" + currentString;\n    }\n    return encodedString;\n}\n\nvector<string> decode(const string &encodedString)\n{\n    vector<string> stringList;\n    int currentIndex = 0;\n    while (currentIndex < encodedString.length())\n    {\n        int delimiterPosition = encodedString.find('#', currentIndex);\n        int stringLength = stoi(encodedString.substr(currentIndex, delimiterPosition - currentIndex));\n        stringList.push_back(encodedString.substr(delimiterPosition + 1, stringLength));\n        currentIndex = delimiterPosition + stringLength + 1;\n    }\n    return stringList;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string encode(const std::vector<std::string> &stringList)\n{\n    std::string encodedString;\n    for(const auto &currentString : stringList)\n    {\n        encodedString+= std::to_string(currentString.length()) + \"#\" + currentString;\n    }\n    return encodedString;\n}\n\nstd::vector<std::string> decode(const std::string &encodedString)\n{\n    std::vector<std::string> stringList;\n    int currentIndex= 0;\n    while(currentIndex < encodedString.length())\n    {\n        int delimiterPosition= encodedString.find('#', currentIndex);\n        int stringLength= std::stoi(encodedString.substr(currentIndex, delimiterPosition - currentIndex));\n        stringList.push_back(encodedString.substr(delimiterPosition + 1, stringLength));\n        currentIndex= delimiterPosition + stringLength + 1;\n    }\n    return stringList;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nvector<int> closestKValues(TreeNode *rootNode, double targetValue, int k)\n{\n    vector<int> closestValues;\n    priority_queue<pair<double, int>> maxHeap;\n\n    function<void(TreeNode *)> inorderTraversal= [&](TreeNode *currentNode)\n    {\n        if(!currentNode)\n            return;\n        inorderTraversal(currentNode->leftChild);\n        maxHeap.push(make_pair(fabs(currentNode->value - targetValue), currentNode->value));\n        if(maxHeap.size() > k)\n            maxHeap.pop();\n        inorderTraversal(currentNode->rightChild);\n    };\n\n    inorderTraversal(rootNode);\n    while(!maxHeap.empty())\n    {\n        closestValues.push_back(maxHeap.top().second);\n        maxHeap.pop();\n    }\n    return closestValues;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nstd::vector<int> closestKValues(TreeNode *rootNode, double targetValue, int k)\n{\n    std::vector<int> closestValues;\n    std::priority_queue<std::pair<double, int>> maxHeap;\n\n    std::function<void(TreeNode *)> inorderTraversal= [&](TreeNode *currentNode)\n    {\n        if(!currentNode)\n            return;\n        inorderTraversal(currentNode->leftChild);\n        maxHeap.push(std::make_pair(fabs(currentNode->value - targetValue), currentNode->value));\n        if(maxHeap.size() > k)\n            maxHeap.pop();\n        inorderTraversal(currentNode->rightChild);\n    };\n\n    inorderTraversal(rootNode);\n    while(!maxHeap.empty())\n    {\n        closestValues.push_back(maxHeap.top().second);\n        maxHeap.pop();\n    }\n    return closestValues;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution\n{\n  public:\n    string numberToWords(int number)\n    {\n        if(number == 0)\n            return \"Zero\";\n        string result;\n        int thousandIndex= 0;\n        while(number > 0)\n        {\n            if(number % 1000 != 0)\n            {\n                result= helper(number % 1000) + thousands[thousandIndex] + \" \" + result;\n            }\n            number/= 1000;\n            thousandIndex++;\n        }\n        return trim(result);\n    }\n\n  private:\n    vector<string> lessThanTwenty= {\n        \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\n    vector<string> tens= {\n        \"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\n    vector<string> thousands= {\n        \"\", \"Thousand\", \"Million\", \"Billion\"};\n\n    string helper(int number)\n    {\n        if(number == 0)\n        {\n            return \"\";\n        }\n        else if(number < 20)\n        {\n            return lessThanTwenty[number] + \" \";\n        }\n        else if(number < 100)\n        {\n            return tens[number / 10] + \" \" + helper(number % 10);\n        }\n        else\n        {\n            return lessThanTwenty[number / 100] + \" Hundred \" + helper(number % 100);\n        }\n    }\n\n    string trim(const string &inputString)\n    {\n        return inputString.substr(0, inputString.find_last_not_of(' ') + 1);\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Solution\n{\n  public:\n    std::string numberToWords(int number)\n    {\n        if(number == 0)\n            return \"Zero\";\n        std::string result;\n        int thousandIndex= 0;\n        while(number > 0)\n        {\n            if(number % 1000 != 0)\n            {\n                result= helper(number % 1000) + thousands[thousandIndex] + \" \" + result;\n            }\n            number/= 1000;\n            thousandIndex++;\n        }\n        return trim(result);\n    }\n\n  private:\n    std::vector<std::string> lessThanTwenty= {\n        \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\n    std::vector<std::string> tens= {\n        \"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\n    std::vector<std::string> thousands= {\n        \"\", \"Thousand\", \"Million\", \"Billion\"};\n\n    std::string helper(int number)\n    {\n        if(number == 0)\n        {\n            return \"\";\n        }\n        else if(number < 20)\n        {\n            return lessThanTwenty[number] + \" \";\n        }\n        else if(number < 100)\n        {\n            return tens[number / 10] + \" \" + helper(number % 10);\n        }\n        else\n        {\n            return lessThanTwenty[number / 100] + \" Hundred \" + helper(number % 100);\n        }\n    }\n\n    std::string trim(const std::string &inputString)\n    {\n        return inputString.substr(0, inputString.find_last_not_of(' ') + 1);\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateHIndex(vector<int> &citationCounts)\n{\n    sort(citationCounts.begin(), citationCounts.end(), greater<int>());\n    int hIndex= 0;\n    for(int index= 0; index < citationCounts.size(); ++index)\n    {\n        if(citationCounts[index] >= index + 1)\n        {\n            hIndex= index + 1;\n        }\n        else\n        {\n            break;\n        }\n    }\n    return hIndex;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateHIndex(std::vector<int> &citationCounts)\n{\n    std::sort(citationCounts.begin(), citationCounts.end(), std::greater<int>());\n    int hIndex= 0;\n    for(int index= 0; index < citationCounts.size(); ++index)\n    {\n        if(citationCounts[index] >= index + 1)\n        {\n            hIndex= index + 1;\n        }\n        else\n        {\n            break;\n        }\n    }\n    return hIndex;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateHIndex(vector<int> &citationCounts)\n{\n    int totalCitations= citationCounts.size();\n    int leftIndex= 0, rightIndex= totalCitations - 1;\n\n    while(leftIndex <= rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(citationCounts[midIndex] == totalCitations - midIndex)\n        {\n            return totalCitations - midIndex;\n        }\n        else if(citationCounts[midIndex] < totalCitations - midIndex)\n        {\n            leftIndex= midIndex + 1;\n        }\n        else\n        {\n            rightIndex= midIndex - 1;\n        }\n    }\n\n    return totalCitations - leftIndex;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateHIndex(std::vector<int> &citationCounts)\n{\n    int totalCitations= citationCounts.size();\n    int leftIndex= 0, rightIndex= totalCitations - 1;\n\n    while(leftIndex <= rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(citationCounts[midIndex] == totalCitations - midIndex)\n        {\n            return totalCitations - midIndex;\n        }\n        else if(citationCounts[midIndex] < totalCitations - midIndex)\n        {\n            leftIndex= midIndex + 1;\n        }\n        else\n        {\n            rightIndex= midIndex - 1;\n        }\n    }\n\n    return totalCitations - leftIndex;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int calculateNumWays(int numHouses, int numColors)\n{\n    if(numHouses == 0)\n        return 0;\n    if(numHouses == 1)\n        return numColors;\n    int sameColorCount= numColors;\n    int differentColorCount= numColors * (numColors - 1);\n    for(int houseIndex= 2; houseIndex < numHouses; ++houseIndex)\n    {\n        int temp= differentColorCount;\n        differentColorCount= (sameColorCount + differentColorCount) * (numColors - 1);\n        sameColorCount= temp;\n    }\n    return sameColorCount + differentColorCount;\n}",
    "output": "int calculateNumWays(int numHouses, int numColors)\n{\n    if(numHouses == 0)\n        return 0;\n    if(numHouses == 1)\n        return numColors;\n    int sameColorCount= numColors;\n    int differentColorCount= numColors * (numColors - 1);\n    for(int houseIndex= 2; houseIndex < numHouses; ++houseIndex)\n    {\n        int temp= differentColorCount;\n        differentColorCount= (sameColorCount + differentColorCount) * (numColors - 1);\n        sameColorCount= temp;\n    }\n    return sameColorCount + differentColorCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "bool knows(int personA, int personB);\n\nint findCelebrity(int numberOfPeople)\n{\n    int celebrityCandidate= 0;\n    for(int currentPerson= 1; currentPerson < numberOfPeople; currentPerson++)\n    {\n        if(knows(celebrityCandidate, currentPerson))\n        {\n            celebrityCandidate= currentPerson;\n        }\n    }\n\n    for(int index= 0; index < numberOfPeople; index++)\n    {\n        if(index != celebrityCandidate && (knows(celebrityCandidate, index) || !knows(index, celebrityCandidate)))\n        {\n            return -1;\n        }\n    }\n    return celebrityCandidate;\n}",
    "output": "bool knows(int personA, int personB);\n\nint findCelebrity(int numberOfPeople)\n{\n    int celebrityCandidate= 0;\n    for(int currentPerson= 1; currentPerson < numberOfPeople; currentPerson++)\n    {\n        if(knows(celebrityCandidate, currentPerson))\n        {\n            celebrityCandidate= currentPerson;\n        }\n    }\n\n    for(int index= 0; index < numberOfPeople; index++)\n    {\n        if(index != celebrityCandidate && (knows(celebrityCandidate, index) || !knows(index, celebrityCandidate)))\n        {\n            return -1;\n        }\n    }\n    return celebrityCandidate;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int findFirstBadVersion(int totalVersions)\n{\n    int leftBoundary= 1;\n    int rightBoundary= totalVersions;\n    while(leftBoundary < rightBoundary)\n    {\n        int midVersion= leftBoundary + (rightBoundary - leftBoundary) / 2;\n        if(isBadVersion(midVersion))\n        {\n            rightBoundary= midVersion;\n        }\n        else\n        {\n            leftBoundary= midVersion + 1;\n        }\n    }\n    return leftBoundary;\n}",
    "output": "int findFirstBadVersion(int totalVersions)\n{\n    int leftBoundary= 1;\n    int rightBoundary= totalVersions;\n    while(leftBoundary < rightBoundary)\n    {\n        int midVersion= leftBoundary + (rightBoundary - leftBoundary) / 2;\n        if(isBadVersion(midVersion))\n        {\n            rightBoundary= midVersion;\n        }\n        else\n        {\n            leftBoundary= midVersion + 1;\n        }\n    }\n    return leftBoundary;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numSquares(int targetNumber)\n{\n    vector<int> minSquares(targetNumber + 1, numeric_limits<int>::max());\n    minSquares[0] = 0;\n\n    for(int currentNumber = 1; currentNumber <= targetNumber; currentNumber++)\n    {\n        for(int squareRoot = 1; squareRoot * squareRoot <= currentNumber; squareRoot++)\n        {\n            minSquares[currentNumber] = min(minSquares[currentNumber], minSquares[currentNumber - squareRoot * squareRoot] + 1);\n        }\n    }\n\n    return minSquares[targetNumber];\n}",
    "output": "#include <bits/stdc++.h>\nint numSquares(int targetNumber)\n{\n    std::vector<int> minSquares(targetNumber + 1, std::numeric_limits<int>::max());\n    minSquares[0]= 0;\n\n    for(int currentNumber= 1; currentNumber <= targetNumber; currentNumber++)\n    {\n        for(int squareRoot= 1; squareRoot * squareRoot <= currentNumber; squareRoot++)\n        {\n            minSquares[currentNumber]= std::min(minSquares[currentNumber], minSquares[currentNumber - squareRoot * squareRoot] + 1);\n        }\n    }\n\n    return minSquares[targetNumber];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid wiggleSort(vector<int> &numberList)\n{\n    for(int index= 1; index < numberList.size(); index++)\n    {\n        if(index % 2 == 0 && numberList[index] > numberList[index - 1] || index % 2 == 1 && numberList[index] < numberList[index - 1])\n        {\n            swap(numberList[index], numberList[index - 1]);\n        }\n    }\n}",
    "output": "#include <bits/stdc++.h>\nvoid wiggleSort(std::vector<int> &numberList)\n{\n    for(int index= 1; index < numberList.size(); index++)\n    {\n        if(index % 2 == 0 && numberList[index] > numberList[index - 1] || index % 2 == 1 && numberList[index] < numberList[index - 1])\n        {\n            std::swap(numberList[index], numberList[index - 1]);\n        }\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass ZigzagIterator\n{\n  public:\n    ZigzagIterator(vector<int> &firstVector, vector<int> &secondVector) : currentVector(NULL), indexCurrent(0), indexOther(0)\n    {\n        if(!firstVector.empty())\n        {\n            currentVector= &firstVector;\n            otherVector= &secondVector;\n        }\n        else if(!secondVector.empty())\n        {\n            currentVector= &secondVector;\n            otherVector= &firstVector;\n        }\n    }\n\n    int next()\n    {\n        int result= (*currentVector)[indexCurrent++];\n        if(indexOther < otherVector->size())\n        {\n            swap(currentVector, otherVector);\n            swap(indexCurrent, indexOther);\n        }\n        return result;\n    }\n\n    bool hasNext()\n    {\n        return currentVector && indexCurrent < currentVector->size();\n    }\n\n  private:\n    vector<int> *currentVector;\n    vector<int> *otherVector;\n    int indexCurrent;\n    int indexOther;\n};",
    "output": "#include <bits/stdc++.h>\nclass ZigzagIterator\n{\n  public:\n    ZigzagIterator(std::vector<int> &firstVector, std::vector<int> &secondVector) : currentVector(NULL), indexCurrent(0), indexOther(0)\n    {\n        if(!firstVector.empty())\n        {\n            currentVector= &firstVector;\n            otherVector= &secondVector;\n        }\n        else if(!secondVector.empty())\n        {\n            currentVector= &secondVector;\n            otherVector= &firstVector;\n        }\n    }\n\n    int next()\n    {\n        int result= (*currentVector)[indexCurrent++];\n        if(indexOther < otherVector->size())\n        {\n            std::swap(currentVector, otherVector);\n            std::swap(indexCurrent, indexOther);\n        }\n        return result;\n    }\n\n    bool hasNext()\n    {\n        return currentVector && indexCurrent < currentVector->size();\n    }\n\n  private:\n    std::vector<int> *currentVector;\n    std::vector<int> *otherVector;\n    int indexCurrent;\n    int indexOther;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid evaluateExpression(const string &number, int target, int position, long long currentValue, long long previousValue, string currentExpression, vector<string> &results)\n{\n    if(position == number.size())\n    {\n        if(currentValue == target)\n        {\n            results.push_back(currentExpression);\n        }\n        return;\n    }\n\n    for(int i= position; i < number.size(); ++i)\n    {\n        if(i != position && number[position] == '0')\n            break;\n        long long value= stoll(number.substr(position, i - position + 1));\n        if(position == 0)\n        {\n            evaluateExpression(number, target, i + 1, value, value, currentExpression + number.substr(position, i - position + 1), results);\n        }\n        else\n        {\n            evaluateExpression(number, target, i + 1, currentValue + value, value, currentExpression + \"+\" + number.substr(position, i - position + 1), results);\n            evaluateExpression(number, target, i + 1, currentValue - value, -value, currentExpression + \"-\" + number.substr(position, i - position + 1), results);\n            evaluateExpression(number, target, i + 1, currentValue - previousValue + previousValue * value, previousValue * value, currentExpression + \"*\" + number.substr(position, i - position + 1), results);\n        }\n    }\n}\n\nvector<string> addOperators(string number, int target)\n{\n    vector<string> results;\n    evaluateExpression(number, target, 0, 0, 0, \"\", results);\n    return results;\n}",
    "output": "#include <bits/stdc++.h>\nvoid evaluateExpression(const std::string &number, int target, int position, long long currentValue, long long previousValue, std::string currentExpression, std::vector<std::string> &results)\n{\n    if(position == number.size())\n    {\n        if(currentValue == target)\n        {\n            results.push_back(currentExpression);\n        }\n        return;\n    }\n\n    for(int i= position; i < number.size(); ++i)\n    {\n        if(i != position && number[position] == '0')\n            break;\n        long long value= std::stoll(number.substr(position, i - position + 1));\n        if(position == 0)\n        {\n            evaluateExpression(number, target, i + 1, value, value, currentExpression + number.substr(position, i - position + 1), results);\n        }\n        else\n        {\n            evaluateExpression(number, target, i + 1, currentValue + value, value, currentExpression + \"+\" + number.substr(position, i - position + 1), results);\n            evaluateExpression(number, target, i + 1, currentValue - value, -value, currentExpression + \"-\" + number.substr(position, i - Position + 1), results);\n            evaluateExpression(number, target, i + 1, currentValue - previousValue + previousValue * value, previousValue * value, currentExpression + \"*\" + number.substr(position, i - position + 1), results);\n        }\n    }\n}\n\nstd::vector<std::string> addOperators(std::string number, int target)\n{\n    std::vector<std::string> results;\n    evaluateExpression(number, target, 0, 0, 0, \"\", results);\n    return results;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid moveZeroes(vector<int> &numberList)\n{\n    int nonZeroIndex= 0;\n    for(int currentIndex= 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        if(numberList[currentIndex] != 0)\n        {\n            numberList[nonZeroIndex++]= numberList[currentIndex];\n        }\n    }\n    for(int zeroIndex= nonZeroIndex; zeroIndex < numberList.size(); zeroIndex++)\n    {\n        numberList[zeroIndex]= 0;\n    }\n}",
    "output": "#include <bits/stdc++.h>\nvoid moveZeroes(std::vector<int> &numberList)\n{\n    int nonZeroIndex= 0;\n    for(int currentIndex= 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        if(numberList[currentIndex] != 0)\n        {\n            numberList[nonZeroIndex++]= numberList[currentIndex];\n        }\n    }\n    for(int zeroIndex= nonZeroIndex; zeroIndex < numberList.size(); zeroIndex++)\n    {\n        numberList[zeroIndex]= 0;\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass PeekingIterator : public iterator<input_iterator_tag, int>\n{\n  public:\n    PeekingIterator(vector<int>::iterator currentIterator, vector<int>::iterator endIterator)\n        : currentIterator_(currentIterator), endIterator_(endIterator)\n    {\n        if(currentIterator_ != endIterator_)\n        {\n            nextValue_ = *currentIterator_;\n            ++currentIterator_;\n        }\n    }\n\n    int peek()\n    {\n        return nextValue_;\n    }\n\n    int next()\n    {\n        int returnedValue = nextValue_;\n        if(currentIterator_ != endIterator_)\n        {\n            nextValue_ = *currentIterator_;\n            ++currentIterator_;\n        }\n        return returnedValue;\n    }\n\n    bool hasNext() const\n    {\n        return currentIterator_ != endIterator_;\n    }\n\n  private:\n    vector<int>::iterator currentIterator_;\n    vector<int>::iterator endIterator_;\n    int nextValue_;\n};",
    "output": "#include <bits/stdc++.h>\nclass PeekingIterator : public std::iterator<std::input_iterator_tag, int>\n{\n  public:\n    PeekingIterator(std::vector<int>::iterator currentIterator, std::vector<int>::iterator endIterator)\n        : currentIterator_(currentIterator), endIterator_(endIterator)\n    {\n        if(currentIterator_ != endIterator_)\n        {\n            nextValue_= *currentIterator_;\n            ++currentIterator_;\n        }\n    }\n\n    int peek()\n    {\n        return nextValue_;\n    }\n\n    int next()\n    {\n        int returnedValue= nextValue_;\n        if(currentIterator_ != endIterator_)\n        {\n            nextValue_= *currentIterator_;\n            ++currentIterator_;\n        }\n        return returnedValue;\n    }\n\n    bool hasNext() const\n    {\n        return currentIterator_ != endIterator_;\n    }\n\n  private:\n    std::vector<int>::iterator currentIterator_;\n    std::vector<int>::iterator endIterator_;\n    int nextValue_;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int Value;\n    TreeNode *LeftChild;\n    TreeNode *RightChild;\n};\n\nTreeNode *inorderSuccessor(TreeNode *root, TreeNode *targetNode)\n{\n    TreeNode *successorNode= NULL;\n    while(root != NULL)\n    {\n        if(root->Value > targetNode->Value)\n        {\n            successorNode= root;\n            root= root->LeftChild;\n        }\n        else\n        {\n            root= root->RightChild;\n        }\n    }\n    return successorNode;\n}",
    "output": "struct TreeNode\n{\n    int Value;\n    TreeNode *LeftChild;\n    TreeNode *RightChild;\n};\n\nTreeNode *inorderSuccessor(TreeNode *root, TreeNode *targetNode)\n{\n    TreeNode *successorNode= NULL;\n    while(root != NULL)\n    {\n        if(root->Value > targetNode->Value)\n        {\n            successorNode= root;\n            root= root->LeftChild;\n        }\n        else\n        {\n            root= root->RightChild;\n        }\n    }\n    return successorNode;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid wallsAndGates(vector<vector<int>> &rooms)\n{\n    const int infinity = 2147483647;\n    int rowCount = rooms.size();\n    int columnCount = rooms[0].size();\n    queue<pair<int, int>> gateQueue;\n\n    for (int row = 0; row < rowCount; row++)\n    {\n        for (int column = 0; column < columnCount; column++)\n        {\n            if (rooms[row][column] == 0)\n            {\n                gateQueue.push(make_pair(row, column));\n            }\n        }\n    }\n\n    int directions[][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    while (!gateQueue.empty())\n    {\n        int currentRow = gateQueue.front().first;\n        int currentColumn = gateQueue.front().second;\n        gateQueue.pop();\n\n        for (int i = 0; i < 4; i++) // Replacing range-based for loop\n        {\n            int neighborRow = currentRow + directions[i][0];\n            int neighborColumn = currentColumn + directions[i][1];\n\n            if (neighborRow >= 0 && neighborRow < rowCount && neighborColumn >= 0 && neighborColumn < columnCount && rooms[neighborRow][neighborColumn] == infinity)\n            {\n                rooms[neighborRow][neighborColumn] = rooms[currentRow][currentColumn] + 1;\n                gateQueue.push(make_pair(neighborRow, neighborColumn));\n            }\n        }\n    }\n}",
    "output": "#include <bits/stdc++.h>\nvoid wallsAndGates(std::vector<std::vector<int>> &rooms)\n{\n    const int infinity = 2147483647;\n    int rowCount = rooms.size();\n    int columnCount = rooms[0].size();\n    std::queue<std::pair<int, int>> gateQueue;\n\n    for(int row = 0; row < rowCount; row++)\n    {\n        for(int column = 0; column < columnCount; column++)\n        {\n            if(rooms[row][column] == 0)\n            {\n                gateQueue.push(std::make_pair(row, column));\n            }\n        }\n    }\n\n    int directions[][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    while(!gateQueue.empty())\n    {\n        int currentRow = gateQueue.front().first;\n        int currentColumn = gateQueue.front().second;\n        gateQueue.pop();\n\n        for(auto direction : directions)\n        {\n            int neighborRow = currentRow + direction[0];\n            int neighborColumn = currentColumn + direction[1];\n\n            if(neighborRow >= 0 && neighborRow < rowCount && neighborColumn >= 0 && neighborColumn < columnCount && rooms[neighborRow][neighborColumn] == infinity)\n            {\n                rooms[neighborRow][neighborColumn] = rooms[currentRow][currentColumn] + 1;\n                gateQueue.push(std::make_pair(neighborRow, neighborColumn));\n            }\n        }\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findDuplicate(vector<int> &numberList)\n{\n    int slowPointer= numberList[0];\n    int fastPointer= numberList[0];\n\n    do\n    {\n        slowPointer= numberList[slowPointer];\n        fastPointer= numberList[numberList[fastPointer]];\n    } while(slowPointer != fastPointer);\n\n    slowPointer= numberList[0];\n\n    while(slowPointer != fastPointer)\n    {\n        slowPointer= numberList[slowPointer];\n        fastPointer= numberList[fastPointer];\n    }\n\n    return slowPointer;\n}",
    "output": "#include <bits/stdc++.h>\nint findDuplicate(std::vector<int> &numberList)\n{\n    int slowPointer= numberList[0];\n    int fastPointer= numberList[0];\n\n    do\n    {\n        slowPointer= numberList[slowPointer];\n        fastPointer= numberList[numberList[fastPointer]];\n    } while(slowPointer != fastPointer);\n\n    slowPointer= numberList[0];\n\n    while(slowPointer != fastPointer)\n    {\n        slowPointer= numberList[slowPointer];\n        fastPointer= numberList[fastPointer];\n    }\n\n    return slowPointer;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass ValidWordAbbreviation\n{\n  public:\n    ValidWordAbbreviation(vector<string> &dictionary)\n    {\n        for (size_t i = 0; i < dictionary.size(); ++i)\n        {\n            string &word = dictionary[i];\n            string abbreviation = getAbbreviation(word);\n            abbreviationMap[abbreviation].insert(word);\n        }\n    }\n\n    bool isUnique(string word)\n    {\n        string abbreviation = getAbbreviation(word);\n        auto abbreviationGroup = abbreviationMap.find(abbreviation);\n        return abbreviationGroup == abbreviationMap.end() || (abbreviationGroup->second.size() == 1 && abbreviationGroup->second.count(word));\n    }\n\n  private:\n    unordered_map<string, unordered_set<string>> abbreviationMap;\n\n    string getAbbreviation(const string &word)\n    {\n        int length = word.size();\n        return length <= 2 ? word : word.front() + to_string(length - 2) + word.back();\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass ValidWordAbbreviation\n{\n  public:\n    ValidWordAbbreviation(std::vector<std::string> &dictionary)\n    {\n        for(auto &word : dictionary)\n        {\n            std::string abbreviation= getAbbreviation(word);\n            abbreviationMap[abbreviation].insert(word);\n        }\n    }\n\n    bool isUnique(std::string word)\n    {\n        std::string abbreviation= getAbbreviation(word);\n        auto abbreviationGroup= abbreviationMap.find(abbreviation);\n        return abbreviationGroup == abbreviationMap.end() || (abbreviationGroup->second.size() == 1 && abbreviationGroup->second.count(word));\n    }\n\n  private:\n    std::unordered_map<std::string, std::unordered_set<std::string>> abbreviationMap;\n\n    std::string getAbbreviation(const std::string &word)\n    {\n        int length= word.size();\n        return length <= 2 ? word : word.front() + std::to_string(length - 2) + word.back();\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> gameOfLife(vector<vector<int>> &currentBoard)\n{\n    int rowCount = currentBoard.size();\n    int columnCount = currentBoard[0].size();\n    vector<vector<int>> nextBoard(rowCount, vector<int>(columnCount, 0));\n\n    vector<vector<int>> directions = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n\n    for(int row = 0; row < rowCount; row++)\n    {\n        for(int column = 0; column < columnCount; column++)\n        {\n            int liveNeighborCount = 0;\n\n            for(int i = 0; i < directions.size(); i++)\n            {\n                int newRow = row + directions[i][0];\n                int newColumn = column + directions[i][1];\n\n                if(newRow >= 0 && newRow < rowCount && newColumn >= 0 && newColumn < columnCount && currentBoard[newRow][newColumn] == 1)\n                {\n                    liveNeighborCount++;\n                }\n            }\n\n            if(currentBoard[row][column] == 1 && (liveNeighborCount == 2 || liveNeighborCount == 3))\n            {\n                nextBoard[row][column] = 1;\n            }\n            else if(currentBoard[row][column] == 0 && liveNeighborCount == 3)\n            {\n                nextBoard[row][column] = 1;\n            }\n        }\n    }\n\n    return nextBoard;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> gameOfLife(std::vector<std::vector<int>> &currentBoard)\n{\n    int rowCount= currentBoard.size();\n    int columnCount= currentBoard[0].size();\n    std::vector<std::vector<int>> nextBoard(rowCount, std::vector<int>(columnCount, 0));\n\n    std::vector<std::vector<int>> directions= {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n\n    for(int row= 0; row < rowCount; row++)\n    {\n        for(int column= 0; column < columnCount; column++)\n        {\n            int liveNeighborCount= 0;\n\n            for(std::vector<int> direction : directions)\n            {\n                int newRow= row + direction[0];\n                int newColumn= column + direction[1];\n\n                if(newRow >= 0 && newRow < rowCount && newColumn >= 0 && newColumn < columnCount && currentBoard[newRow][newColumn] == 1)\n                {\n                    liveNeighborCount++;\n                }\n            }\n\n            if(currentBoard[row][column] == 1 && (liveNeighborCount == 2 || liveNeighborCount == 3))\n            {\n                nextBoard[row][column]= 1;\n            }\n            else if(currentBoard[row][column] == 0 && liveNeighborCount == 3)\n            {\n                nextBoard[row][column]= 1;\n            }\n        }\n    }\n\n    return nextBoard;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool wordPattern(string pattern, string sentence)\n{\n    unordered_map<char, string> charToWordMap;\n    unordered_map<string, char> wordToCharMap;\n    stringstream sentenceStream(sentence);\n\n    int wordIndex= 0;\n    for(string currentWord; sentenceStream >> currentWord; ++wordIndex)\n    {\n        if(wordIndex == pattern.size())\n            return false;\n        char currentChar= pattern[wordIndex];\n        if(charToWordMap.count(currentChar) == 0 && wordToCharMap.count(currentWord) == 0)\n        {\n            charToWordMap[currentChar]= currentWord;\n            wordToCharMap[currentWord]= currentChar;\n        }\n        else\n        {\n            if(charToWordMap[currentChar] != currentWord || wordToCharMap[currentWord] != currentChar)\n                return false;\n        }\n    }\n\n    return wordIndex == pattern.size();\n}",
    "output": "#include <bits/stdc++.h>\nbool wordPattern(std::string pattern, std::string sentence)\n{\n    std::unordered_map<char, std::string> charToWordMap;\n    std::unordered_map<std::string, char> wordToCharMap;\n    std::stringstream sentenceStream(sentence);\n\n    int wordIndex= 0;\n    for(std::string currentWord; sentenceStream >> currentWord; ++wordIndex)\n    {\n        if(wordIndex == pattern.size())\n            return false;\n        char currentChar= pattern[wordIndex];\n        if(charToWordMap.count(currentChar) == 0 && wordToCharMap.count(currentWord) == 0)\n        {\n            charToWordMap[currentChar]= currentWord;\n            wordToCharMap[currentWord]= currentChar;\n        }\n        else\n        {\n            if(charToWordMap[currentChar] != currentWord || wordToCharMap[currentWord] != currentChar)\n                return false;\n        }\n    }\n\n    return wordIndex == pattern.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool wordPatternMatch(string pattern, string inputString);\nbool backtrack(string &pattern, int patternIndex, string &inputString, int stringIndex, unordered_map<char, string> &charToStringMap, unordered_set<string> &usedWords);\n\nbool wordPatternMatch(string pattern, string inputString)\n{\n    unordered_map<char, string> charToStringMap;\n    unordered_set<string> usedWords;\n    return backtrack(pattern, 0, inputString, 0, charToStringMap, usedWords);\n}\n\nbool backtrack(string &pattern, int patternIndex, string &inputString, int stringIndex, unordered_map<char, string> &charToStringMap, unordered_set<string> &usedWords)\n{\n    if(patternIndex == pattern.size() && stringIndex == inputString.size())\n        return true;\n    if(patternIndex == pattern.size() || stringIndex == inputString.size())\n        return false;\n\n    char currentChar= pattern[patternIndex];\n    if(charToStringMap.count(currentChar))\n    {\n        string mappedWord= charToStringMap[currentChar];\n        if(inputString.substr(stringIndex, mappedWord.size()) != mappedWord)\n            return false;\n        return backtrack(pattern, patternIndex + 1, inputString, stringIndex + mappedWord.size(), charToStringMap, usedWords);\n    }\n    else\n    {\n        for(int length= 1; length <= inputString.size() - stringIndex; length++)\n        {\n            string potentialWord= inputString.substr(stringIndex, length);\n            if(usedWords.count(potentialWord))\n                continue;\n            charToStringMap[currentChar]= potentialWord;\n            usedWords.insert(potentialWord);\n            if(backtrack(pattern, patternIndex + 1, inputString, stringIndex + length, charToStringMap, usedWords))\n                return true;\n            charToStringMap.erase(currentChar);\n            usedWords.erase(potentialWord);\n        }\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool wordPatternMatch(std::string pattern, std::string inputString)\n{\n    std::unordered_map<char, std::string> charToStringMap;\n    std::unordered_set<std::string> usedWords;\n    return backtrack(pattern, 0, inputString, 0, charToStringMap, usedWords);\n}\n\nbool backtrack(std::string &pattern, int patternIndex, std::string &inputString, int stringIndex, std::unordered_map<char, std::string> &charToStringMap, std::unordered_set<std::string> &usedWords)\n{\n    if(patternIndex == pattern.size() && stringIndex == inputString.size())\n        return true;\n    if(patternIndex == pattern.size() || stringIndex == inputString.size())\n        return false;\n\n    char currentChar= pattern[patternIndex];\n    if(charToStringMap.count(currentChar))\n    {\n        std::string mappedWord= charToStringMap[currentChar];\n        if(inputString.substr(stringIndex, mappedWord.size()) != mappedWord)\n            return false;\n        return backtrack(pattern, patternIndex + 1, inputString, stringIndex + mappedWord.size(), charToStringMap, usedWords);\n    }\n    else\n    {\n        for(int length= 1; length <= inputString.size() - stringIndex; length++)\n        {\n            std::string potentialWord= inputString.substr(stringIndex, length);\n            if(usedWords.count(potentialWord))\n                continue;\n            charToStringMap[currentChar]= potentialWord;\n            usedWords.insert(potentialWord);\n            if(backtrack(pattern, patternIndex + 1, inputString, stringIndex + length, charToStringMap, usedWords))\n                return true;\n            charToStringMap.erase(currentChar);\n            usedWords.erase(potentialWord);\n        }\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "bool canWinNim(int totalStones)\n{\n    return totalStones % 4 != 0;\n}",
    "output": "bool canWinNim(int totalStones)\n{\n    return totalStones % 4 != 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> generatePossibleNextMoves(string currentState)\n{\n    vector<string> nextStates;\n    for(int index= 1; index < currentState.size(); ++index)\n    {\n        if(currentState[index] == '+' && currentState[index - 1] == '+')\n        {\n            currentState[index]= currentState[index - 1]= '-';\n            nextStates.push_back(currentState);\n            currentState[index]= currentState[index - 1]= '+';\n        }\n    }\n    return nextStates;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> generatePossibleNextMoves(std::string currentState)\n{\n    std::vector<std::string> nextStates;\n    for(int index= 1; index < currentState.size(); ++index)\n    {\n        if(currentState[index] == '+' && currentState[index - 1] == '+')\n        {\n            currentState[index]= currentState[index - 1]= '-';\n            nextStates.push_back(currentState);\n            currentState[index]= currentState[index - 1]= '+';\n        }\n    }\n    return nextStates;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canWin(string currentState)\n{\n    for(int index= 0; index < currentState.size() - 1; ++index)\n    {\n        if(currentState[index] == '+' && currentState[index + 1] == '+')\n        {\n            currentState[index]= '-';\n            currentState[index + 1]= '-';\n            bool opponentWins= canWin(currentState);\n            currentState[index]= '+';\n            currentState[index + 1]= '+';\n            if(!opponentWins)\n                return true;\n        }\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool canWin(std::string currentState)\n{\n    for(int index= 0; index < currentState.size() - 1; ++index)\n    {\n        if(currentState[index] == '+' && currentState[index + 1] == '+')\n        {\n            currentState[index]= '-';\n            currentState[index + 1]= '-';\n            bool opponentWins= canWin(currentState);\n            currentState[index]= '+';\n            currentState[index + 1]= '+';\n            if(!opponentWins)\n                return true;\n        }\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass MedianFinder\n{\n  public:\n    /** initialize your data structure here. */\n    priority_queue<int> maxHeap;                            // renamed MaxHeap to maxHeap for consistency with naming conventions\n    priority_queue<int, vector<int>, greater<int>> minHeap; // renamed MinHeap to minHeap for consistency with naming conventions\n\n    MedianFinder() {}\n\n    void addNum(int number)\n    { // renamed Number to number for consistency with naming conventions\n        if(maxHeap.empty() || number <= maxHeap.top())\n        {\n            maxHeap.push(number);\n        }\n        else\n        {\n            minHeap.push(number);\n        }\n\n        if(maxHeap.size() < minHeap.size())\n        {\n            maxHeap.push(minHeap.top());\n            minHeap.pop();\n        }\n        else if(maxHeap.size() > minHeap.size() + 1)\n        {\n            minHeap.push(maxHeap.top());\n            maxHeap.pop();\n        }\n    }\n\n    double findMedian()\n    {\n        if(maxHeap.size() == minHeap.size())\n        {\n            return ((double)maxHeap.top() + (double)minHeap.top()) / 2;\n        }\n        else\n        {\n            return maxHeap.top();\n        }\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass MedianFinder\n{\n  public:\n    /** initialize your data structure here. */\n    std::priority_queue<int> maxHeap;                            // renamed MaxHeap to maxHeap for consistency with naming conventions\n    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap; // renamed MinHeap to minHeap for consistency with naming conventions\n\n    MedianFinder() {}\n\n    void addNum(int number)\n    { // renamed Number to number for consistency with naming conventions\n        if(maxHeap.empty() || number <= maxHeap.top())\n        {\n            maxHeap.push(number);\n        }\n        else\n        {\n            minHeap.push(number);\n        }\n\n        if(maxHeap.size() < minHeap.size())\n        {\n            maxHeap.push(minHeap.top());\n            minHeap.pop();\n        }\n        else if(maxHeap.size() > minHeap.size() + 1)\n        {\n            minHeap.push(maxHeap.top());\n            maxHeap.pop();\n        }\n    }\n\n    double findMedian()\n    {\n        if(maxHeap.size() == minHeap.size())\n        {\n            return ((double)maxHeap.top() + (double)minHeap.top()) / 2;\n        }\n        else\n        {\n            return maxHeap.top();\n        }\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minTotalDistance(vector<vector<int>> &grid)\n{\n    vector<int> occupiedRows, occupiedCols;\n    int rowCount = grid.size(), colCount = grid[0].size();\n    for (int rowIndex = 0; rowIndex < rowCount; ++rowIndex)\n    {\n        for (int colIndex = 0; colIndex < colCount; ++colIndex)\n        {\n            if (grid[rowIndex][colIndex])\n            {\n                occupiedRows.push_back(rowIndex);\n                occupiedCols.push_back(colIndex);\n            }\n        }\n    }\n    sort(occupiedCols.begin(), occupiedCols.end());\n    int rowMedian = occupiedRows[occupiedRows.size() / 2], colMedian = occupiedCols[occupiedCols.size() / 2];\n    int totalDistance = 0;\n    for (int i = 0; i < occupiedRows.size(); ++i)\n        totalDistance += abs(occupiedRows[i] - rowMedian);\n    for (int i = 0; i < occupiedCols.size(); ++i)\n        totalDistance += abs(occupiedCols[i] - colMedian);\n    return totalDistance;\n}",
    "output": "#include <bits/stdc++.h>\nint minTotalDistance(std::vector<std::vector<int>> &grid)\n{\n    std::vector<int> occupiedRows, occupiedCols;\n    int rowCount= grid.size(), colCount= grid[0].size();\n    for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex < colCount; ++colIndex)\n        {\n            if(grid[rowIndex][colIndex])\n            {\n                occupiedRows.push_back(rowIndex);\n                occupiedCols.push_back(colIndex);\n            }\n        }\n    }\n    std::sort(occupiedCols.begin(), occupiedCols.end());\n    int rowMedian= occupiedRows[occupiedRows.size() / 2], colMedian= occupiedCols[occupiedCols.size() / 2];\n    int totalDistance= 0;\n    for(int row : occupiedRows)\n        totalDistance+= std::abs(row - rowMedian);\n    for(int col : occupiedCols)\n        totalDistance+= std::abs(col - colMedian);\n    return totalDistance;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nstring serialize(TreeNode *root)\n{\n    if(!root)\n        return \"null,\";\n    return to_string(root->value) + \",\" + serialize(root->leftChild) + serialize(root->rightChild);\n}\n\nTreeNode *deserialize(string data)\n{\n    istringstream inputStream(data);\n    return deserializeHelper(inputStream);\n}\n\nTreeNode *deserializeHelper(istringstream &inputStream)\n{\n    string value;\n    if(!getline(inputStream, value, ','))\n        return NULL;\n    if(value == \"null\")\n        return NULL;\n    TreeNode *root= new TreeNode(stoi(value));\n    root->leftChild= deserializeHelper(inputStream);\n    root->rightChild= deserializeHelper(inputStream);\n    return root;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nstd::string serialize(TreeNode *root)\n{\n    if(!root)\n        return \"null,\";\n    return std::to_string(root->value) + \",\" + serialize(root->leftChild) + serialize(root->rightChild);\n}\n\nTreeNode *deserialize(std::string data)\n{\n    std::istringstream inputStream(data);\n    return deserializeHelper(inputStream);\n}\n\nTreeNode *deserializeHelper(std::istringstream &inputStream)\n{\n    std::string value;\n    if(!std::getline(inputStream, value, ','))\n        return NULL;\n    if(value == \"null\")\n        return NULL;\n    TreeNode *root= new TreeNode(std::stoi(value));\n    root->leftChild= deserializeHelper(inputStream);\n    root->rightChild= deserializeHelper(inputStream);\n    return root;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nint findLongestConsecutiveSequence(TreeNode *rootNode, int &longestPathLength)\n{\n    if(rootNode == NULL)\n    {\n        return 0;\n    }\n    int leftLength= findLongestConsecutiveSequence(rootNode->leftChild, longestPathLength);\n    int rightLength= findLongestConsecutiveSequence(rootNode->rightChild, longestPathLength);\n    int currentPathLength= 1;\n    if(rootNode->leftChild != NULL && rootNode->leftChild->value == rootNode->value + 1)\n    {\n        currentPathLength= max(currentPathLength, leftLength + 1);\n    }\n    if(rootNode->rightChild != NULL && rootNode->rightChild->value == rootNode->value + 1)\n    {\n        currentPathLength= max(currentPathLength, rightLength + 1);\n    }\n    longestPathLength= max(longestPathLength, currentPathLength);\n    return currentPathLength;\n}\n\nint longestConsecutive(TreeNode *rootNode)\n{\n    int longestPathLength= 0;\n    findLongestConsecutiveSequence(rootNode, longestPathLength);\n    return longestPathLength;\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nint findLongestConsecutiveSequence(TreeNode *rootNode, int &longestPathLength)\n{\n    if(rootNode == NULL)\n    {\n        return 0;\n    }\n    int leftLength= findLongestConsecutiveSequence(rootNode->leftChild, longestPathLength);\n    int rightLength= findLongestConsecutiveSequence(rootNode->rightChild, longestPathLength);\n    int currentPathLength= 1;\n    if(rootNode->leftChild != NULL && rootNode->leftChild->value == rootNode->value + 1)\n    {\n        currentPathLength= max(currentPathLength, leftLength + 1);\n    }\n    if(rootNode->rightChild != NULL && rootNode->rightChild->value == rootNode->value + 1)\n    {\n        currentPathLength= max(currentPathLength, rightLength + 1);\n    }\n    longestPathLength= max(longestPathLength, currentPathLength);\n    return currentPathLength;\n}\n\nint longestConsecutive(TreeNode *rootNode)\n{\n    int longestPathLength= 0;\n    findLongestConsecutiveSequence(rootNode, longestPathLength);\n    return longestPathLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring getHint(string secret, string guess)\n{\n    int bullCount= 0, cowCount= 0;\n    vector<int> secretDigitCount(10, 0);\n    vector<int> guessDigitCount(10, 0);\n\n    for(size_t index= 0; index < secret.length(); index++)\n    {\n        if(secret[index] == guess[index])\n        {\n            bullCount++;\n        }\n        else\n        {\n            secretDigitCount[secret[index] - '0']++;\n            guessDigitCount[guess[index] - '0']++;\n        }\n    }\n\n    for(size_t digitIndex= 0; digitIndex < 10; digitIndex++)\n    {\n        cowCount+= min(secretDigitCount[digitIndex], guessDigitCount[digitIndex]);\n    }\n\n    return to_string(bullCount) + \"A\" + to_string(cowCount) + \"B\";\n}",
    "output": "std::string getHint(std::string secret, std::string guess)\n{\n    int bullCount= 0, cowCount= 0;\n    std::vector<int> secretDigitCount(10, 0);\n    std::vector<int> guessDigitCount(10, 0);\n\n    for(size_t index= 0; index < secret.length(); index++)\n    {\n        if(secret[index] == guess[index])\n        {\n            bullCount++;\n        }\n        else\n        {\n            secretDigitCount[secret[index] - '0']++;\n            guessDigitCount[guess[index] - '0']++;\n        }\n    }\n\n    for(size_t digitIndex= 0; digitIndex < 10; digitIndex++)\n    {\n        cowCount+= std::min(secretDigitCount[digitIndex], guessDigitCount[digitIndex]);\n    }\n\n    return std::to_string(bullCount) + \"A\" + std::to_string(cowCount) + \"B\";\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint lengthOfLongestIncreasingSubsequence(vector<int> &numberSequence)\n{\n    vector<int> dynamicProgrammingArray(numberSequence.size(), 1);\n    int maximumLength= 1;\n    for(int currentIndex= 1; currentIndex < numberSequence.size(); currentIndex++)\n    {\n        for(int previousIndex= 0; previousIndex < currentIndex; previousIndex++)\n        {\n            if(numberSequence[currentIndex] > numberSequence[previousIndex])\n            {\n                dynamicProgrammingArray[currentIndex]= max(dynamicProgrammingArray[currentIndex], dynamicProgrammingArray[previousIndex] + 1);\n            }\n        }\n        maximumLength= max(maximumLength, dynamicProgrammingArray[currentIndex]);\n    }\n    return maximumLength;\n}",
    "output": "#include <bits/stdc++.h>\nint lengthOfLongestIncreasingSubsequence(std::vector<int> &numberSequence)\n{\n    std::vector<int> dynamicProgrammingArray(numberSequence.size(), 1);\n    int maximumLength= 1;\n    for(int currentIndex= 1; currentIndex < numberSequence.size(); currentIndex++)\n    {\n        for(int previousIndex= 0; previousIndex < currentIndex; previousIndex++)\n        {\n            if(numberSequence[currentIndex] > numberSequence[previousIndex])\n            {\n                dynamicProgrammingArray[currentIndex]= std::max(dynamicProgrammingArray[currentIndex], dynamicProgrammingArray[previousIndex] + 1);\n            }\n        }\n        maximumLength= std::max(maximumLength, dynamicProgrammingArray[currentIndex]);\n    }\n    return maximumLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution\n{\n  public:\n    vector<string> removeInvalidParentheses(string inputString)\n    {\n        set<string> visitedStrings;\n        queue<string> stringQueue;\n        vector<string> validResults;\n        bool isFound= false;\n\n        visitedStrings.insert(inputString);\n        stringQueue.push(inputString);\n\n        while(!stringQueue.empty())\n        {\n            string currentString = stringQueue.front();\n            stringQueue.pop();\n\n            if(isValid(currentString))\n            {\n                isFound = true;\n                validResults.push_back(currentString);\n            }\n\n            if(isFound)\n                continue;\n\n            for(int index = 0; index < currentString.length(); ++index)\n            {\n                if(currentString[index] == '(' || currentString[index] == ')')\n                {\n                    string nextString = currentString.substr(0, index) + currentString.substr(index + 1);\n                    if(visitedStrings.find(nextString) == visitedStrings.end())\n                    {\n                        visitedStrings.insert(nextString);\n                        stringQueue.push(nextString);\n                    }\n                }\n            }\n        }\n        return validResults;\n    }\n\n    bool isValid(const string &inputStr)\n    {\n        int parenthesesCount = 0;\n        for(int i = 0; i < inputStr.length(); ++i)\n        {\n            char character = inputStr[i];\n            if(character == '(')\n                parenthesesCount++;\n            if(character == ')')\n                parenthesesCount--;\n            if(parenthesesCount < 0)\n                return false;\n        }\n        return parenthesesCount == 0;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Solution\n{\n  public:\n    std::vector<std::string> removeInvalidParentheses(std::string inputString)\n    {\n        std::set<std::string> visitedStrings;\n        std::queue<std::string> stringQueue;\n        std::vector<std::string> validResults;\n        bool isFound= false;\n\n        visitedStrings.insert(inputString);\n        stringQueue.push(inputString);\n\n        while(!stringQueue.empty())\n        {\n            std::string currentString= stringQueue.front();\n            stringQueue.pop();\n\n            if(isValid(currentString))\n            {\n                isFound= true;\n                validResults.push_back(currentString);\n            }\n\n            if(isFound)\n                continue;\n\n            for(int index= 0; index < currentString.length(); ++index)\n            {\n                if(currentString[index] == '(' || currentString[index] == ')')\n                {\n                    std::string nextString= currentString.substr(0, index) + currentString.substr(index + 1);\n                    if(visitedStrings.find(nextString) == visitedStrings.end())\n                    {\n                        visitedStrings.insert(nextString);\n                        stringQueue.push(nextString);\n                    }\n                }\n            }\n        }\n        return validResults;\n    }\n\n    bool isValid(const std::string &inputStr)\n    {\n        int parenthesesCount= 0;\n        for(char character : inputStr)\n        {\n            if(character == '(')\n                parenthesesCount++;\n            if(character == ')')\n                parenthesesCount--;\n            if(parenthesesCount < 0)\n                return false;\n        }\n        return parenthesesCount == 0;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinArea(vector<vector<char>> &image, int startX, int startY)\n{\n    int topBoundary= startX, bottomBoundary= startX, leftBoundary= startY, rightBoundary= startY;\n    for(int rowIndex= 0; rowIndex < image.size(); ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex < image[rowIndex].size(); ++colIndex)\n        {\n            if(image[rowIndex][colIndex] == '1')\n            {\n                topBoundary= min(topBoundary, rowIndex);\n                bottomBoundary= max(bottomBoundary, rowIndex);\n                leftBoundary= min(leftBoundary, colIndex);\n                rightBoundary= max(rightBoundary, colIndex);\n            }\n        }\n    }\n    return (bottomBoundary - topBoundary + 1) * (rightBoundary - leftBoundary + 1);\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMinArea(std::vector<std::vector<char>> &image, int startX, int startY)\n{\n    int topBoundary= startX, bottomBoundary= startX, leftBoundary= startY, rightBoundary= startY;\n    for(int rowIndex= 0; rowIndex < image.size(); ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex < image[rowIndex].size(); ++colIndex)\n        {\n            if(image[rowIndex][colIndex] == '1')\n            {\n                topBoundary= std::min(topBoundary, rowIndex);\n                bottomBoundary= std::max(bottomBoundary, rowIndex);\n                leftBoundary= std::min(leftBoundary, colIndex);\n                rightBoundary= std::max(rightBoundary, colIndex);\n            }\n        }\n    }\n    return (bottomBoundary - topBoundary + 1) * (rightBoundary - leftBoundary + 1);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass NumArray\n{\n  public:\n    vector<int> prefixSum;\n\n    NumArray(vector<int> &inputNumbers)\n    {\n        prefixSum.resize(inputNumbers.size() + 1);\n        for(int index= 0; index < inputNumbers.size(); index++)\n        {\n            prefixSum[index + 1]= prefixSum[index] + inputNumbers[index];\n        }\n    }\n\n    int sumRange(int leftIndex, int rightIndex)\n    {\n        return prefixSum[rightIndex + 1] - prefixSum[leftIndex];\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass NumArray\n{\n  public:\n    std::vector<int> prefixSum;\n\n    NumArray(std::vector<int> &inputNumbers)\n    {\n        prefixSum.resize(inputNumbers.size() + 1);\n        for(int index= 0; index < inputNumbers.size(); index++)\n        {\n            prefixSum[index + 1]= prefixSum[index] + inputNumbers[index];\n        }\n    }\n\n    int sumRange(int leftIndex, int rightIndex)\n    {\n        return prefixSum[rightIndex + 1] - prefixSum[leftIndex];\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass NumMatrix\n{\n  public:\n    vector<vector<int>> prefixSumMatrix;\n\n    NumMatrix(vector<vector<int>> &inputMatrix)\n    {\n        int rowCount= inputMatrix.size();\n        int colCount= inputMatrix[0].size();\n        prefixSumMatrix= vector<vector<int>>(rowCount + 1, vector<int>(colCount + 1));\n\n        for(int currentRow= 1; currentRow <= rowCount; ++currentRow)\n        {\n            for(int currentCol= 1; currentCol <= colCount; ++currentCol)\n            {\n                prefixSumMatrix[currentRow][currentCol]= prefixSumMatrix[currentRow - 1][currentCol] +\n                                                         prefixSumMatrix[currentRow][currentCol - 1] -\n                                                         prefixSumMatrix[currentRow - 1][currentCol - 1] +\n                                                         inputMatrix[currentRow - 1][currentCol - 1];\n            }\n        }\n    }\n\n    int sumRegion(int startRow, int startCol, int endRow, int endCol)\n    {\n        return prefixSumMatrix[endRow + 1][endCol + 1] -\n               prefixSumMatrix[startRow][endCol + 1] -\n               prefixSumMatrix[endRow + 1][startCol] +\n               prefixSumMatrix[startRow][startCol];\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass NumMatrix\n{\n  public:\n    std::vector<std::vector<int>> prefixSumMatrix;\n\n    NumMatrix(std::vector<std::vector<int>> &inputMatrix)\n    {\n        int rowCount = inputMatrix.size();\n        int colCount = inputMatrix[0].size();\n        prefixSumMatrix = std::vector<std::vector<int>>(rowCount + 1, std::vector<int>(colCount + 1));\n\n        for(int currentRow = 1; currentRow <= rowCount; ++currentRow)\n        {\n            for(int currentCol = 1; currentCol <= colCount; ++currentCol)\n            {\n                prefixSumMatrix[currentRow][currentCol] = prefixSumMatrix[currentRow - 1][currentCol] +\n                                                           prefixSumMatrix[currentRow][currentCol - 1] -\n                                                           prefixSumMatrix[currentRow - 1][currentCol - 1] +\n                                                           inputMatrix[currentRow - 1][currentCol - 1];\n            }\n        }\n    }\n\n    int sumRegion(int startRow, int startCol, int endRow, int endCol)\n    {\n        return prefixSumMatrix[endRow + 1][endCol + 1] -\n               prefixSumMatrix[startRow][endCol + 1] -\n               prefixSumMatrix[endRow + 1][startCol] +\n               prefixSumMatrix[startRow][startCol];\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> numIslands2(int rowCount, int colCount, vector<vector<int>> &positions)\n{\n    vector<int> islandRoots(rowCount * colCount, -1);\n    vector<vector<int>> directionVectors{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n    int currentIslandCount = 0;\n    vector<int> resultCount;\n\n    auto getIndex = [&](int row, int col)\n    {\n        return row * colCount + col;\n    };\n\n    function<int(int)> findRoot = [&](int index)\n    {\n        if (islandRoots[index] != index)\n        {\n            islandRoots[index] = findRoot(islandRoots[index]);\n        }\n        return islandRoots[index];\n    };\n\n    for (int i = 0; i < positions.size(); ++i)\n    {\n        const auto &position = positions[i];\n        int row = position[0], col = position[1], index = getIndex(row, col);\n        if (islandRoots[index] != -1)\n        {\n            resultCount.push_back(currentIslandCount);\n            continue;\n        }\n        currentIslandCount++;\n        islandRoots[index] = index;\n        for (int j = 0; j < directionVectors.size(); ++j)\n        {\n            const auto &direction = directionVectors[j];\n            int neighborRow = row + direction[0], neighborCol = col + direction[1], neighborIndex = getIndex(neighborRow, neighborCol);\n            if (neighborRow >= 0 && neighborRow < rowCount && neighborCol >= 0 && neighborCol < colCount && islandRoots[neighborIndex] != -1)\n            {\n                int rootNeighbor = findRoot(neighborIndex);\n                if (index != rootNeighbor)\n                {\n                    islandRoots[rootNeighbor] = index;\n                    currentIslandCount--;\n                }\n            }\n        }\n        resultCount.push_back(currentIslandCount);\n    }\n    return resultCount;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> numIslands2(int rowCount, int colCount, std::vector<std::vector<int>> &positions)\n{\n    std::vector<int> islandRoots(rowCount * colCount, -1);\n    std::vector<std::vector<int>> directionVectors{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n    int currentIslandCount= 0;\n    std::vector<int> resultCount;\n\n    auto getIndex= [&](int row, int col)\n    {\n        return row * colCount + col;\n    };\n\n    std::function<int(int)> findRoot= [&](int index)\n    {\n        if(islandRoots[index] != index)\n        {\n            islandRoots[index]= findRoot(islandRoots[index]);\n        }\n        return islandRoots[index];\n    };\n\n    for(const auto &position : positions)\n    {\n        int row= position[0], col= position[1], index= getIndex(row, col);\n        if(islandRoots[index] != -1)\n        {\n            resultCount.push_back(currentIslandCount);\n            continue;\n        }\n        currentIslandCount++;\n        islandRoots[index]= index;\n        for(const auto &direction : directionVectors)\n        {\n            int neighborRow= row + direction[0], neighborCol= col + direction[1], neighborIndex= getIndex(neighborRow, neighborCol);\n            if(neighborRow >= 0 && neighborRow < rowCount && neighborCol >= 0 && neighborCol < colCount && islandRoots[neighborIndex] != -1)\n            {\n                int rootNeighbor= findRoot(neighborIndex);\n                if(index != rootNeighbor)\n                {\n                    islandRoots[rootNeighbor]= index;\n                    currentIslandCount--;\n                }\n            }\n        }\n        resultCount.push_back(currentIslandCount);\n    }\n    return resultCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isAdditiveNumber(string inputNumber)\n{\n    for(int firstPartLength= 1; firstPartLength <= inputNumber.length() / 2; firstPartLength++)\n    {\n        for(int secondPartLength= 1; secondPartLength <= (inputNumber.length() - firstPartLength) / 2; secondPartLength++)\n        {\n            if(check(inputNumber.substr(0, firstPartLength), inputNumber.substr(firstPartLength, secondPartLength), inputNumber.substr(firstPartLength + secondPartLength)))\n            {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool check(string firstNumber, string secondNumber, string remainingNumber)\n{\n    if((firstNumber.size() > 1 && firstNumber[0] == '0') || (secondNumber.size() > 1 && secondNumber[0] == '0'))\n    {\n        return false;\n    }\n    string sum= add(firstNumber, secondNumber);\n    if(remainingNumber == sum)\n    {\n        return true;\n    }\n    if(remainingNumber.substr(0, sum.size()) != sum)\n    {\n        return false;\n    }\n    return check(secondNumber, sum, remainingNumber.substr(sum.size()));\n}\n\nstring add(string firstNumber, string secondNumber)\n{\n    int carry= 0;\n    string result;\n    for(int i= firstNumber.size() - 1, j= secondNumber.size() - 1;\n        i >= 0 || j >= 0 || carry > 0; i--, j--)\n    {\n        int number1= i >= 0 ? firstNumber[i] - '0' : 0;\n        int number2= j >= 0 ? secondNumber[j] - '0' : 0;\n        int sum= number1 + number2 + carry;\n        carry= sum / 10;\n        result.push_back('0' + sum % 10);\n    }\n    reverse(result.begin(), result.end());\n    return result;\n}",
    "output": "bool isAdditiveNumber(std::string inputNumber)\n{\n    for(int firstPartLength= 1; firstPartLength <= inputNumber.length() / 2; firstPartLength++)\n    {\n        for(int secondPartLength= 1; secondPartLength <= (inputNumber.length() - firstPartLength) / 2; secondPartLength++)\n        {\n            if(check(inputNumber.substr(0, firstPartLength), inputNumber.substr(firstPartLength, secondPartLength), inputNumber.substr(firstPartLength + secondPartLength)))\n            {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool check(std::string firstNumber, std::string secondNumber, std::string remainingNumber)\n{\n    if((firstNumber.size() > 1 && firstNumber[0] == '0') || (secondNumber.size() > 1 && secondNumber[0] == '0'))\n    {\n        return false;\n    }\n    std::string sum= add(firstNumber, secondNumber);\n    if(remainingNumber == sum)\n    {\n        return true;\n    }\n    if(remainingNumber.substr(0, sum.size()) != sum)\n    {\n        return false;\n    }\n    return check(secondNumber, sum, remainingNumber.substr(sum.size()));\n}\n\nstd::string add(std::string firstNumber, std::string secondNumber)\n{\n    int carry= 0;\n    std::string result;\n    for(int i= firstNumber.size() - 1, j= secondNumber.size() - 1;\n        i >= 0 || j >= 0 || carry > 0; i--, j--)\n    {\n        int number1= i >= 0 ? firstNumber[i] - '0' : 0;\n        int number2= j >= 0 ? secondNumber[j] - '0' : 0;\n        int sum= number1 + number2 + carry;\n        carry= sum / 10;\n        result.push_back('0' + sum % 10);\n    }\n    std::reverse(result.begin(), result.end());\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass NumArray\n{\n  public:\n    vector<int> prefixSum;\n\n    NumArray(vector<int> &inputNumbers)\n    {\n        prefixSum.resize(inputNumbers.size() + 1);\n        for(int index= 0; index < inputNumbers.size(); ++index)\n        {\n            prefixSum[index + 1]= prefixSum[index] + inputNumbers[index];\n        }\n    }\n\n    int sumRange(int leftIndex, int rightIndex)\n    {\n        return prefixSum[rightIndex + 1] - prefixSum[leftIndex];\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass NumArray\n{\n  public:\n    std::vector<int> prefixSum;\n\n    NumArray(std::vector<int> &inputNumbers)\n    {\n        prefixSum.resize(inputNumbers.size() + 1);\n        for(int index= 0; index < inputNumbers.size(); ++index)\n        {\n            prefixSum[index + 1]= prefixSum[index] + inputNumbers[index];\n        }\n    }\n\n    int sumRange(int leftIndex, int rightIndex)\n    {\n        return prefixSum[rightIndex + 1] - prefixSum[leftIndex];\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass NumMatrix\n{\n  public:\n    vector<vector<int>> cumulativeSumMatrix;\n    \n    NumMatrix(vector<vector<int>> &inputMatrix)\n    {\n        int rowCount= inputMatrix.size(), columnCount= inputMatrix[0].size();\n        cumulativeSumMatrix.resize(rowCount + 1, vector<int>(columnCount + 1, 0));\n        for(int rowIndex= 0; rowIndex < rowCount; rowIndex++)\n        {\n            for(int columnIndex= 0; columnIndex < columnCount; columnIndex++)\n            {\n                cumulativeSumMatrix[rowIndex + 1][columnIndex + 1]= cumulativeSumMatrix[rowIndex + 1][columnIndex] + cumulativeSumMatrix[rowIndex][columnIndex + 1] - cumulativeSumMatrix[rowIndex][columnIndex] + inputMatrix[rowIndex][columnIndex];\n            }\n        }\n    }\n\n    void update(int targetRow, int targetColumn, int newValue)\n    {\n        int oldValue= cumulativeSumMatrix[targetRow + 1][targetColumn + 1] - cumulativeSumMatrix[targetRow + 1][targetColumn] - cumulativeSumMatrix[targetRow][targetColumn + 1] + cumulativeSumMatrix[targetRow][targetColumn];\n        int valueDifference= newValue - oldValue;\n        for(int rowIndex= targetRow + 1; rowIndex < cumulativeSumMatrix.size(); rowIndex++)\n            for(int columnIndex= targetColumn + 1; columnIndex < cumulativeSumMatrix[0].size(); columnIndex++)\n                cumulativeSumMatrix[rowIndex][columnIndex]+= valueDifference;\n    }\n\n    int sumRegion(int startRow, int startColumn, int endRow, int endColumn)\n    {\n        return cumulativeSumMatrix[endRow + 1][endColumn + 1] - cumulativeSumMatrix[endRow + 1][startColumn] - cumulativeSumMatrix[startRow][endColumn + 1] + cumulativeSumMatrix[startRow][startColumn];\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass NumMatrix\n{\n  public:\n    std::vector<std::vector<int>> cumulativeSumMatrix;\n    \n    NumMatrix(std::vector<std::vector<int>> &inputMatrix)\n    {\n        int rowCount= inputMatrix.size(), columnCount= inputMatrix[0].size();\n        cumulativeSumMatrix.resize(rowCount + 1, std::vector<int>(columnCount + 1, 0));\n        for(int rowIndex= 0; rowIndex < rowCount; rowIndex++)\n        {\n            for(int columnIndex= 0; columnIndex < columnCount; columnIndex++)\n            {\n                cumulativeSumMatrix[rowIndex + 1][columnIndex + 1]= cumulativeSumMatrix[rowIndex + 1][columnIndex] + cumulativeSumMatrix[rowIndex][columnIndex + 1] - cumulativeSumMatrix[rowIndex][columnIndex] + inputMatrix[rowIndex][columnIndex];\n            }\n        }\n    }\n\n    void update(int targetRow, int targetColumn, int newValue)\n    {\n        int oldValue= cumulativeSumMatrix[targetRow + 1][targetColumn + 1] - cumulativeSumMatrix[targetRow + 1][targetColumn] - cumulativeSumMatrix[targetRow][targetColumn + 1] + cumulativeSumMatrix[targetRow][targetColumn];\n        int valueDifference= newValue - oldValue;\n        for(int rowIndex= targetRow + 1; rowIndex < cumulativeSumMatrix.size(); rowIndex++)\n            for(int columnIndex= targetColumn + 1; columnIndex < cumulativeSumMatrix[0].size(); columnIndex++)\n                cumulativeSumMatrix[rowIndex][columnIndex]+= valueDifference;\n    }\n\n    int sumRegion(int startRow, int startColumn, int endRow, int endColumn)\n    {\n        return cumulativeSumMatrix[endRow + 1][endColumn + 1] - cumulativeSumMatrix[endRow + 1][startColumn] - cumulativeSumMatrix[startRow][endColumn + 1] + cumulativeSumMatrix[startRow][startColumn];\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxProfit(vector<int> &stockPrices)\n{\n    int totalProfit= 0;\n    for(int currentDay= 1; currentDay < stockPrices.size(); ++currentDay)\n    {\n        totalProfit+= max(stockPrices[currentDay] - stockPrices[currentDay - 1], 0);\n    }\n    return totalProfit;\n}",
    "output": "#include <bits/stdc++.h>\nint maxProfit(std::vector<int> &stockPrices)\n{\n    int totalProfit= 0;\n    for(int currentDay= 1; currentDay < stockPrices.size(); ++currentDay)\n    {\n        totalProfit+= std::max(stockPrices[currentDay] - stockPrices[currentDay - 1], 0);\n    }\n    return totalProfit;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findMinHeightTrees(int nodeCount, vector<vector<int>> &edgeList)\n{\n    if(nodeCount == 1)\n        return {0};\n\n    vector<int> degreeCount(nodeCount, 0);\n    vector<vector<int>> adjacencyList(nodeCount);\n    for (int i = 0; i < edgeList.size(); ++i)\n    {\n        const auto &edge = edgeList[i];\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n        degreeCount[edge[0]]++;\n        degreeCount[edge[1]]++;\n    }\n\n    queue<int> leavesQueue;\n    for (int index = 0; index < nodeCount; ++index)\n    {\n        if (degreeCount[index] == 1)\n            leavesQueue.push(index);\n    }\n\n    while (nodeCount > 2)\n    {\n        int leavesSize = leavesQueue.size();\n        nodeCount -= leavesSize;\n        for (int index = 0; index < leavesSize; index++)\n        {\n            int leaf = leavesQueue.front();\n            leavesQueue.pop();\n            for (int j = 0; j < adjacencyList[leaf].size(); ++j)\n            {\n                int neighbor = adjacencyList[leaf][j];\n                if (--degreeCount[neighbor] == 1)\n                    leavesQueue.push(neighbor);\n            }\n        }\n    }\n\n    vector<int> result;\n    while (!leavesQueue.empty())\n    {\n        result.push_back(leavesQueue.front());\n        leavesQueue.pop();\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findMinHeightTrees(int nodeCount, std::vector<std::vector<int>> &edgeList)\n{\n    if(nodeCount == 1)\n        return {0};\n\n    std::vector<int> degreeCount(nodeCount, 0);\n    std::vector<std::vector<int>> adjacencyList(nodeCount);\n    for(const auto &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n        degreeCount[edge[0]]++;\n        degreeCount[edge[1]]++;\n    }\n\n    std::queue<int> leavesQueue;\n    for(int index= 0; index < nodeCount; ++index)\n    {\n        if(degreeCount[index] == 1)\n            leavesQueue.push(index);\n    }\n\n    while(nodeCount > 2)\n    {\n        int leavesSize= leavesQueue.size();\n        nodeCount-= leavesSize;\n        for(int index= 0; index < leavesSize; index++)\n        {\n            int leaf= leavesQueue.front();\n            leavesQueue.pop();\n            for(int neighbor : adjacencyList[leaf])\n            {\n                if(--degreeCount[neighbor] == 1)\n                    leavesQueue.push(neighbor);\n            }\n        }\n    }\n\n    std::vector<int> result;\n    while(!leavesQueue.empty())\n    {\n        result.push_back(leavesQueue.front());\n        leavesQueue.pop();\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> multiply(vector<vector<int>> &firstMatrix, vector<vector<int>> &secondMatrix)\n{\n    int rowCount= firstMatrix.size();\n    int columnCount= firstMatrix[0].size();\n    int resultColumnCount= secondMatrix[0].size();\n    vector<vector<int>> resultMatrix(rowCount, vector<int>(resultColumnCount, 0));\n    for(int rowIndex= 0; rowIndex < rowCount; rowIndex++)\n    {\n        for(int columnIndex= 0; columnIndex < columnCount; columnIndex++)\n        {\n            if(firstMatrix[rowIndex][columnIndex] != 0)\n            {\n                for(int resultColumnIndex= 0; resultColumnIndex < resultColumnCount; resultColumnIndex++)\n                {\n                    resultMatrix[rowIndex][resultColumnIndex]+= firstMatrix[rowIndex][columnIndex] * secondMatrix[columnIndex][resultColumnIndex];\n                }\n            }\n        }\n    }\n    return resultMatrix;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> multiply(std::vector<std::vector<int>> &firstMatrix, std::vector<std::vector<int>> &secondMatrix)\n{\n    int rowCount = firstMatrix.size();\n    int columnCount = firstMatrix[0].size();\n    int resultColumnCount = secondMatrix[0].size();\n    std::vector<std::vector<int>> resultMatrix(rowCount, std::vector<int>(resultColumnCount, 0));\n    \n    for(int rowIndex = 0; rowIndex < rowCount; rowIndex++)\n    {\n        for(int columnIndex = 0; columnIndex < columnCount; columnIndex++)\n        {\n            if(firstMatrix[rowIndex][columnIndex] != 0)\n            {\n                for(int resultColumnIndex = 0; resultColumnIndex < resultColumnCount; resultColumnIndex++)\n                {\n                    resultMatrix[rowIndex][resultColumnIndex] += firstMatrix[rowIndex][columnIndex] * secondMatrix[columnIndex][resultColumnIndex];\n                }\n            }\n        }\n    }\n    return resultMatrix;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxCoins(vector<int> &balloonValues)\n{\n    int totalBalloons= balloonValues.size();\n    balloonValues.insert(balloonValues.begin(), 1);\n    balloonValues.push_back(1);\n\n    vector<vector<int>> dynamicProgramming(totalBalloons + 2, vector<int>(totalBalloons + 2, 0));\n    for(int length= 1; length <= totalBalloons; length++)\n    {\n        for(int leftIndex= 1; leftIndex <= totalBalloons - length + 1; leftIndex++)\n        {\n            int rightIndex= leftIndex + length - 1;\n            for(int burstIndex= leftIndex; burstIndex <= rightIndex; burstIndex++)\n            {\n                dynamicProgramming[leftIndex][rightIndex]= max(dynamicProgramming[leftIndex][rightIndex],\n                                                               balloonValues[leftIndex - 1] * balloonValues[burstIndex] * balloonValues[rightIndex + 1] +\n                                                                   dynamicProgramming[leftIndex][burstIndex - 1] +\n                                                                   dynamicProgramming[burstIndex + 1][rightIndex]);\n            }\n        }\n    }\n\n    return dynamicProgramming[1][totalBalloons];\n}",
    "output": "#include <bits/stdc++.h>\nint maxCoins(std::vector<int> &balloonValues)\n{\n    int totalBalloons= balloonValues.size();\n    balloonValues.insert(balloonValues.begin(), 1);\n    balloonValues.push_back(1);\n\n    std::vector<std::vector<int>> dynamicProgramming(totalBalloons + 2, std::vector<int>(totalBalloons + 2, 0));\n    for(int length= 1; length <= totalBalloons; length++)\n    {\n        for(int leftIndex= 1; leftIndex <= totalBalloons - length + 1; leftIndex++)\n        {\n            int rightIndex= leftIndex + length - 1;\n            for(int burstIndex= leftIndex; burstIndex <= rightIndex; burstIndex++)\n            {\n                dynamicProgramming[leftIndex][rightIndex]= std::max(dynamicProgramming[leftIndex][rightIndex],\n                                                               balloonValues[leftIndex - 1] * balloonValues[burstIndex] * balloonValues[rightIndex + 1] +\n                                                                   dynamicProgramming[leftIndex][burstIndex - 1] +\n                                                                   dynamicProgramming[burstIndex + 1][rightIndex]);\n            }\n        }\n    }\n\n    return dynamicProgramming[1][totalBalloons];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For INT_MAX\nusing namespace std;\n\nint getNthSuperUglyNumber(int n, vector<int> &primeNumbers)\n{\n    vector<int> uglyNumbers(n);\n    uglyNumbers[0]= 1;\n    vector<int> primeIndices(primeNumbers.size(), 0);\n\n    for(int i= 1; i < n; i++)\n    {\n        int minimumValue= INT_MAX;\n\n        for(int j= 0; j < primeNumbers.size(); j++)\n            minimumValue= min(minimumValue, uglyNumbers[primeIndices[j]] * primeNumbers[j]);\n\n        uglyNumbers[i]= minimumValue;\n\n        for(int j= 0; j < primeNumbers.size(); j++)\n            if(uglyNumbers[i] == uglyNumbers[primeIndices[j]] * primeNumbers[j])\n                primeIndices[j]++;\n    }\n\n    return uglyNumbers.back();\n}",
    "output": "#include <bits/stdc++.h>\nint getNthSuperUglyNumber(int n, std::vector<int> &primeNumbers)\n{\n    std::vector<int> uglyNumbers(n);\n    uglyNumbers[0] = 1;\n    std::vector<int> primeIndices(primeNumbers.size(), 0);\n\n    for(int i = 1; i < n; i++)\n    {\n        int minimumValue = std::numeric_limits<int>::max();\n\n        for(int j = 0; j < primeNumbers.size(); j++)\n            minimumValue = std::min(minimumValue, uglyNumbers[primeIndices[j]] * primeNumbers[j]);\n\n        uglyNumbers[i] = minimumValue;\n\n        for(int j = 0; j < primeNumbers.size(); j++)\n            if(uglyNumbers[i] == uglyNumbers[primeIndices[j]] * primeNumbers[j])\n                primeIndices[j]++;\n    }\n\n    return uglyNumbers.back();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nvector<vector<int>> verticalOrder(TreeNode *root)\n{\n    if(!root)\n        return {};\n\n    map<int, vector<int>> columnTable;\n    queue<pair<TreeNode *, int>> queue;\n    queue.push({root, 0});\n\n    while(!queue.empty())\n    {\n        TreeNode *currentNode = queue.front().first;\n        int columnIndex = queue.front().second;\n        queue.pop();\n\n        if(currentNode)\n        {\n            columnTable[columnIndex].push_back(currentNode->value);\n            queue.push({currentNode->leftChild, columnIndex - 1});\n            queue.push({currentNode->rightChild, columnIndex + 1});\n        }\n    }\n\n    vector<vector<int>> result;\n    for (auto it = columnTable.begin(); it != columnTable.end(); ++it)\n    {\n        result.push_back(move(it->second));\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nclass TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nstd::vector<std::vector<int>> verticalOrder(TreeNode *root)\n{\n    if(!root)\n        return {};\n\n    std::map<int, std::vector<int>> columnTable;\n    std::queue<std::pair<TreeNode *, int>> queue;\n    queue.push({root, 0});\n\n    while(!queue.empty())\n    {\n        TreeNode *currentNode= queue.front().first;\n        int columnIndex= queue.front().second;\n        queue.pop();\n\n        if(currentNode)\n        {\n            columnTable[columnIndex].push_back(currentNode->value);\n            queue.push({currentNode->leftChild, columnIndex - 1});\n            queue.push({currentNode->rightChild, columnIndex + 1});\n        }\n    }\n\n    std::vector<std::vector<int>> result;\n    for(auto &[_, values] : columnTable)\n    {\n        result.push_back(std::move(values));\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countSmaller(vector<int> &inputNumbers)\n{\n    vector<int> smallerCount(inputNumbers.size(), 0);\n    vector<int> indices(inputNumbers.size(), 0);\n\n    for(int index= 0; index < inputNumbers.size(); ++index)\n    {\n        indices[index]= index;\n    }\n\n    mergeSort(inputNumbers, indices, smallerCount, 0, inputNumbers.size() - 1);\n    return smallerCount;\n}\n\nvoid mergeSort(vector<int> &inputNumbers, vector<int> &indices, vector<int> &smallerCount, int leftIndex, int rightIndex)\n{\n    if(leftIndex >= rightIndex)\n    {\n        return;\n    }\n\n    int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n    mergeSort(inputNumbers, indices, smallerCount, leftIndex, midIndex);\n    mergeSort(inputNumbers, indices, smallerCount, midIndex + 1, rightIndex);\n\n    int leftPointer= leftIndex;\n    int rightPointer= midIndex + 1;\n    int tempIndex= 0;\n    vector<int> tempArray(rightIndex - leftIndex + 1);\n    while(leftPointer <= midIndex && rightPointer <= rightIndex)\n    {\n        if(inputNumbers[indices[leftPointer]] <= inputNumbers[indices[rightPointer]])\n        {\n            smallerCount[indices[leftPointer]]+= (rightPointer - midIndex - 1);\n            tempArray[tempIndex++]= indices[leftPointer++];\n        }\n        else\n        {\n            tempArray[tempIndex++]= indices[rightPointer++];\n        }\n    }\n\n    while(leftPointer <= midIndex)\n    {\n        smallerCount[indices[leftPointer]]+= (rightPointer - midIndex - 1);\n        tempArray[tempIndex++]= indices[leftPointer++];\n    }\n\n    while(rightPointer <= rightIndex)\n    {\n        tempArray[tempIndex++]= indices[rightPointer++];\n    }\n\n    for(int index= leftIndex, k= 0; index <= rightIndex; ++index, ++k)\n    {\n        indices[index]= tempArray[k];\n    }\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> countSmaller(std::vector<int> &inputNumbers)\n{\n    std::vector<int> smallerCount(inputNumbers.size(), 0);\n    std::vector<int> indices(inputNumbers.size(), 0);\n\n    for(int index= 0; index < inputNumbers.size(); ++index)\n    {\n        indices[index]= index;\n    }\n\n    mergeSort(inputNumbers, indices, smallerCount, 0, inputNumbers.size() - 1);\n    return smallerCount;\n}\n\nvoid mergeSort(std::vector<int> &inputNumbers, std::vector<int> &indices, std::vector<int> &smallerCount, int leftIndex, int rightIndex)\n{\n    if(leftIndex >= rightIndex)\n    {\n        return;\n    }\n\n    int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n    mergeSort(inputNumbers, indices, smallerCount, leftIndex, midIndex);\n    mergeSort(inputNumbers, indices, smallerCount, midIndex + 1, rightIndex);\n\n    int leftPointer= leftIndex;\n    int rightPointer= midIndex + 1;\n    int tempIndex= 0;\n    std::vector<int> tempArray(rightIndex - leftIndex + 1);\n    while(leftPointer <= midIndex && rightPointer <= rightIndex)\n    {\n        if(inputNumbers[indices[leftPointer]] <= inputNumbers[indices[rightPointer]])\n        {\n            smallerCount[indices[leftPointer]]+= (rightPointer - midIndex - 1);\n            tempArray[tempIndex++]= indices[leftPointer++];\n        }\n        else\n        {\n            tempArray[tempIndex++]= indices[rightPointer++];\n        }\n    }\n\n    while(leftPointer <= midIndex)\n    {\n        smallerCount[indices[leftPointer]]+= (rightPointer - midIndex - 1);\n        tempArray[tempIndex++]= indices[leftPointer++];\n    }\n\n    while(rightPointer <= rightIndex)\n    {\n        tempArray[tempIndex++]= indices[rightPointer++];\n    }\n\n    for(int index= leftIndex, k= 0; index <= rightIndex; ++index, ++k)\n    {\n        indices[index]= tempArray[k];\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring removeDuplicateLetters(string inputString)\n{\n    vector<int> characterCount(256, 0);\n    vector<bool> isVisited(256, false);\n    stack<char> characterStack;\n\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentChar = inputString[i];\n        characterCount[currentChar]++;\n    }\n\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentChar = inputString[i];\n        characterCount[currentChar]--;\n        if (isVisited[currentChar])\n            continue;\n        while (!characterStack.empty() && currentChar < characterStack.top() && characterCount[characterStack.top()] > 0)\n        {\n            isVisited[characterStack.top()] = false;\n            characterStack.pop();\n        }\n        characterStack.push(currentChar);\n        isVisited[currentChar] = true;\n    }\n\n    string resultString = \"\";\n    while (!characterStack.empty())\n    {\n        resultString = characterStack.top() + resultString;\n        characterStack.pop();\n    }\n    return resultString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string removeDuplicateLetters(std::string inputString)\n{\n    std::vector<int> characterCount(256, 0);\n    std::vector<bool> isVisited(256, false);\n    std::stack<char> characterStack;\n\n    for(char currentChar : inputString)\n    {\n        characterCount[currentChar]++;\n    }\n\n    for(char currentChar : inputString)\n    {\n        characterCount[currentChar]--;\n        if(isVisited[currentChar])\n            continue;\n        while(!characterStack.empty() && currentChar < characterStack.top() && characterCount[characterStack.top()] > 0)\n        {\n            isVisited[characterStack.top()]= false;\n            characterStack.pop();\n        }\n        characterStack.push(currentChar);\n        isVisited[currentChar]= true;\n    }\n\n    std::string resultString= \"\";\n    while(!characterStack.empty())\n    {\n        resultString= characterStack.top() + resultString;\n        characterStack.pop();\n    }\n    return resultString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestDistance(vector<vector<int>> &grid)\n{\n    int rowCount = grid.size();\n    int colCount = grid[0].size();\n\n    vector<vector<int>> houseReachCount(rowCount, vector<int>(colCount, 0));\n    vector<vector<int>> distanceSum(rowCount, vector<int>(colCount, 0));\n    int totalHouses = 0;\n\n    int directions[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n    for (int row = 0; row < rowCount; row++)\n    {\n        for (int col = 0; col < colCount; col++)\n        {\n            if (grid[row][col] == 1)\n            {\n                totalHouses++;\n                queue<pair<int, int>> bfsQueue;\n                bfsQueue.push({row, col});\n                vector<vector<bool>> visited(rowCount, vector<bool>(colCount, false));\n                int currentLevel = 1;\n                while (!bfsQueue.empty())\n                {\n                    int queueSize = bfsQueue.size();\n                    for (int qIndex = 0; qIndex < queueSize; qIndex++)\n                    {\n                        int x = bfsQueue.front().first;\n                        int y = bfsQueue.front().second;\n                        bfsQueue.pop();\n                        for (int d = 0; d < 4; d++)\n                        {\n                            int newX = x + directions[d][0];\n                            int newY = y + directions[d][1];\n                            if (newX >= 0 && newX < rowCount && newY >= 0 && newY < colCount && !visited[newX][newY] && grid[newX][newY] == 0)\n                            {\n                                visited[newX][newY] = true;\n                                bfsQueue.push({newX, newY});\n                                distanceSum[newX][newY] += currentLevel;\n                                houseReachCount[newX][newY]++;\n                            }\n                        }\n                    }\n                    currentLevel++;\n                }\n            }\n        }\n    }\n\n    int minimumDistance = INT_MAX;\n    for (int row = 0; row < rowCount; row++)\n    {\n        for (int col = 0; col < colCount; col++)\n        {\n            if (houseReachCount[row][col] == totalHouses)\n            {\n                minimumDistance = min(minimumDistance, distanceSum[row][col]);\n            }\n        }\n    }\n\n    return minimumDistance == INT_MAX ? -1 : minimumDistance;\n}",
    "output": "#include <bits/stdc++.h>\nint shortestDistance(std::vector<std::vector<int>> &grid)\n{\n    int rowCount = grid.size();\n    int colCount = grid[0].size();\n\n    std::vector<std::vector<int>> houseReachCount(rowCount, std::vector<int>(colCount, 0));\n    std::vector<std::vector<int>> distanceSum(rowCount, std::vector<int>(colCount, 0));\n    int totalHouses = 0;\n\n    int directions[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n    for(int row = 0; row < rowCount; row++)\n    {\n        for(int col = 0; col < colCount; col++)\n        {\n            if(grid[row][col] == 1)\n            {\n                totalHouses++;\n                std::queue<std::pair<int, int>> bfsQueue;\n                bfsQueue.push({row, col});\n                std::vector<std::vector<bool>> visited(rowCount, std::vector<bool>(colCount, false));\n                int currentLevel = 1;\n                while(!bfsQueue.empty())\n                {\n                    int queueSize = bfsQueue.size();\n                    for(int qIndex = 0; qIndex < queueSize; qIndex++)\n                    {\n                        int x = bfsQueue.front().first;\n                        int y = bfsQueue.front().second;\n                        bfsQueue.pop();\n                        for(auto &direction : directions)\n                        {\n                            int newX = x + direction[0];\n                            int newY = y + direction[1];\n                            if(newX >= 0 && newX < rowCount && newY >= 0 && newY < colCount && !visited[newX][newY] && grid[newX][newY] == 0)\n                            {\n                                visited[newX][newY] = true;\n                                bfsQueue.push({newX, newY});\n                                distanceSum[newX][newY] += currentLevel;\n                                houseReachCount[newX][newY]++;\n                            }\n                        }\n                    }\n                    currentLevel++;\n                }\n            }\n        }\n    }\n\n    int minimumDistance = std::numeric_limits<int>::max();\n    for(int row = 0; row < rowCount; row++)\n    {\n        for(int col = 0; col < colCount; col++)\n        {\n            if(houseReachCount[row][col] == totalHouses)\n            {\n                minimumDistance = std::min(minimumDistance, distanceSum[row][col]);\n            }\n        }\n    }\n\n    return minimumDistance == std::numeric_limits<int>::max() ? -1 : minimumDistance;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxProduct(vector<string> &wordList)\n{\n    int wordCount = wordList.size();\n    vector<int> characterMask(wordCount, 0);\n    for (int wordIndex = 0; wordIndex < wordCount; ++wordIndex)\n    {\n        for (int j = 0; j < wordList[wordIndex].size(); ++j)\n        {\n            char character = wordList[wordIndex][j];\n            characterMask[wordIndex] |= (1 << (character - 'a'));\n        }\n    }\n\n    int maximumProduct = 0;\n    for (int firstWordIndex = 0; firstWordIndex < wordCount; ++firstWordIndex)\n    {\n        for (int secondWordIndex = firstWordIndex + 1; secondWordIndex < wordCount; ++secondWordIndex)\n        {\n            if ((characterMask[firstWordIndex] & characterMask[secondWordIndex]) == 0)\n            {\n                maximumProduct = max(maximumProduct, int(wordList[firstWordIndex].length() * wordList[secondWordIndex].length()));\n            }\n        }\n    }\n\n    return maximumProduct;\n}",
    "output": "#include <bits/stdc++.h>\nint maxProduct(std::vector<std::string> &wordList)\n{\n    int wordCount= wordList.size();\n    std::vector<int> characterMask(wordCount, 0);\n    for(int wordIndex= 0; wordIndex < wordCount; ++wordIndex)\n    {\n        for(char character : wordList[wordIndex])\n        {\n            characterMask[wordIndex]|= (1 << (character - 'a'));\n        }\n    }\n\n    int maximumProduct= 0;\n    for(int firstWordIndex= 0; firstWordIndex < wordCount; ++firstWordIndex)\n    {\n        for(int secondWordIndex= firstWordIndex + 1; secondWordIndex < wordCount; ++secondWordIndex)\n        {\n            if((characterMask[firstWordIndex] & characterMask[secondWordIndex]) == 0)\n            {\n                maximumProduct= std::max(maximumProduct, int(wordList[firstWordIndex].length() * wordList[secondWordIndex].length()));\n            }\n        }\n    }\n\n    return maximumProduct;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int bulbSwitch(int totalBulbs)\n{\n    return sqrt(totalBulbs);\n}",
    "output": "int bulbSwitch(int totalBulbs)\n{\n    return sqrt(totalBulbs);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> generateAbbreviations(string originalWord)\n{\n    vector<string> abbreviatedWords;\n    abbreviatedWords.push_back(originalWord.empty() ? \"\" : to_string(originalWord.size()));\n    for(size_t index = 0; index < originalWord.size(); ++index)\n    {\n        vector<string> abbreviations = generateAbbreviations(originalWord.substr(index + 1));\n        for(size_t j = 0; j < abbreviations.size(); ++j)\n        {\n            const string &abbreviation = abbreviations[j];\n            size_t number;\n            if(abbreviation.empty() || (number = abbreviation.find_first_not_of('123456789')) > 0)\n                abbreviatedWords.push_back(originalWord.substr(0, index) + '1' + abbreviation);\n            if(index == 0 || abbreviation.empty() || abbreviation[0] > '9')\n                abbreviatedWords.push_back(originalWord.substr(0, index + 1) + abbreviation);\n        }\n    }\n    return abbreviatedWords;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> generateAbbreviations(std::string originalWord)\n{\n    std::vector<std::string> abbreviatedWords;\n    abbreviatedWords.push_back(originalWord.empty() ? \"\" : std::to_string(originalWord.size()));\n    for(size_t index= 0; index < originalWord.size(); ++index)\n        for(const std::string &abbreviation : generateAbbreviations(originalWord.substr(index + 1)))\n        {\n            size_t number;\n            if(abbreviation.empty() || (number= abbreviation.find_first_not_of('123456789')) > 0)\n                abbreviatedWords.push_back(originalWord.substr(0, index) + '1' + abbreviation);\n            if(index == 0 || abbreviation.empty() || abbreviation[0] > '9')\n                abbreviatedWords.push_back(originalWord.substr(0, index + 1) + abbreviation);\n        }\n    return abbreviatedWords;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> getMaxNumber(vector<int> &firstArray, vector<int> &secondArray, int maxLength)\n{\n    int firstArraySize = firstArray.size(), secondArraySize = secondArray.size();\n    vector<int> result(maxLength, 0);\n    for(int i = max(0, maxLength - secondArraySize); i <= maxLength && i <= firstArraySize; ++i)\n    {\n        vector<int> candidate = merge(maxSubArray(firstArray, i), maxSubArray(secondArray, maxLength - i), maxLength);\n        if(isGreater(candidate, 0, result, 0))\n            result = candidate;\n    }\n    return result;\n}\n\nvector<int> maxSubArray(vector<int> &nums, int k)\n{\n    int numsSize = nums.size();\n    vector<int> result(k, 0);\n    for(int i = 0, j = 0; i < numsSize; ++i)\n    {\n        while(numsSize - i > k - j && j > 0 && result[j - 1] < nums[i])\n            j--;\n        if(j < k)\n            result[j++] = nums[i];\n    }\n    return result;\n}\n\nvector<int> merge(vector<int> &firstArray, vector<int> &secondArray, int k)\n{\n    vector<int> result(k, 0);\n    for(int i = 0, j = 0, r = 0; r < k; ++r)\n        result[r] = isGreater(firstArray, i, secondArray, j) ? firstArray[i++] : secondArray[j++];\n    return result;\n}\n\nbool isGreater(vector<int> &firstArray, int firstIndex, vector<int> &secondArray, int secondIndex)\n{\n    while(firstIndex < firstArray.size() && secondIndex < secondArray.size() && firstArray[firstIndex] == secondArray[secondIndex])\n    {\n        firstIndex++;\n        secondIndex++;\n    }\n    return secondIndex == secondArray.size() || (firstIndex < firstArray.size() && firstArray[firstIndex] > secondArray[secondIndex]);\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> getMaxNumber(std::vector<int> &firstArray, std::vector<int> &secondArray, int maxLength)\n{\n    int firstArraySize= firstArray.size(), secondArraySize= secondArray.size();\n    std::vector<int> result(maxLength, 0);\n    for(int i= std::max(0, maxLength - secondArraySize); i <= maxLength && i <= firstArraySize; ++i)\n    {\n        std::vector<int> candidate= merge(maxSubArray(firstArray, i), maxSubArray(secondArray, maxLength - i), maxLength);\n        if(isGreater(candidate, 0, result, 0))\n            result= candidate;\n    }\n    return result;\n}\n\nstd::vector<int> maxSubArray(std::vector<int> &nums, int k)\n{\n    int numsSize= nums.size();\n    std::vector<int> result(k, 0);\n    for(int i= 0, j= 0; i < numsSize; ++i)\n    {\n        while(numsSize - i > k - j && j > 0 && result[j - 1] < nums[i])\n            j--;\n        if(j < k)\n            result[j++]= nums[i];\n    }\n    return result;\n}\n\nstd::vector<int> merge(std::vector<int> &firstArray, std::vector<int> &secondArray, int k)\n{\n    std::vector<int> result(k, 0);\n    for(int i= 0, j= 0, r= 0; r < k; ++r)\n        result[r]= isGreater(firstArray, i, secondArray, j) ? firstArray[i++] : secondArray[j++];\n    return result;\n}\n\nbool isGreater(std::vector<int> &firstArray, int firstIndex, std::vector<int> &secondArray, int secondIndex)\n{\n    while(firstIndex < firstArray.size() && secondIndex < secondArray.size() && firstArray[firstIndex] == secondArray[secondIndex])\n    {\n        firstIndex++;\n        secondIndex++;\n    }\n    return secondIndex == secondArray.size() || (firstIndex < firstArray.size() && firstArray[firstIndex] > secondArray[secondIndex]);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint coinChange(vector<int> &coinValues, int targetAmount)\n{\n    vector<int> minimumCoins(targetAmount + 1, targetAmount + 1);\n    minimumCoins[0] = 0;\n\n    for(int coinIndex = 0; coinIndex < coinValues.size(); coinIndex++)\n    {\n        for(int currentAmount = coinValues[coinIndex]; currentAmount <= targetAmount; currentAmount++)\n        {\n            minimumCoins[currentAmount] = min(minimumCoins[currentAmount], minimumCoins[currentAmount - coinValues[coinIndex]] + 1);\n        }\n    }\n\n    return minimumCoins[targetAmount] <= targetAmount ? minimumCoins[targetAmount] : -1;\n}",
    "output": "#include <bits/stdc++.h>\nint coinChange(std::vector<int> &coinValues, int targetAmount)\n{\n    std::vector<int> minimumCoins(targetAmount + 1, targetAmount + 1);\n    minimumCoins[0]= 0;\n\n    for(int coinIndex= 0; coinIndex < coinValues.size(); coinIndex++)\n    {\n        for(int currentAmount= coinValues[coinIndex]; currentAmount <= targetAmount; currentAmount++)\n        {\n            minimumCoins[currentAmount]= std::min(minimumCoins[currentAmount], minimumCoins[currentAmount - coinValues[coinIndex]] + 1);\n        }\n    }\n\n    return minimumCoins[targetAmount] <= targetAmount ? minimumCoins[targetAmount] : -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countComponents(int totalNodes, vector<vector<int>> &edges)\n{\n    vector<vector<int>> adjacencyList(totalNodes);\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        adjacencyList[edges[i][0]].push_back(edges[i][1]);\n        adjacencyList[edges[i][1]].push_back(edges[i][0]);\n    }\n\n    vector<bool> visitedNodes(totalNodes, false);\n    int numberOfConnectedComponents = 0;\n\n    for (int currentNode = 0; currentNode < totalNodes; ++currentNode)\n    {\n        if (!visitedNodes[currentNode])\n        {\n            function<void(int)> depthFirstSearch = [&](int node)\n            {\n                visitedNodes[node] = true;\n                for (int j = 0; j < adjacencyList[node].size(); ++j)\n                {\n                    int neighbor = adjacencyList[node][j];\n                    if (!visitedNodes[neighbor])\n                    {\n                        depthFirstSearch(neighbor);\n                    }\n                }\n            };\n            depthFirstSearch(currentNode);\n            numberOfConnectedComponents++;\n        }\n    }\n    return numberOfConnectedComponents;\n}",
    "output": "#include <bits/stdc++.h>\nint countComponents(int totalNodes, std::vector<std::vector<int>> &edges)\n{\n    std::vector<std::vector<int>> adjacencyList(totalNodes);\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<bool> visitedNodes(totalNodes, false);\n    int numberOfConnectedComponents= 0;\n\n    for(int currentNode= 0; currentNode < totalNodes; ++currentNode)\n    {\n        if(!visitedNodes[currentNode])\n        {\n            std::function<void(int)> depthFirstSearch= [&](int node)\n            {\n                visitedNodes[node]= true;\n                for(int neighbor : adjacencyList[node])\n                {\n                    if(!visitedNodes[neighbor])\n                    {\n                        depthFirstSearch(neighbor);\n                    }\n                }\n            };\n            depthFirstSearch(currentNode);\n            numberOfConnectedComponents++;\n        }\n    }\n    return numberOfConnectedComponents;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid wiggleSort(vector<int> &numberList)\n{\n    sort(numberList.begin(), numberList.end());\n    for(int index= 1; index < numberList.size() - 1; index+= 2)\n    {\n        swap(numberList[index], numberList[index + 1]);\n    }\n}",
    "output": "#include <bits/stdc++.h>\nvoid wiggleSort(std::vector<int> &numberList)\n{\n    std::sort(numberList.begin(), numberList.end());\n    for(int index= 1; index < numberList.size() - 1; index+= 2)\n    {\n        std::swap(numberList[index], numberList[index + 1]);\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSubArrayLen(vector<int> &numbers, int targetSum)\n{\n    unordered_map<int, int> sumIndexMap;\n    int maximumLength= 0, currentSum= 0;\n    for(int index= 0; index < numbers.size(); index++)\n    {\n        currentSum+= numbers[index];\n        if(currentSum == targetSum)\n            maximumLength= index + 1;\n        if(sumIndexMap.count(currentSum - targetSum))\n            maximumLength= max(maximumLength, index - sumIndexMap[currentSum - targetSum]);\n        if(!sumIndexMap.count(currentSum))\n            sumIndexMap[currentSum]= index;\n    }\n    return maximumLength;\n}",
    "output": "#include <bits/stdc++.h>\nint maxSubArrayLen(std::vector<int> &numbers, int targetSum)\n{\n    std::unordered_map<int, int> sumIndexMap;\n    int maximumLength= 0, currentSum= 0;\n    for(int index= 0; index < numbers.size(); index++)\n    {\n        currentSum+= numbers[index];\n        if(currentSum == targetSum)\n            maximumLength= index + 1;\n        if(sumIndexMap.count(currentSum - targetSum))\n            maximumLength= std::max(maximumLength, index - sumIndexMap[currentSum - targetSum]);\n        if(!sumIndexMap.count(currentSum))\n            sumIndexMap[currentSum]= index;\n    }\n    return maximumLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "bool isPowerOfThree(int number)\n{\n    if(number < 1)\n    {\n        return false;\n    }\n\n    while(number % 3 == 0)\n    {\n        number/= 3;\n    }\n\n    return number == 1;\n}",
    "output": "bool isPowerOfThree(int number)\n{\n    if(number < 1)\n    {\n        return false;\n    }\n\n    while(number % 3 == 0)\n    {\n        number/= 3;\n    }\n\n    return number == 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countRangeSum(vector<int> &numbers, int lowerBound, int upperBound)\n{\n    int size= numbers.size();\n    vector<long> prefixSums(size + 1, 0);\n    for(int index= 0; index < size; ++index)\n        prefixSums[index + 1]= prefixSums[index] + numbers[index];\n\n    function<int(int, int)> mergeSort= [&](int start, int end)\n    {\n        if(start == end)\n            return 0;\n        int mid= start + (end - start) / 2;\n        int count= mergeSort(start, mid) + mergeSort(mid + 1, end);\n\n        int rightIndex= mid + 1, upperIndex= mid + 1;\n        for(int leftIndex= start; leftIndex <= mid; ++leftIndex)\n        {\n            while(rightIndex <= end && prefixSums[rightIndex] - prefixSums[leftIndex] < lowerBound)\n                ++rightIndex;\n            while(upperIndex <= end && prefixSums[upperIndex] - prefixSums[leftIndex] <= upperBound)\n                ++upperIndex;\n            count+= upperIndex - rightIndex;\n        }\n\n        inplace_merge(prefixSums.begin() + start, prefixSums.begin() + mid + 1, prefixSums.begin() + end + 1);\n        return count;\n    };\n\n    return mergeSort(0, size);\n}",
    "output": "#include <bits/stdc++.h>\nint countRangeSum(std::vector<int> &numbers, int lowerBound, int upperBound)\n{\n    int size= numbers.size();\n    std::vector<long> prefixSums(size + 1, 0);\n    for(int index= 0; index < size; ++index)\n        prefixSums[index + 1]= prefixSums[index] + numbers[index];\n\n    std::function<int(int, int)> mergeSort= [&](int start, int end)\n    {\n        if(start == end)\n            return 0;\n        int mid= start + (end - start) / 2;\n        int count= mergeSort(start, mid) + mergeSort(mid + 1, end);\n\n        int rightIndex= mid + 1, upperIndex= mid + 1;\n        for(int leftIndex= start; leftIndex <= mid; ++leftIndex)\n        {\n            while(rightIndex <= end && prefixSums[rightIndex] - prefixSums[leftIndex] < lowerBound)\n                ++rightIndex;\n            while(upperIndex <= end && prefixSums[upperIndex] - prefixSums[leftIndex] <= upperBound)\n                ++upperIndex;\n            count+= upperIndex - rightIndex;\n        }\n\n        std::inplace_merge(prefixSums.begin() + start, prefixSums.begin() + mid + 1, prefixSums.begin() + end + 1);\n        return count;\n    };\n\n    return mergeSort(0, size);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode() : value(0), next(NULL) {}\n    ListNode(int x) : value(x), next(NULL) {}\n    ListNode(int x, ListNode *next) : value(x), next(next) {}\n};\n\nListNode *rearrangeOddEvenList(ListNode *head)\n{\n    if(!head)\n        return NULL;\n    ListNode *oddNode= head, *evenNode= head->next, *evenHead= evenNode;\n    while(evenNode && evenNode->next)\n    {\n        oddNode->next= evenNode->next;\n        oddNode= oddNode->next;\n        evenNode->next= oddNode->next;\n        evenNode= evenNode->next;\n    }\n    oddNode->next= evenHead;\n    return head;\n}",
    "output": "struct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode() : value(0), next(NULL) {}\n    ListNode(int x) : value(x), next(NULL) {}\n    ListNode(int x, ListNode *next) : value(x), next(next) {}\n};\n\nListNode *rearrangeOddEvenList(ListNode *head)\n{\n    if(!head)\n        return NULL;\n    ListNode *oddNode= head, *evenNode= head->next, *evenHead= evenNode;\n    while(evenNode && evenNode->next)\n    {\n        oddNode->next= evenNode->next;\n        oddNode= oddNode->next;\n        evenNode->next= oddNode->next;\n        evenNode= evenNode->next;\n    }\n    oddNode->next= evenHead;\n    return head;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint directionX[]= {0, 0, 1, -1};\nint directionY[]= {1, -1, 0, 0};\n\nint depthFirstSearch(vector<vector<int>> &inputMatrix, vector<vector<int>> &memoizationTable, int rowIndex, int columnIndex)\n{\n    if(memoizationTable[rowIndex][columnIndex] != 0)\n        return memoizationTable[rowIndex][columnIndex];\n\n    int maxLength= 0;\n    for(int directionIndex= 0; directionIndex < 4; ++directionIndex)\n    {\n        int newRowIndex= rowIndex + directionX[directionIndex], newColumnIndex= columnIndex + directionY[directionIndex];\n        if(newRowIndex >= 0 && newRowIndex < inputMatrix.size() && newColumnIndex >= 0 && newColumnIndex < inputMatrix[0].size() && inputMatrix[newRowIndex][newColumnIndex] > inputMatrix[rowIndex][columnIndex])\n        {\n            maxLength= max(maxLength, depthFirstSearch(inputMatrix, memoizationTable, newRowIndex, newColumnIndex));\n        }\n    }\n\n    memoizationTable[rowIndex][columnIndex]= maxLength + 1;\n    return memoizationTable[rowIndex][columnIndex];\n}\n\nint longestIncreasingPath(vector<vector<int>> &inputMatrix)\n{\n    int rowCount= inputMatrix.size(), columnCount= inputMatrix[0].size();\n\n    vector<vector<int>> memoizationTable(rowCount, vector<int>(columnCount, 0));\n\n    int result= 0;\n    for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n        for(int columnIndex= 0; columnIndex < columnCount; ++columnIndex)\n            result= max(result, depthFirstSearch(inputMatrix, memoizationTable, rowIndex, columnIndex));\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nint directionX[]= {0, 0, 1, -1};\nint directionY[]= {1, -1, 0, 0};\n\nint depthFirstSearch(std::vector<std::vector<int>> &inputMatrix, std::vector<std::vector<int>> &memoizationTable, int rowIndex, int columnIndex)\n{\n    if(memoizationTable[rowIndex][columnIndex] != 0)\n        return memoizationTable[rowIndex][columnIndex];\n\n    int maxLength= 0;\n    for(int directionIndex= 0; directionIndex < 4; ++directionIndex)\n    {\n        int newRowIndex= rowIndex + directionX[directionIndex], newColumnIndex= columnIndex + directionY[directionIndex];\n        if(newRowIndex >= 0 && newRowIndex < inputMatrix.size() && newColumnIndex >= 0 && newColumnIndex < inputMatrix[0].size() && inputMatrix[newRowIndex][newColumnIndex] > inputMatrix[rowIndex][columnIndex])\n        {\n            maxLength= std::max(maxLength, depthFirstSearch(inputMatrix, memoizationTable, newRowIndex, newColumnIndex));\n        }\n    }\n\n    memoizationTable[rowIndex][columnIndex]= maxLength + 1;\n    return memoizationTable[rowIndex][columnIndex];\n}\n\nint longestIncreasingPath(std::vector<std::vector<int>> &inputMatrix)\n{\n    int rowCount= inputMatrix.size(), columnCount= inputMatrix[0].size();\n\n    std::vector<std::vector<int>> memoizationTable(rowCount, std::vector<int>(columnCount, 0));\n\n    int result= 0;\n    for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n        for(int columnIndex= 0; columnIndex < columnCount; ++columnIndex)\n            result= std::max(result, depthFirstSearch(inputMatrix, memoizationTable, rowIndex, columnIndex));\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minPatches(vector<int> &numbers, int targetSum)\n{\n    long long maxSum= 0;\n    int patchesCount= 0, currentIndex= 0;\n\n    while(maxSum < targetSum)\n    {\n        if(currentIndex < numbers.size() && numbers[currentIndex] <= maxSum + 1)\n        {\n            maxSum+= numbers[currentIndex];\n            currentIndex++;\n        }\n        else\n        {\n            maxSum+= maxSum + 1;\n            patchesCount++;\n        }\n    }\n    return patchesCount;\n}",
    "output": "#include <bits/stdc++.h>\nint minPatches(std::vector<int> &numbers, int targetSum)\n{\n    long long maxSum= 0;\n    int patchesCount= 0, currentIndex= 0;\n\n    while(maxSum < targetSum)\n    {\n        if(currentIndex < numbers.size() && numbers[currentIndex] <= maxSum + 1)\n        {\n            maxSum+= numbers[currentIndex];\n            currentIndex++;\n        }\n        else\n        {\n            maxSum+= maxSum + 1;\n            patchesCount++;\n        }\n    }\n    return patchesCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidSerialization(const string &preorderTraversal)\n{\n    istringstream inputStream(preorderTraversal);\n    string currentToken;\n    int availableSlots = 1;\n\n    while(getline(inputStream, currentToken, ','))\n    {\n        --availableSlots;\n        if(availableSlots < 0)\n            return false;\n        if(currentToken != \"#\")\n            availableSlots += 2;\n    }\n\n    return availableSlots == 0;\n}",
    "output": "#include <bits/stdc++.h>\nbool isValidSerialization(const std::string &preorderTraversal)\n{\n    std::istringstream inputStream(preorderTraversal);\n    std::string currentToken;\n    int availableSlots= 1;\n\n    while(std::getline(inputStream, currentToken, ','))\n    {\n        --availableSlots;\n        if(availableSlots < 0)\n            return false;\n        if(currentToken != \"#\")\n            availableSlots+= 2;\n    }\n\n    return availableSlots == 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> findItinerary(vector<vector<string>> &ticketList)\n{\n    unordered_map<string, multiset<string>> flightMap;\n    vector<string> itinerary;\n\n    for (int i = 0; i < ticketList.size(); ++i)\n        flightMap[ticketList[i][0]].insert(ticketList[i][1]);\n\n    stack<string> depthFirstStack;\n    depthFirstStack.push(\"JFK\");\n\n    while (!depthFirstStack.empty())\n    {\n        string currentAirport = depthFirstStack.top();\n        if (flightMap[currentAirport].empty())\n        {\n            itinerary.push_back(currentAirport);\n            depthFirstStack.pop();\n        }\n        else\n        {\n            depthFirstStack.push(*flightMap[currentAirport].begin());\n            flightMap[currentAirport].erase(flightMap[currentAirport].begin());\n        }\n    }\n\n    reverse(itinerary.begin(), itinerary.end());\n    return itinerary;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> findItinerary(std::vector<std::vector<std::string>> &ticketList)\n{\n    std::unordered_map<std::string, std::multiset<std::string>> flightMap;\n    std::vector<std::string> itinerary;\n\n    for(const auto &ticket : ticketList)\n        flightMap[ticket[0]].insert(ticket[1]);\n\n    std::stack<std::string> depthFirstStack;\n    depthFirstStack.push(\"JFK\");\n\n    while(!depthFirstStack.empty())\n    {\n        std::string currentAirport = depthFirstStack.top();\n        if(flightMap[currentAirport].empty())\n        {\n            itinerary.push_back(currentAirport);\n            depthFirstStack.pop();\n        }\n        else\n        {\n            depthFirstStack.push(*flightMap[currentAirport].begin());\n            flightMap[currentAirport].erase(flightMap[currentAirport].begin());\n        }\n    }\n\n    std::reverse(itinerary.begin(), itinerary.end());\n    return itinerary;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nstruct TreeInfo\n{\n    bool isBST;\n    int size;\n    int minValue;\n    int maxValue;\n};\n\nTreeInfo largestBSTUtil(TreeNode *root, int &largestBST)\n{\n    if(!root)\n        return {true, 0, INT_MAX, INT_MIN};\n\n    TreeInfo leftSubtree= largestBSTUtil(root->leftChild, largestBST);\n    TreeInfo rightSubtree= largestBSTUtil(root->rightChild, largestBST);\n\n    if(leftSubtree.isBST && root->value > leftSubtree.maxValue && rightSubtree.isBST && root->value < rightSubtree.minValue)\n    {\n        largestBST= max(largestBST, leftSubtree.size + 1 + rightSubtree.size);\n        return {true, leftSubtree.size + 1 + rightSubtree.size, min(root->value, leftSubtree.minValue), max(root->value, rightSubtree.maxValue)};\n    }\n\n    return {false, -1, INT_MAX, INT_MIN};\n}\n\nint largestBSTSubtree(TreeNode *root)\n{\n    int largestBST= 0;\n    largestBSTUtil(root, largestBST);\n    return largestBST;\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nstruct TreeInfo\n{\n    bool isBST;\n    int size;\n    int minValue;\n    int maxValue;\n};\n\nTreeInfo largestBSTUtil(TreeNode *root, int &largestBST)\n{\n    if(!root)\n        return {true, 0, INT_MAX, INT_MIN};\n\n    TreeInfo leftSubtree= largestBSTUtil(root->leftChild, largestBST);\n    TreeInfo rightSubtree= largestBSTUtil(root->rightChild, largestBST);\n\n    if(leftSubtree.isBST && root->value > leftSubtree.maxValue && rightSubtree.isBST && root->value < rightSubtree.minValue)\n    {\n        largestBST= max(largestBST, leftSubtree.size + 1 + rightSubtree.size);\n        return {true, leftSubtree.size + 1 + rightSubtree.size, min(root->value, leftSubtree.minValue), max(root->value, rightSubtree.maxValue)};\n    }\n\n    return {false, -1, INT_MAX, INT_MIN};\n}\n\nint largestBSTSubtree(TreeNode *root)\n{\n    int largestBST= 0;\n    largestBSTUtil(root, largestBST);\n    return largestBST;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For INT_MAX\nusing namespace std;\n\nbool findTriplets(vector<int> &numbers)\n{\n    int smallest= INT_MAX, secondSmallest= INT_MAX;\n\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        if(currentNumber <= smallest)\n        {\n            smallest = currentNumber;\n        }\n        else if(currentNumber <= secondSmallest)\n        {\n            secondSmallest = currentNumber;\n        }\n        else\n        {\n            return true;\n        }\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool findTriplets(std::vector<int> &numbers)\n{\n    int smallest = std::numeric_limits<int>::max();\n    int secondSmallest = std::numeric_limits<int>::max();\n\n    for(int currentNumber : numbers)\n    {\n        if(currentNumber <= smallest)\n        {\n            smallest = currentNumber;\n        }\n        else if(currentNumber <= secondSmallest)\n        {\n            secondSmallest = currentNumber;\n        }\n        else\n        {\n            return true;\n        }\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct pair_hash {\n    template <class T1, class T2>\n    std::size_t operator () (const std::pair<T1, T2>& pair) const {\n        auto hash1 = std::hash<T1>{}(pair.first);\n        auto hash2 = std::hash<T2>{}(pair.second);\n        return hash1 ^ hash2; // Combine the two hash values\n    }\n};\n\nbool isPathCrossing(const vector<int> &distance)\n{\n    unordered_set<pair<int, int>, pair_hash> visitedPositions;\n    int currentX = 0, currentY = 0;\n    visitedPositions.insert({currentX, currentY});\n    int directionX[] = {0, -1, 0, 1};\n    int directionY[] = {1, 0, -1, 0};\n\n    for(int stepIndex = 0; stepIndex < distance.size(); ++stepIndex)\n    {\n        int currentDirection = stepIndex % 4;\n        for(int stepCount = 0; stepCount < distance[stepIndex]; ++stepCount)\n        {\n            currentX += directionX[currentDirection];\n            currentY += directionY[currentDirection];\n            if(!visitedPositions.insert({currentX, currentY}).second)\n            {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
    "output": "bool isPathCrossing(const std::vector<int> &distance)\n{\n    std::unordered_set<std::pair<int, int>, pair_hash> visitedPositions;\n    int currentX= 0, currentY= 0;\n    visitedPositions.insert({currentX, currentY});\n    int directionX[]= {0, -1, 0, 1};\n    int directionY[]= {1, 0, -1, 0};\n\n    for(int stepIndex= 0; stepIndex < distance.size(); ++stepIndex)\n    {\n        int currentDirection= stepIndex % 4;\n        for(int stepCount= 0; stepCount < distance[stepIndex]; ++stepCount)\n        {\n            currentX+= directionX[currentDirection];\n            currentY+= directionY[currentDirection];\n            if(!visitedPositions.insert({currentX, currentY}).second)\n            {\n                return true;\n            }\n        }\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int, int>> findPalindromePairs(const vector<string> &wordList)\n{\n    vector<pair<int, int>> palindromePairIndices;\n\n    for(size_t firstIndex= 0; firstIndex < wordList.size(); firstIndex++)\n    {\n        for(size_t secondIndex= 0; secondIndex < wordList.size(); secondIndex++)\n        {\n            if(firstIndex == secondIndex)\n                continue;\n            string concatenatedWords= wordList[firstIndex] + wordList[secondIndex];\n\n            bool isPalindrome= true;\n            for(size_t leftIndex= 0, rightIndex= concatenatedWords.size() - 1; leftIndex < rightIndex; leftIndex++, rightIndex--)\n            {\n                if(concatenatedWords[leftIndex] != concatenatedWords[rightIndex])\n                {\n                    isPalindrome= false;\n                    break;\n                }\n            }\n\n            if(isPalindrome)\n            {\n                palindromePairIndices.push_back(make_pair(firstIndex, secondIndex));\n            }\n        }\n    }\n\n    return palindromePairIndices;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::pair<int, int>> findPalindromePairs(const std::vector<std::string> &wordList)\n{\n    std::vector<std::pair<int, int>> palindromePairIndices;\n\n    for(size_t firstIndex= 0; firstIndex < wordList.size(); firstIndex++)\n    {\n        for(size_t secondIndex= 0; secondIndex < wordList.size(); secondIndex++)\n        {\n            if(firstIndex == secondIndex)\n                continue;\n            std::string concatenatedWords= wordList[firstIndex] + wordList[secondIndex];\n\n            bool isPalindrome= true;\n            for(size_t leftIndex= 0, rightIndex= concatenatedWords.size() - 1; leftIndex < rightIndex; leftIndex++, rightIndex--)\n            {\n                if(concatenatedWords[leftIndex] != concatenatedWords[rightIndex])\n                {\n                    isPalindrome= false;\n                    break;\n                }\n            }\n\n            if(isPalindrome)\n            {\n                palindromePairIndices.push_back(std::make_pair(firstIndex, secondIndex));\n            }\n        }\n    }\n\n    return palindromePairIndices;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int robHelper(TreeNode *currentNode, int &includeCurrentNode, int &excludeCurrentNode)\n{\n    if(!currentNode)\n        return 0;\n\n    int leftInclude, leftExclude, rightInclude, rightExclude;\n\n    robHelper(currentNode->left, leftInclude, leftExclude);\n    robHelper(currentNode->right, rightInclude, rightExclude);\n\n    includeCurrentNode= currentNode->val + leftExclude + rightExclude;\n    excludeCurrentNode= max(leftInclude, leftExclude) + max(rightInclude, rightExclude);\n    return max(includeCurrentNode, excludeCurrentNode);\n}\n\nint rob(TreeNode *rootNode)\n{\n    int includeRootNode= 0, excludeRootNode= 0;\n    return robHelper(rootNode, includeRootNode, excludeRootNode);\n}",
    "output": "int robHelper(TreeNode *currentNode, int &includeCurrentNode, int &excludeCurrentNode)\n{\n    if(!currentNode)\n        return 0;\n\n    int leftInclude, leftExclude, rightInclude, rightExclude;\n\n    robHelper(currentNode->left, leftInclude, leftExclude);\n    robHelper(currentNode->right, rightInclude, rightExclude);\n\n    includeCurrentNode= currentNode->val + leftExclude + rightExclude;\n    excludeCurrentNode= max(leftInclude, leftExclude) + max(rightInclude, rightExclude);\n    return max(includeCurrentNode, excludeCurrentNode);\n}\n\nint rob(TreeNode *rootNode)\n{\n    int includeRootNode= 0, excludeRootNode= 0;\n    return robHelper(rootNode, includeRootNode, excludeRootNode);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countBits(int number)\n{\n    vector<int> bitCount(number + 1, 0);\n    for(int currentNumber= 1; currentNumber <= number; ++currentNumber)\n    {\n        bitCount[currentNumber]= bitCount[currentNumber & (currentNumber - 1)] + 1;\n    }\n    return bitCount;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> countBits(int number)\n{\n    std::vector<int> bitCount(number + 1, 0);\n    for(int currentNumber= 1; currentNumber <= number; ++currentNumber)\n    {\n        bitCount[currentNumber]= bitCount[currentNumber & (currentNumber - 1)] + 1;\n    }\n    return bitCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing NestedList = vector<variant<int, vector<variant<int, vector<int>>>>>;\n\nint calculateDepthSumHelper(NestedList nestedElements, int currentDepth)\n{\n    int totalSum = 0;\n    for (size_t i = 0; i < nestedElements.size(); ++i)\n    {\n        auto &element = nestedElements[i];\n        if (holds_alternative<int>(element))\n        {\n            totalSum += get<int>(element) * currentDepth;\n        }\n        else\n        {\n            totalSum += calculateDepthSumHelper(get<vector<variant<int, vector<int>>>>(element), currentDepth + 1);\n        }\n    }\n    return totalSum;\n}\n\nint calculateDepthSum(NestedList nestedElements)\n{\n    return calculateDepthSumHelper(nestedElements, 1);\n}",
    "output": "#include <bits/stdc++.h>\nusing NestedList= std::vector<std::variant<int, std::vector<std::variant<int, std::vector<int>>>>>;\n\nint calculateDepthSumHelper(NestedList nestedElements, int currentDepth)\n{\n    int totalSum= 0;\n    for(auto &element : nestedElements)\n    {\n        if(std::holds_alternative<int>(element))\n        {\n            totalSum+= std::get<int>(element) * currentDepth;\n        }\n        else\n        {\n            totalSum+= calculateDepthSumHelper(std::get<std::vector<std::variant<int, std::vector<int>>>>(element), currentDepth + 1);\n        }\n    }\n    return totalSum;\n}\n\nint calculateDepthSum(NestedList nestedElements)\n{\n    return calculateDepthSumHelper(nestedElements, 1);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint lengthOfLongestSubstringKDistinct(string inputString, int maxDistinctChars)\n{\n    unordered_map<char, int> characterCount;\n    int leftIndex = 0, longestLength = 0;\n\n    for(int rightIndex = 0; rightIndex < inputString.size(); ++rightIndex)\n    {\n        characterCount[inputString[rightIndex]]++;\n\n        while(characterCount.size() > maxDistinctChars)\n        {\n            characterCount[inputString[leftIndex]]--;\n            if(characterCount[inputString[leftIndex]] == 0)\n            {\n                characterCount.erase(inputString[leftIndex]);\n            }\n            leftIndex++;\n        }\n\n        longestLength = max(longestLength, rightIndex - leftIndex + 1);\n    }\n    return longestLength;\n}",
    "output": "#include <bits/stdc++.h>\nint lengthOfLongestSubstringKDistinct(std::string inputString, int maxDistinctChars)\n{\n    std::unordered_map<char, int> characterCount;\n    int leftIndex= 0, longestLength= 0;\n\n    for(int rightIndex= 0; rightIndex < inputString.size(); ++rightIndex)\n    {\n        characterCount[inputString[rightIndex]]++;\n\n        while(characterCount.size() > maxDistinctChars)\n        {\n            characterCount[inputString[leftIndex]]--;\n            if(characterCount[inputString[leftIndex]] == 0)\n            {\n                characterCount.erase(inputString[leftIndex]);\n            }\n            leftIndex++;\n        }\n\n        longestLength= std::max(longestLength, rightIndex - leftIndex + 1);\n    }\n    return longestLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Assuming NestedInteger class is defined elsewhere\nclass NestedIterator\n{\npublic:\n    vector<int> flattenedList;\n    int currentIndex;\n\n    void flatten(vector<NestedInteger> &nestedList)\n    {\n        for (int i = 0; i < nestedList.size(); ++i)\n        {\n            NestedInteger &nestedInt = nestedList[i];\n            if (nestedInt.isInteger())\n            {\n                flattenedList.push_back(nestedInt.getInteger());\n            }\n            else\n            {\n                flatten(nestedInt.getList());\n            }\n        }\n    }\n\n    NestedIterator(vector<NestedInteger> &nestedList)\n    {\n        flatten(nestedList);\n        currentIndex = 0;\n    }\n\n    int next()\n    {\n        return flattenedList[currentIndex++];\n    }\n\n    bool hasNext()\n    {\n        return currentIndex < flattenedList.size();\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass NestedIterator\n{\n  public:\n    std::vector<int> flattenedList;\n    int currentIndex;\n\n    void flatten(std::vector<NestedInteger> &nestedList)\n    {\n        for(NestedInteger &nestedInt : nestedList)\n        {\n            if(nestedInt.isInteger())\n            {\n                flattenedList.push_back(nestedInt.getInteger());\n            }\n            else\n            {\n                flatten(nestedInt.getList());\n            }\n        }\n    }\n\n    NestedIterator(std::vector<NestedInteger> &nestedList)\n    {\n        flatten(nestedList);\n        currentIndex= 0;\n    }\n\n    int next()\n    {\n        return flattenedList[currentIndex++];\n    }\n\n    bool hasNext()\n    {\n        return currentIndex < flattenedList.size();\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "bool isPowerOfFour(int number)\n{\n    if(number <= 0)\n        return false;\n    while(number % 4 == 0)\n    {\n        number/= 4;\n    }\n    return number == 1;\n}",
    "output": "bool isPowerOfFour(int number)\n{\n    if(number <= 0)\n        return false;\n    while(number % 4 == 0)\n    {\n        number/= 4;\n    }\n    return number == 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int integerBreak(int number)\n{\n    if(number <= 3)\n        return number - 1;\n    int product= 1;\n    while(number > 4)\n    {\n        product*= 3;\n        number-= 3;\n    }\n    return product * number;\n}",
    "output": "int integerBreak(int number)\n{\n    if(number <= 3)\n        return number - 1;\n    int product= 1;\n    while(number > 4)\n    {\n        product*= 3;\n        number-= 3;\n    }\n    return product * number;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// for std::swap\nusing namespace std;\n\nvoid reverseString(vector<char> &characterArray)\n{\n    int leftIndex= 0, rightIndex= characterArray.size() - 1;\n    while(leftIndex < rightIndex)\n    {\n        swap(characterArray[leftIndex++], characterArray[rightIndex--]);\n    }\n}",
    "output": "#include <bits/stdc++.h>\nvoid reverseString(std::vector<char> &characterArray)\n{\n    int leftIndex= 0, rightIndex= characterArray.size() - 1;\n    while(leftIndex < rightIndex)\n    {\n        std::swap(characterArray[leftIndex++], characterArray[rightIndex--]);\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring reverseVowels(string inputString)\n{\n    int leftIndex= 0, rightIndex= inputString.size() - 1;\n    while(leftIndex < rightIndex)\n    {\n        if(!isVowel(inputString[leftIndex]))\n        {\n            leftIndex++;\n        }\n        else if(!isVowel(inputString[rightIndex]))\n        {\n            rightIndex--;\n        }\n        else\n        {\n            swap(inputString[leftIndex], inputString[rightIndex]);\n            leftIndex++;\n            rightIndex--;\n        }\n    }\n    return inputString;\n}\n\nbool isVowel(char currentCharacter)\n{\n    currentCharacter= tolower(currentCharacter);\n    return currentCharacter == 'a' || currentCharacter == 'e' || currentCharacter == 'i' || currentCharacter == 'o' || currentCharacter == 'u';\n}",
    "output": "#include <bits/stdc++.h>\nstd::string reverseVowels(std::string inputString)\n{\n    int leftIndex= 0, rightIndex= inputString.size() - 1;\n    while(leftIndex < rightIndex)\n    {\n        if(!isVowel(inputString[leftIndex]))\n        {\n            leftIndex++;\n        }\n        else if(!isVowel(inputString[rightIndex]))\n        {\n            rightIndex--;\n        }\n        else\n        {\n            std::swap(inputString[leftIndex], inputString[rightIndex]);\n            leftIndex++;\n            rightIndex--;\n        }\n    }\n    return inputString;\n}\n\nbool isVowel(char currentCharacter)\n{\n    currentCharacter= std::tolower(currentCharacter);\n    return currentCharacter == 'a' || currentCharacter == 'e' || currentCharacter == 'i' || currentCharacter == 'o' || currentCharacter == 'u';\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass MovingAverage\n{\n  public:\n    queue<int> valueQueue;\n    int maxSize;\n    double sum;\n\n    MovingAverage(int size)\n    {\n        maxSize= size;\n        sum= 0;\n    }\n\n    double next(int newValue)\n    {\n        if(valueQueue.size() == maxSize)\n        {\n            sum-= valueQueue.front();\n            valueQueue.pop();\n        }\n        valueQueue.push(newValue);\n        sum+= newValue;\n        return sum / valueQueue.size();\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass MovingAverage\n{\n  public:\n    std::queue<int> valueQueue;\n    int maxSize;\n    double sum;\n\n    MovingAverage(int size)\n    {\n        maxSize = size;\n        sum = 0;\n    }\n\n    double next(int newValue)\n    {\n        if(valueQueue.size() == maxSize)\n        {\n            sum -= valueQueue.front();\n            valueQueue.pop();\n        }\n        valueQueue.push(newValue);\n        sum += newValue;\n        return sum / valueQueue.size();\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> kMostFrequent(vector<int> &numbers, int k)\n{\n    unordered_map<int, int> frequencyMap;\n    for(int i = 0; i < numbers.size(); ++i)\n    {\n        frequencyMap[numbers[i]]++;\n    }\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minHeap;\n    for(auto it = frequencyMap.begin(); it != frequencyMap.end(); ++it)\n    {\n        minHeap.push({it->second, it->first});\n        if(minHeap.size() > k)\n        {\n            minHeap.pop();\n        }\n    }\n\n    vector<int> result;\n    while(!minHeap.empty())\n    {\n        result.push_back(minHeap.top().second);\n        minHeap.pop();\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> kMostFrequent(std::vector<int> &numbers, int k)\n{\n    std::unordered_map<int, int> frequencyMap;\n    for(int number : numbers)\n    {\n        frequencyMap[number]++;\n    }\n\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> minHeap;\n    for(const auto &frequencyEntry : frequencyMap)\n    {\n        minHeap.push({frequencyEntry.second, frequencyEntry.first});\n        if(minHeap.size() > k)\n        {\n            minHeap.pop();\n        }\n    }\n\n    std::vector<int> result;\n    while(!minHeap.empty())\n    {\n        result.push_back(minHeap.top().second);\n        minHeap.pop();\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For abs\nusing namespace std;\n\nclass TicTacToe\n{\n  public:\n    vector<int> rowCounts, columnCounts;\n    int mainDiagonal, antiDiagonal, boardSize;\n\n    TicTacToe(int boardSize)\n    {\n        this->boardSize= boardSize;\n        rowCounts= vector<int>(boardSize, 0);\n        columnCounts= vector<int>(boardSize, 0);\n        mainDiagonal= 0;\n        antiDiagonal= 0;\n    }\n\n    int move(int row, int col, int player)\n    {\n        int valueToAdd= (player == 1) ? 1 : -1;\n\n        rowCounts[row]+= valueToAdd;\n        columnCounts[col]+= valueToAdd;\n\n        if(row == col)\n            mainDiagonal+= valueToAdd;\n        if(row + col == boardSize - 1)\n            antiDiagonal+= valueToAdd;\n\n        if(abs(rowCounts[row]) == boardSize ||\n           abs(columnCounts[col]) == boardSize ||\n           abs(mainDiagonal) == boardSize ||\n           abs(antiDiagonal) == boardSize)\n            return player;\n\n        return 0;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass TicTacToe\n{\n  public:\n    std::vector<int> rowCounts, columnCounts;\n    int mainDiagonal, antiDiagonal, boardSize;\n\n    TicTacToe(int boardSize)\n    {\n        this->boardSize = boardSize;\n        rowCounts = std::vector<int>(boardSize, 0);\n        columnCounts = std::vector<int>(boardSize, 0);\n        mainDiagonal = 0;\n        antiDiagonal = 0;\n    }\n\n    int move(int row, int col, int player)\n    {\n        int valueToAdd = (player == 1) ? 1 : -1;\n\n        rowCounts[row] += valueToAdd;\n        columnCounts[col] += valueToAdd;\n\n        if (row == col)\n            mainDiagonal += valueToAdd;\n        if (row + col == boardSize - 1)\n            antiDiagonal += valueToAdd;\n\n        if (std::abs(rowCounts[row]) == boardSize ||\n            std::abs(columnCounts[col]) == boardSize ||\n            std::abs(mainDiagonal) == boardSize ||\n            std::abs(antiDiagonal) == boardSize)\n            return player;\n\n        return 0;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> intersection(vector<int> &firstArray, vector<int> &secondArray)\n{\n    set<int> uniqueElementsFromFirstArray(firstArray.begin(), firstArray.end());\n    set<int> intersectionResult;\n    for (int i = 0; i < secondArray.size(); ++i)\n    {\n        int element = secondArray[i];\n        if (uniqueElementsFromFirstArray.count(element))\n        {\n            intersectionResult.insert(element);\n        }\n    }\n    return vector<int>(intersectionResult.begin(), intersectionResult.end());\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> intersection(std::vector<int> &firstArray, std::vector<int> &secondArray)\n{\n    std::set<int> uniqueElementsFromFirstArray(firstArray.begin(), firstArray.end());\n    std::set<int> intersectionResult;\n    for(int element : secondArray)\n    {\n        if(uniqueElementsFromFirstArray.count(element))\n        {\n            intersectionResult.insert(element);\n        }\n    }\n    return std::vector<int>(intersectionResult.begin(), intersectionResult.end());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> intersect(vector<int> &firstArray, vector<int> &secondArray)\n{\n    unordered_map<int, int> elementCountMap;\n    vector<int> intersectionResult;\n\n    for (int i = 0; i < firstArray.size(); ++i)\n    {\n        int element = firstArray[i];\n        elementCountMap[element]++;\n    }\n\n    for (int i = 0; i < secondArray.size(); ++i)\n    {\n        int element = secondArray[i];\n        if (elementCountMap[element] > 0)\n        {\n            intersectionResult.push_back(element);\n            elementCountMap[element]--;\n        }\n    }\n\n    return intersectionResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> intersect(std::vector<int> &firstArray, std::vector<int> &secondArray)\n{\n    std::unordered_map<int, int> elementCountMap;\n    std::vector<int> intersectionResult;\n\n    for(int element : firstArray)\n    {\n        elementCountMap[element]++;\n    }\n\n    for(int element : secondArray)\n    {\n        if(elementCountMap[element] > 0)\n        {\n            intersectionResult.push_back(element);\n            elementCountMap[element]--;\n        }\n    }\n\n    return intersectionResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dfs(const vector<vector<int>> &jumpPatterns, vector<bool> &isVisited, int current, int remaining);\n\nint countPatterns(int minLength, int maxLength)\n{\n    const vector<vector<int>> jumpPatterns(10, vector<int>(10, 0));\n    jumpPatterns[1][3]= jumpPatterns[3][1]= 2;\n    jumpPatterns[1][7]= jumpPatterns[7][1]= 4;\n    jumpPatterns[3][9]= jumpPatterns[9][3]= 6;\n    jumpPatterns[7][9]= jumpPatterns[9][7]= 8;\n    jumpPatterns[1][9]= jumpPatterns[9][1]= jumpPatterns[2][8]= jumpPatterns[8][2]= jumpPatterns[3][7]= jumpPatterns[7][3]= jumpPatterns[4][6]= jumpPatterns[6][4]= 5;\n\n    vector<bool> isVisited(10, false);\n\n    int totalCount= 0;\n    for(int length= minLength; length <= maxLength; ++length)\n    {\n        totalCount+= dfs(jumpPatterns, isVisited, 1, length - 1) * 4; // 1, 3, 7, 9\n        totalCount+= dfs(jumpPatterns, isVisited, 2, length - 1) * 4; // 2, 4, 6, 8\n        totalCount+= dfs(jumpPatterns, isVisited, 5, length - 1);     // 5\n    }\n\n    return totalCount;\n}\n\nint dfs(const vector<vector<int>> &jumpPatterns, vector<bool> &isVisited, int current, int remaining)\n{\n    if(remaining < 0)\n        return 0;\n    if(remaining == 0)\n        return 1;\n\n    isVisited[current]= true;\n    int totalCount= 0;\n    for(int next= 1; next <= 9; ++next)\n    {\n        if(!isVisited[next] && (jumpPatterns[current][next] == 0 || isVisited[jumpPatterns[current][next]]))\n        {\n            totalCount+= dfs(jumpPatterns, isVisited, next, remaining - 1);\n        }\n    }\n    isVisited[current]= false;\n\n    return totalCount;\n}",
    "output": "#include <bits/stdc++.h>\nint dfs(const std::vector<std::vector<int>> &jumpPatterns, std::vector<bool> &isVisited, int current, int remaining);\n\nint countPatterns(int minLength, int maxLength)\n{\n    const std::vector<std::vector<int>> jumpPatterns(10, std::vector<int>(10, 0));\n    jumpPatterns[1][3]= jumpPatterns[3][1]= 2;\n    jumpPatterns[1][7]= jumpPatterns[7][1]= 4;\n    jumpPatterns[3][9]= jumpPatterns[9][3]= 6;\n    jumpPatterns[7][9]= jumpPatterns[9][7]= 8;\n    jumpPatterns[1][9]= jumpPatterns[9][1]= jumpPatterns[2][8]= jumpPatterns[8][2]= jumpPatterns[3][7]= jumpPatterns[7][3]= jumpPatterns[4][6]= jumpPatterns[6][4]= 5;\n\n    std::vector<bool> isVisited(10, false);\n\n    int totalCount= 0;\n    for(int length= minLength; length <= maxLength; ++length)\n    {\n        totalCount+= dfs(jumpPatterns, isVisited, 1, length - 1) * 4; // 1, 3, 7, 9\n        totalCount+= dfs(jumpPatterns, isVisited, 2, length - 1) * 4; // 2, 4, 6, 8\n        totalCount+= dfs(jumpPatterns, isVisited, 5, length - 1);     // 5\n    }\n\n    return totalCount;\n}\n\nint dfs(const std::vector<std::vector<int>> &jumpPatterns, std::vector<bool> &isVisited, int current, int remaining)\n{\n    if(remaining < 0)\n        return 0;\n    if(remaining == 0)\n        return 1;\n\n    isVisited[current]= true;\n    int totalCount= 0;\n    for(int next= 1; next <= 9; ++next)\n    {\n        if(!isVisited[next] && (jumpPatterns[current][next] == 0 || isVisited[jumpPatterns[current][next]]))\n        {\n            totalCount+= dfs(jumpPatterns, isVisited, next, remaining - 1);\n        }\n    }\n    isVisited[current]= false;\n\n    return totalCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass SummaryRanges\n{\n  public:\n    void addNum(int value)\n    {\n        if(intervalMap.empty() || intervalMap.begin()->first > value + 1)\n        {\n            intervalMap[value] = value;\n        }\n        else\n        {\n            auto iterator = intervalMap.lower_bound(value);\n            auto leftInterval = prev(iterator), rightInterval = iterator;\n\n            if(leftInterval != intervalMap.end() && leftInterval->second + 1 == value)\n            {\n                leftInterval->second++;\n                if(rightInterval != intervalMap.end() && value + 1 == rightInterval->first)\n                {\n                    leftInterval->second = rightInterval->second;\n                    intervalMap.erase(rightInterval);\n                }\n            }\n            else if(rightInterval != intervalMap.end() && value + 1 == rightInterval->first)\n            {\n                intervalMap[value] = rightInterval->second;\n                intervalMap.erase(rightInterval);\n            }\n            else\n            {\n                intervalMap[value] = value;\n            }\n        }\n    }\n\n    vector<vector<int>> getIntervals()\n    {\n        vector<vector<int>> result;\n        for(auto it = intervalMap.begin(); it != intervalMap.end(); ++it)\n        {\n            result.push_back({it->first, it->second});\n        }\n        return result;\n    }\n\n  private:\n    map<int, int> intervalMap;\n};",
    "output": "#include <bits/stdc++.h>\nclass SummaryRanges\n{\n  public:\n    void addNum(int value)\n    {\n        if(intervalMap.empty() || intervalMap.begin()->first > value + 1)\n        {\n            intervalMap[value]= value;\n        }\n        else\n        {\n            auto iterator= intervalMap.lower_bound(value);\n            auto leftInterval= prev(iterator), rightInterval= iterator;\n\n            if(leftInterval != intervalMap.end() && leftInterval->second + 1 == value)\n            {\n                leftInterval->second++;\n                if(rightInterval != intervalMap.end() && value + 1 == rightInterval->first)\n                {\n                    leftInterval->second= rightInterval->second;\n                    intervalMap.erase(rightInterval);\n                }\n            }\n            else if(rightInterval != intervalMap.end() && value + 1 == rightInterval->first)\n            {\n                intervalMap[value]= rightInterval->second;\n                intervalMap.erase(rightInterval);\n            }\n            else\n            {\n                intervalMap[value]= value;\n            }\n        }\n    }\n\n    std::vector<std::vector<int>> getIntervals()\n    {\n        std::vector<std::vector<int>> result;\n        for(const auto &interval : intervalMap)\n        {\n            result.push_back({interval.first, interval.second});\n        }\n        return result;\n    }\n\n  private:\n    std::map<int, int> intervalMap;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass SnakeGame\n{\n  public:\n    SnakeGame(int gameWidth, int gameHeight, vector<vector<int>> &foodItems)\n        : gameWidth(gameWidth), gameHeight(gameHeight), foodItems(foodItems), foodIndex(0), currentScore(0)\n    {\n        snakePositions.push_back({0, 0});\n        occupiedPositions.insert(0);\n    }\n\n    int move(string direction)\n    {\n        int newX= snakePositions.back().first + deltaX[direction];\n        int newY= snakePositions.back().second + deltaY[direction];\n\n        if(newX < 0 || newX >= gameHeight || newY < 0 || newY >= gameWidth)\n        {\n            return -1;\n        }\n\n        pair<int, int> newHead= make_pair(newX, newY);\n        pair<int, int> tail= snakePositions.front();\n\n        if(foodIndex < foodItems.size() && foodItems[foodIndex][0] == newX && foodItems[foodIndex][1] == newY)\n        {\n            currentScore++;\n            foodIndex++;\n        }\n        else\n        {\n            snakePositions.pop_front();\n            occupiedPositions.erase(tail.first * gameWidth + tail.second);\n        }\n\n        if(occupiedPositions.count(newHead.first * gameWidth + newHead.second))\n        {\n            return -1;\n        }\n\n        snakePositions.push_back(newHead);\n        occupiedPositions.insert(newHead.first * gameWidth + newHead.second);\n        return currentScore;\n    }\n\n  private:\n    int gameWidth;\n    int gameHeight;\n    vector<vector<int>> foodItems;\n    int foodIndex;\n    int currentScore;\n    list<pair<int, int>> snakePositions;\n    unordered_set<int> occupiedPositions;\n    unordered_map<string, int> deltaX= {{\"U\", -1}, {\"D\", 1}, {\"L\", 0}, {\"R\", 0}};\n    unordered_map<string, int> deltaY= {{\"U\", 0}, {\"D\", 0}, {\"L\", -1}, {\"R\", 1}};\n};",
    "output": "#include <bits/stdc++.h>\nclass SnakeGame\n{\n  public:\n    SnakeGame(int gameWidth, int gameHeight, std::vector<std::vector<int>> &foodItems)\n        : gameWidth(gameWidth), gameHeight(gameHeight), foodItems(foodItems), foodIndex(0), currentScore(0)\n    {\n        snakePositions.push_back({0, 0});\n        occupiedPositions.insert(0);\n    }\n\n    int move(std::string direction)\n    {\n        int newX= snakePositions.back().first + deltaX[direction];\n        int newY= snakePositions.back().second + deltaY[direction];\n\n        if(newX < 0 || newX >= gameHeight || newY < 0 || newY >= gameWidth)\n        {\n            return -1;\n        }\n\n        std::pair<int, int> newHead= std::make_pair(newX, newY);\n        std::pair<int, int> tail= snakePositions.front();\n\n        if(foodIndex < foodItems.size() && foodItems[foodIndex][0] == newX && foodItems[foodIndex][1] == newY)\n        {\n            currentScore++;\n            foodIndex++;\n        }\n        else\n        {\n            snakePositions.pop_front();\n            occupiedPositions.erase(tail.first * gameWidth + tail.second);\n        }\n\n        if(occupiedPositions.count(newHead.first * gameWidth + newHead.second))\n        {\n            return -1;\n        }\n\n        snakePositions.push_back(newHead);\n        occupiedPositions.insert(newHead.first * gameWidth + newHead.second);\n        return currentScore;\n    }\n\n  private:\n    int gameWidth;\n    int gameHeight;\n    std::vector<std::vector<int>> foodItems;\n    int foodIndex;\n    int currentScore;\n    std::list<std::pair<int, int>> snakePositions;\n    std::unordered_set<int> occupiedPositions;\n    std::unordered_map<std::string, int> deltaX= {{\"U\", -1}, {\"D\", 1}, {\"L\", 0}, {\"R\", 0}};\n    std::unordered_map<std::string, int> deltaY= {{\"U\", 0}, {\"D\", 0}, {\"L\", -1}, {\"R\", 1}};\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxEnvelopes(vector<vector<int>> &envelopes)\n{\n    sort(envelopes.begin(), envelopes.end(), [](const vector<int> &firstEnvelope, const vector<int> &secondEnvelope)\n              { return firstEnvelope[0] == secondEnvelope[0] ? firstEnvelope[1] > secondEnvelope[1] : firstEnvelope[0] < secondEnvelope[0]; });\n\n    vector<int> longestIncreasingSubsequence;\n    for (int i = 0; i < envelopes.size(); ++i)\n    {\n        const auto &currentEnvelope = envelopes[i];\n        auto position = lower_bound(longestIncreasingSubsequence.begin(), longestIncreasingSubsequence.end(), currentEnvelope[1]);\n        if (position == longestIncreasingSubsequence.end())\n        {\n            longestIncreasingSubsequence.push_back(currentEnvelope[1]);\n        }\n        else\n        {\n            *position = currentEnvelope[1];\n        }\n    }\n\n    return longestIncreasingSubsequence.size();\n}",
    "output": "#include <bits/stdc++.h>\nint maxEnvelopes(std::vector<std::vector<int>> &envelopes)\n{\n    std::sort(envelopes.begin(), envelopes.end(), [](const std::vector<int> &firstEnvelope, const std::vector<int> &secondEnvelope)\n              { return firstEnvelope[0] == secondEnvelope[0] ? firstEnvelope[1] > secondEnvelope[1] : firstEnvelope[0] < secondEnvelope[0]; });\n\n    std::vector<int> longestIncreasingSubsequence;\n    for(const auto &currentEnvelope : envelopes)\n    {\n        auto position= std::lower_bound(longestIncreasingSubsequence.begin(), longestIncreasingSubsequence.end(), currentEnvelope[1]);\n        if(position == longestIncreasingSubsequence.end())\n        {\n            longestIncreasingSubsequence.push_back(currentEnvelope[1]);\n        }\n        else\n        {\n            *position= currentEnvelope[1];\n        }\n    }\n\n    return longestIncreasingSubsequence.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Twitter\n{\n  public:\n    class Tweet\n    {\n      public:\n        int timestamp;\n        int tweetId;\n        Tweet(int t, int id) : timestamp(t), tweetId(id) {}\n    };\n\n    unordered_map<int, vector<Tweet>> userTweets;\n    unordered_map<int, unordered_set<int>> userFollowing;\n    int globalTimestamp;\n\n    Twitter()\n    {\n        globalTimestamp = 0;\n    }\n\n    void postTweet(int userId, int tweetId)\n    {\n        userTweets[userId].emplace_back(globalTimestamp++, tweetId);\n    }\n\n    vector<int> getNewsFeed(int userId)\n    {\n        vector<Tweet *> feed;\n        for (int i = 0; i < userTweets[userId].size(); ++i)\n        {\n            feed.push_back(&userTweets[userId][i]);\n        }\n        for (int followedUser : userFollowing[userId])\n        {\n            for (int j = 0; j < userTweets[followedUser].size(); ++j)\n            {\n                feed.push_back(&userTweets[followedUser][j]);\n            }\n        }\n\n        sort(feed.begin(), feed.end(), [](Tweet *a, Tweet *b)\n             { return a->timestamp > b->timestamp; });\n\n        vector<int> result;\n        for (int i = 0; i < feed.size() && i < 10; ++i)\n        {\n            result.push_back(feed[i]->tweetId);\n        }\n        return result;\n    }\n\n    void follow(int followerId, int followeeId)\n    {\n        if (followerId != followeeId)\n        {\n            userFollowing[followerId].insert(followeeId);\n        }\n    }\n\n    void unfollow(int followerId, int followeeId)\n    {\n        userFollowing[followerId].erase(followeeId);\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Twitter\n{\n  public:\n    class Tweet\n    {\n      public:\n        int timestamp;\n        int tweetId;\n        Tweet(int t, int id) : timestamp(t), tweetId(id) {}\n    };\n\n    std::unordered_map<int, std::vector<Tweet>> userTweets;\n    std::unordered_map<int, std::unordered_set<int>> userFollowing;\n    int globalTimestamp;\n\n    Twitter()\n    {\n        globalTimestamp = 0;\n    }\n\n    void postTweet(int userId, int tweetId)\n    {\n        userTweets[userId].emplace_back(globalTimestamp++, tweetId);\n    }\n\n    std::vector<int> getNewsFeed(int userId)\n    {\n        std::vector<Tweet *> feed;\n        for(Tweet &t : userTweets[userId])\n        {\n            feed.push_back(&t);\n        }\n        for(int followedUser : userFollowing[userId])\n        {\n            for(Tweet &t : userTweets[followedUser])\n            {\n                feed.push_back(&t);\n            }\n        }\n\n        std::sort(feed.begin(), feed.end(), [](Tweet *a, Tweet *b)\n             { return a->timestamp > b->timestamp; });\n\n        std::vector<int> result;\n        for(int i = 0; i < feed.size() && i < 10; ++i)\n        {\n            result.push_back(feed[i]->tweetId);\n        }\n        return result;\n    }\n\n    void follow(int followerId, int followeeId)\n    {\n        if(followerId != followeeId)\n        {\n            userFollowing[followerId].insert(followeeId);\n        }\n    }\n\n    void unfollow(int followerId, int followeeId)\n    {\n        userFollowing[followerId].erase(followeeId);\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For INT_MAX and INT_MIN\nusing namespace std;\n\nbool isReflected(vector<vector<int>> &points)\n{\n    int minimumX = INT_MAX;\n    int maximumX = INT_MIN;\n\n    unordered_set<string> pointSet;\n    for (int i = 0; i < points.size(); ++i)\n    {\n        minimumX = min(minimumX, points[i][0]);\n        maximumX = max(maximumX, points[i][0]);\n        pointSet.insert(to_string(points[i][0]) + \",\" + to_string(points[i][1]));\n    }\n\n    int sum = minimumX + maximumX;\n    for (int i = 0; i < points.size(); ++i)\n    {\n        if (!pointSet.count(to_string(sum - points[i][0]) + \",\" + to_string(points[i][1])))\n        {\n            return false;\n        }\n    }\n\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isReflected(std::vector<std::vector<int>> &points)\n{\n    int minimumX= std::numeric_limits<int>::max();\n    int maximumX= std::numeric_limits<int>::min();\n\n    std::unordered_set<std::string> pointSet;\n    for(const auto &point : points)\n    {\n        minimumX= std::min(minimumX, point[0]);\n        maximumX= std::max(maximumX, point[0]);\n        pointSet.insert(std::to_string(point[0]) + \",\" + std::to_string(point[1]));\n    }\n\n    int sum= minimumX + maximumX;\n    for(const auto &point : points)\n    {\n        if(!pointSet.count(std::to_string(sum - point[0]) + \",\" + std::to_string(point[1])))\n        {\n            return false;\n        }\n    }\n\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int countNumbersWithUniqueDigits(int maxDigits)\n{\n    if(maxDigits == 0)\n        return 1;\n\n    int totalCount= 10;\n    int uniqueDigitCount= 9;\n    int availableDigits= 9;\n\n    while(maxDigits-- > 1 && availableDigits > 0)\n    {\n        uniqueDigitCount*= availableDigits;\n        totalCount+= uniqueDigitCount;\n        availableDigits--;\n    }\n\n    return totalCount;\n}",
    "output": "int countNumbersWithUniqueDigits(int maxDigits)\n{\n    if(maxDigits == 0)\n        return 1;\n\n    int totalCount= 10;\n    int uniqueDigitCount= 9;\n    int availableDigits= 9;\n\n    while(maxDigits-- > 1 && availableDigits > 0)\n    {\n        uniqueDigitCount*= availableDigits;\n        totalCount+= uniqueDigitCount;\n        availableDigits--;\n    }\n\n    return totalCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring rearrangeString(string inputString, int distance)\n{\n    if(distance == 0)\n        return inputString;\n\n    unordered_map<char, int> characterFrequency;\n    for(char character : inputString)\n    {\n        characterFrequency[character]++;\n    }\n\n    priority_queue<pair<int, char>> maxHeap;\n    for(const auto &frequencyPair : characterFrequency)\n    {\n        maxHeap.emplace(frequencyPair.second, frequencyPair.first);\n    }\n\n    string rearrangedString;\n    while(!maxHeap.empty())\n    {\n        vector<pair<int, char>> tempStorage;\n\n        for(int i = 0; i < distance && !maxHeap.empty(); ++i)\n        {\n            auto current = maxHeap.top();\n            maxHeap.pop();\n\n            rearrangedString += current.second;\n            if(--current.first > 0)\n            {\n                tempStorage.push_back(current);\n            }\n        }\n\n        for(int i = 0; i < tempStorage.size(); ++i)\n        {\n            maxHeap.push(tempStorage[i]);\n        }\n\n        if(maxHeap.empty())\n            break;\n        if(rearrangedString.length() < inputString.length())\n            rearrangedString.append(distance - tempStorage.size(), ' ');\n    }\n\n    if(rearrangedString.length() < inputString.length())\n        return \"\";\n    return rearrangedString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string rearrangeString(std::string inputString, int distance)\n{\n    if(distance == 0)\n        return inputString;\n\n    std::unordered_map<char, int> characterFrequency;\n    for(char character : inputString)\n    {\n        characterFrequency[character]++;\n    }\n\n    std::priority_queue<std::pair<int, char>> maxHeap;\n    for(const auto &frequencyPair : characterFrequency)\n    {\n        maxHeap.emplace(frequencyPair.second, frequencyPair.first);\n    }\n\n    std::string rearrangedString;\n    while(!maxHeap.empty())\n    {\n        std::vector<std::pair<int, char>> tempStorage;\n\n        for(int i= 0; i < distance && !maxHeap.empty(); ++i)\n        {\n            auto current= maxHeap.top();\n            maxHeap.pop();\n\n            rearrangedString+= current.second;\n            if(--current.first > 0)\n            {\n                tempStorage.push_back(current);\n            }\n        }\n\n        for(const auto &entry : tempStorage)\n        {\n            maxHeap.push(entry);\n        }\n\n        if(maxHeap.empty())\n            break;\n        if(rearrangedString.length() < inputString.length())\n            rearrangedString.append(distance - tempStorage.size(), ' ');\n    }\n\n    if(rearrangedString.length() < inputString.length())\n        return \"\";\n    return rearrangedString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Logger\n{\n  public:\n    unordered_map<string, int> messageTimestamps;\n\n    Logger()\n    {\n    }\n\n    bool shouldPrintMessage(int timestamp, string message)\n    {\n        if(!messageTimestamps.count(message) || timestamp - messageTimestamps[message] >= 10)\n        {\n            messageTimestamps[message]= timestamp;\n            return true;\n        }\n        return false;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Logger\n{\n  public:\n    std::unordered_map<std::string, int> messageTimestamps;\n\n    Logger()\n    {\n    }\n\n    bool shouldPrintMessage(int timestamp, std::string message)\n    {\n        if(!messageTimestamps.count(message) || timestamp - messageTimestamps[message] >= 10)\n        {\n            messageTimestamps[message]= timestamp;\n            return true;\n        }\n        return false;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> sortTransformedArray(vector<int> &inputArray, int coefficientA, int coefficientB, int constantC)\n{\n    vector<int> transformedArray(inputArray.size());\n    int leftIndex= 0, rightIndex= inputArray.size() - 1, resultIndex= (coefficientA >= 0) ? inputArray.size() - 1 : 0;\n\n    while(leftIndex <= rightIndex)\n    {\n        int leftValue= inputArray[leftIndex] * inputArray[leftIndex] * coefficientA + inputArray[leftIndex] * coefficientB + constantC;\n        int rightValue= inputArray[rightIndex] * inputArray[rightIndex] * coefficientA + inputArray[rightIndex] * coefficientB + constantC;\n\n        if(coefficientA >= 0)\n        {\n            if(leftValue >= rightValue)\n            {\n                transformedArray[resultIndex--]= leftValue;\n                leftIndex++;\n            }\n            else\n            {\n                transformedArray[resultIndex--]= rightValue;\n                rightIndex--;\n            }\n        }\n        else\n        {\n            if(leftValue <= rightValue)\n            {\n                transformedArray[resultIndex++]= leftValue;\n                leftIndex++;\n            }\n            else\n            {\n                transformedArray[resultIndex++]= rightValue;\n                rightIndex--;\n            }\n        }\n    }\n    return transformedArray;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> sortTransformedArray(std::vector<int> &inputArray, int coefficientA, int coefficientB, int constantC)\n{\n    std::vector<int> transformedArray(inputArray.size());\n    int leftIndex= 0, rightIndex= inputArray.size() - 1, resultIndex= (coefficientA >= 0) ? inputArray.size() - 1 : 0;\n\n    while(leftIndex <= rightIndex)\n    {\n        int leftValue= inputArray[leftIndex] * inputArray[leftIndex] * coefficientA + inputArray[leftIndex] * coefficientB + constantC;\n        int rightValue= inputArray[rightIndex] * inputArray[rightIndex] * coefficientA + inputArray[rightIndex] * coefficientB + constantC;\n\n        if(coefficientA >= 0)\n        {\n            if(leftValue >= rightValue)\n            {\n                transformedArray[resultIndex--]= leftValue;\n                leftIndex++;\n            }\n            else\n            {\n                transformedArray[resultIndex--]= rightValue;\n                rightIndex--;\n            }\n        }\n        else\n        {\n            if(leftValue <= rightValue)\n            {\n                transformedArray[resultIndex++]= leftValue;\n                leftIndex++;\n            }\n            else\n            {\n                transformedArray[resultIndex++]= rightValue;\n                rightIndex--;\n            }\n        }\n    }\n    return transformedArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxKilledEnemies(vector<vector<char>> &grid)\n{\n    if(grid.empty())\n        return 0;\n    int rowCount= grid.size(), colCount= grid[0].size(), maxEnemies= 0, rowHits= 0;\n    vector<int> colHits(colCount, 0);\n    for(int rowIndex= 0; rowIndex < rowCount; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < colCount; colIndex++)\n        {\n            if(colIndex == 0 || grid[rowIndex][colIndex - 1] == 'W')\n            {\n                rowHits= 0;\n                for(int k= colIndex; k < colCount && grid[rowIndex][k] != 'W'; k++)\n                    rowHits+= grid[rowIndex][k] == 'E';\n            }\n            if(rowIndex == 0 || grid[rowIndex - 1][colIndex] == 'W')\n            {\n                colHits[colIndex]= 0;\n                for(int k= rowIndex; k < rowCount && grid[k][colIndex] != 'W'; k++)\n                    colHits[colIndex]+= grid[k][colIndex] == 'E';\n            }\n            if(grid[rowIndex][colIndex] == '0')\n                maxEnemies= max(maxEnemies, rowHits + colHits[colIndex]);\n        }\n    }\n    return maxEnemies;\n}",
    "output": "#include <bits/stdc++.h>\nint maxKilledEnemies(std::vector<std::vector<char>> &grid)\n{\n    if(grid.empty())\n        return 0;\n    int rowCount= grid.size(), colCount= grid[0].size(), maxEnemies= 0, rowHits= 0;\n    std::vector<int> colHits(colCount, 0);\n    for(int rowIndex= 0; rowIndex < rowCount; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < colCount; colIndex++)\n        {\n            if(colIndex == 0 || grid[rowIndex][colIndex - 1] == 'W')\n            {\n                rowHits= 0;\n                for(int k= colIndex; k < colCount && grid[rowIndex][k] != 'W'; k++)\n                    rowHits+= grid[rowIndex][k] == 'E';\n            }\n            if(rowIndex == 0 || grid[rowIndex - 1][colIndex] == 'W')\n            {\n                colHits[colIndex]= 0;\n                for(int k= rowIndex; k < rowCount && grid[k][colIndex] != 'W'; k++)\n                    colHits[colIndex]+= grid[k][colIndex] == 'E';\n            }\n            if(grid[rowIndex][colIndex] == '0')\n                maxEnemies= std::max(maxEnemies, rowHits + colHits[colIndex]);\n        }\n    }\n    return maxEnemies;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass HitCounter\n{\n  public:\n    HitCounter() {}\n\n    void recordHit(int timeStamp)\n    {\n        hitTimestamps.push(timeStamp);\n    }\n\n    int getHits(int timeStamp)\n    {\n        while(!hitTimestamps.empty() && hitTimestamps.front() <= (timeStamp - 300))\n        {\n            hitTimestamps.pop();\n        }\n        return hitTimestamps.size();\n    }\n\n  private:\n    queue<int> hitTimestamps;\n};",
    "output": "#include <bits/stdc++.h>\nclass HitCounter\n{\n  public:\n    HitCounter() {}\n\n    void recordHit(int timeStamp)\n    {\n        hitTimestamps.push(timeStamp);\n    }\n\n    int getHits(int timeStamp)\n    {\n        while(!hitTimestamps.empty() && hitTimestamps.front() <= (timeStamp - 300))\n        {\n            hitTimestamps.pop();\n        }\n        return hitTimestamps.size();\n    }\n\n  private:\n    std::queue<int> hitTimestamps;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumSubmatrix(vector<vector<int>> &matrix, int targetSum)\n{\n    int rowCount = matrix.size();\n    int columnCount = matrix[0].size();\n    int maximumSum = INT_MIN;\n\n    for(int leftColumn = 0; leftColumn < columnCount; ++leftColumn)\n    {\n        vector<int> cumulativeSums(rowCount, 0);\n        for(int rightColumn = leftColumn; rightColumn < columnCount; ++rightColumn)\n        {\n            for(int rowIndex = 0; rowIndex < rowCount; ++rowIndex)\n            {\n                cumulativeSums[rowIndex] += matrix[rowIndex][rightColumn];\n            }\n\n            set<int> sortedCumulativeSums;\n            sortedCumulativeSums.insert(0);\n            int currentSum = 0;\n            for(int i = 0; i < cumulativeSums.size(); ++i)\n            {\n                currentSum += cumulativeSums[i];\n                auto iterator = sortedCumulativeSums.lower_bound(currentSum - targetSum);\n                if(iterator != sortedCumulativeSums.end())\n                    maximumSum = max(maximumSum, currentSum - *iterator);\n                sortedCumulativeSums.insert(currentSum);\n            }\n        }\n    }\n\n    return maximumSum;\n}",
    "output": "#include <bits/stdc++.h>\nint maxSumSubmatrix(std::vector<std::vector<int>> &matrix, int targetSum)\n{\n    int rowCount= matrix.size();\n    int columnCount= matrix[0].size();\n    int maximumSum= INT_MIN;\n\n    for(int leftColumn= 0; leftColumn < columnCount; ++leftColumn)\n    {\n        std::vector<int> cumulativeSums(rowCount, 0);\n        for(int rightColumn= leftColumn; rightColumn < columnCount; ++rightColumn)\n        {\n            for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n            {\n                cumulativeSums[rowIndex]+= matrix[rowIndex][rightColumn];\n            }\n\n            std::set<int> sortedCumulativeSums;\n            sortedCumulativeSums.insert(0);\n            int currentSum= 0;\n            for(int sum : cumulativeSums)\n            {\n                currentSum+= sum;\n                auto iterator= sortedCumulativeSums.lower_bound(currentSum - targetSum);\n                if(iterator != sortedCumulativeSums.end())\n                    maximumSum= std::max(maximumSum, currentSum - *iterator);\n                sortedCumulativeSums.insert(currentSum);\n            }\n        }\n    }\n\n    return maximumSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing NestedInteger = variant<int, vector<variant<int, vector<NestedInteger>>>>;\n\nint calculateSumHelper(NestedInteger &nestedInteger, int currentDepth)\n{\n    int totalSum = 0;\n    if(auto pInteger = get_if<int>(&nestedInteger))\n    {\n        totalSum += currentDepth * (*pInteger);\n    }\n    else\n    {\n        auto &nestedList = get<vector<NestedInteger>>(nestedInteger);\n        for(int i = 0; i < nestedList.size(); ++i)\n        {\n            totalSum += calculateSumHelper(nestedList[i], currentDepth - 1);\n        }\n    }\n    return totalSum;\n}\n\nint calculateMaxDepth(NestedInteger &nestedInteger)\n{\n    if(holds_alternative<int>(nestedInteger))\n        return 0;\n    int currentDepth = 1;\n    for(int i = 0; i < get<vector<NestedInteger>>(nestedInteger).size(); ++i)\n    {\n        currentDepth = max(currentDepth, 1 + calculateMaxDepth(get<vector<NestedInteger>>(nestedInteger)[i]));\n    }\n    return currentDepth;\n}\n\nint calculateDepthSumInverse(vector<NestedInteger> &nestedIntegerList)\n{\n    int maximumDepth = 1;\n    for(int i = 0; i < nestedIntegerList.size(); ++i)\n    {\n        maximumDepth = max(maximumDepth, 1 + calculateMaxDepth(nestedIntegerList[i]));\n    }\n    int totalSum = 0;\n    for(int i = 0; i < nestedIntegerList.size(); ++i)\n    {\n        totalSum += calculateSumHelper(nestedIntegerList[i], maximumDepth);\n    }\n    return totalSum;\n}",
    "output": "#include <bits/stdc++.h>\nusing NestedInteger= std::variant<int, std::vector<std::variant<int, std::vector<NestedInteger>>>>;\n\nint calculateSumHelper(NestedInteger &nestedInteger, int currentDepth)\n{\n    int totalSum= 0;\n    if(auto pInteger= std::get_if<int>(&nestedInteger))\n    {\n        totalSum+= currentDepth * (*pInteger);\n    }\n    else\n    {\n        auto &nestedList= std::get<std::vector<NestedInteger>>(nestedInteger);\n        for(auto &element : nestedList)\n        {\n            totalSum+= calculateSumHelper(element, currentDepth - 1);\n        }\n    }\n    return totalSum;\n}\n\nint calculateMaxDepth(NestedInteger &nestedInteger)\n{\n    if(std::holds_alternative<int>(nestedInteger))\n        return 0;\n    int currentDepth= 1;\n    for(auto &element : std::get<std::vector<NestedInteger>>(nestedInteger))\n    {\n        currentDepth= std::max(currentDepth, 1 + calculateMaxDepth(element));\n    }\n    return currentDepth;\n}\n\nint calculateDepthSumInverse(std::vector<NestedInteger> &nestedIntegerList)\n{\n    int maximumDepth= 1;\n    for(auto &nestedInteger : nestedIntegerList)\n    {\n        maximumDepth= std::max(maximumDepth, 1 + calculateMaxDepth(nestedInteger));\n    }\n    int totalSum= 0;\n    for(auto &nestedInteger : nestedIntegerList)\n    {\n        totalSum+= calculateSumHelper(nestedInteger, maximumDepth);\n    }\n    return totalSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "bool canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity)\n{\n    if(targetCapacity > jug1Capacity + jug2Capacity)\n        return false;\n    if(jug1Capacity == targetCapacity || jug2Capacity == targetCapacity || jug1Capacity + jug2Capacity == targetCapacity)\n        return true;\n    return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0;\n}\n\nint gcd(int a, int b)\n{\n    while(b)\n    {\n        int temp= a % b;\n        a= b;\n        b= temp;\n    }\n    return a;\n}",
    "output": "bool canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity)\n{\n    if(targetCapacity > jug1Capacity + jug2Capacity)\n        return false;\n    if(jug1Capacity == targetCapacity || jug2Capacity == targetCapacity || jug1Capacity + jug2Capacity == targetCapacity)\n        return true;\n    return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0;\n}\n\nint gcd(int a, int b)\n{\n    while(b)\n    {\n        int temp= a % b;\n        a= b;\n        b= temp;\n    }\n    return a;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nvoid collectLeaves(TreeNode *currentNode, vector<vector<int>> &leafGroups, int &currentLevel)\n{\n    if(!currentNode)\n        return;\n    if(!currentNode->leftChild && !currentNode->rightChild)\n    {\n        if(leafGroups.size() <= currentLevel)\n        {\n            leafGroups.push_back(vector<int>());\n        }\n        leafGroups[currentLevel].push_back(currentNode->value);\n        currentNode= NULL;\n        return;\n    }\n    currentLevel++;\n    collectLeaves(currentNode->leftChild, leafGroups, currentLevel);\n    collectLeaves(currentNode->rightChild, leafGroups, currentLevel);\n    currentLevel--;\n}\n\nvector<vector<int>> findLeaves(TreeNode *rootNode)\n{\n    vector<vector<int>> leafGroups;\n    int currentLevel= 0;\n    while(rootNode)\n    {\n        collectLeaves(rootNode, leafGroups, currentLevel);\n        if(!rootNode->leftChild && !rootNode->rightChild)\n            rootNode= NULL;\n    }\n    return leafGroups;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nvoid collectLeaves(TreeNode *currentNode, std::vector<std::vector<int>> &leafGroups, int &currentLevel)\n{\n    if(!currentNode)\n        return;\n    if(!currentNode->leftChild && !currentNode->rightChild)\n    {\n        if(leafGroups.size() <= currentLevel)\n        {\n            leafGroups.push_back(std::vector<int>());\n        }\n        leafGroups[currentLevel].push_back(currentNode->value);\n        currentNode= NULL;\n        return;\n    }\n    currentLevel++;\n    collectLeaves(currentNode->leftChild, leafGroups, currentLevel);\n    collectLeaves(currentNode->rightChild, leafGroups, currentLevel);\n    currentLevel--;\n}\n\nstd::vector<std::vector<int>> findLeaves(TreeNode *rootNode)\n{\n    std::vector<std::vector<int>> leafGroups;\n    int currentLevel= 0;\n    while(rootNode)\n    {\n        collectLeaves(rootNode, leafGroups, currentLevel);\n        if(!rootNode->leftChild && !rootNode->rightChild)\n            rootNode= NULL;\n    }\n    return leafGroups;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "bool isPerfectSquare(int inputNumber)\n{\n    if(inputNumber < 2)\n        return true;\n    long long lowerBound= 2, upperBound= inputNumber / 2, midPoint, squareValue;\n    while(lowerBound <= upperBound)\n    {\n        midPoint= lowerBound + (upperBound - lowerBound) / 2;\n        squareValue= midPoint * midPoint;\n        if(squareValue == inputNumber)\n            return true;\n        if(squareValue > inputNumber)\n            upperBound= midPoint - 1;\n        else\n            lowerBound= midPoint + 1;\n    }\n    return false;\n}",
    "output": "bool isPerfectSquare(int inputNumber)\n{\n    if(inputNumber < 2)\n        return true;\n    long long lowerBound= 2, upperBound= inputNumber / 2, midPoint, squareValue;\n    while(lowerBound <= upperBound)\n    {\n        midPoint= lowerBound + (upperBound - lowerBound) / 2;\n        squareValue= midPoint * midPoint;\n        if(squareValue == inputNumber)\n            return true;\n        if(squareValue > inputNumber)\n            upperBound= midPoint - 1;\n        else\n            lowerBound= midPoint + 1;\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> largestDivisibleSubset(vector<int> &inputNumbers)\n{\n    sort(inputNumbers.begin(), inputNumbers.end());\n    int totalNumbers= inputNumbers.size();\n    vector<int> subsetCount(totalNumbers, 1), previousIndex(totalNumbers, -1), result;\n    int maxIndex= 0;\n\n    for(int currentIndex= 1; currentIndex < totalNumbers; ++currentIndex)\n    {\n        for(int previousIndexValue= 0; previousIndexValue < currentIndex; ++previousIndexValue)\n        {\n            if(inputNumbers[currentIndex] % inputNumbers[previousIndexValue] == 0 && subsetCount[currentIndex] < subsetCount[previousIndexValue] + 1)\n            {\n                subsetCount[currentIndex]= subsetCount[previousIndexValue] + 1;\n                previousIndex[currentIndex]= previousIndexValue;\n            }\n        }\n        if(subsetCount[maxIndex] < subsetCount[currentIndex])\n            maxIndex= currentIndex;\n    }\n\n    for(int i= maxIndex; i >= 0; i= previousIndex[i])\n    {\n        result.push_back(inputNumbers[i]);\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> largestDivisibleSubset(std::vector<int> &inputNumbers)\n{\n    std::sort(inputNumbers.begin(), inputNumbers.end());\n    int totalNumbers = inputNumbers.size();\n    std::vector<int> subsetCount(totalNumbers, 1), previousIndex(totalNumbers, -1), result;\n    int maxIndex = 0;\n\n    for(int currentIndex = 1; currentIndex < totalNumbers; ++currentIndex)\n    {\n        for(int previousIndexValue = 0; previousIndexValue < currentIndex; ++previousIndexValue)\n        {\n            if(inputNumbers[currentIndex] % inputNumbers[previousIndexValue] == 0 && subsetCount[currentIndex] < subsetCount[previousIndexValue] + 1)\n            {\n                subsetCount[currentIndex] = subsetCount[previousIndexValue] + 1;\n                previousIndex[currentIndex] = previousIndexValue;\n            }\n        }\n        if(subsetCount[maxIndex] < subsetCount[currentIndex])\n            maxIndex = currentIndex;\n    }\n\n    for(int i = maxIndex; i >= 0; i = previousIndex[i])\n    {\n        result.push_back(inputNumbers[i]);\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *plusOne(ListNode *head)\n{\n    if(head == NULL)\n        return head;\n    if(plusOneDfs(head) == 1)\n    {\n        ListNode *newHead= new ListNode(1);\n        newHead->next= head;\n        return newHead;\n    }\n    return head;\n}\n\nint plusOneDfs(ListNode *node)\n{\n    if(node == NULL)\n        return 1;\n    int carry= plusOneDfs(node->next);\n    if(carry + node->value == 10)\n    {\n        node->value= 0;\n        return 1;\n    }\n    else\n    {\n        node->value+= carry;\n        return 0;\n    }\n}",
    "output": "struct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *plusOne(ListNode *head)\n{\n    if(head == NULL)\n        return head;\n    if(plusOneDfs(head) == 1)\n    {\n        ListNode *newHead= new ListNode(1);\n        newHead->next= head;\n        return newHead;\n    }\n    return head;\n}\n\nint plusOneDfs(ListNode *node)\n{\n    if(node == NULL)\n        return 1;\n    int carry= plusOneDfs(node->next);\n    if(carry + node->value == 10)\n    {\n        node->value= 0;\n        return 1;\n    }\n    else\n    {\n        node->value+= carry;\n        return 0;\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> getUpdatedArray(int arrayLength, vector<vector<int>> &updates)\n{\n    vector<int> resultArray(arrayLength, 0);\n\n    for (int i = 0; i < updates.size(); ++i)\n    {\n        const auto &update = updates[i];\n        resultArray[update[0]] += update[2];\n        if (update[1] + 1 < arrayLength)\n        {\n            resultArray[update[1] + 1] -= update[2];\n        }\n    }\n\n    for (int index = 1; index < arrayLength; index++)\n    {\n        resultArray[index] += resultArray[index - 1];\n    }\n\n    return resultArray;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> getUpdatedArray(int arrayLength, std::vector<std::vector<int>> &updates)\n{\n    std::vector<int> resultArray(arrayLength, 0);\n\n    for(const auto &update : updates)\n    {\n        resultArray[update[0]]+= update[2];\n        if(update[1] + 1 < arrayLength)\n        {\n            resultArray[update[1] + 1]-= update[2];\n        }\n    }\n\n    for(int index= 1; index < arrayLength; index++)\n    {\n        resultArray[index]+= resultArray[index - 1];\n    }\n\n    return resultArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int add(int firstOperand, int secondOperand)\n{\n    while(secondOperand != 0)\n    {\n        int carry= firstOperand & secondOperand;\n        firstOperand= firstOperand ^ secondOperand;\n        secondOperand= carry << 1;\n    }\n    return firstOperand;\n}",
    "output": "int add(int firstOperand, int secondOperand)\n{\n    while(secondOperand != 0)\n    {\n        int carry= firstOperand & secondOperand;\n        firstOperand= firstOperand ^ secondOperand;\n        secondOperand= carry << 1;\n    }\n    return firstOperand;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint powerMod(int base, int exponent)\n{\n    if(exponent == 0)\n        return 1;\n    int result = powerMod(base, exponent / 2);\n    if(exponent % 2 == 0)\n        return result * result % 1337;\n    return result * result % 1337 * base % 1337;\n}\n\nint superPow(int base, vector<int> &exponentDigits)\n{\n    int exponent = 0;\n    for (int i = 0; i < exponentDigits.size(); ++i)\n        exponent = (exponent * 10 + exponentDigits[i]) % 1140;\n    return powerMod(base % 1337, exponent + 1140);\n}",
    "output": "#include <bits/stdc++.h>\nint powerMod(int base, int exponent)\n{\n    if(exponent == 0)\n        return 1;\n    int result= powerMod(base, exponent / 2);\n    if(exponent % 2 == 0)\n        return result * result % 1337;\n    return result * result % 1337 * base % 1337;\n}\n\nint superPow(int base, std::vector<int> &exponentDigits)\n{\n    int exponent= 0;\n    for(int digit : exponentDigits)\n        exponent= (exponent * 10 + digit) % 1140;\n    return powerMod(base % 1337, exponent + 1140);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> findKSmallestPairs(vector<int> &firstArray, vector<int> &secondArray, int k)\n{\n    auto comparator= [&firstArray, &secondArray](pair<int, int> a, pair<int, int> b)\n    {\n        return firstArray[a.first] + secondArray[a.second] > firstArray[b.first] + secondArray[b.second];\n    };\n    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comparator)> minHeap(comparator);\n    vector<vector<int>> result;\n\n    if(firstArray.empty() || secondArray.empty())\n        return result;\n\n    for(int i= 0; i < firstArray.size(); ++i)\n    {\n        minHeap.emplace(i, 0);\n    }\n\n    while(k-- && !minHeap.empty())\n    {\n        auto currentPair= minHeap.top();\n        minHeap.pop();\n        result.push_back({firstArray[currentPair.first], secondArray[currentPair.second]});\n        if(currentPair.second + 1 < secondArray.size())\n        {\n            minHeap.emplace(currentPair.first, currentPair.second + 1);\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> findKSmallestPairs(std::vector<int> &firstArray, std::vector<int> &secondArray, int k)\n{\n    auto comparator = [&firstArray, &secondArray](std::pair<int, int> a, std::pair<int, int> b)\n    {\n        return firstArray[a.first] + secondArray[a.second] > firstArray[b.first] + secondArray[b.second];\n    };\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, decltype(comparator)> minHeap(comparator);\n    std::vector<std::vector<int>> result;\n\n    if(firstArray.empty() || secondArray.empty())\n        return result;\n\n    for(int i = 0; i < firstArray.size(); ++i)\n    {\n        minHeap.emplace(i, 0);\n    }\n\n    while(k-- && !minHeap.empty())\n    {\n        auto currentPair = minHeap.top();\n        minHeap.pop();\n        result.push_back({firstArray[currentPair.first], secondArray[currentPair.second]});\n        if(currentPair.second + 1 < secondArray.size())\n        {\n            minHeap.emplace(currentPair.first, currentPair.second + 1);\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int guessNumber(int upperLimit)\n{\n    int lowerBound= 1, upperBound= upperLimit;\n    while(lowerBound <= upperBound)\n    {\n        int midpoint= lowerBound + (upperBound - lowerBound) / 2;\n        int guessResult= guess(midpoint);\n        if(guessResult == 0)\n        {\n            return midpoint;\n        }\n        else if(guessResult < 0)\n        {\n            upperBound= midpoint - 1;\n        }\n        else\n        {\n            lowerBound= midpoint + 1;\n        }\n    }\n    return -1;\n}",
    "output": "int guessNumber(int upperLimit)\n{\n    int lowerBound= 1, upperBound= upperLimit;\n    while(lowerBound <= upperBound)\n    {\n        int midpoint= lowerBound + (upperBound - lowerBound) / 2;\n        int guessResult= guess(midpoint);\n        if(guessResult == 0)\n        {\n            return midpoint;\n        }\n        else if(guessResult < 0)\n        {\n            upperBound= midpoint - 1;\n        }\n        else\n        {\n            lowerBound= midpoint + 1;\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint getMoneyAmount(int numberOfChances)\n{\n    vector<vector<int>> minimumCostMatrix(numberOfChances + 1, vector<int>(numberOfChances + 1, 0));\n    for(int currentStart= numberOfChances - 1; currentStart >= 1; currentStart--)\n    {\n        for(int currentEnd= currentStart + 1; currentEnd <= numberOfChances; currentEnd++)\n        {\n            int minimumCost= INT_MAX;\n            for(int guess= currentStart; guess < currentEnd; guess++)\n            {\n                int cost= guess + max(minimumCostMatrix[currentStart][guess - 1], minimumCostMatrix[guess + 1][currentEnd]);\n                minimumCost= min(minimumCost, cost);\n            }\n            minimumCostMatrix[currentStart][currentEnd]= minimumCost;\n        }\n    }\n    return minimumCostMatrix[1][numberOfChances];\n}",
    "output": "#include <bits/stdc++.h>\nint getMoneyAmount(int numberOfChances)\n{\n    std::vector<std::vector<int>> minimumCostMatrix(numberOfChances + 1, std::vector<int>(numberOfChances + 1, 0));\n    for(int currentStart = numberOfChances - 1; currentStart >= 1; currentStart--)\n    {\n        for(int currentEnd = currentStart + 1; currentEnd <= numberOfChances; currentEnd++)\n        {\n            int minimumCost = std::numeric_limits<int>::max();\n            for(int guess = currentStart; guess < currentEnd; guess++)\n            {\n                int cost = guess + std::max(minimumCostMatrix[currentStart][guess - 1], minimumCostMatrix[guess + 1][currentEnd]);\n                minimumCost = std::min(minimumCost, cost);\n            }\n            minimumCostMatrix[currentStart][currentEnd] = minimumCost;\n        }\n    }\n    return minimumCostMatrix[1][numberOfChances];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint getWiggleMaxLength(vector<int> &numberSequence)\n{\n    int sequenceLength= numberSequence.size();\n    if(sequenceLength < 2)\n        return sequenceLength;\n\n    int upCount= 1, downCount= 1;\n    for(int index= 1; index < sequenceLength; ++index)\n    {\n        if(numberSequence[index] > numberSequence[index - 1])\n            upCount= downCount + 1;\n        else if(numberSequence[index] < numberSequence[index - 1])\n            downCount= upCount + 1;\n    }\n    return max(upCount, downCount);\n}",
    "output": "#include <bits/stdc++.h>\nint getWiggleMaxLength(std::vector<int> &numberSequence)\n{\n    int sequenceLength= numberSequence.size();\n    if(sequenceLength < 2)\n        return sequenceLength;\n\n    int upCount= 1, downCount= 1;\n    for(int index= 1; index < sequenceLength; ++index)\n    {\n        if(numberSequence[index] > numberSequence[index - 1])\n            upCount= downCount + 1;\n        else if(numberSequence[index] < numberSequence[index - 1])\n            downCount= upCount + 1;\n    }\n    return std::max(upCount, downCount);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint combinationSum(vector<int> &numberList, int targetSum)\n{\n    vector<int> dynamicProgrammingArray(targetSum + 1, 0);\n    dynamicProgrammingArray[0] = 1;\n\n    for (int i = 0; i < numberList.size(); ++i)\n    {\n        int currentNumber = numberList[i];\n        for (int currentTarget = currentNumber; currentTarget <= targetSum; currentTarget++)\n        {\n            dynamicProgrammingArray[currentTarget] += dynamicProgrammingArray[currentTarget - currentNumber];\n        }\n    }\n\n    return dynamicProgrammingArray[targetSum];\n}",
    "output": "#include <bits/stdc++.h>\nint combinationSum(std::vector<int> &numberList, int targetSum)\n{\n    std::vector<int> dynamicProgrammingArray(targetSum + 1, 0);\n    dynamicProgrammingArray[0] = 1;\n\n    for(int currentNumber : numberList)\n    {\n        for(int currentTarget = currentNumber; currentTarget <= targetSum; currentTarget++)\n        {\n            dynamicProgrammingArray[currentTarget] += dynamicProgrammingArray[currentTarget - currentNumber];\n        }\n    }\n\n    return dynamicProgrammingArray[targetSum];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findKthSmallest(vector<vector<int>> &numberMatrix, int k)\n{\n    int matrixSize = numberMatrix.size();\n    priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>> minHeap;\n\n    for(int rowIndex = 0; rowIndex < matrixSize; ++rowIndex)\n    {\n        minHeap.emplace(numberMatrix[rowIndex][0], make_pair(rowIndex, 0));\n    }\n\n    while(--k)\n    {\n        auto [currentValue, currentPosition] = minHeap.top();\n        minHeap.pop();\n\n        if(++currentPosition.second < matrixSize)\n        {\n            minHeap.emplace(numberMatrix[currentPosition.first][currentPosition.second], currentPosition);\n        }\n    }\n\n    return minHeap.top().first;\n}",
    "output": "#include <bits/stdc++.h>\nint findKthSmallest(std::vector<std::vector<int>> &numberMatrix, int k)\n{\n    int matrixSize= numberMatrix.size();\n    std::priority_queue<std::pair<int, std::pair<int, int>>, std::vector<std::pair<int, std::pair<int, int>>>, std::greater<>> minHeap;\n\n    for(int rowIndex= 0; rowIndex < matrixSize; ++rowIndex)\n    {\n        minHeap.emplace(numberMatrix[rowIndex][0], std::make_pair(rowIndex, 0));\n    }\n\n    while(--k)\n    {\n        auto [currentValue, currentPosition]= minHeap.top();\n        minHeap.pop();\n\n        if(++currentPosition.second < matrixSize)\n        {\n            minHeap.emplace(numberMatrix[currentPosition.first][currentPosition.second], currentPosition);\n        }\n    }\n\n    return minHeap.top().first;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass PhoneDirectory\n{\n    vector<bool> isAvailable;\n    queue<int> releasedNumbers;\n\n  public:\n    PhoneDirectory(int maxNumbers) : isAvailable(maxNumbers, true) {}\n\n    int get()\n    {\n        if(!releasedNumbers.empty())\n        {\n            int number= releasedNumbers.front();\n            releasedNumbers.pop();\n            isAvailable[number]= false;\n            return number;\n        }\n        for(int i= 0; i < isAvailable.size(); i++)\n        {\n            if(isAvailable[i])\n            {\n                isAvailable[i]= false;\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    bool check(int number)\n    {\n        return isAvailable[number];\n    }\n\n    void release(int number)\n    {\n        if(!isAvailable[number])\n        {\n            isAvailable[number]= true;\n            releasedNumbers.push(number);\n        }\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass PhoneDirectory\n{\n    std::vector<bool> isAvailable;\n    std::queue<int> releasedNumbers;\n\n  public:\n    PhoneDirectory(int maxNumbers) : isAvailable(maxNumbers, true) {}\n\n    int get()\n    {\n        if(!releasedNumbers.empty())\n        {\n            int number= releasedNumbers.front();\n            releasedNumbers.pop();\n            isAvailable[number]= false;\n            return number;\n        }\n        for(int i= 0; i < isAvailable.size(); i++)\n        {\n            if(isAvailable[i])\n            {\n                isAvailable[i]= false;\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    bool check(int number)\n    {\n        return isAvailable[number];\n    }\n\n    void release(int number)\n    {\n        if(!isAvailable[number])\n        {\n            isAvailable[number]= true;\n            releasedNumbers.push(number);\n        }\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass RandomizedSet\n{\n    unordered_map<int, int> valueIndexMap;\n    vector<int> values;\n\n  public:\n    bool insert(int value)\n    {\n        if(valueIndexMap.count(value))\n            return false;\n\n        valueIndexMap[value]= values.size();\n        values.push_back(value);\n        return true;\n    }\n\n    bool remove(int value)\n    {\n        if(!valueIndexMap.count(value))\n            return false;\n\n        int lastValue= values.back();\n        valueIndexMap[lastValue]= valueIndexMap[value];\n        values[valueIndexMap[value]]= lastValue;\n\n        values.pop_back();\n        valueIndexMap.erase(value);\n        return true;\n    }\n\n    int getRandom()\n    {\n        return values[rand() % values.size()];\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass RandomizedSet\n{\n    std::unordered_map<int, int> valueIndexMap;\n    std::vector<int> values;\n\n  public:\n    bool insert(int value)\n    {\n        if(valueIndexMap.count(value))\n            return false;\n\n        valueIndexMap[value]= values.size();\n        values.push_back(value);\n        return true;\n    }\n\n    bool remove(int value)\n    {\n        if(!valueIndexMap.count(value))\n            return false;\n\n        int lastValue= values.back();\n        valueIndexMap[lastValue]= valueIndexMap[value];\n        values[valueIndexMap[value]]= lastValue;\n\n        values.pop_back();\n        valueIndexMap.erase(value);\n        return true;\n    }\n\n    int getRandom()\n    {\n        return values[rand() % values.size()];\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass RandomizedCollection\n{\n  public:\n    unordered_map<int, unordered_set<int>> valueIndices;\n    vector<int> values;\n\n    bool insert(int newValue)\n    {\n        values.push_back(newValue);\n        valueIndices[newValue].insert(values.size() - 1);\n        return valueIndices[newValue].size() == 1;\n    }\n\n    bool remove(int existingValue)\n    {\n        if(!valueIndices[existingValue].size())\n            return false;\n        int index= *valueIndices[existingValue].begin();\n        valueIndices[existingValue].erase(index);\n        if(index < values.size() - 1)\n        {\n            int lastValue= values.back();\n            values[index]= lastValue;\n            valueIndices[lastValue].erase(values.size() - 1);\n            valueIndices[lastValue].insert(index);\n        }\n        values.pop_back();\n        return true;\n    }\n\n    int getRandom()\n    {\n        return values[rand() % values.size()];\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass RandomizedCollection\n{\n  public:\n    std::unordered_map<int, std::unordered_set<int>> valueIndices;\n    std::vector<int> values;\n\n    bool insert(int newValue)\n    {\n        values.push_back(newValue);\n        valueIndices[newValue].insert(values.size() - 1);\n        return valueIndices[newValue].size() == 1;\n    }\n\n    bool remove(int existingValue)\n    {\n        if(!valueIndices[existingValue].size())\n            return false;\n        int index= *valueIndices[existingValue].begin();\n        valueIndices[existingValue].erase(index);\n        if(index < values.size() - 1)\n        {\n            int lastValue= values.back();\n            values[index]= lastValue;\n            valueIndices[lastValue].erase(values.size() - 1);\n            valueIndices[lastValue].insert(index);\n        }\n        values.pop_back();\n        return true;\n    }\n\n    int getRandom()\n    {\n        return values[std::rand() % values.size()];\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    ListNode *head;\n\n    Solution(ListNode *initialHead)\n    {\n        head = initialHead;\n        srand(time(0));\n    }\n\n    int getRandom()\n    {\n        int randomValue;\n        ListNode *currentNode = head;\n        for (int i = 1; currentNode; ++i)\n        {\n            if (rand() % i == 0)\n            {\n                randomValue = currentNode->value;\n            }\n            currentNode = currentNode->next;\n        }\n        return randomValue;\n    }\n};\n",
    "output": "#include <bits/stdc++.h>\nstruct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    ListNode *head;\n\n    Solution(ListNode *initialHead)\n    {\n        head= initialHead;\n        std::srand(std::time(0));\n    }\n\n    int getRandom()\n    {\n        int randomValue;\n        ListNode *currentNode= head;\n        for(int i= 1; currentNode; ++i)\n        {\n            if(std::rand() % i == 0)\n            {\n                randomValue= currentNode->value;\n            }\n            currentNode= currentNode->next;\n        }\n        return randomValue;\n    }\n};\n"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canConstruct(string ransomNote, string magazine)\n{\n    unordered_map<char, int> letterCount;\n    for (int i = 0; i < magazine.size(); ++i)\n    {\n        char character = magazine[i];\n        letterCount[character]++;\n    }\n\n    for (int i = 0; i < ransomNote.size(); ++i)\n    {\n        char character = ransomNote[i];\n        if (letterCount[character] == 0)\n        {\n            return false;\n        }\n        letterCount[character]--;\n    }\n\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool canConstruct(std::string ransomNote, std::string magazine)\n{\n    std::unordered_map<char, int> letterCount;\n    for(char character : magazine)\n    {\n        letterCount[character]++;\n    }\n\n    for(char character : ransomNote)\n    {\n        if(letterCount[character] == 0)\n        {\n            return false;\n        }\n        letterCount[character]--;\n    }\n\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution\n{\n  public:\n    Solution(vector<int> &inputNumbers)\n    {\n        originalNumbers = inputNumbers;\n        srand(time(0));\n    }\n\n    vector<int> reset()\n    {\n        return originalNumbers;\n    }\n\n    vector<int> shuffle()\n    {\n        vector<int> shuffledNumbers = originalNumbers;\n        for(int currentIndex = shuffledNumbers.size() - 1; currentIndex > 0; currentIndex--)\n        {\n            int randomIndex = rand() % (currentIndex + 1);\n            swap(shuffledNumbers[currentIndex], shuffledNumbers[randomIndex]);\n        }\n        return shuffledNumbers;\n    }\n\n  private:\n    vector<int> originalNumbers;\n};",
    "output": "#include <bits/stdc++.h>\nclass Solution\n{\n  public:\n    Solution(std::vector<int> &inputNumbers)\n    {\n        originalNumbers= inputNumbers;\n        srand(time(0));\n    }\n\n    std::vector<int> reset()\n    {\n        return originalNumbers;\n    }\n\n    std::vector<int> shuffle()\n    {\n        std::vector<int> shuffledNumbers= originalNumbers;\n        for(int currentIndex= shuffledNumbers.size() - 1; currentIndex > 0; currentIndex--)\n        {\n            int randomIndex= rand() % (currentIndex + 1);\n            std::swap(shuffledNumbers[currentIndex], shuffledNumbers[randomIndex]);\n        }\n        return shuffledNumbers;\n    }\n\n  private:\n    std::vector<int> originalNumbers;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass NestedInteger\n{\n  public:\n    NestedInteger() {}\n    NestedInteger(int value) {}\n    void add(const NestedInteger &nestedInteger) {}\n};\n\nNestedInteger deserialize(string serializedString);\n\nNestedInteger deserializeHelper(istringstream &stringStream)\n{\n    int number;\n    if(stringStream >> number)\n        return NestedInteger(number);\n\n    stringStream.clear();\n    stringStream.get();\n    NestedInteger nestedList;\n    while(stringStream.peek() != ']')\n    {\n        nestedList.add(deserializeHelper(stringStream));\n        if(stringStream.peek() == ',')\n            stringStream.get();\n    }\n    stringStream.get();\n    return nestedList;\n}\n\nNestedInteger deserialize(string serializedString)\n{\n    istringstream stringStream(serializedString);\n    return deserializeHelper(stringStream);\n}",
    "output": "#include <bits/stdc++.h>\nclass NestedInteger\n{\n  public:\n    NestedInteger() {}\n    NestedInteger(int value) {}\n    void add(const NestedInteger &nestedInteger) {}\n};\n\nNestedInteger deserialize(std::string serializedString);\n\nNestedInteger deserializeHelper(std::istringstream &stringStream)\n{\n    int number;\n    if(stringStream >> number)\n        return NestedInteger(number);\n\n    stringStream.clear();\n    stringStream.get();\n    NestedInteger nestedList;\n    while(stringStream.peek() != ']')\n    {\n        nestedList.add(deserializeHelper(stringStream));\n        if(stringStream.peek() == ',')\n            stringStream.get();\n    }\n    stringStream.get();\n    return nestedList;\n}\n\nNestedInteger deserialize(std::string serializedString)\n{\n    std::istringstream stringStream(serializedString);\n    return deserializeHelper(stringStream);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generateLexicographicalOrder(int currentNumber, int upperLimit, vector<int> &orderedResult)\n{\n    if(currentNumber > upperLimit)\n        return;\n\n    orderedResult.push_back(currentNumber);\n    for(int digit= 0; digit <= 9; ++digit)\n    {\n        generateLexicographicalOrder(currentNumber * 10 + digit, upperLimit, orderedResult);\n    }\n}\n\nvector<int> getLexicalOrder(int n)\n{\n    vector<int> orderedResult;\n    for(int startingDigit= 1; startingDigit <= 9; ++startingDigit)\n    {\n        generateLexicographicalOrder(startingDigit, n, orderedResult);\n    }\n    return orderedResult;\n}",
    "output": "#include <bits/stdc++.h>\nvoid generateLexicographicalOrder(int currentNumber, int upperLimit, std::vector<int> &orderedResult)\n{\n    if(currentNumber > upperLimit)\n        return;\n\n    orderedResult.push_back(currentNumber);\n    for(int digit= 0; digit <= 9; ++digit)\n    {\n        generateLexicographicalOrder(currentNumber * 10 + digit, upperLimit, orderedResult);\n    }\n}\n\nstd::vector<int> getLexicalOrder(int n)\n{\n    std::vector<int> orderedResult;\n    for(int startingDigit= 1; startingDigit <= 9; ++startingDigit)\n    {\n        generateLexicographicalOrder(startingDigit, n, orderedResult);\n    }\n    return orderedResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint firstUniqChar(string inputString)\n{\n    unordered_map<char, int> characterCount;\n    for (int i = 0; i < inputString.length(); i++)\n        characterCount[inputString[i]]++;\n    for (int index = 0; index < inputString.length(); index++)\n        if (characterCount[inputString[index]] == 1)\n            return index;\n    return -1;\n}",
    "output": "int firstUniqChar(std::string inputString)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentChar : inputString)\n        characterCount[currentChar]++;\n    for(int index= 0; index < inputString.length(); index++)\n        if(characterCount[inputString[index]] == 1)\n            return index;\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint lengthLongestPath(string input)\n{\n    istringstream inputStream(input);\n    vector<int> directoryLengthStack;\n    string line;\n    int maxFileLength = 0;\n\n    while(getline(inputStream, line, '\\n'))\n    {\n        int level = 0;\n        while(line.find('\\t') != string::npos)\n        {\n            line.erase(0, 1);\n            level++;\n        }\n\n        while(directoryLengthStack.size() > level)\n            directoryLengthStack.pop_back();\n\n        int length;\n        if(directoryLengthStack.empty())\n        {\n            length = line.length();\n        }\n        else\n        {\n            length = directoryLengthStack.back() + line.length() + 1;\n        }\n        directoryLengthStack.push_back(length);\n\n        if(line.find('.') != string::npos)\n        {\n            maxFileLength = max(maxFileLength, length);\n        }\n    }\n\n    return maxFileLength;\n}",
    "output": "#include <bits/stdc++.h>\nint lengthLongestPath(std::string input)\n{\n    std::istringstream inputStream(input);\n    std::vector<int> directoryLengthStack;\n    std::string line;\n    int maxFileLength= 0;\n\n    while(std::getline(inputStream, line, '\\n'))\n    {\n        int level= 0;\n        while(line.find('\\t') != std::string::npos)\n        {\n            line.erase(0, 1);\n            level++;\n        }\n\n        while(directoryLengthStack.size() > level)\n            directoryLengthStack.pop_back();\n\n        int length;\n        if(directoryLengthStack.empty())\n        {\n            length= line.length();\n        }\n        else\n        {\n            length= directoryLengthStack.back() + line.length() + 1;\n        }\n        directoryLengthStack.push_back(length);\n\n        if(line.find('.') != std::string::npos)\n        {\n            maxFileLength= std::max(maxFileLength, length);\n        }\n    }\n\n    return maxFileLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar findTheDifference(string sourceString, string targetString)\n{\n    int sumSource = 0, sumTarget = 0;\n    for (int i = 0; i < sourceString.size(); ++i)\n        sumSource += sourceString[i];\n    for (int i = 0; i < targetString.size(); ++i)\n        sumTarget += targetString[i];\n    return sumTarget - sumSource;\n}",
    "output": "char findTheDifference(std::string sourceString, std::string targetString)\n{\n    int sumSource= 0, sumTarget= 0;\n    for(char character : sourceString)\n        sumSource+= character;\n    for(char character : targetString)\n        sumTarget+= character;\n    return sumTarget - sumSource;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int lastRemaining(int totalNumbers)\n{\n    bool isLeftDirection= true;\n    int currentHead= 1, remainingCount= totalNumbers, stepSize= 1;\n\n    while(remainingCount > 1)\n    {\n        if(isLeftDirection || remainingCount % 2 == 1)\n        {\n            currentHead+= stepSize;\n        }\n        remainingCount/= 2;\n        stepSize*= 2;\n        isLeftDirection= !isLeftDirection;\n    }\n\n    return currentHead;\n}",
    "output": "int lastRemaining(int totalNumbers)\n{\n    bool isLeftDirection= true;\n    int currentHead= 1, remainingCount= totalNumbers, stepSize= 1;\n\n    while(remainingCount > 1)\n    {\n        if(isLeftDirection || remainingCount % 2 == 1)\n        {\n            currentHead+= stepSize;\n        }\n        remainingCount/= 2;\n        stepSize*= 2;\n        isLeftDirection= !isLeftDirection;\n    }\n\n    return currentHead;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isRectangleCover(vector<vector<int>> &rectangles)\n{\n    int totalArea = 0;\n    set<pair<int, int>> uniquePoints;\n    int leftX = INT_MAX, leftY = INT_MAX, rightX = INT_MIN, rightY = INT_MIN;\n\n    for (int i = 0; i < rectangles.size(); ++i)\n    {\n        auto &rectangle = rectangles[i];\n        leftX = min(leftX, rectangle[0]);\n        leftY = min(leftY, rectangle[1]);\n        rightX = max(rightX, rectangle[2]);\n        rightY = max(rightY, rectangle[3]);\n\n        totalArea += (rectangle[2] - rectangle[0]) * (rectangle[3] - rectangle[1]);\n\n        pair<int, int> bottomLeft(rectangle[0], rectangle[1]);\n        pair<int, int> topLeft(rectangle[0], rectangle[3]);\n        pair<int, int> bottomRight(rectangle[2], rectangle[1]);\n        pair<int, int> topRight(rectangle[2], rectangle[3]);\n\n        if (!uniquePoints.erase(bottomLeft))\n            uniquePoints.insert(bottomLeft);\n        if (!uniquePoints.erase(topLeft))\n            uniquePoints.insert(topLeft);\n        if (!uniquePoints.erase(bottomRight))\n            uniquePoints.insert(bottomRight);\n        if (!uniquePoints.erase(topRight))\n            uniquePoints.insert(topRight);\n    }\n\n    if (uniquePoints.count({leftX, leftY}) && uniquePoints.count({leftX, rightY}) &&\n        uniquePoints.count({rightX, leftY}) && uniquePoints.count({rightX, rightY}) &&\n        uniquePoints.size() == 4)\n        return totalArea == (rightX - leftX) * (rightY - leftY);\n\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool isRectangleCover(std::vector<std::vector<int>> &rectangles)\n{\n    int totalArea= 0;\n    std::set<std::pair<int, int>> uniquePoints;\n    int leftX= INT_MAX, leftY= INT_MAX, rightX= INT_MIN, rightY= INT_MIN;\n\n    for(auto &rectangle : rectangles)\n    {\n        leftX= std::min(leftX, rectangle[0]);\n        leftY= std::min(leftY, rectangle[1]);\n        rightX= std::max(rightX, rectangle[2]);\n        rightY= std::max(rightY, rectangle[3]);\n\n        totalArea+= (rectangle[2] - rectangle[0]) * (rectangle[3] - rectangle[1]);\n\n        std::pair<int, int> bottomLeft(rectangle[0], rectangle[1]);\n        std::pair<int, int> topLeft(rectangle[0], rectangle[3]);\n        std::pair<int, int> bottomRight(rectangle[2], rectangle[1]);\n        std::pair<int, int> topRight(rectangle[2], rectangle[3]);\n\n        if(!uniquePoints.erase(bottomLeft))\n            uniquePoints.insert(bottomLeft);\n        if(!uniquePoints.erase(topLeft))\n            uniquePoints.insert(topLeft);\n        if(!uniquePoints.erase(bottomRight))\n            uniquePoints.insert(bottomRight);\n        if(!uniquePoints.erase(topRight))\n            uniquePoints.insert(topRight);\n    }\n\n    if(uniquePoints.count({leftX, leftY}) && uniquePoints.count({leftX, rightY}) &&\n       uniquePoints.count({rightX, leftY}) && uniquePoints.count({rightX, rightY}) &&\n       uniquePoints.size() == 4)\n        return totalArea == (rightX - leftX) * (rightY - leftY);\n\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isSubsequence(string subsequence, string target)\n{\n    int subsequenceIndex= 0, targetIndex= 0;\n\n    while(subsequenceIndex < subsequence.size() && targetIndex < target.size())\n    {\n        if(subsequence[subsequenceIndex] == target[targetIndex])\n            subsequenceIndex++;\n        targetIndex++;\n    }\n\n    return subsequenceIndex == subsequence.size();\n}",
    "output": "bool isSubsequence(std::string subsequence, std::string target)\n{\n    int subsequenceIndex= 0, targetIndex= 0;\n\n    while(subsequenceIndex < subsequence.size() && targetIndex < target.size())\n    {\n        if(subsequence[subsequenceIndex] == target[targetIndex])\n            subsequenceIndex++;\n        targetIndex++;\n    }\n\n    return subsequenceIndex == subsequence.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidUtf8(vector<int> &byteData)\n{\n    int remainingBytes = 0;\n    for (int i = 0; i < byteData.size(); ++i)\n    {\n        int currentByte = byteData[i];\n        if (remainingBytes == 0)\n        {\n            if ((currentByte >> 5) == 0b110)\n                remainingBytes = 1;\n            else if ((currentByte >> 4) == 0b1110)\n                remainingBytes = 2;\n            else if ((currentByte >> 3) == 0b11110)\n                remainingBytes = 3;\n            else if ((currentByte >> 7))\n                return false;\n        }\n        else\n        {\n            if ((currentByte >> 6) != 0b10)\n                return false;\n            remainingBytes--;\n        }\n    }\n    return remainingBytes == 0;\n}",
    "output": "#include <bits/stdc++.h>\nbool isValidUtf8(std::vector<int> &byteData)\n{\n    int remainingBytes= 0;\n    for(int currentByte : byteData)\n    {\n        if(remainingBytes == 0)\n        {\n            if((currentByte >> 5) == 0b110)\n                remainingBytes= 1;\n            else if((currentByte >> 4) == 0b1110)\n                remainingBytes= 2;\n            else if((currentByte >> 3) == 0b11110)\n                remainingBytes= 3;\n            else if((currentByte >> 7))\n                return false;\n        }\n        else\n        {\n            if((currentByte >> 6) != 0b10)\n                return false;\n            remainingBytes--;\n        }\n    }\n    return remainingBytes == 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring decodeString(const string &encodedString)\n{\n    stack<int> repeatCounts;\n    stack<string> stringResults;\n    string currentSubstring;\n    int currentIndex = 0;\n\n    while(currentIndex < encodedString.size())\n    {\n        if(isdigit(encodedString[currentIndex]))\n        {\n            int repeatCount = 0;\n            while(isdigit(encodedString[currentIndex]))\n            {\n                repeatCount = repeatCount * 10 + (encodedString[currentIndex] - '0');\n                currentIndex++;\n            }\n            repeatCounts.push(repeatCount);\n        }\n        else if(encodedString[currentIndex] == '[')\n        {\n            stringResults.push(currentSubstring);\n            currentSubstring = \"\";\n            currentIndex++;\n        }\n        else if(encodedString[currentIndex] == ']')\n        {\n            string previousSubstring = stringResults.top();\n            stringResults.pop();\n            int repeatCount = repeatCounts.top();\n            repeatCounts.pop();\n            for(int i = 0; i < repeatCount; i++)\n            {\n                previousSubstring += currentSubstring;\n            }\n            currentSubstring = previousSubstring;\n            currentIndex++;\n        }\n        else\n        {\n            currentSubstring += encodedString[currentIndex];\n            currentIndex++;\n        }\n    }\n\n    return currentSubstring;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string decodeString(const std::string &encodedString)\n{\n    std::stack<int> repeatCounts;\n    std::stack<std::string> stringResults;\n    std::string currentSubstring;\n    int currentIndex= 0;\n\n    while(currentIndex < encodedString.size())\n    {\n        if(isdigit(encodedString[currentIndex]))\n        {\n            int repeatCount= 0;\n            while(isdigit(encodedString[currentIndex]))\n            {\n                repeatCount= repeatCount * 10 + (encodedString[currentIndex] - '0');\n                currentIndex++;\n            }\n            repeatCounts.push(repeatCount);\n        }\n        else if(encodedString[currentIndex] == '[')\n        {\n            stringResults.push(currentSubstring);\n            currentSubstring= \"\";\n            currentIndex++;\n        }\n        else if(encodedString[currentIndex] == ']')\n        {\n            std::string previousSubstring= stringResults.top();\n            stringResults.pop();\n            int repeatCount= repeatCounts.top();\n            repeatCounts.pop();\n            for(int i= 0; i < repeatCount; i++)\n            {\n                previousSubstring+= currentSubstring;\n            }\n            currentSubstring= previousSubstring;\n            currentIndex++;\n        }\n        else\n        {\n            currentSubstring+= encodedString[currentIndex];\n            currentIndex++;\n        }\n    }\n\n    return currentSubstring;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint longestSubstring(const string &inputString, int minFrequency)\n{\n    if(inputString.empty() || minFrequency <= 0)\n        return 0;\n\n    unordered_map<char, int> characterCount;\n    for(char character : inputString)\n        characterCount[character]++;\n\n    for(auto it = characterCount.begin(); it != characterCount.end(); ++it)\n    {\n        if(it->second < minFrequency)\n        {\n            int maxLength= 0;\n            for(size_t i = 0; i < split(inputString, it->first).size(); ++i)\n            {\n                const string &substring = split(inputString, it->first)[i];\n                maxLength= max(maxLength, longestSubstring(substring, minFrequency));\n            }\n            return maxLength;\n        }\n    }\n    return inputString.length();\n}\n\nvector<string> split(const string &inputString, char delimiter)\n{\n    vector<string> substrings;\n    size_t startIndex= 0;\n    size_t endIndex= inputString.find(delimiter);\n    while(endIndex != string::npos)\n    {\n        substrings.push_back(inputString.substr(startIndex, endIndex - startIndex));\n        startIndex= endIndex + 1;\n        endIndex= inputString.find(delimiter, startIndex);\n    }\n    substrings.push_back(inputString.substr(startIndex));\n    return substrings;\n}",
    "output": "#include <bits/stdc++.h>\nint longestSubstring(const std::string &inputString, int minFrequency)\n{\n    if(inputString.empty() || minFrequency <= 0)\n        return 0;\n\n    std::unordered_map<char, int> characterCount;\n    for(char character : inputString)\n        characterCount[character]++;\n\n    for(const auto &countPair : characterCount)\n    {\n        if(countPair.second < minFrequency)\n        {\n            int maxLength= 0;\n            for(const std::string &substring : split(inputString, countPair.first))\n                maxLength= std::max(maxLength, longestSubstring(substring, minFrequency));\n            return maxLength;\n        }\n    }\n    return inputString.length();\n}\n\nstd::vector<std::string> split(const std::string &inputString, char delimiter)\n{\n    std::vector<std::string> substrings;\n    size_t startIndex= 0;\n    size_t endIndex= inputString.find(delimiter);\n    while(endIndex != std::string::npos)\n    {\n        substrings.push_back(inputString.substr(startIndex, endIndex - startIndex));\n        startIndex= endIndex + 1;\n        endIndex= inputString.find(delimiter, startIndex);\n    }\n    substrings.push_back(inputString.substr(startIndex));\n    return substrings;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxRotateFunction(vector<int> &numArray)\n{\n    int arraySize= numArray.size();\n    int totalSum= 0;\n    int currentFunctionValue= 0;\n\n    for(int index= 0; index < arraySize; index++)\n    {\n        totalSum+= numArray[index];\n        currentFunctionValue+= index * numArray[index];\n    }\n\n    int maxFunctionValue= currentFunctionValue;\n    for(int i= 1; i < arraySize; i++)\n    {\n        currentFunctionValue+= totalSum - arraySize * numArray[arraySize - i];\n        maxFunctionValue= max(maxFunctionValue, currentFunctionValue);\n    }\n\n    return maxFunctionValue;\n}",
    "output": "#include <bits/stdc++.h>\nint maxRotateFunction(std::vector<int> &numArray)\n{\n    int arraySize= numArray.size();\n    int totalSum= 0;\n    int currentFunctionValue= 0;\n\n    for(int index= 0; index < arraySize; index++)\n    {\n        totalSum+= numArray[index];\n        currentFunctionValue+= index * numArray[index];\n    }\n\n    int maxFunctionValue= currentFunctionValue;\n    for(int i= 1; i < arraySize; i++)\n    {\n        currentFunctionValue+= totalSum - arraySize * numArray[arraySize - i];\n        maxFunctionValue= std::max(maxFunctionValue, currentFunctionValue);\n    }\n\n    return maxFunctionValue;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int minOperations(int inputNumber)\n{\n    int operationCount= 0;\n    while(inputNumber > 1)\n    {\n        inputNumber= (inputNumber % 2 == 0) ? inputNumber / 2 : inputNumber - 1;\n        operationCount++;\n    }\n    return operationCount;\n}",
    "output": "int minOperations(int inputNumber)\n{\n    int operationCount= 0;\n    while(inputNumber > 1)\n    {\n        inputNumber= (inputNumber % 2 == 0) ? inputNumber / 2 : inputNumber - 1;\n        operationCount++;\n    }\n    return operationCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution\n{\n  public:\n    vector<int> numberList;\n\n    Solution(vector<int> &numberList)\n    {\n        this->numberList = numberList;\n    }\n\n    int pick(int target)\n    {\n        int count = 0, resultIndex = 0;\n        for(int index = 0; index < numberList.size(); index++)\n        {\n            if(numberList[index] == target)\n            {\n                count++;\n                if(rand() % count == 0)\n                {\n                    resultIndex = index;\n                }\n            }\n        }\n        return resultIndex;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Solution\n{\n  public:\n    std::vector<int> numberList;\n\n    Solution(std::vector<int> &numberList)\n    {\n        this->numberList= numberList;\n    }\n\n    int pick(int target)\n    {\n        int count= 0, resultIndex= 0;\n        for(int index= 0; index < numberList.size(); index++)\n        {\n            if(numberList[index] == target)\n            {\n                count++;\n                if(std::rand() % count == 0)\n                {\n                    resultIndex= index;\n                }\n            }\n        }\n        return resultIndex;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble depthFirstSearch(const string &startNode, const string &endNode, unordered_map<string, vector<pair<string, double>>> &graph)\n{\n    if(!graph.count(startNode) || !graph.count(endNode))\n        return -1.0;\n    if(startNode == endNode)\n        return 1.0;\n\n    for (auto it = graph[startNode].begin(); it != graph[startNode].end(); ++it)\n    {\n        double result = depthFirstSearch(it->first, endNode, graph);\n        if(result > 0)\n            return it->second * result;\n    }\n    return -1.0;\n}\n\nvector<double> calculateEquation(vector<vector<string>> &equations, vector<double> &values, vector<vector<string>> &queries)\n{\n    unordered_map<string, vector<pair<string, double>>> graph;\n    for(int index = 0; index < equations.size(); index++)\n    {\n        graph[equations[index][0]].push_back({equations[index][1], values[index]});\n        graph[equations[index][1]].push_back({equations[index][0], 1 / values[index]});\n    }\n\n    vector<double> results;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        results.push_back(depthFirstSearch(queries[i][0], queries[i][1], graph));\n    }\n    return results;\n}",
    "output": "#include <bits/stdc++.h>\nstd::unordered_map<std::string, std::vector<std::pair<std::string, double>>> graph;\n\ndouble depthFirstSearch(const std::string &startNode, const std::string &endNode, std::unordered_map<std::string, std::vector<std::pair<std::string, double>>> &graph)\n{\n    if(!graph.count(startNode) || !graph.count(endNode))\n        return -1.0;\n    if(startNode == endNode)\n        return 1.0;\n\n    for(auto &edge : graph[startNode])\n    {\n        double result= depthFirstSearch(edge.first, endNode, graph);\n        if(result > 0)\n            return edge.second * result;\n    }\n    return -1.0;\n}\n\nstd::vector<double> calculateEquation(std::vector<std::vector<std::string>> &equations, std::vector<double> &values, std::vector<std::vector<std::string>> &queries)\n{\n    std::unordered_map<std::string, std::vector<std::pair<std::string, double>>> graph;\n    for(int index= 0; index < equations.size(); index++)\n    {\n        graph[equations[index][0]].push_back({equations[index][1], values[index]});\n        graph[equations[index][1]].push_back({equations[index][0], 1 / values[index]});\n    }\n\n    std::vector<double> results;\n    for(const auto &query : queries)\n    {\n        results.push_back(depthFirstSearch(query[0], query[1], graph));\n    }\n    return results;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findNthDigit(int n)\n{\n    int digitSize= 1;\n    long totalLength= 9;\n    int startingNumber= 1;\n\n    while(n > totalLength * digitSize)\n    {\n        n-= totalLength * digitSize;\n        digitSize++;\n        totalLength*= 10;\n        startingNumber*= 10;\n    }\n\n    startingNumber+= (n - 1) / digitSize;\n    string numberString= to_string(startingNumber);\n    return numberString[(n - 1) % digitSize] - '0';\n}",
    "output": "#include <bits/stdc++.h>\nint findNthDigit(int n)\n{\n    int digitSize= 1;\n    long totalLength= 9;\n    int startingNumber= 1;\n\n    while(n > totalLength * digitSize)\n    {\n        n-= totalLength * digitSize;\n        digitSize++;\n        totalLength*= 10;\n        startingNumber*= 10;\n    }\n\n    startingNumber+= (n - 1) / digitSize;\n    std::string numberString= std::to_string(startingNumber);\n    return numberString[(n - 1) % digitSize] - '0';\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> readBinaryWatch(int numberOfLightsOn)\n{\n    vector<string> timeCombinations;\n    for(int hour= 0; hour < 12; hour++)\n    {\n        for(int minute= 0; minute < 60; minute++)\n        {\n            if(__builtin_popcount(hour) + __builtin_popcount(minute) == numberOfLightsOn)\n            {\n                timeCombinations.push_back(to_string(hour) + (minute < 10 ? \":0\" : \":\") + to_string(minute));\n            }\n        }\n    }\n    return timeCombinations;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> readBinaryWatch(int numberOfLightsOn)\n{\n    std::vector<std::string> timeCombinations;\n    for(int hour= 0; hour < 12; hour++)\n    {\n        for(int minute= 0; minute < 60; minute++)\n        {\n            if(__builtin_popcount(hour) + __builtin_popcount(minute) == numberOfLightsOn)\n            {\n                timeCombinations.push_back(std::to_string(hour) + (minute < 10 ? \":0\" : \":\") + std::to_string(minute));\n            }\n        }\n    }\n    return timeCombinations;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring removeKDigits(string number, int digitsToRemove)\n{\n    string result = \"\";\n    for (int i = 0; i < number.size(); ++i)\n    {\n        char currentChar = number[i];\n        while (digitsToRemove > 0 && !result.empty() && result.back() > currentChar)\n        {\n            result.pop_back();\n            digitsToRemove--;\n        }\n        result.push_back(currentChar);\n    }\n    result.resize(result.length() - digitsToRemove);\n    while (!result.empty() && result[0] == '0')\n    {\n        result.erase(result.begin());\n    }\n    return result.empty() ? \"0\" : result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string removeKDigits(std::string number, int digitsToRemove)\n{\n    std::string result= \"\";\n    for(char currentChar : number)\n    {\n        while(digitsToRemove > 0 && !result.empty() && result.back() > currentChar)\n        {\n            result.pop_back();\n            digitsToRemove--;\n        }\n        result.push_back(currentChar);\n    }\n    result.resize(result.length() - digitsToRemove);\n    while(!result.empty() && result[0] == '0')\n    {\n        result.erase(result.begin());\n    }\n    return result.empty() ? \"0\" : result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canCross(vector<int> &stonePositions)\n{\n    unordered_map<int, unordered_set<int>> jumpOptions;\n    int numberOfStones = stonePositions.size();\n    for (int stone : stonePositions)\n        jumpOptions[stone] = unordered_set<int>();\n    jumpOptions[0].insert(0);\n\n    for (int i = 0; i < stonePositions.size(); ++i)\n    {\n        int stone = stonePositions[i];\n        for (int j = 0; j < jumpOptions[stone].size(); ++j)\n        {\n            int previousJump = *next(jumpOptions[stone].begin(), j);\n            for (int currentJump : {previousJump - 1, previousJump, previousJump + 1})\n            {\n                if (currentJump > 0 && jumpOptions.count(stone + currentJump))\n                    jumpOptions[stone + currentJump].insert(currentJump);\n            }\n        }\n    }\n    return !jumpOptions[stonePositions.back()].empty();\n}",
    "output": "#include <bits/stdc++.h>\nbool canCross(std::vector<int> &stonePositions)\n{\n    std::unordered_map<int, std::unordered_set<int>> jumpOptions;\n    int numberOfStones = stonePositions.size();\n    for(int stone : stonePositions)\n        jumpOptions[stone] = std::unordered_set<int>();\n    jumpOptions[0].insert(0);\n\n    for(int stone : stonePositions)\n    {\n        for(int previousJump : jumpOptions[stone])\n        {\n            for(int currentJump : {previousJump - 1, previousJump, previousJump + 1})\n            {\n                if(currentJump > 0 && jumpOptions.count(stone + currentJump))\n                    jumpOptions[stone + currentJump].insert(currentJump);\n            }\n        }\n    }\n    return !jumpOptions[stonePositions.back()].empty();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nint sumOfLeftLeaves(TreeNode *root)\n{\n    if(!root)\n        return 0;\n    int sum= 0;\n    if(root->leftChild && !root->leftChild->leftChild && !root->leftChild->rightChild)\n        sum+= root->leftChild->value;\n    return sum + sumOfLeftLeaves(root->leftChild) + sumOfLeftLeaves(root->rightChild);\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nint sumOfLeftLeaves(TreeNode *root)\n{\n    if(!root)\n        return 0;\n    int sum= 0;\n    if(root->leftChild && !root->leftChild->leftChild && !root->leftChild->rightChild)\n        sum+= root->leftChild->value;\n    return sum + sumOfLeftLeaves(root->leftChild) + sumOfLeftLeaves(root->rightChild);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "using namespace std;\n\nstring convertToHex(int number)\n{\n    if(number == 0)\n        return \"0\";\n    string hexString= \"\";\n    unsigned int unsignedNumber= number;\n    char hexDigits[]= {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n    while(unsignedNumber)\n    {\n        hexString= hexDigits[unsignedNumber & 15] + hexString;\n        unsignedNumber>>= 4;\n    }\n    return hexString;\n}",
    "output": "std::string convertToHex(int number)\n{\n    if(number == 0)\n        return \"0\";\n    std::string hexString= \"\";\n    unsigned int unsignedNumber= number;\n    char hexDigits[]= {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n    while(unsignedNumber)\n    {\n        hexString= hexDigits[unsignedNumber & 15] + hexString;\n        unsignedNumber>>= 4;\n    }\n    return hexString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> reconstructQueue(vector<vector<int>> &people)\n{\n    sort(people.begin(), people.end(), [](const vector<int> &personA, const vector<int> &personB)\n              { return personA[0] > personB[0] || (personA[0] == personB[0] && personA[1] < personB[1]); });\n\n    vector<vector<int>> result;\n    for (int i = 0; i < people.size(); ++i)\n    {\n        const vector<int> &currentPerson = people[i];\n        result.insert(result.begin() + currentPerson[1], currentPerson);\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> reconstructQueue(std::vector<std::vector<int>> &people)\n{\n    std::sort(people.begin(), people.end(), [](const std::vector<int> &personA, const std::vector<int> &personB)\n              { return personA[0] > personB[0] || (personA[0] == personB[0] && personA[1] < personB[1]); });\n\n    std::vector<std::vector<int>> result;\n    for(const std::vector<int> &currentPerson : people)\n    {\n        result.insert(result.begin() + currentPerson[1], currentPerson);\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint trapRainWater(vector<vector<int>> &heightMap)\n{\n    int rowCount = heightMap.size(), columnCount = heightMap[0].size();\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minHeap;\n    vector<vector<int>> visited(rowCount, vector<int>(columnCount, 0));\n\n    for (int row = 0; row < rowCount; row++)\n    {\n        minHeap.push({heightMap[row][0], row * columnCount});\n        minHeap.push({heightMap[row][columnCount - 1], row * columnCount + columnCount - 1});\n        visited[row][0] = visited[row][columnCount - 1] = 1;\n    }\n\n    for (int column = 1; column < columnCount - 1; column++)\n    {\n        minHeap.push({heightMap[0][column], column});\n        minHeap.push({heightMap[rowCount - 1][column], (rowCount - 1) * columnCount + column});\n        visited[0][column] = visited[rowCount - 1][column] = 1;\n    }\n\n    int totalWater = 0, maxHeight = 0;\n    vector<vector<int>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    while (!minHeap.empty())\n    {\n        auto topElement = minHeap.top();\n        minHeap.pop();\n        int height = topElement.first, row = topElement.second / columnCount, column = topElement.second % columnCount;\n        maxHeight = max(maxHeight, height);\n        for (int i = 0; i < directions.size(); ++i)\n        {\n            int newRow = row + directions[i][0], newColumn = column + directions[i][1];\n            if (newRow < 0 || newRow >= rowCount || newColumn < 0 || newColumn >= columnCount || visited[newRow][newColumn])\n                continue;\n            if (heightMap[newRow][newColumn] < maxHeight)\n                totalWater += maxHeight - heightMap[newRow][newColumn];\n            minHeap.push({heightMap[newRow][newColumn], newRow * columnCount + newColumn});\n            visited[newRow][newColumn] = 1;\n        }\n    }\n\n    return totalWater;\n}",
    "output": "#include <bits/stdc++.h>\nint trapRainWater(std::vector<std::vector<int>> &heightMap)\n{\n    int rowCount = heightMap.size(), columnCount = heightMap[0].size();\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> minHeap;\n    std::vector<std::vector<int>> visited(rowCount, std::vector<int>(columnCount, 0));\n\n    for(int row = 0; row < rowCount; row++)\n    {\n        minHeap.push({heightMap[row][0], row * columnCount});\n        minHeap.push({heightMap[row][columnCount - 1], row * columnCount + columnCount - 1});\n        visited[row][0] = visited[row][columnCount - 1] = 1;\n    }\n\n    for(int column = 1; column < columnCount - 1; column++)\n    {\n        minHeap.push({heightMap[0][column], column});\n        minHeap.push({heightMap[rowCount - 1][column], (rowCount - 1) * columnCount + column});\n        visited[0][column] = visited[rowCount - 1][column] = 1;\n    }\n\n    int totalWater = 0, maxHeight = 0;\n    std::vector<std::vector<int>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    while(!minHeap.empty())\n    {\n        auto topElement = minHeap.top();\n        minHeap.pop();\n        int height = topElement.first, row = topElement.second / columnCount, column = topElement.second % columnCount;\n        maxHeight = std::max(maxHeight, height);\n        for(auto direction : directions)\n        {\n            int newRow = row + direction[0], newColumn = column + direction[1];\n            if(newRow < 0 || newRow >= rowCount || newColumn < 0 || newColumn >= columnCount || visited[newRow][newColumn])\n                continue;\n            if(heightMap[newRow][newColumn] < maxHeight)\n                totalWater += maxHeight - heightMap[newRow][newColumn];\n            minHeap.push({heightMap[newRow][newColumn], newRow * columnCount + newColumn});\n            visited[newRow][newColumn] = 1;\n        }\n    }\n\n    return totalWater;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For isdigit function\nusing namespace std;\n\nbool isValidWordAbbreviation(string originalWord, string abbreviation)\n{\n    int wordIndex= 0, abbrIndex= 0;\n    while(wordIndex < originalWord.size() && abbrIndex < abbreviation.size())\n    {\n        if(isdigit(abbreviation[abbrIndex]))\n        {\n            if(abbreviation[abbrIndex] == '0')\n                return false; // leading zero\n            int number= 0;\n            while(abbrIndex < abbreviation.size() && isdigit(abbreviation[abbrIndex]))\n                number= number * 10 + (abbreviation[abbrIndex++] - '0');\n            wordIndex+= number;\n        }\n        else\n        {\n            if(originalWord[wordIndex++] != abbreviation[abbrIndex++])\n                return false;\n        }\n    }\n    return wordIndex == originalWord.size() && abbrIndex == abbreviation.size();\n}",
    "output": "#include <bits/stdc++.h>\nbool isValidWordAbbreviation(std::string originalWord, std::string abbreviation)\n{\n    int wordIndex= 0, abbrIndex= 0;\n    while(wordIndex < originalWord.size() && abbrIndex < abbreviation.size())\n    {\n        if(std::isdigit(abbreviation[abbrIndex]))\n        {\n            if(abbreviation[abbrIndex] == '0')\n                return false; // leading zero\n            int number= 0;\n            while(abbrIndex < abbreviation.size() && std::isdigit(abbreviation[abbrIndex]))\n                number= number * 10 + (abbreviation[abbrIndex++] - '0');\n            wordIndex+= number;\n        }\n        else\n        {\n            if(originalWord[wordIndex++] != abbreviation[abbrIndex++])\n                return false;\n        }\n    }\n    return wordIndex == originalWord.size() && abbrIndex == abbreviation.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint longestPalindrome(string inputString)\n{\n    int characterCount[128] = {0};\n    int palindromeLength = 0;\n    for (char currentChar : inputString)\n        characterCount[currentChar]++;\n    for (int i = 0; i < 128; ++i)\n    {\n        int count = characterCount[i];\n        palindromeLength += count / 2 * 2;\n        if (palindromeLength % 2 == 0 && count % 2 == 1)\n            palindromeLength++;\n    }\n    return palindromeLength;\n}",
    "output": "#include <bits/stdc++.h>\nint longestPalindrome(std::string inputString)\n{\n    int characterCount[128]= {0};\n    int palindromeLength= 0;\n    for(char currentChar : inputString)\n        characterCount[currentChar]++;\n    for(int count : characterCount)\n    {\n        palindromeLength+= count / 2 * 2;\n        if(palindromeLength % 2 == 0 && count % 2 == 1)\n            palindromeLength++;\n    }\n    return palindromeLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint splitArray(vector<int> &numbers, int maximumParts)\n{\n    long long minimumSum = 0, maximumSum = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        minimumSum = max(minimumSum, (long long)number);\n        maximumSum += number;\n    }\n\n    while (minimumSum < maximumSum)\n    {\n        long long midPoint = (minimumSum + maximumSum) / 2;\n        int partitionCount = 1;\n        long long currentSum = 0;\n        for (int i = 0; i < numbers.size(); ++i)\n        {\n            int number = numbers[i];\n            currentSum += number;\n            if (currentSum > midPoint)\n            {\n                currentSum = number;\n                partitionCount++;\n            }\n        }\n\n        if (partitionCount > maximumParts)\n        {\n            minimumSum = midPoint + 1;\n        }\n        else\n        {\n            maximumSum = midPoint;\n        }\n    }\n\n    return (int)minimumSum;\n}",
    "output": "#include <bits/stdc++.h>\nint splitArray(std::vector<int> &numbers, int maximumParts)\n{\n    long long minimumSum= 0, maximumSum= 0;\n    for(int number : numbers)\n    {\n        minimumSum= std::max(minimumSum, (long long)number);\n        maximumSum+= number;\n    }\n\n    while(minimumSum < maximumSum)\n    {\n        long long midPoint= (minimumSum + maximumSum) / 2;\n        int partitionCount= 1;\n        long long currentSum= 0;\n        for(int number : numbers)\n        {\n            currentSum+= number;\n            if(currentSum > midPoint)\n            {\n                currentSum= number;\n                partitionCount++;\n            }\n        }\n\n        if(partitionCount > maximumParts)\n        {\n            minimumSum= midPoint + 1;\n        }\n        else\n        {\n            maximumSum= midPoint;\n        }\n    }\n\n    return (int)minimumSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring abbreviate(const string &inputString, int abbreviationCount, int currentIndex)\n{\n    if(currentIndex == inputString.length())\n    {\n        return (abbreviationCount > 0) ? to_string(abbreviationCount) : \"\";\n    }\n    if(abbreviationCount == 0)\n    {\n        return inputString.substr(currentIndex) + (currentIndex + 1 < inputString.length() ? abbreviate(inputString, 1, currentIndex + 1) : \"\");\n    }\n    return to_string(abbreviationCount) + inputString[currentIndex] + (currentIndex + 1 < inputString.length() ? abbreviate(inputString, 1, currentIndex + 1) : \"\");\n}\n\nbool isAbbreviation(const string &abbreviation, const string &targetWord)\n{\n    int abbreviationIndex = 0, wordIndex = 0;\n    while(abbreviationIndex < abbreviation.length() && wordIndex < targetWord.length())\n    {\n        if(abbreviation[abbreviationIndex] == targetWord[wordIndex])\n        {\n            abbreviationIndex++;\n            wordIndex++;\n        }\n        else if(isdigit(abbreviation[abbreviationIndex]))\n        {\n            int number = 0;\n            while(abbreviationIndex < abbreviation.length() && isdigit(abbreviation[abbreviationIndex]))\n            {\n                number = number * 10 + abbreviation[abbreviationIndex++] - '0';\n            }\n            wordIndex += number;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    return (abbreviationIndex == abbreviation.length() && wordIndex == targetWord.length());\n}\n\nstring minAbbreviation(string targetWord, vector<string> &dictionary)\n{\n    string shortestAbbreviation = targetWord;\n    for(int abbreviationCount = 0; abbreviationCount <= targetWord.length(); abbreviationCount++)\n    {\n        for(int startIndex = 0; startIndex <= targetWord.length() - abbreviationCount; startIndex++)\n        {\n            string currentAbbreviation = abbreviate(targetWord, abbreviationCount, startIndex);\n            if(currentAbbreviation.length() < shortestAbbreviation.length())\n            {\n                bool isValid = true;\n                for(int dictIndex = 0; dictIndex < dictionary.size(); dictIndex++)\n                {\n                    if(isAbbreviation(currentAbbreviation, dictionary[dictIndex]))\n                    {\n                        isValid = false;\n                        break;\n                    }\n                }\n                if(isValid)\n                {\n                    shortestAbbreviation = currentAbbreviation;\n                }\n            }\n        }\n    }\n    return shortestAbbreviation;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string abbreviate(const std::string &inputString, int abbreviationCount, int currentIndex)\n{\n    if(currentIndex == inputString.length())\n    {\n        return (abbreviationCount > 0) ? std::to_string(abbreviationCount) : \"\";\n    }\n    if(abbreviationCount == 0)\n    {\n        return inputString.substr(currentIndex) + (currentIndex + 1 < inputString.length() ? abbreviate(inputString, 1, currentIndex + 1) : \"\");\n    }\n    return std::to_string(abbreviationCount) + inputString[currentIndex] + (currentIndex + 1 < inputString.length() ? abbreviate(inputString, 1, currentIndex + 1) : \"\");\n}\n\nbool isAbbreviation(const std::string &abbreviation, const std::string &targetWord)\n{\n    int abbreviationIndex= 0, wordIndex= 0;\n    while(abbreviationIndex < abbreviation.length() && wordIndex < targetWord.length())\n    {\n        if(abbreviation[abbreviationIndex] == targetWord[wordIndex])\n        {\n            abbreviationIndex++;\n            wordIndex++;\n        }\n        else if(isdigit(abbreviation[abbreviationIndex]))\n        {\n            int number= 0;\n            while(abbreviationIndex < abbreviation.length() && isdigit(abbreviation[abbreviationIndex]))\n            {\n                number= number * 10 + abbreviation[abbreviationIndex++] - '0';\n            }\n            wordIndex+= number;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    return (abbreviationIndex == abbreviation.length() && wordIndex == targetWord.length());\n}\n\nstd::string minAbbreviation(std::string targetWord, std::vector<std::string> &dictionary)\n{\n    std::string shortestAbbreviation= targetWord;\n    for(int abbreviationCount= 0; abbreviationCount <= targetWord.length(); abbreviationCount++)\n    {\n        for(int startIndex= 0; startIndex <= targetWord.length() - abbreviationCount; startIndex++)\n        {\n            std::string currentAbbreviation= abbreviate(targetWord, abbreviationCount, startIndex);\n            if(currentAbbreviation.length() < shortestAbbreviation.length())\n            {\n                bool isValid= true;\n                for(const std::string &dictWord : dictionary)\n                {\n                    if(isAbbreviation(currentAbbreviation, dictWord))\n                    {\n                        isValid= false;\n                        break;\n                    }\n                }\n                if(isValid)\n                {\n                    shortestAbbreviation= currentAbbreviation;\n                }\n            }\n        }\n    }\n    return shortestAbbreviation;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> generateFizzBuzz(int upperLimit)\n{\n    vector<string> fizzBuzzList(upperLimit);\n    for(int currentNumber= 1; currentNumber <= upperLimit; ++currentNumber)\n    {\n        if(currentNumber % 15 == 0)\n            fizzBuzzList[currentNumber - 1]= \"FizzBuzz\";\n        else if(currentNumber % 3 == 0)\n            fizzBuzzList[currentNumber - 1]= \"Fizz\";\n        else if(currentNumber % 5 == 0)\n            fizzBuzzList[currentNumber - 1]= \"Buzz\";\n        else\n            fizzBuzzList[currentNumber - 1]= to_string(currentNumber);\n    }\n    return fizzBuzzList;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> generateFizzBuzz(int upperLimit)\n{\n    std::vector<std::string> fizzBuzzList(upperLimit);\n    for(int currentNumber= 1; currentNumber <= upperLimit; ++currentNumber)\n    {\n        if(currentNumber % 15 == 0)\n            fizzBuzzList[currentNumber - 1]= \"FizzBuzz\";\n        else if(currentNumber % 3 == 0)\n            fizzBuzzList[currentNumber - 1]= \"Fizz\";\n        else if(currentNumber % 5 == 0)\n            fizzBuzzList[currentNumber - 1]= \"Buzz\";\n        else\n            fizzBuzzList[currentNumber - 1]= std::to_string(currentNumber);\n    }\n    return fizzBuzzList;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countArithmeticSlices(vector<int> &numbers)\n{\n    int size= numbers.size(), totalCount= 0, currentCount= 0;\n    for(int index= 2; index < size; ++index)\n    {\n        if(numbers[index] - numbers[index - 1] == numbers[index - 1] - numbers[index - 2])\n        {\n            currentCount++;\n            totalCount+= currentCount;\n        }\n        else\n        {\n            currentCount= 0;\n        }\n    }\n    return totalCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countArithmeticSlices(std::vector<int> &numbers)\n{\n    int size= numbers.size(), totalCount= 0, currentCount= 0;\n    for(int index= 2; index < size; ++index)\n    {\n        if(numbers[index] - numbers[index - 1] == numbers[index - 1] - numbers[index - 2])\n        {\n            currentCount++;\n            totalCount+= currentCount;\n        }\n        else\n        {\n            currentCount= 0;\n        }\n    }\n    return totalCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint thirdMax(vector<int> &numbers)\n{\n    set<int> topThree;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        topThree.insert(number);\n        if (topThree.size() > 3)\n        {\n            topThree.erase(topThree.begin());\n        }\n    }\n    return topThree.size() == 3 ? *topThree.begin() : *topThree.rbegin();\n}",
    "output": "#include <bits/stdc++.h>\nint thirdMax(std::vector<int> &numbers)\n{\n    std::set<int> topThree;\n    for(int number : numbers)\n    {\n        topThree.insert(number);\n        if(topThree.size() > 3)\n        {\n            topThree.erase(topThree.begin());\n        }\n    }\n    return topThree.size() == 3 ? *topThree.begin() : *topThree.rbegin();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "using namespace std;\n\nstring addStrings(string firstNumber, string secondNumber)\n{\n    int indexFirst = firstNumber.size() - 1, indexSecond = secondNumber.size() - 1, carry = 0;\n    string result;\n\n    while(indexFirst >= 0 || indexSecond >= 0 || carry)\n    {\n        int sum = carry;\n\n        if(indexFirst >= 0)\n        {\n            sum += firstNumber[indexFirst] - '0';\n            --indexFirst;\n        }\n        if(indexSecond >= 0)\n        {\n            sum += secondNumber[indexSecond] - '0';\n            --indexSecond;\n        }\n\n        carry = sum / 10;\n        result.push_back(sum % 10 + '0');\n    }\n\n    reverse(result.begin(), result.end());\n    return result;\n}",
    "output": "std::string addStrings(std::string firstNumber, std::string secondNumber)\n{\n    int indexFirst= firstNumber.size() - 1, indexSecond= secondNumber.size() - 1, carry= 0;\n    std::string result;\n\n    while(indexFirst >= 0 || indexSecond >= 0 || carry)\n    {\n        int sum= carry;\n\n        if(indexFirst >= 0)\n        {\n            sum+= firstNumber[indexFirst] - '0';\n            --indexFirst;\n        }\n        if(indexSecond >= 0)\n        {\n            sum+= secondNumber[indexSecond] - '0';\n            --indexSecond;\n        }\n\n        carry= sum / 10;\n        result.push_back(sum % 10 + '0');\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canPartition(vector<int> &numbers)\n{\n    int totalSum = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n        totalSum += numbers[i];\n\n    if (totalSum % 2 != 0)\n        return false;\n\n    int targetSum = totalSum / 2;\n    vector<bool> subsetSumPossible(targetSum + 1, false);\n    subsetSumPossible[0] = true;\n\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        for (int index = targetSum; index >= number; index--)\n        {\n            subsetSumPossible[index] = subsetSumPossible[index] || subsetSumPossible[index - number];\n        }\n    }\n    return subsetSumPossible[targetSum];\n}",
    "output": "#include <bits/stdc++.h>\nbool canPartition(std::vector<int> &numbers)\n{\n    int totalSum = 0;\n    for(int number : numbers)\n        totalSum += number;\n\n    if(totalSum % 2 != 0)\n        return false;\n\n    int targetSum = totalSum / 2;\n    std::vector<bool> subsetSumPossible(targetSum + 1, false);\n    subsetSumPossible[0] = true;\n\n    for(int number : numbers)\n    {\n        for(int index = targetSum; index >= number; index--)\n        {\n            subsetSumPossible[index] = subsetSumPossible[index] || subsetSumPossible[index - number];\n        }\n    }\n    return subsetSumPossible[targetSum];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(const vector<vector<int>> &heightMap, int row, int column, int previousHeight, vector<vector<bool>> &visited)\n{\n    if(row < 0 || row >= heightMap.size() || column < 0 || column >= heightMap[0].size())\n        return;\n    if(heightMap[row][column] >= previousHeight && !visited[row][column])\n    {\n        visited[row][column]= true;\n        depthFirstSearch(heightMap, row - 1, column, heightMap[row][column], visited);\n        depthFirstSearch(heightMap, row + 1, column, heightMap[row][column], visited);\n        depthFirstSearch(heightMap, row, column - 1, heightMap[row][column], visited);\n        depthFirstSearch(heightMap, row, column + 1, heightMap[row][column], visited);\n    }\n}\n\nvector<vector<int>> pacificAtlanticFlow(vector<vector<int>> &heightMap)\n{\n    int rowCount= heightMap.size();\n    int columnCount= heightMap[0].size();\n    vector<vector<bool>> pacific(rowCount, vector<bool>(columnCount, false));\n    vector<vector<bool>> atlantic(rowCount, vector<bool>(columnCount, false));\n\n    for(int row= 0; row < rowCount; ++row)\n    {\n        depthFirstSearch(heightMap, row, 0, -1, pacific);\n        depthFirstSearch(heightMap, row, columnCount - 1, -1, atlantic);\n    }\n    for(int column= 0; column < columnCount; ++column)\n    {\n        depthFirstSearch(heightMap, 0, column, -1, pacific);\n        depthFirstSearch(heightMap, rowCount - 1, column, -1, atlantic);\n    }\n    vector<vector<int>> result;\n    for(int row= 0; row < rowCount; ++row)\n    {\n        for(int column= 0; column < columnCount; ++column)\n        {\n            if(pacific[row][column] && atlantic[row][column])\n            {\n                result.push_back({row, column});\n            }\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nvoid depthFirstSearch(const std::vector<std::vector<int>> &heightMap, int row, int column, int previousHeight, std::vector<std::vector<bool>> &visited)\n{\n    if(row < 0 || row >= heightMap.size() || column < 0 || column >= heightMap[0].size())\n        return;\n    if(heightMap[row][column] >= previousHeight && !visited[row][column])\n    {\n        visited[row][column]= true;\n        depthFirstSearch(heightMap, row - 1, column, heightMap[row][column], visited);\n        depthFirstSearch(heightMap, row + 1, column, heightMap[row][column], visited);\n        depthFirstSearch(heightMap, row, column - 1, heightMap[row][column], visited);\n        depthFirstSearch(heightMap, row, column + 1, heightMap[row][column], visited);\n    }\n}\n\nstd::vector<std::vector<int>> pacificAtlanticFlow(std::vector<std::vector<int>> &heightMap)\n{\n    int rowCount= heightMap.size();\n    int columnCount= heightMap[0].size();\n    std::vector<std::vector<bool>> pacific(rowCount, std::vector<bool>(columnCount, false));\n    std::vector<std::vector<bool>> atlantic(rowCount, std::vector<bool>(columnCount, false));\n\n    for(int row= 0; row < rowCount; ++row)\n    {\n        depthFirstSearch(heightMap, row, 0, -1, pacific);\n        depthFirstSearch(heightMap, row, columnCount - 1, -1, atlantic);\n    }\n    for(int column= 0; column < columnCount; ++column)\n    {\n        depthFirstSearch(heightMap, 0, column, -1, pacific);\n        depthFirstSearch(heightMap, rowCount - 1, column, -1, atlantic);\n    }\n    std::vector<std::vector<int>> result;\n    for(int row= 0; row < rowCount; ++row)\n    {\n        for(int column= 0; column < columnCount; ++column)\n        {\n            if(pacific[row][column] && atlantic[row][column])\n            {\n                result.push_back({row, column});\n            }\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint wordsTyping(vector<string> &sentence, int totalRows, int totalCols)\n{\n    int totalChars = 0;\n    for (int i = 0; i < sentence.size(); ++i)\n    {\n        totalChars += sentence[i].size() + 1;\n    }\n\n    int completeLines = 0;\n    int wordIndex = 0;\n    for (int row = 0; row < totalRows; ++row)\n    {\n        int remainingCols = totalCols;\n        while (true)\n        {\n            int wordLength = sentence[wordIndex].size();\n            if (remainingCols >= wordLength)\n            {\n                remainingCols -= wordLength + 1;\n                wordIndex = (wordIndex + 1) % sentence.size();\n                if (wordIndex == 0)\n                    completeLines++;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n\n    return completeLines;\n}",
    "output": "#include <bits/stdc++.h>\nint wordsTyping(std::vector<std::string> &sentence, int totalRows, int totalCols)\n{\n    int totalChars= 0;\n    for(const auto &word : sentence)\n    {\n        totalChars+= word.size() + 1;\n    }\n\n    int completeLines= 0;\n    int wordIndex= 0;\n    for(int row= 0; row < totalRows; ++row)\n    {\n        int remainingCols= totalCols;\n        while(true)\n        {\n            int wordLength= sentence[wordIndex].size();\n            if(remainingCols >= wordLength)\n            {\n                remainingCols-= wordLength + 1;\n                wordIndex= (wordIndex + 1) % sentence.size();\n                if(wordIndex == 0)\n                    completeLines++;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n\n    return completeLines;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countBattleships(vector<vector<char>> &board)\n{\n    int battleshipCount= 0;\n    for(int rowIndex= 0; rowIndex < board.size(); rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < board[rowIndex].size(); colIndex++)\n        {\n            if(board[rowIndex][colIndex] == 'X' &&\n               (rowIndex == 0 || board[rowIndex - 1][colIndex] == '.') &&\n               (colIndex == 0 || board[rowIndex][colIndex - 1] == '.'))\n            {\n                battleshipCount++;\n            }\n        }\n    }\n    return battleshipCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countBattleships(std::vector<std::vector<char>> &board)\n{\n    int battleshipCount= 0;\n    for(int rowIndex= 0; rowIndex < board.size(); rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < board[rowIndex].size(); colIndex++)\n        {\n            if(board[rowIndex][colIndex] == 'X' &&\n               (rowIndex == 0 || board[rowIndex - 1][colIndex] == '.') &&\n               (colIndex == 0 || board[rowIndex][colIndex - 1] == '.'))\n            {\n                battleshipCount++;\n            }\n        }\n    }\n    return battleshipCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint strongPassword(string password)\n{\n    int missingLowercase = 1, missingUppercase = 1, missingDigit = 1;\n    int totalLength = (int)password.size();\n    for (int i = 0; i < totalLength; ++i)\n    {\n        char character = password[i];\n        if (islower(character))\n            missingLowercase = 0;\n        if (isupper(character))\n            missingUppercase = 0;\n        if (isdigit(character))\n            missingDigit = 0;\n    }\n    int missingRequirements = missingLowercase + missingUppercase + missingDigit;\n    if (totalLength < 6)\n        return max(missingRequirements, 6 - totalLength);\n    if (totalLength > 20)\n        return missingRequirements + totalLength - 20;\n    return missingRequirements;\n}",
    "output": "#include <bits/stdc++.h>\nint strongPassword(std::string password)\n{\n    int missingLowercase= 1, missingUppercase= 1, missingDigit= 1;\n    int totalLength= (int)password.size();\n    for(char character : password)\n    {\n        if(std::islower(character))\n            missingLowercase= 0;\n        if(std::isupper(character))\n            missingUppercase= 0;\n        if(std::isdigit(character))\n            missingDigit= 0;\n    }\n    int missingRequirements= missingLowercase + missingUppercase + missingDigit;\n    if(totalLength < 6)\n        return std::max(missingRequirements, 6 - totalLength);\n    if(totalLength > 20)\n        return missingRequirements + totalLength - 20;\n    return missingRequirements;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMaximumXor(vector<int> &inputNumbers)\n{\n    int maxXor = 0;\n    int bitmask = 0;\n\n    for (int bitPosition = 31; bitPosition >= 0; bitPosition--)\n    {\n        bitmask |= (1 << bitPosition);\n        unordered_set<int> prefixSet;\n\n        for (int j = 0; j < inputNumbers.size(); ++j)\n        {\n            prefixSet.insert(inputNumbers[j] & bitmask);\n        }\n\n        int possibleMax = maxXor | (1 << bitPosition);\n\n        for (int j = 0; j < prefixSet.size(); ++j)\n        {\n            int prefix = *next(prefixSet.begin(), j); // Getting the j-th element from the set\n            if (prefixSet.count(prefix ^ possibleMax))\n            {\n                maxXor = possibleMax;\n                break;\n            }\n        }\n    }\n\n    return maxXor;\n}",
    "output": "#include <bits/stdc++.h>\nint findMaximumXor(std::vector<int> &inputNumbers)\n{\n    int maxXor= 0;\n    int bitmask= 0;\n\n    for(int bitPosition= 31; bitPosition >= 0; bitPosition--)\n    {\n        bitmask|= (1 << bitPosition);\n        std::unordered_set<int> prefixSet;\n\n        for(int number : inputNumbers)\n        {\n            prefixSet.insert(number & bitmask);\n        }\n\n        int possibleMax= maxXor | (1 << bitPosition);\n\n        for(int prefix : prefixSet)\n        {\n            if(prefixSet.count(prefix ^ possibleMax))\n            {\n                maxXor= possibleMax;\n                break;\n            }\n        }\n    }\n\n    return maxXor;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidWordSquare(vector<string> &wordList)\n{\n    for(int rowIndex= 0; rowIndex < wordList.size(); ++rowIndex)\n    {\n        for(int columnIndex= 0; columnIndex < wordList[rowIndex].size(); ++columnIndex)\n        {\n            if(columnIndex >= wordList.size() || rowIndex >= wordList[columnIndex].size() || wordList[rowIndex][columnIndex] != wordList[columnIndex][rowIndex])\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isValidWordSquare(std::vector<std::string> &wordList)\n{\n    for(int rowIndex= 0; rowIndex < wordList.size(); ++rowIndex)\n    {\n        for(int columnIndex= 0; columnIndex < wordList[rowIndex].size(); ++columnIndex)\n        {\n            if(columnIndex >= wordList.size() || rowIndex >= wordList[columnIndex].size() || wordList[rowIndex][columnIndex] != wordList[columnIndex][rowIndex])\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring findDigitsInAscendingOrder(string inputString)\n{\n    vector<int> digitCount(10, 0);\n    for(char character : inputString)\n    {\n        if(character == 'z')\n            digitCount[0]++;\n        if(character == 'w')\n            digitCount[2]++;\n        if(character == 'u')\n            digitCount[4]++;\n        if(character == 'x')\n            digitCount[6]++;\n        if(character == 'g')\n            digitCount[8]++;\n        if(character == 'o')\n            digitCount[1]++; // o = one + two + four\n        if(character == 'h')\n            digitCount[3]++; // h = three + eight\n        if(character == 'f')\n            digitCount[5]++; // f = five + seven\n        if(character == 's')\n            digitCount[7]++; // s = six + seven\n        if(character == 'i')\n            digitCount[9]++; // i = five + six + eight + nine\n    }\n    digitCount[1]-= digitCount[0] + digitCount[2] + digitCount[4];\n    digitCount[3]-= digitCount[8];\n    digitCount[5]-= digitCount[4];\n    digitCount[7]-= digitCount[6];\n    digitCount[9]-= digitCount[5] + digitCount[6] + digitCount[8];\n\n    string result;\n    for(int digit = 0; digit < 10; digit++)\n    {\n        for(int occurrence = 0; occurrence < digitCount[digit]; occurrence++)\n        {\n            result += to_string(digit);\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string findDigitsInAscendingOrder(std::string inputString)\n{\n    std::vector<int> digitCount(10, 0);\n    for(char character : inputString)\n    {\n        if(character == 'z')\n            digitCount[0]++;\n        if(character == 'w')\n            digitCount[2]++;\n        if(character == 'u')\n            digitCount[4]++;\n        if(character == 'x')\n            digitCount[6]++;\n        if(character == 'g')\n            digitCount[8]++;\n        if(character == 'o')\n            digitCount[1]++; // o = one + two + four\n        if(character == 'h')\n            digitCount[3]++; // h = three + eight\n        if(character == 'f')\n            digitCount[5]++; // f = five + seven\n        if(character == 's')\n            digitCount[7]++; // s = six + seven\n        if(character == 'i')\n            digitCount[9]++; // i = five + six + eight + nine\n    }\n    digitCount[1]-= digitCount[0] + digitCount[2] + digitCount[4];\n    digitCount[3]-= digitCount[8];\n    digitCount[5]-= digitCount[4];\n    digitCount[7]-= digitCount[6];\n    digitCount[9]-= digitCount[5] + digitCount[6] + digitCount[8];\n\n    std::string result;\n    for(int digit= 0; digit < 10; digit++)\n    {\n        for(int occurrence= 0; occurrence < digitCount[digit]; occurrence++)\n        {\n            result+= std::to_string(digit);\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint characterReplacement(string inputString, int maxReplacements)\n{\n    int stringLength= inputString.length();\n    int leftIndex= 0, rightIndex= 0, maxFrequency= 0, longestSubstringLength= 0;\n    int frequencyArray[26]= {0};\n\n    for(rightIndex= 0; rightIndex < stringLength; rightIndex++)\n    {\n        frequencyArray[inputString[rightIndex] - 'A']++;\n        maxFrequency= max(maxFrequency, frequencyArray[inputString[rightIndex] - 'A']);\n\n        if(rightIndex - leftIndex + 1 - maxFrequency > maxReplacements)\n        {\n            frequencyArray[inputString[leftIndex] - 'A']--;\n            leftIndex++;\n        }\n\n        longestSubstringLength= max(longestSubstringLength, rightIndex - leftIndex + 1);\n    }\n\n    return longestSubstringLength;\n}",
    "output": "#include <bits/stdc++.h>\nint characterReplacement(std::string inputString, int maxReplacements)\n{\n    int stringLength = inputString.length();\n    int leftIndex = 0, rightIndex = 0, maxFrequency = 0, longestSubstringLength = 0;\n    int frequencyArray[26] = {0};\n\n    for(rightIndex = 0; rightIndex < stringLength; rightIndex++)\n    {\n        frequencyArray[inputString[rightIndex] - 'A']++;\n        maxFrequency = std::max(maxFrequency, frequencyArray[inputString[rightIndex] - 'A']);\n\n        if(rightIndex - leftIndex + 1 - maxFrequency > maxReplacements)\n        {\n            frequencyArray[inputString[leftIndex] - 'A']--;\n            leftIndex++;\n        }\n\n        longestSubstringLength = std::max(longestSubstringLength, rightIndex - leftIndex + 1);\n    }\n\n    return longestSubstringLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid build(int rowIndex, const vector<string> &wordList, vector<string> &square, unordered_map<string, vector<string>> &prefixMapping, vector<vector<string>> &resultList)\n{\n    if(rowIndex == square.size())\n    {\n        resultList.push_back(square);\n        return;\n    }\n    string prefix;\n    for(int i = 0; i < rowIndex; i++)\n    {\n        prefix.push_back(square[i][rowIndex]);\n    }\n    for(auto it = prefixMapping[prefix].begin(); it != prefixMapping[prefix].end(); ++it)\n    {\n        square[rowIndex] = *it;\n        build(rowIndex + 1, wordList, square, prefixMapping, resultList);\n    }\n}\n\nvector<vector<string>> wordSquares(vector<string> &wordList)\n{\n    vector<vector<string>> resultList;\n    if(wordList.empty())\n        return resultList;\n    unordered_map<string, vector<string>> prefixMapping;\n    for(const auto &word : wordList)\n    {\n        for(int i = 0; i <= word.size(); i++)\n        {\n            prefixMapping[word.substr(0, i)].push_back(word);\n        }\n    }\n    for(auto it = wordList.begin(); it != wordList.end(); ++it)\n    {\n        vector<string> square(wordList[0].size(), \"\");\n        square[0] = *it;\n        build(1, wordList, square, prefixMapping, resultList);\n    }\n    return resultList;\n}",
    "output": "#include <bits/stdc++.h>\nvoid build(int rowIndex, const std::vector<std::string> &wordList, std::vector<std::string> &square, std::unordered_map<std::string, std::vector<std::string>> &prefixMapping, std::vector<std::vector<std::string>> &resultList)\n{\n    if(rowIndex == square.size())\n    {\n        resultList.push_back(square);\n        return;\n    }\n    std::string prefix;\n    for(int i= 0; i < rowIndex; i++)\n    {\n        prefix.push_back(square[i][rowIndex]);\n    }\n    for(auto &word : prefixMapping[prefix])\n    {\n        square[rowIndex]= word;\n        build(rowIndex + 1, wordList, square, prefixMapping, resultList);\n    }\n}\n\nstd::vector<std::vector<std::string>> wordSquares(std::vector<std::string> &wordList)\n{\n    std::vector<std::vector<std::string>> resultList;\n    if(wordList.empty())\n        return resultList;\n    std::unordered_map<std::string, std::vector<std::string>> prefixMapping;\n    for(const auto &word : wordList)\n    {\n        for(int i= 0; i <= word.size(); i++)\n        {\n            prefixMapping[word.substr(0, i)].push_back(word);\n        }\n    }\n    for(const auto &word : wordList)\n    {\n        std::vector<std::string> square(wordList[0].size(), \"\");\n        square[0]= word;\n        build(1, wordList, square, prefixMapping, resultList);\n    }\n    return resultList;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n\n    TreeNode() {}\n\n    TreeNode(int valueIn)\n    {\n        value= valueIn;\n        leftChild= NULL;\n        rightChild= NULL;\n    }\n\n    TreeNode(int valueIn, TreeNode *leftChildIn, TreeNode *rightChildIn)\n    {\n        value= valueIn;\n        leftChild= leftChildIn;\n        rightChild= rightChildIn;\n    }\n};\n\nclass Solution\n{\n  public:\n    TreeNode *treeToDoublyList(TreeNode *root)\n    {\n        if(!root)\n            return NULL;\n        TreeNode *firstNode= NULL, *lastNode= NULL;\n        inorder(root, firstNode, lastNode);\n        firstNode->leftChild= lastNode;\n        lastNode->rightChild= firstNode;\n        return firstNode;\n    }\n\n    void inorder(TreeNode *root, TreeNode *&firstNode, TreeNode *&lastNode)\n    {\n        if(!root)\n            return;\n        inorder(root->leftChild, firstNode, lastNode);\n\n        if(lastNode)\n        {\n            lastNode->rightChild= root;\n            root->leftChild= lastNode;\n        }\n        else\n        {\n            firstNode= root;\n        }\n        lastNode= root;\n\n        inorder(root->rightChild, firstNode, lastNode);\n    }\n};",
    "output": "class TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n\n    TreeNode() {}\n\n    TreeNode(int valueIn)\n    {\n        value= valueIn;\n        leftChild= NULL;\n        rightChild= NULL;\n    }\n\n    TreeNode(int valueIn, TreeNode *leftChildIn, TreeNode *rightChildIn)\n    {\n        value= valueIn;\n        leftChild= leftChildIn;\n        rightChild= rightChildIn;\n    }\n};\n\nclass Solution\n{\n  public:\n    TreeNode *treeToDoublyList(TreeNode *root)\n    {\n        if(!root)\n            return NULL;\n        TreeNode *firstNode= NULL, *lastNode= NULL;\n        inorder(root, firstNode, lastNode);\n        firstNode->leftChild= lastNode;\n        lastNode->rightChild= firstNode;\n        return firstNode;\n    }\n\n    void inorder(TreeNode *root, TreeNode *&firstNode, TreeNode *&lastNode)\n    {\n        if(!root)\n            return;\n        inorder(root->leftChild, firstNode, lastNode);\n\n        if(lastNode)\n        {\n            lastNode->rightChild= root;\n            root->leftChild= lastNode;\n        }\n        else\n        {\n            firstNode= root;\n        }\n        lastNode= root;\n\n        inorder(root->rightChild, firstNode, lastNode);\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Node\n{\n  public:\n    bool value;\n    bool isLeaf;\n    Node *topLeft;\n    Node *topRight;\n    Node *bottomLeft;\n    Node *bottomRight;\n};\n\nNode *build(const vector<vector<int>> &grid, int row, int col, int size)\n{\n    if(size == 1)\n    {\n        return new Node{grid[row][col], true, NULL, NULL, NULL, NULL};\n    }\n    int half= size / 2;\n    Node *topLeft= build(grid, row, col, half);\n    Node *topRight= build(grid, row, col + half, half);\n    Node *bottomLeft= build(grid, row + half, col, half);\n    Node *bottomRight= build(grid, row + half, col + half, half);\n    if(topLeft->isLeaf && topRight->isLeaf && bottomLeft->isLeaf && bottomRight->isLeaf && topLeft->value == topRight->value && topLeft->value == bottomLeft->value && topLeft->value == bottomRight->value)\n    {\n        return topLeft;\n    }\n    return new Node{false, false, topLeft, topRight, bottomLeft, bottomRight};\n}\n\nNode *construct(vector<vector<int>> &grid)\n{\n    return build(grid, 0, 0, grid.size());\n}",
    "output": "#include <bits/stdc++.h>\nclass Node\n{\n  public:\n    bool value;\n    bool isLeaf;\n    Node *topLeft;\n    Node *topRight;\n    Node *bottomLeft;\n    Node *bottomRight;\n};\n\nNode *build(const std::vector<std::vector<int>> &grid, int row, int col, int size)\n{\n    if(size == 1)\n    {\n        return new Node{grid[row][col], true, NULL, NULL, NULL, NULL};\n    }\n    int half= size / 2;\n    Node *topLeft= build(grid, row, col, half);\n    Node *topRight= build(grid, row, col + half, half);\n    Node *bottomLeft= build(grid, row + half, col, half);\n    Node *bottomRight= build(grid, row + half, col + half, half);\n    if(topLeft->isLeaf && topRight->isLeaf && bottomLeft->isLeaf && bottomRight->isLeaf && topLeft->value == topRight->value && topLeft->value == bottomLeft->value && topLeft->value == bottomRight->value)\n    {\n        return topLeft;\n    }\n    return new Node{false, false, topLeft, topRight, bottomLeft, bottomRight};\n}\n\nNode *construct(std::vector<std::vector<int>> &grid)\n{\n    return build(grid, 0, 0, grid.size());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Node\n{\n  public:\n    int value;\n    vector<Node *> children;\n\n    Node() {}\n\n    Node(int valueIn)\n    {\n        value = valueIn;\n    }\n\n    Node(int valueIn, vector<Node *> childrenIn)\n    {\n        value = valueIn;\n        children = childrenIn;\n    }\n};\n\nclass Codec\n{\n  public:\n    string serialize(Node *root)\n    {\n        if (!root)\n            return \"\";\n        string data = to_string(root->value) + \" \";\n        for (int i = 0; i < root->children.size(); ++i)\n        {\n            data += serialize(root->children[i]);\n        }\n        data += \"# \";\n        return data;\n    }\n\n    Node *deserialize(string data)\n    {\n        istringstream inputStream(data);\n        return deserialize(inputStream);\n    }\n\n  private:\n    Node *deserialize(istringstream &inputStream)\n    {\n        string value;\n        inputStream >> value;\n        if (value == \"#\")\n            return NULL;\n        Node *nodeInstance = new Node(stoi(value));\n        while (true)\n        {\n            Node *child = deserialize(inputStream);\n            if (!child)\n                break;\n            nodeInstance->children.push_back(child);\n        }\n        return nodeInstance;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Node\n{\n  public:\n    int value;\n    std::vector<Node *> children;\n\n    Node() {}\n\n    Node(int valueIn)\n    {\n        value = valueIn;\n    }\n\n    Node(int valueIn, std::vector<Node *> childrenIn)\n    {\n        value = valueIn;\n        children = childrenIn;\n    }\n};\n\nclass Codec\n{\n  public:\n    std::string serialize(Node *root)\n    {\n        if(!root)\n            return \"\";\n        std::string data = std::to_string(root->value) + \" \";\n        for(Node *child : root->children)\n        {\n            data += serialize(child);\n        }\n        data += \"# \";\n        return data;\n    }\n\n    Node *deserialize(std::string data)\n    {\n        std::istringstream inputStream(data);\n        return deserialize(inputStream);\n    }\n\n  private:\n    Node *deserialize(std::istringstream &inputStream)\n    {\n        std::string value;\n        inputStream >> value;\n        if(value == \"#\")\n            return NULL;\n        Node *nodeInstance = new Node(std::stoi(value));\n        while(true)\n        {\n            Node *child = deserialize(inputStream);\n            if(!child)\n                break;\n            nodeInstance->children.push_back(child);\n        }\n        return nodeInstance;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Node\n{\n  public:\n    int value;\n    vector<Node *> children;\n};\n\nvector<vector<int>> levelOrder(Node *root)\n{\n    vector<vector<int>> result;\n    if(!root)\n        return result;\n\n    queue<Node *> nodeQueue;\n    nodeQueue.push(root);\n\n    while(!nodeQueue.empty())\n    {\n        int levelSize = nodeQueue.size();\n        vector<int> currentLevel;\n\n        for(int index = 0; index < levelSize; index++)\n        {\n            Node *currentNode = nodeQueue.front();\n            nodeQueue.pop();\n            currentLevel.push_back(currentNode->value);\n            for(int i = 0; i < currentNode->children.size(); i++)\n            {\n                Node *child = currentNode->children[i];\n                nodeQueue.push(child);\n            }\n        }\n        result.push_back(currentLevel);\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nclass Node\n{\n  public:\n    int value;\n    std::vector<Node *> children;\n};\n\nstd::vector<std::vector<int>> levelOrder(Node *root)\n{\n    std::vector<std::vector<int>> result;\n    if(!root)\n        return result;\n\n    std::queue<Node *> nodeQueue;\n    nodeQueue.push(root);\n\n    while(!nodeQueue.empty())\n    {\n        int levelSize= nodeQueue.size();\n        std::vector<int> currentLevel;\n\n        for(int index= 0; index < levelSize; index++)\n        {\n            Node *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n            currentLevel.push_back(currentNode->value);\n            for(Node *child : currentNode->children)\n            {\n                nodeQueue.push(child);\n            }\n        }\n        result.push_back(currentLevel);\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class Node\n{\n  public:\n    int value;\n    Node *previous;\n    Node *next;\n    Node *child;\n};\n\nNode *flatten(Node *head)\n{\n    if(!head)\n        return NULL;\n\n    Node *current= head, *previousNode= NULL, *nextNode;\n\n    while(current)\n    {\n        nextNode= current->next;\n        if(current->child)\n        {\n            current->next= flatten(current->child);\n            current->child->previous= current;\n            current->child= NULL;\n\n            if(nextNode)\n            {\n                previousNode= current;\n                while(current->next)\n                {\n                    current= current->next;\n                    previousNode= previousNode->next;\n                }\n                current->next= nextNode;\n                nextNode->previous= previousNode;\n            }\n        }\n        current= nextNode;\n    }\n\n    return head;\n}",
    "output": "class Node\n{\n  public:\n    int value;\n    Node *previous;\n    Node *next;\n    Node *child;\n};\n\nNode *flatten(Node *head)\n{\n    if(!head)\n        return NULL;\n\n    Node *current= head, *previousNode= NULL, *nextNode;\n\n    while(current)\n    {\n        nextNode= current->next;\n        if(current->child)\n        {\n            current->next= flatten(current->child);\n            current->child->previous= current;\n            current->child= NULL;\n\n            if(nextNode)\n            {\n                previousNode= current;\n                while(current->next)\n                {\n                    current= current->next;\n                    previousNode= previousNode->next;\n                }\n                current->next= nextNode;\n                nextNode->previous= previousNode;\n            }\n        }\n        current= nextNode;\n    }\n\n    return head;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct NaryTreeNode\n{\n    int value;\n    vector<NaryTreeNode *> children;\n};\n\nstruct BinaryTreeNode\n{\n    int value;\n    BinaryTreeNode *left, *right;\n};\n\nBinaryTreeNode *encode(NaryTreeNode *naryRoot)\n{\n    if(!naryRoot)\n        return NULL;\n    BinaryTreeNode *binaryRoot= new BinaryTreeNode();\n    binaryRoot->value= naryRoot->value;\n    if(naryRoot->children.size() > 0)\n        binaryRoot->left= encode(naryRoot->children[0]);\n    BinaryTreeNode *sibling= binaryRoot->left;\n    for(int i= 1; i < naryRoot->children.size(); ++i)\n    {\n        sibling->right= encode(naryRoot->children[i]);\n        sibling= sibling->right;\n    }\n    return binaryRoot;\n}\n\nNaryTreeNode *decode(BinaryTreeNode *binaryRoot)\n{\n    if(!binaryRoot)\n        return NULL;\n    NaryTreeNode *naryRoot= new NaryTreeNode();\n    naryRoot->value= binaryRoot->value;\n    BinaryTreeNode *sibling= binaryRoot->left;\n    while(sibling)\n    {\n        naryRoot->children.push_back(decode(sibling));\n        sibling= sibling->right;\n    }\n    return naryRoot;\n}",
    "output": "#include <bits/stdc++.h>\nstruct NaryTreeNode\n{\n    int value;\n    std::vector<NaryTreeNode *> children;\n};\n\nstruct BinaryTreeNode\n{\n    int value;\n    BinaryTreeNode *left, *right;\n};\n\nBinaryTreeNode *encode(NaryTreeNode *naryRoot)\n{\n    if(!naryRoot)\n        return NULL;\n    BinaryTreeNode *binaryRoot= new BinaryTreeNode();\n    binaryRoot->value= naryRoot->value;\n    if(naryRoot->children.size() > 0)\n        binaryRoot->left= encode(naryRoot->children[0]);\n    BinaryTreeNode *sibling= binaryRoot->left;\n    for(int i= 1; i < naryRoot->children.size(); ++i)\n    {\n        sibling->right= encode(naryRoot->children[i]);\n        sibling= sibling->right;\n    }\n    return binaryRoot;\n}\n\nNaryTreeNode *decode(BinaryTreeNode *binaryRoot)\n{\n    if(!binaryRoot)\n        return NULL;\n    NaryTreeNode *naryRoot= new NaryTreeNode();\n    naryRoot->value= binaryRoot->value;\n    BinaryTreeNode *sibling= binaryRoot->left;\n    while(sibling)\n    {\n        naryRoot->children.push_back(decode(sibling));\n        sibling= sibling->right;\n    }\n    return naryRoot;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass AllOne\n{\n  public:\n    unordered_map<string, int> keyCountMap;\n    \n    void inc(string key)\n    {\n        keyCountMap[key]++;\n    }\n    \n    void dec(string key)\n    {\n        if(keyCountMap[key] > 0)\n            keyCountMap[key]--;\n        if(keyCountMap[key] == 0)\n            keyCountMap.erase(key);\n    }\n    \n    string getMaxKey()\n    {\n        if(keyCountMap.empty())\n            return \"\";\n        return max_element(keyCountMap.begin(), keyCountMap.end(),\n                           [](const auto &a, const auto &b)\n                           { return a.second < b.second; })\n            ->first;\n    }\n    \n    string getMinKey()\n    {\n        if(keyCountMap.empty())\n            return \"\";\n        return min_element(keyCountMap.begin(), keyCountMap.end(),\n                           [](const auto &a, const auto &b)\n                           { return a.second < b.second; })\n            ->first;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass AllOne\n{\n  public:\n    std::unordered_map<std::string, int> keyCountMap;\n\n    void inc(std::string key)\n    {\n        keyCountMap[key]++;\n    }\n\n    void dec(std::string key)\n    {\n        if(keyCountMap[key] > 0)\n            keyCountMap[key]--;\n        if(keyCountMap[key] == 0)\n            keyCountMap.erase(key);\n    }\n\n    std::string getMaxKey()\n    {\n        if(keyCountMap.empty())\n            return \"\";\n        return std::max_element(keyCountMap.begin(), keyCountMap.end(),\n                           [](const auto &a, const auto &b)\n                           { return a.second < b.second; })\n            ->first;\n    }\n\n    std::string getMinKey()\n    {\n        if(keyCountMap.empty())\n            return \"\";\n        return std::min_element(keyCountMap.begin(), keyCountMap.end(),\n                           [](const auto &a, const auto &b)\n                           { return a.second < b.second; })\n            ->first;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minMutation(string startGene, string endGene, vector<string> &geneBank)\n{\n    queue<string> geneQueue;\n    geneQueue.push(startGene);\n    unordered_set<string> visitedGenes;\n    visitedGenes.insert(startGene);\n    int mutationDepth = 0;\n\n    while(!geneQueue.empty())\n    {\n        int currentLevelSize = geneQueue.size();\n        for(int geneIndex = 0; geneIndex < currentLevelSize; ++geneIndex)\n        {\n            string currentGene = geneQueue.front();\n            geneQueue.pop();\n            if(currentGene == endGene)\n                return mutationDepth;\n\n            for(int i = 0; i < geneBank.size(); ++i)\n            {\n                const auto &nextGene = geneBank[i];\n                if(!visitedGenes.count(nextGene))\n                {\n                    int differencesCount = 0;\n                    for(int genePosition = 0; genePosition < 8; ++genePosition)\n                    {\n                        if(currentGene[genePosition] != nextGene[genePosition])\n                            ++differencesCount;\n                        if(differencesCount > 1)\n                            break;\n                    }\n\n                    if(differencesCount == 1)\n                    {\n                        geneQueue.push(nextGene);\n                        visitedGenes.insert(nextGene);\n                    }\n                }\n            }\n        }\n        mutationDepth++;\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint minMutation(std::string startGene, std::string endGene, std::vector<std::string> &geneBank)\n{\n    std::queue<std::string> geneQueue;\n    geneQueue.push(startGene);\n    std::unordered_set<std::string> visitedGenes;\n    visitedGenes.insert(startGene);\n    int mutationDepth= 0;\n\n    while(!geneQueue.empty())\n    {\n        int currentLevelSize= geneQueue.size();\n        for(int geneIndex= 0; geneIndex < currentLevelSize; ++geneIndex)\n        {\n            std::string currentGene= geneQueue.front();\n            geneQueue.pop();\n            if(currentGene == endGene)\n                return mutationDepth;\n\n            for(const auto &nextGene : geneBank)\n            {\n                if(!visitedGenes.count(nextGene))\n                {\n                    int differencesCount= 0;\n                    for(int genePosition= 0; genePosition < 8; ++genePosition)\n                    {\n                        if(currentGene[genePosition] != nextGene[genePosition])\n                            ++differencesCount;\n                        if(differencesCount > 1)\n                            break;\n                    }\n\n                    if(differencesCount == 1)\n                    {\n                        geneQueue.push(nextGene);\n                        visitedGenes.insert(nextGene);\n                    }\n                }\n            }\n        }\n        mutationDepth++;\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countSegments(const string &inputString)\n{\n    stringstream stringStream(inputString);\n    int segmentCount = 0;\n    string segment;\n\n    while(stringStream >> segment)\n    {\n        ++segmentCount;\n    }\n\n    return segmentCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countSegments(const std::string &inputString)\n{\n    std::stringstream stringStream(inputString);\n    int segmentCount= 0;\n    std::string segment;\n\n    while(stringStream >> segment)\n    {\n        ++segmentCount;\n    }\n\n    return segmentCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool compare(const vector<int> &intervalA, const vector<int> &intervalB)\n{\n    return intervalA[1] < intervalB[1];\n}\n\nint eraseOverlapIntervals(vector<vector<int>> &overlappingIntervals)\n{\n    if(overlappingIntervals.empty())\n        return 0;\n\n    sort(overlappingIntervals.begin(), overlappingIntervals.end(), compare);\n\n    int removeCount= 0;\n    int previousEnd= overlappingIntervals[0][1];\n\n    for(size_t currentIndex= 1; currentIndex < overlappingIntervals.size(); currentIndex++)\n    {\n        if(overlappingIntervals[currentIndex][0] < previousEnd)\n        {\n            removeCount++;\n        }\n        else\n        {\n            previousEnd= overlappingIntervals[currentIndex][1];\n        }\n    }\n\n    return removeCount;\n}",
    "output": "#include <bits/stdc++.h>\nbool compare(const std::vector<int> &intervalA, const std::vector<int> &intervalB)\n{\n    return intervalA[1] < intervalB[1];\n}\n\nint eraseOverlapIntervals(std::vector<std::vector<int>> &overlappingIntervals)\n{\n    if(overlappingIntervals.empty())\n        return 0;\n\n    std::sort(overlappingIntervals.begin(), overlappingIntervals.end(), compare);\n\n    int removeCount= 0;\n    int previousEnd= overlappingIntervals[0][1];\n\n    for(size_t currentIndex= 1; currentIndex < overlappingIntervals.size(); currentIndex++)\n    {\n        if(overlappingIntervals[currentIndex][0] < previousEnd)\n        {\n            removeCount++;\n        }\n        else\n        {\n            previousEnd= overlappingIntervals[currentIndex][1];\n        }\n    }\n\n    return removeCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findRightInterval(vector<vector<int>> &intervals)\n{\n    vector<int> result(intervals.size(), -1);\n    map<int, int> intervalStarts;\n    for(int index= 0; index < intervals.size(); ++index)\n    {\n        intervalStarts[intervals[index][0]]= index;\n    }\n\n    for(int index= 0; index < intervals.size(); ++index)\n    {\n        auto iterator= intervalStarts.lower_bound(intervals[index][1]);\n        if(iterator != intervalStarts.end())\n        {\n            result[index]= iterator->second;\n        }\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findRightInterval(std::vector<std::vector<int>> &intervals)\n{\n    std::vector<int> result(intervals.size(), -1);\n    std::map<int, int> intervalStarts;\n    for(int index= 0; index < intervals.size(); ++index)\n    {\n        intervalStarts[intervals[index][0]]= index;\n    }\n\n    for(int index= 0; index < intervals.size(); ++index)\n    {\n        auto iterator= intervalStarts.lower_bound(intervals[index][1]);\n        if(iterator != intervalStarts.end())\n        {\n            result[index]= iterator->second;\n        }\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int countPathsWithSum(TreeNode *currentNode, int targetSum, int currentSum)\n{\n    if(currentNode == NULL)\n    {\n        return 0;\n    }\n\n    currentSum+= currentNode->val;\n    int totalPaths= currentSum == targetSum;\n    totalPaths+= countPathsWithSum(currentNode->left, targetSum, currentSum);\n    totalPaths+= countPathsWithSum(currentNode->right, targetSum, currentSum);\n    return totalPaths;\n}\n\nint pathSum(TreeNode *rootNode, int targetSum)\n{\n    if(rootNode == NULL)\n    {\n        return 0;\n    }\n\n    return countPathsWithSum(rootNode, targetSum, 0) + pathSum(rootNode->left, targetSum) + pathSum(rootNode->right, targetSum);\n}",
    "output": "int countPathsWithSum(TreeNode *currentNode, int targetSum, int currentSum)\n{\n    if(currentNode == NULL)\n    {\n        return 0;\n    }\n\n    currentSum+= currentNode->val;\n    int totalPaths= currentSum == targetSum;\n    totalPaths+= countPathsWithSum(currentNode->left, targetSum, currentSum);\n    totalPaths+= countPathsWithSum(currentNode->right, targetSum, currentSum);\n    return totalPaths;\n}\n\nint pathSum(TreeNode *rootNode, int targetSum)\n{\n    if(rootNode == NULL)\n    {\n        return 0;\n    }\n\n    return countPathsWithSum(rootNode, targetSum, 0) + pathSum(rootNode->left, targetSum) + pathSum(rootNode->right, targetSum);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findAnagrams(string sourceString, string patternString)\n{\n    vector<int> anagramIndices;\n    if(sourceString.size() < patternString.size())\n        return anagramIndices;\n\n    vector<int> sourceCount(26, 0), patternCount(26, 0);\n    for(int i = 0; i < patternString.size(); i++)\n        patternCount[patternString[i] - 'a']++;\n\n    for(int index = 0; index < sourceString.size(); index++)\n    {\n        sourceCount[sourceString[index] - 'a']++;\n        if(index >= patternString.size())\n            sourceCount[sourceString[index - patternString.size()] - 'a']--;\n        if(sourceCount == patternCount)\n            anagramIndices.push_back(index - patternString.size() + 1);\n    }\n\n    return anagramIndices;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findAnagrams(std::string sourceString, std::string patternString)\n{\n    std::vector<int> anagramIndices;\n    if(sourceString.size() < patternString.size())\n        return anagramIndices;\n\n    std::vector<int> sourceCount(26, 0), patternCount(26, 0);\n    for(char character : patternString)\n        patternCount[character - 'a']++;\n\n    for(int index= 0; index < sourceString.size(); index++)\n    {\n        sourceCount[sourceString[index] - 'a']++;\n        if(index >= patternString.size())\n            sourceCount[sourceString[index - patternString.size()] - 'a']--;\n        if(sourceCount == patternCount)\n            anagramIndices.push_back(index - patternString.size() + 1);\n    }\n\n    return anagramIndices;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring parseTernary(string ternaryExpression)\n{\n    stack<char> operatorStack;\n    for(int index= ternaryExpression.size() - 1; index >= 0; --index)\n    {\n        char currentChar= ternaryExpression[index];\n        if(!operatorStack.empty() && operatorStack.top() == '?')\n        {\n            operatorStack.pop(); // Pop '?'\n            char trueCase= operatorStack.top();\n            operatorStack.pop();\n            operatorStack.pop(); // Pop ':'\n            char falseCase= operatorStack.top();\n            operatorStack.pop();\n            operatorStack.push(currentChar == 'T' ? trueCase : falseCase);\n        }\n        else\n        {\n            operatorStack.push(currentChar);\n        }\n    }\n    return string(1, operatorStack.top());\n}",
    "output": "#include <bits/stdc++.h>\nstd::string parseTernary(std::string ternaryExpression)\n{\n    std::stack<char> operatorStack;\n    for(int index= ternaryExpression.size() - 1; index >= 0; --index)\n    {\n        char currentChar= ternaryExpression[index];\n        if(!operatorStack.empty() && operatorStack.top() == '?')\n        {\n            operatorStack.pop(); // Pop '?'\n            char trueCase= operatorStack.top();\n            operatorStack.pop();\n            operatorStack.pop(); // Pop ':'\n            char falseCase= operatorStack.top();\n            operatorStack.pop();\n            operatorStack.push(currentChar == 'T' ? trueCase : falseCase);\n        }\n        else\n        {\n            operatorStack.push(currentChar);\n        }\n    }\n    return std::string(1, operatorStack.top());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findKthNumber(int totalNumbers, int kthPosition)\n{\n    vector<int> numberList;\n    for(int currentNumber= 1; currentNumber <= totalNumbers; ++currentNumber)\n    {\n        numberList.push_back(currentNumber);\n    }\n    sort(numberList.begin(), numberList.end(), [](int firstNumber, int secondNumber)\n         { return to_string(firstNumber) < to_string(secondNumber); });\n    return numberList[kthPosition - 1];\n}",
    "output": "#include <bits/stdc++.h>\nint findKthNumber(int totalNumbers, int kthPosition)\n{\n    std::vector<int> numberList;\n    for(int currentNumber= 1; currentNumber <= totalNumbers; ++currentNumber)\n    {\n        numberList.push_back(currentNumber);\n    }\n    std::sort(numberList.begin(), numberList.end(), [](int firstNumber, int secondNumber)\n         { return std::to_string(firstNumber) < std::to_string(secondNumber); });\n    return numberList[kthPosition - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int arrangeCoins(int totalCoins)\n{\n    int completeRows= 0;\n    while(totalCoins > completeRows)\n    {\n        completeRows++;\n        totalCoins-= completeRows;\n    }\n    return completeRows;\n}",
    "output": "int arrangeCoins(int totalCoins)\n{\n    int completeRows= 0;\n    while(totalCoins > completeRows)\n    {\n        completeRows++;\n        totalCoins-= completeRows;\n    }\n    return completeRows;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDuplicates(vector<int> &inputNumbers)\n{\n    vector<int> duplicates;\n    for(int currentIndex= 0; currentIndex < inputNumbers.size(); currentIndex++)\n    {\n        int numberIndex= abs(inputNumbers[currentIndex]) - 1;\n        if(inputNumbers[numberIndex] < 0)\n        {\n            duplicates.push_back(abs(inputNumbers[currentIndex]));\n        }\n        else\n        {\n            inputNumbers[numberIndex]*= -1;\n        }\n    }\n    return duplicates;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findDuplicates(std::vector<int> &inputNumbers)\n{\n    std::vector<int> duplicates;\n    for(int currentIndex= 0; currentIndex < inputNumbers.size(); currentIndex++)\n    {\n        int numberIndex= abs(inputNumbers[currentIndex]) - 1;\n        if(inputNumbers[numberIndex] < 0)\n        {\n            duplicates.push_back(abs(inputNumbers[currentIndex]));\n        }\n        else\n        {\n            inputNumbers[numberIndex]*= -1;\n        }\n    }\n    return duplicates;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint compress(vector<char> &characterArray)\n{\n    int currentIndex = 0, characterCount;\n    for (int i = 0; i < characterArray.size(); i += characterCount)\n    {\n        characterCount = 1;\n        while (i + characterCount < characterArray.size() && characterArray[i] == characterArray[i + characterCount])\n        {\n            characterCount++;\n        }\n        characterArray[currentIndex++] = characterArray[i];\n        if (characterCount > 1)\n        {\n            for (int j = 0; j < to_string(characterCount).size(); ++j)\n            {\n                char c = to_string(characterCount)[j];\n                characterArray[currentIndex++] = c;\n            }\n        }\n    }\n    return currentIndex;\n}",
    "output": "#include <bits/stdc++.h>\nint compress(std::vector<char> &characterArray)\n{\n    int currentIndex= 0, characterCount;\n    for(int i= 0; i < characterArray.size(); i+= characterCount)\n    {\n        characterCount= 1;\n        while(i + characterCount < characterArray.size() && characterArray[i] == characterArray[i + characterCount])\n        {\n            characterCount++;\n        }\n        characterArray[currentIndex++]= characterArray[i];\n        if(characterCount > 1)\n        {\n            for(char c : std::to_string(characterCount))\n            {\n                characterArray[currentIndex++]= c;\n            }\n        }\n    }\n    return currentIndex;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isShortestAndUniqueSupersequence(vector<int> &inputNumbers, vector<vector<int>> &inputSequences)\n{\n    unordered_map<int, int> numberPositionMap;\n    for(int index = 0; index < inputNumbers.size(); ++index)\n    {\n        numberPositionMap[inputNumbers[index]] = index;\n    }\n\n    for(int i = 0; i < inputSequences.size(); ++i)\n    {\n        const auto &sequence = inputSequences[i];\n        if(numberPositionMap[sequence[0]] > numberPositionMap[sequence.back()])\n        {\n            return false;\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isShortestAndUniqueSupersequence(std::vector<int> &inputNumbers, std::vector<std::vector<int>> &inputSequences)\n{\n    std::unordered_map<int, int> numberPositionMap;\n    for(int index= 0; index < inputNumbers.size(); ++index)\n    {\n        numberPositionMap[inputNumbers[index]]= index;\n    }\n\n    for(const auto &sequence : inputSequences)\n    {\n        if(numberPositionMap[sequence[0]] > numberPositionMap[sequence.back()])\n        {\n            return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *addTwoNumbers(ListNode *firstList, ListNode *secondList)\n{\n    ListNode *resultList= NULL;\n    ListNode **currentNode= &resultList;\n    int carry= 0;\n    while(firstList || secondList || carry)\n    {\n        int sum= (firstList ? firstList->value : 0) + (secondList ? secondList->value : 0) + carry;\n        carry= sum / 10;\n        *currentNode= new ListNode(sum % 10);\n        currentNode= &((*currentNode)->next);\n        if(firstList)\n            firstList= firstList->next;\n        if(secondList)\n            secondList= secondList->next;\n    }\n    return resultList;\n}",
    "output": "struct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *addTwoNumbers(ListNode *firstList, ListNode *secondList)\n{\n    ListNode *resultList= NULL;\n    ListNode **currentNode= &resultList;\n    int carry= 0;\n    while(firstList || secondList || carry)\n    {\n        int sum= (firstList ? firstList->value : 0) + (secondList ? secondList->value : 0) + carry;\n        carry= sum / 10;\n        *currentNode= new ListNode(sum % 10);\n        currentNode= &((*currentNode)->next);\n        if(firstList)\n            firstList= firstList->next;\n        if(secondList)\n            secondList= secondList->next;\n    }\n    return resultList;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numberOfArithmeticSlices(vector<int> &numberSequence)\n{\n    int totalSlices = 0;\n    int sequenceLength = numberSequence.size();\n    vector<unordered_map<int, int>> differenceCount(sequenceLength);\n\n    for(int currentIndex = 0; currentIndex < sequenceLength; ++currentIndex)\n    {\n        for(int previousIndex = 0; previousIndex < currentIndex; ++previousIndex)\n        {\n            long difference = (long)numberSequence[currentIndex] - (long)numberSequence[previousIndex];\n            if(difference <= INT_MIN || difference > INT_MAX)\n                continue;\n\n            int delta = (int)difference;\n            differenceCount[currentIndex][delta] += 1;\n\n            if(differenceCount[previousIndex].count(delta))\n            {\n                totalSlices += differenceCount[previousIndex][delta];\n                differenceCount[currentIndex][delta] += differenceCount[previousIndex][delta];\n            }\n        }\n    }\n    return totalSlices;\n}",
    "output": "#include <bits/stdc++.h>\nint numberOfArithmeticSlices(std::vector<int> &numberSequence)\n{\n    int totalSlices= 0;\n    int sequenceLength= numberSequence.size();\n    std::vector<std::unordered_map<int, int>> differenceCount(sequenceLength);\n\n    for(int currentIndex= 0; currentIndex < sequenceLength; ++currentIndex)\n    {\n        for(int previousIndex= 0; previousIndex < currentIndex; ++previousIndex)\n        {\n            long difference= (long)numberSequence[currentIndex] - (long)numberSequence[previousIndex];\n            if(difference <= INT_MIN || difference > INT_MAX)\n                continue;\n\n            int delta= (int)difference;\n            differenceCount[currentIndex][delta]+= 1;\n\n            if(differenceCount[previousIndex].count(delta))\n            {\n                totalSlices+= differenceCount[previousIndex][delta];\n                differenceCount[currentIndex][delta]+= differenceCount[previousIndex][delta];\n            }\n        }\n    }\n    return totalSlices;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numberOfBoomerangs(vector<vector<int>> &points)\n{\n    int totalBoomerangs = 0;\n\n    for (int i = 0; i < points.size(); ++i)\n    {\n        auto &originPoint = points[i];\n        unordered_map<int, int> distanceCount;\n        for (int j = 0; j < points.size(); ++j)\n        {\n            auto &targetPoint = points[j];\n            int deltaX = originPoint[0] - targetPoint[0], deltaY = originPoint[1] - targetPoint[1];\n            int distanceSquared = deltaX * deltaX + deltaY * deltaY;\n            distanceCount[distanceSquared]++;\n        }\n\n        for (auto &distanceGroup : distanceCount)\n        {\n            totalBoomerangs += distanceGroup.second * (distanceGroup.second - 1);\n        }\n    }\n\n    return totalBoomerangs;\n}",
    "output": "#include <bits/stdc++.h>\nint numberOfBoomerangs(std::vector<std::vector<int>> &points)\n{\n    int totalBoomerangs= 0;\n\n    for(auto &originPoint : points)\n    {\n        std::unordered_map<int, int> distanceCount;\n        for(auto &targetPoint : points)\n        {\n            int deltaX= originPoint[0] - targetPoint[0], deltaY= originPoint[1] - targetPoint[1];\n            int distanceSquared= deltaX * deltaX + deltaY * deltaY;\n            distanceCount[distanceSquared]++;\n        }\n\n        for(auto &distanceGroup : distanceCount)\n        {\n            totalBoomerangs+= distanceGroup.second * (distanceGroup.second - 1);\n        }\n    }\n\n    return totalBoomerangs;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDisappearedNumbers(vector<int> &inputNumbers)\n{\n    vector<int> missingNumbers;\n\n    for(int currentIndex= 0; currentIndex < inputNumbers.size(); ++currentIndex)\n    {\n        int indexToCheck= abs(inputNumbers[currentIndex]) - 1;\n        inputNumbers[indexToCheck]= -abs(inputNumbers[indexToCheck]);\n    }\n\n    for(int currentIndex= 0; currentIndex < inputNumbers.size(); ++currentIndex)\n    {\n        if(inputNumbers[currentIndex] > 0)\n        {\n            missingNumbers.push_back(currentIndex + 1);\n        }\n    }\n\n    return missingNumbers;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findDisappearedNumbers(std::vector<int> &inputNumbers)\n{\n    std::vector<int> missingNumbers;\n\n    for(int currentIndex= 0; currentIndex < inputNumbers.size(); ++currentIndex)\n    {\n        int indexToCheck= abs(inputNumbers[currentIndex]) - 1;\n        inputNumbers[indexToCheck]= -abs(inputNumbers[indexToCheck]);\n    }\n\n    for(int currentIndex= 0; currentIndex < inputNumbers.size(); ++currentIndex)\n    {\n        if(inputNumbers[currentIndex] > 0)\n        {\n            missingNumbers.push_back(currentIndex + 1);\n        }\n    }\n\n    return missingNumbers;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nstring serialize(TreeNode *root)\n{\n    if(!root)\n        return \"#\";\n    return to_string(root->value) + ',' + serialize(root->leftChild) + ',' + serialize(root->rightChild);\n}\n\nTreeNode *deserialize(string data)\n{\n    istringstream dataStream(data);\n    return deserializeHelper(dataStream);\n}\n\nTreeNode *deserializeHelper(istringstream &dataStream)\n{\n    string value;\n    getline(dataStream, value, ',');\n\n    if(value == \"#\")\n        return NULL;\n    TreeNode *node= new TreeNode(stoi(value));\n    node->leftChild= deserializeHelper(dataStream);\n    node->rightChild= deserializeHelper(dataStream);\n    return node;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nstd::string serialize(TreeNode *root)\n{\n    if(!root)\n        return \"#\";\n    return std::to_string(root->value) + ',' + serialize(root->leftChild) + ',' + serialize(root->rightChild);\n}\n\nTreeNode *deserialize(std::string data)\n{\n    std::istringstream dataStream(data);\n    return deserializeHelper(dataStream);\n}\n\nTreeNode *deserializeHelper(std::istringstream &dataStream)\n{\n    std::string value;\n    std::getline(dataStream, value, ',');\n\n    if(value == \"#\")\n        return NULL;\n    TreeNode *node= new TreeNode(std::stoi(value));\n    node->leftChild= deserializeHelper(dataStream);\n    node->rightChild= deserializeHelper(dataStream);\n    return node;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nTreeNode *deleteNode(TreeNode *root, int key)\n{\n    if(root == NULL)\n        return NULL;\n\n    if(key < root->value)\n    {\n        root->leftChild= deleteNode(root->leftChild, key);\n    }\n    else if(key > root->value)\n    {\n        root->rightChild= deleteNode(root->rightChild, key);\n    }\n    else\n    {\n        if(root->leftChild == NULL)\n        {\n            TreeNode *tempNode= root->rightChild;\n            delete root;\n            return tempNode;\n        }\n        else if(root->rightChild == NULL)\n        {\n            TreeNode *tempNode= root->leftChild;\n            delete root;\n            return tempNode;\n        }\n        else\n        {\n            TreeNode *tempNode= root->rightChild;\n            while(tempNode->leftChild)\n                tempNode= tempNode->leftChild;\n            root->value= tempNode->value;\n            root->rightChild= deleteNode(root->rightChild, tempNode->value);\n        }\n    }\n    return root;\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nTreeNode *deleteNode(TreeNode *root, int key)\n{\n    if(root == NULL)\n        return NULL;\n\n    if(key < root->value)\n    {\n        root->leftChild= deleteNode(root->leftChild, key);\n    }\n    else if(key > root->value)\n    {\n        root->rightChild= deleteNode(root->rightChild, key);\n    }\n    else\n    {\n        if(root->leftChild == NULL)\n        {\n            TreeNode *tempNode= root->rightChild;\n            delete root;\n            return tempNode;\n        }\n        else if(root->rightChild == NULL)\n        {\n            TreeNode *tempNode= root->leftChild;\n            delete root;\n            return tempNode;\n        }\n        else\n        {\n            TreeNode *tempNode= root->rightChild;\n            while(tempNode->leftChild)\n                tempNode= tempNode->leftChild;\n            root->value= tempNode->value;\n            root->rightChild= deleteNode(root->rightChild, tempNode->value);\n        }\n    }\n    return root;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring sortByFrequency(string inputString)\n{\n    unordered_map<char, int> characterFrequencyMap;\n    vector<char> characterVector(inputString.begin(), inputString.end());\n\n    for(char currentCharacter : inputString)\n        characterFrequencyMap[currentCharacter]++;\n\n    sort(characterVector.begin(), characterVector.end(),\n         [&](char firstCharacter, char secondCharacter)\n         { return characterFrequencyMap[firstCharacter] > characterFrequencyMap[secondCharacter]; });\n\n    return string(characterVector.begin(), characterVector.end());\n}",
    "output": "#include <bits/stdc++.h>\nstd::string sortByFrequency(std::string inputString)\n{\n    std::unordered_map<char, int> characterFrequencyMap;\n    std::vector<char> characterVector(inputString.begin(), inputString.end());\n\n    for(char currentCharacter : inputString)\n        characterFrequencyMap[currentCharacter]++;\n\n    std::sort(characterVector.begin(), characterVector.end(),\n              [&](char firstCharacter, char secondCharacter)\n              { return characterFrequencyMap[firstCharacter] > characterFrequencyMap[secondCharacter]; });\n\n    return std::string(characterVector.begin(), characterVector.end());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinArrowShots(vector<vector<int>> &balloonPoints)\n{\n    if(balloonPoints.empty())\n        return 0;\n    sort(balloonPoints.begin(), balloonPoints.end(), [](const vector<int> &startPoint, const vector<int> &endPoint)\n              { return startPoint[1] < endPoint[1]; });\n\n    int totalArrows= 1;\n    int arrowEnd= balloonPoints[0][1];\n\n    for(int index= 1; index < balloonPoints.size(); ++index)\n    {\n        if(balloonPoints[index][0] > arrowEnd)\n        {\n            totalArrows++;\n            arrowEnd= balloonPoints[index][1];\n        }\n    }\n\n    return totalArrows;\n}",
    "output": "#include <bits/stdc++.h>\nint findMinArrowShots(std::vector<std::vector<int>> &balloonPoints)\n{\n    if(balloonPoints.empty())\n        return 0;\n    std::sort(balloonPoints.begin(), balloonPoints.end(), [](const std::vector<int> &startPoint, const std::vector<int> &endPoint)\n              { return startPoint[1] < endPoint[1]; });\n\n    int totalArrows= 1;\n    int arrowEnd= balloonPoints[0][1];\n\n    for(int index= 1; index < balloonPoints.size(); ++index)\n    {\n        if(balloonPoints[index][0] > arrowEnd)\n        {\n            totalArrows++;\n            arrowEnd= balloonPoints[index][1];\n        }\n    }\n\n    return totalArrows;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minMoves(vector<int> &numbers)\n{\n    int minimumElement = *min_element(numbers.begin(), numbers.end());\n    int totalMoves = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        totalMoves += (currentNumber - minimumElement);\n    }\n    return totalMoves;\n}",
    "output": "#include <bits/stdc++.h>\nint minMoves(std::vector<int> &numbers)\n{\n    int minimumElement= *std::min_element(numbers.begin(), numbers.end());\n    int totalMoves= 0;\n    for(int currentNumber : numbers)\n    {\n        totalMoves+= (currentNumber - minimumElement);\n    }\n    return totalMoves;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint fourSumCount(vector<int> &firstArray, vector<int> &secondArray, vector<int> &thirdArray, vector<int> &fourthArray)\n{\n    unordered_map<int, int> sumCountMap;\n    int totalCount = 0;\n\n    for (int i = 0; i < firstArray.size(); ++i)\n    {\n        for (int j = 0; j < secondArray.size(); ++j)\n        {\n            sumCountMap[firstArray[i] + secondArray[j]]++;\n        }\n    }\n\n    for (int k = 0; k < thirdArray.size(); ++k)\n    {\n        for (int l = 0; l < fourthArray.size(); ++l)\n        {\n            totalCount += sumCountMap[-(thirdArray[k] + fourthArray[l])];\n        }\n    }\n\n    return totalCount;\n}",
    "output": "#include <bits/stdc++.h>\nint fourSumCount(std::vector<int> &firstArray, std::vector<int> &secondArray, std::vector<int> &thirdArray, std::vector<int> &fourthArray)\n{\n    std::unordered_map<int, int> sumCountMap;\n    int totalCount= 0;\n\n    for(auto firstElement : firstArray)\n    {\n        for(auto secondElement : secondArray)\n        {\n            sumCountMap[firstElement + secondElement]++;\n        }\n    }\n\n    for(auto thirdElement : thirdArray)\n    {\n        for(auto fourthElement : fourthArray)\n        {\n            totalCount+= sumCountMap[-(thirdElement + fourthElement)];\n        }\n    }\n\n    return totalCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findContentChildren(vector<int>& children'sAppetite, vector<int>& cookies) {\n    sort(children'sAppetite.begin(), children'sAppetite.end());\n    sort(cookies.begin(), cookies.end());\n    int childIndex = 0, cookieIndex = 0;\n\n    while (childIndex < children'sAppetite.size() && cookieIndex < cookies.size()) {\n        if (cookies[cookieIndex] >= children'sAppetite[childIndex]) {\n            childIndex++;\n        }\n        cookieIndex++;\n    }\n\n    return childIndex;\n}",
    "output": "#include <bits/stdc++.h>\nint findContentChildren(std::vector<int>& children'sAppetite, std::vector<int>& cookies) {\n    std::sort(children'sAppetite.begin(), children'sAppetite.end());\n    std::sort(cookies.begin(), cookies.end());\n    int childIndex = 0, cookieIndex = 0;\n\n    while (childIndex < children'sAppetite.size() && cookieIndex < cookies.size()) {\n        if (cookies[cookieIndex] >= children'sAppetite[childIndex]) {\n            childIndex++;\n}\n\ncookieIndex++;\n}\n\nreturn childIndex;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For INT_MIN\nusing namespace std;\n\nbool find132pattern(vector<int> &numberList)\n{\n    int size= numberList.size(), thirdElement= INT_MIN;\n    stack<int> elementStack;\n    for(int index= size - 1; index >= 0; --index)\n    {\n        if(numberList[index] < thirdElement)\n            return true;\n        while(!elementStack.empty() && elementStack.top() < numberList[index])\n        {\n            thirdElement= elementStack.top();\n            elementStack.pop();\n        }\n        elementStack.push(numberList[index]);\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool find132pattern(std::vector<int> &numberList)\n{\n    int size= numberList.size(), thirdElement= INT_MIN;\n    std::stack<int> elementStack;\n    for(int index= size - 1; index >= 0; --index)\n    {\n        if(numberList[index] < thirdElement)\n            return true;\n        while(!elementStack.empty() && elementStack.top() < numberList[index])\n        {\n            thirdElement= elementStack.top();\n            elementStack.pop();\n        }\n        elementStack.push(numberList[index]);\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint getNextIndex(int currentIndex, vector<int> &numbers)\n{\n    int size= numbers.size();\n    return ((currentIndex + numbers[currentIndex]) % size + size) % size;\n}\n\nbool circularArrayLoop(vector<int> &numbers)\n{\n    int size= numbers.size();\n    for(int index= 0; index < size; index++)\n    {\n        int slowPointer= index, fastPointer= index;\n        do\n        {\n            slowPointer= getNextIndex(slowPointer, numbers);\n            fastPointer= getNextIndex(getNextIndex(fastPointer, numbers), numbers);\n        } while(slowPointer != fastPointer && numbers[slowPointer] * numbers[fastPointer] > 0);\n\n        if(slowPointer != fastPointer)\n            continue;\n        bool isCycle= false;\n        int startIndex= slowPointer;\n        do\n        {\n            isCycle|= getNextIndex(startIndex, numbers) == startIndex;\n            startIndex= getNextIndex(startIndex, numbers);\n        } while(startIndex != slowPointer);\n        if(!isCycle)\n            return true;\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool circularArrayLoop(std::vector<int> &numbers)\n{\n    int size= numbers.size();\n    for(int index= 0; index < size; index++)\n    {\n        int slowPointer= index, fastPointer= index;\n        do\n        {\n            slowPointer= getNextIndex(slowPointer, numbers);\n            fastPointer= getNextIndex(getNextIndex(fastPointer, numbers), numbers);\n        } while(slowPointer != fastPointer && numbers[slowPointer] * numbers[fastPointer] > 0);\n\n        if(slowPointer != fastPointer)\n            continue;\n        bool isCycle= false;\n        int startIndex= slowPointer;\n        do\n        {\n            isCycle|= getNextIndex(startIndex, numbers) == startIndex;\n            startIndex= getNextIndex(startIndex, numbers);\n        } while(startIndex != slowPointer);\n        if(!isCycle)\n            return true;\n    }\n    return false;\n}\n\nint getNextIndex(int currentIndex, std::vector<int> &numbers)\n{\n    int size= numbers.size();\n    return ((currentIndex + numbers[currentIndex]) % size + size) % size;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int calculatePigs(int totalBuckets, int minutesToDie, int minutesToTest)\n{\n    int numberOfPigs= 0;\n    while(pow((minutesToTest / minutesToDie) + 1, numberOfPigs) < totalBuckets)\n    {\n        numberOfPigs++;\n    }\n    return numberOfPigs;\n}",
    "output": "int calculatePigs(int totalBuckets, int minutesToDie, int minutesToTest)\n{\n    int numberOfPigs= 0;\n    while(pow((minutesToTest / minutesToDie) + 1, numberOfPigs) < totalBuckets)\n    {\n        numberOfPigs++;\n    }\n    return numberOfPigs;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canConstruct(string inputString)\n{\n    int length= inputString.size();\n    for(int substringLength= length / 2; substringLength > 0; --substringLength)\n    {\n        if(length % substringLength == 0)\n        {\n            string substring= inputString.substr(0, substringLength);\n            bool isConstructible= true;\n            for(int j= substringLength; j < length; j+= substringLength)\n            {\n                if(inputString.substr(j, substringLength) != substring)\n                {\n                    isConstructible= false;\n                    break;\n                }\n            }\n\n            if(isConstructible)\n                return true;\n        }\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool canConstruct(std::string inputString)\n{\n    int length= inputString.size();\n    for(int substringLength= length / 2; substringLength > 0; --substringLength)\n    {\n        if(length % substringLength == 0)\n        {\n            std::string substring= inputString.substr(0, substringLength);\n            bool isConstructible= true;\n            for(int j= substringLength; j < length; j+= substringLength)\n            {\n                if(inputString.substr(j, substringLength) != substring)\n                {\n                    isConstructible= false;\n                    break;\n                }\n            }\n\n            if(isConstructible)\n                return true;\n        }\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass LFUCache\n{\n  public:\n    LFUCache(int cacheCapacity) : capacity(cacheCapacity), minFreq(0) {}\n\n    int get(int key)\n    {\n        if(cache.count(key) == 0)\n            return -1;\n        auto &node= cache[key];\n        freqList[node.frequency].erase(node.iterator);\n        if(freqList[minFreq].size() == 0)\n            minFreq++;\n        node.frequency++;\n        freqList[node.frequency].push_back(key);\n        node.iterator= prev(freqList[node.frequency].end());\n        return node.value;\n    }\n\n    void put(int key, int value)\n    {\n        if(capacity == 0)\n            return;\n        if(get(key) != -1)\n        {\n            cache[key].value= value;\n            return;\n        }\n        if(cache.size() >= capacity)\n        {\n            int toRemove= freqList[minFreq].front();\n            freqList[minFreq].pop_front();\n            cache.erase(toRemove);\n        }\n        minFreq= 1;\n        freqList[minFreq].push_back(key);\n        cache[key]= {1, value, prev(freqList[minFreq].end())};\n    }\n\n  private:\n    struct Node\n    {\n        int frequency, value;\n        list<int>::iterator iterator;\n    };\n\n    int capacity;\n    int minFreq;\n    unordered_map<int, Node> cache;\n    unordered_map<int, list<int>> freqList;\n};",
    "output": "#include <bits/stdc++.h>\nclass LFUCache\n{\n  public:\n    LFUCache(int cacheCapacity) : capacity(cacheCapacity), minFreq(0) {}\n\n    int get(int key)\n    {\n        if(cache.count(key) == 0)\n            return -1;\n        auto &node= cache[key];\n        freqList[node.frequency].erase(node.iterator);\n        if(freqList[minFreq].size() == 0)\n            minFreq++;\n        node.frequency++;\n        freqList[node.frequency].push_back(key);\n        node.iterator= prev(freqList[node.frequency].end());\n        return node.value;\n    }\n\n    void put(int key, int value)\n    {\n        if(capacity == 0)\n            return;\n        if(get(key) != -1)\n        {\n            cache[key].value= value;\n            return;\n        }\n        if(cache.size() >= capacity)\n        {\n            int toRemove= freqList[minFreq].front();\n            freqList[minFreq].pop_front();\n            cache.erase(toRemove);\n        }\n        minFreq= 1;\n        freqList[minFreq].push_back(key);\n        cache[key]= {1, value, prev(freqList[minFreq].end())};\n    }\n\n  private:\n    struct Node\n    {\n        int frequency, value;\n        std::list<int>::iterator iterator;\n    };\n\n    int capacity;\n    int minFreq;\n    std::unordered_map<int, Node> cache;\n    std::unordered_map<int, std::list<int>> freqList;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int calculateHammingDistance(int firstNumber, int secondNumber)\n{\n    int distance= 0, xorValue= firstNumber ^ secondNumber;\n    while(xorValue)\n    {\n        distance+= xorValue & 1;\n        xorValue>>= 1;\n    }\n    return distance;\n}",
    "output": "int calculateHammingDistance(int firstNumber, int secondNumber)\n{\n    int distance= 0, xorValue= firstNumber ^ secondNumber;\n    while(xorValue)\n    {\n        distance+= xorValue & 1;\n        xorValue>>= 1;\n    }\n    return distance;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minMoves2(vector<int> &numList)\n{\n    int numberOfElements= numList.size();\n    sort(numList.begin(), numList.end());\n    int medianValue= numList[numberOfElements / 2];\n    int totalMoves= 0;\n    for(int i= 0; i < numberOfElements; i++)\n    {\n        totalMoves+= abs(numList[i] - medianValue);\n    }\n    return totalMoves;\n}",
    "output": "#include <bits/stdc++.h>\nint minMoves2(std::vector<int> &numList)\n{\n    int numberOfElements= numList.size();\n    std::sort(numList.begin(), numList.end());\n    int medianValue= numList[numberOfElements / 2];\n    int totalMoves= 0;\n    for(int i= 0; i < numberOfElements; i++)\n    {\n        totalMoves+= std::abs(numList[i] - medianValue);\n    }\n    return totalMoves;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateIslandPerimeter(vector<vector<int>> &islandGrid)\n{\n    int totalPerimeter= 0;\n    for(int currentRow= 0; currentRow < islandGrid.size(); currentRow++)\n    {\n        for(int currentCol= 0; currentCol < islandGrid[currentRow].size(); currentCol++)\n        {\n            if(islandGrid[currentRow][currentCol] == 1)\n            {\n                totalPerimeter+= 4;\n                if(currentRow > 0 && islandGrid[currentRow - 1][currentCol] == 1)\n                    totalPerimeter-= 2;\n                if(currentCol > 0 && islandGrid[currentRow][currentCol - 1] == 1)\n                    totalPerimeter-= 2;\n            }\n        }\n    }\n    return totalPerimeter;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateIslandPerimeter(std::vector<std::vector<int>> &islandGrid)\n{\n    int totalPerimeter= 0;\n    for(int currentRow= 0; currentRow < islandGrid.size(); currentRow++)\n    {\n        for(int currentCol= 0; currentCol < islandGrid[currentRow].size(); currentCol++)\n        {\n            if(islandGrid[currentRow][currentCol] == 1)\n            {\n                totalPerimeter+= 4;\n                if(currentRow > 0 && islandGrid[currentRow - 1][currentCol] == 1)\n                    totalPerimeter-= 2;\n                if(currentCol > 0 && islandGrid[currentRow][currentCol - 1] == 1)\n                    totalPerimeter-= 2;\n            }\n        }\n    }\n    return totalPerimeter;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canWin(int maxChoosableInteger, int desiredTotal, int currentState, unordered_map<int, bool> &memo)\n{\n    if(desiredTotal <= 0)\n    {\n        return false;\n    }\n    if(memo.count(currentState) > 0)\n    {\n        return memo[currentState];\n    }\n    for(int choice= 1; choice <= maxChoosableInteger; choice++)\n    {\n        int bitCheck= 1 << choice;\n        if((currentState & bitCheck) == 0)\n        {\n            if(!canWin(maxChoosableInteger, desiredTotal - choice, currentState | bitCheck, memo))\n            {\n                memo[currentState]= true;\n                return true;\n            }\n        }\n    }\n    memo[currentState]= false;\n    return false;\n}\n\nbool canIWin(int maxChoosableInteger, int desiredTotal)\n{\n    if(maxChoosableInteger >= desiredTotal)\n        return true;\n    if((maxChoosableInteger * (maxChoosableInteger + 1)) / 2 < desiredTotal)\n        return false;\n\n    unordered_map<int, bool> memo;\n    int currentState= 0;\n    return canWin(maxChoosableInteger, desiredTotal, currentState, memo);\n}",
    "output": "#include <bits/stdc++.h>\nbool canWin(int maxChoosableInteger, int desiredTotal, int currentState, std::unordered_map<int, bool> &memo)\n{\n    if(desiredTotal <= 0)\n    {\n        return false;\n    }\n    if(memo.count(currentState) > 0)\n    {\n        return memo[currentState];\n    }\n    for(int choice= 1; choice <= maxChoosableInteger; choice++)\n    {\n        int bitCheck= 1 << choice;\n        if((currentState & bitCheck) == 0)\n        {\n            if(!canWin(maxChoosableInteger, desiredTotal - choice, currentState | bitCheck, memo))\n            {\n                memo[currentState]= true;\n                return true;\n            }\n        }\n    }\n    memo[currentState]= false;\n    return false;\n}\n\nbool canIWin(int maxChoosableInteger, int desiredTotal)\n{\n    if(maxChoosableInteger >= desiredTotal)\n        return true;\n    if((maxChoosableInteger * (maxChoosableInteger + 1)) / 2 < desiredTotal)\n        return false;\n\n    std::unordered_map<int, bool> memo;\n    int currentState= 0;\n    return canWin(maxChoosableInteger, desiredTotal, currentState, memo);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minTransfers(vector<vector<int>> &transactions)\n{\n    unordered_map<int, int> balances;\n    for (const auto &transaction : transactions)\n    {\n        balances[transaction[0]] -= transaction[2];\n        balances[transaction[1]] += transaction[2];\n    }\n\n    vector<int> debts;\n    for (const auto &balance : balances)\n    {\n        if (balance.second != 0)\n        {\n            debts.push_back(balance.second);\n        }\n    }\n    return dfs(debts, 0);\n}\n\nint dfs(vector<int> &debts, int start)\n{\n    while (start < debts.size() && debts[start] == 0)\n    {\n        start++;\n    }\n    if (start == debts.size())\n    {\n        return 0;\n    }\n    int result = INT_MAX;\n    for (int i = start + 1; i < debts.size(); ++i)\n    {\n        if ((debts[start] > 0) != (debts[i] > 0))\n        {\n            debts[i] += debts[start];\n            result = min(result, 1 + dfs(debts, start + 1));\n            debts[i] -= debts[start];\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nint minTransfers(std::vector<std::vector<int>> &transactions)\n{\n    std::unordered_map<int, int> balances;\n    for(const auto &transaction : transactions)\n    {\n        balances[transaction[0]]-= transaction[2];\n        balances[transaction[1]]+= transaction[2];\n    }\n\n    std::vector<int> debts;\n    for(const auto &balance : balances)\n    {\n        if(balance.second != 0)\n        {\n            debts.push_back(balance.second);\n        }\n    }\n    return dfs(debts, 0);\n}\n\nint dfs(std::vector<int> &debts, int start)\n{\n    while(start < debts.size() && debts[start] == 0)\n    {\n        start++;\n    }\n    if(start == debts.size())\n    {\n        return 0;\n    }\n    int result= INT_MAX;\n    for(int i= start + 1; i < debts.size(); ++i)\n    {\n        if((debts[start] > 0) != (debts[i] > 0))\n        {\n            debts[i]+= debts[start];\n            result= std::min(result, 1 + dfs(debts, start + 1));\n            debts[i]-= debts[start];\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxRepetitions(string sourceString, int sourceCount, string targetString, int targetCount)\n{\n    int currentSourceCount= 0, currentTargetCount= 0, sourceIndex= 0, targetIndex= 0;\n    while(currentSourceCount < sourceCount)\n    {\n        if(sourceString[sourceIndex] == targetString[targetIndex])\n        {\n            targetIndex++;\n            if(targetIndex == targetString.size())\n            {\n                targetIndex= 0;\n                currentTargetCount++;\n            }\n        }\n        sourceIndex++;\n        if(sourceIndex == sourceString.size())\n        {\n            sourceIndex= 0;\n            currentSourceCount++;\n        }\n    }\n    return currentTargetCount / targetCount;\n}",
    "output": "#include <bits/stdc++.h>\nint getMaxRepetitions(std::string sourceString, int sourceCount, std::string targetString, int targetCount)\n{\n    int currentSourceCount= 0, currentTargetCount= 0, sourceIndex= 0, targetIndex= 0;\n    while(currentSourceCount < sourceCount)\n    {\n        if(sourceString[sourceIndex] == targetString[targetIndex])\n        {\n            targetIndex++;\n            if(targetIndex == targetString.size())\n            {\n                targetIndex= 0;\n                currentTargetCount++;\n            }\n        }\n        sourceIndex++;\n        if(sourceIndex == sourceString.size())\n        {\n            sourceIndex= 0;\n            currentSourceCount++;\n        }\n    }\n    return currentTargetCount / targetCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findSubstringInWraproundString(const string &inputString)\n{\n    vector<int> characterCount(26, 0);\n    int currentLength= 0;\n\n    for(int index= 0; index < inputString.size(); index++)\n    {\n        if(index > 0 && (inputString[index] == inputString[index - 1] + 1 || inputString[index - 1] - inputString[index] == 25))\n        {\n            currentLength++;\n        }\n        else\n        {\n            currentLength= 1;\n        }\n        characterCount[inputString[index] - 'a']= max(characterCount[inputString[index] - 'a'], currentLength);\n    }\n\n    return accumulate(characterCount.begin(), characterCount.end(), 0);\n}",
    "output": "#include <bits/stdc++.h>\nint findSubstringInWraproundString(const std::string &inputString)\n{\n    std::vector<int> characterCount(26, 0);\n    int currentLength= 0;\n\n    for(int index= 0; index < inputString.size(); index++)\n    {\n        if(index > 0 && (inputString[index] == inputString[index - 1] + 1 || inputString[index - 1] - inputString[index] == 25))\n        {\n            currentLength++;\n        }\n        else\n        {\n            currentLength= 1;\n        }\n        characterCount[inputString[index] - 'a']= std::max(characterCount[inputString[index] - 'a'], currentLength);\n    }\n\n    return std::accumulate(characterCount.begin(), characterCount.end(), 0);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidIPv4Segment(const string &ipSegment);\nbool isValidIPv6Segment(const string &ipSegment);\n\nstring validateIp(const string &ipAddress)\n{\n    stringstream ss(ipAddress);\n    string ipSegment;\n    int segmentCount = 0;\n\n    if(ipAddress.find(':') == string::npos)\n    {\n        while(getline(ss, ipSegment, '.'))\n        {\n            if(!isValidIPv4Segment(ipSegment))\n                return \"Neither\";\n            segmentCount++;\n        }\n        if(segmentCount == 4)\n            return \"IPv4\";\n    }\n    else\n    {\n        while(getline(ss, ipSegment, ':'))\n        {\n            if(!isValidIPv6Segment(ipSegment))\n                return \"Neither\";\n            segmentCount++;\n        }\n        if(segmentCount == 8)\n            return \"IPv6\";\n    }\n\n    return \"Neither\";\n}\n\nbool isValidIPv4Segment(const string &ipSegment)\n{\n    if(ipSegment.empty() || ipSegment.size() > 3)\n        return false;\n    if(ipSegment.size() > 1 && ipSegment[0] == '0')\n        return false;\n\n    int number = 0;\n    for (int i = 0; i < ipSegment.size(); ++i)\n    {\n        char character = ipSegment[i];\n        if(!isdigit(character))\n            return false;\n        number = number * 10 + (character - '0');\n    }\n\n    return number >= 0 && number <= 255;\n}\n\nbool isValidIPv6Segment(const string &ipSegment)\n{\n    if(ipSegment.empty() || ipSegment.size() > 4)\n        return false;\n\n    for (int i = 0; i < ipSegment.size(); ++i)\n    {\n        char character = ipSegment[i];\n        if(!isxdigit(character))\n            return false;\n    }\n\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isValidIPv4Segment(const std::string &ipSegment);\nbool isValidIPv6Segment(const std::string &ipSegment);\n\nstd::string validateIp(const std::string &ipAddress)\n{\n    std::stringstream ss(ipAddress);\n    std::string ipSegment;\n    int segmentCount= 0;\n\n    if(ipAddress.find(':') == std::string::npos)\n    {\n        while(getline(ss, ipSegment, '.'))\n        {\n            if(!isValidIPv4Segment(ipSegment))\n                return \"Neither\";\n            segmentCount++;\n        }\n        if(segmentCount == 4)\n            return \"IPv4\";\n    }\n    else\n    {\n        while(getline(ss, ipSegment, ':'))\n        {\n            if(!isValidIPv6Segment(ipSegment))\n                return \"Neither\";\n            segmentCount++;\n        }\n        if(segmentCount == 8)\n            return \"IPv6\";\n    }\n\n    return \"Neither\";\n}\n\nbool isValidIPv4Segment(const std::string &ipSegment)\n{\n    if(ipSegment.empty() || ipSegment.size() > 3)\n        return false;\n    if(ipSegment.size() > 1 && ipSegment[0] == '0')\n        return false;\n\n    int number= 0;\n    for(char character : ipSegment)\n    {\n        if(!isdigit(character))\n            return false;\n        number= number * 10 + (character - '0');\n    }\n\n    return number >= 0 && number <= 255;\n}\n\nbool isValidIPv6Segment(const std::string &ipSegment)\n{\n    if(ipSegment.empty() || ipSegment.size() > 4)\n        return false;\n\n    for(char character : ipSegment)\n    {\n        if(!isxdigit(character))\n            return false;\n    }\n\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isConvex(vector<vector<int>> &polygonPoints)\n{\n    int numberOfPoints= polygonPoints.size();\n    int previousCrossProduct= 0, currentCrossProduct= 0;\n\n    for(int i= 0; i < numberOfPoints; ++i)\n    {\n        int deltaX1= polygonPoints[(i + 1) % numberOfPoints][0] - polygonPoints[i][0];\n        int deltaY1= polygonPoints[(i + 1) % numberOfPoints][1] - polygonPoints[i][1];\n        int deltaX2= polygonPoints[(i + 2) % numberOfPoints][0] - polygonPoints[(i + 1) % numberOfPoints][0];\n        int deltaY2= polygonPoints[(i + 2) % numberOfPoints][1] - polygonPoints[(i + 1) % numberOfPoints][1];\n        currentCrossProduct= deltaX1 * deltaY2 - deltaX2 * deltaY1;\n\n        if(currentCrossProduct == 0)\n            continue;\n        if(currentCrossProduct * previousCrossProduct < 0)\n            return false;\n        previousCrossProduct= currentCrossProduct;\n    }\n\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isConvex(std::vector<std::vector<int>> &polygonPoints)\n{\n    int numberOfPoints= polygonPoints.size();\n    int previousCrossProduct= 0, currentCrossProduct= 0;\n\n    for(int i= 0; i < numberOfPoints; ++i)\n    {\n        int deltaX1= polygonPoints[(i + 1) % numberOfPoints][0] - polygonPoints[i][0];\n        int deltaY1= polygonPoints[(i + 1) % numberOfPoints][1] - polygonPoints[i][1];\n        int deltaX2= polygonPoints[(i + 2) % numberOfPoints][0] - polygonPoints[(i + 1) % numberOfPoints][0];\n        int deltaY2= polygonPoints[(i + 2) % numberOfPoints][1] - polygonPoints[(i + 1) % numberOfPoints][1];\n        currentCrossProduct= deltaX1 * deltaY2 - deltaX2 * deltaY1;\n\n        if(currentCrossProduct == 0)\n            continue;\n        if(currentCrossProduct * previousCrossProduct < 0)\n            return false;\n        previousCrossProduct= currentCrossProduct;\n    }\n\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For rand()\nusing namespace std;\n\nint rand10()\n{\n    int randomResult;\n    do\n    {\n        randomResult= (rand7() - 1) * 7 + rand7();\n    } while(randomResult > 40);\n    return randomResult % 10 + 1;\n}",
    "output": "#include <bits/stdc++.h>\nint rand10()\n{\n    int randomResult;\n    do\n    {\n        randomResult = (std::rand() % 7) * 7 + (std::rand() % 7);\n    } while(randomResult > 40);\n    return randomResult % 10 + 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "using namespace std;\n\nstring encode(string inputString)\n{\n    int stringLength= inputString.length();\n    for(int halfLength= stringLength / 2; halfLength > 0; halfLength--)\n    {\n        if(stringLength % halfLength == 0)\n        {\n            int repetitions= stringLength / halfLength;\n            string substring= inputString.substr(0, halfLength);\n            string composedString= \"\";\n            for(int j= 0; j < repetitions; j++)\n            {\n                composedString+= substring;\n            }\n            if(inputString == composedString)\n            {\n                return to_string(repetitions) + \"[\" + substring + \"]\";\n            }\n        }\n    }\n    return inputString;\n}",
    "output": "std::string encode(std::string inputString)\n{\n    int stringLength= inputString.length();\n    for(int halfLength= stringLength / 2; halfLength > 0; halfLength--)\n    {\n        if(stringLength % halfLength == 0)\n        {\n            int repetitions= stringLength / halfLength;\n            std::string substring= inputString.substr(0, halfLength);\n            std::string composedString= \"\";\n            for(int j= 0; j < repetitions; j++)\n            {\n                composedString+= substring;\n            }\n            if(inputString == composedString)\n            {\n                return std::to_string(repetitions) + \"[\" + substring + \"]\";\n            }\n        }\n    }\n    return inputString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isConcatenated(const string &targetWord, unordered_set<string> &wordDictionary)\n{\n    int wordLength = targetWord.size();\n    vector<bool> dynamicProgramming(wordLength + 1, false);\n    dynamicProgramming[0] = true;\n\n    for (int endIndex = 1; endIndex <= wordLength; ++endIndex)\n    {\n        for (int startIndex = 0; startIndex < endIndex; ++startIndex)\n        {\n            if (dynamicProgramming[startIndex] && wordDictionary.count(targetWord.substr(startIndex, endIndex - startIndex)))\n            {\n                dynamicProgramming[endIndex] = true;\n                break;\n            }\n        }\n    }\n    return dynamicProgramming[wordLength];\n}\n\nvector<string> findAllConcatenatedWords(vector<string> &wordsList)\n{\n    unordered_set<string> wordDictionary(wordsList.begin(), wordsList.end());\n    vector<string> concatenatedWords;\n\n    for (int i = 0; i < wordsList.size(); ++i)\n    {\n        const string &currentWord = wordsList[i];\n        if (isConcatenated(currentWord, wordDictionary))\n        {\n            concatenatedWords.push_back(currentWord);\n        }\n    }\n\n    return concatenatedWords;\n}",
    "output": "#include <bits/stdc++.h>\nbool isConcatenated(const std::string &targetWord, std::unordered_set<std::string> &wordDictionary)\n{\n    int wordLength= targetWord.size();\n    std::vector<bool> dynamicProgramming(wordLength + 1, false);\n    dynamicProgramming[0]= true;\n\n    for(int endIndex= 1; endIndex <= wordLength; ++endIndex)\n    {\n        for(int startIndex= 0; startIndex < endIndex; ++startIndex)\n        {\n            if(dynamicProgramming[startIndex] && wordDictionary.count(targetWord.substr(startIndex, endIndex - startIndex)))\n            {\n                dynamicProgramming[endIndex]= true;\n                break;\n            }\n        }\n    }\n    return dynamicProgramming[wordLength];\n}\n\nstd::vector<std::string> findAllConcatenatedWords(std::vector<std::string> &wordsList)\n{\n    std::unordered_set<std::string> wordDictionary(wordsList.begin(), wordsList.end());\n    std::vector<std::string> concatenatedWords;\n\n    for(const std::string &currentWord : wordsList)\n    {\n        if(isConcatenated(currentWord, wordDictionary))\n        {\n            concatenatedWords.push_back(currentWord);\n        }\n    }\n\n    return concatenatedWords;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canFormSquare(vector<int> &matchsticks)\n{\n    if(matchsticks.size() < 4)\n        return false;\n    int totalLength = accumulate(matchsticks.begin(), matchsticks.end(), 0);\n    if(totalLength % 4)\n        return false;\n    int targetLength = totalLength / 4;\n    sort(matchsticks.rbegin(), matchsticks.rend());\n    vector<int> sides(4, 0);\n    return depthFirstSearch(matchsticks, sides, targetLength, 0);\n}\n\nbool depthFirstSearch(vector<int> &matchsticks, vector<int> &sides, int targetLength, int currentIndex)\n{\n    if(currentIndex == matchsticks.size())\n    {\n        return sides[0] == targetLength && sides[1] == targetLength && sides[2] == targetLength;\n    }\n    for(int i = 0; i < 4; ++i)\n    {\n        if(sides[i] + matchsticks[currentIndex] <= targetLength)\n        {\n            sides[i] += matchsticks[currentIndex];\n            if(depthFirstSearch(matchsticks, sides, targetLength, currentIndex + 1))\n                return true;\n            sides[i] -= matchsticks[currentIndex];\n        }\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool canFormSquare(std::vector<int> &matchsticks)\n{\n    if(matchsticks.size() < 4)\n        return false;\n    int totalLength= std::accumulate(matchsticks.begin(), matchsticks.end(), 0);\n    if(totalLength % 4)\n        return false;\n    int targetLength= totalLength / 4;\n    std::sort(matchsticks.rbegin(), matchsticks.rend());\n    std::vector<int> sides(4, 0);\n    return depthFirstSearch(matchsticks, sides, targetLength, 0);\n}\n\nbool depthFirstSearch(std::vector<int> &matchsticks, std::vector<int> &sides, int targetLength, int currentIndex)\n{\n    if(currentIndex == matchsticks.size())\n    {\n        return sides[0] == targetLength && sides[1] == targetLength && sides[2] == targetLength;\n    }\n    for(int i= 0; i < 4; ++i)\n    {\n        if(sides[i] + matchsticks[currentIndex] <= targetLength)\n        {\n            sides[i]+= matchsticks[currentIndex];\n            if(depthFirstSearch(matchsticks, sides, targetLength, currentIndex + 1))\n                return true;\n            sides[i]-= matchsticks[currentIndex];\n        }\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMaxForm(vector<string> &binaryStrings, int maxZeros, int maxOnes)\n{\n    vector<vector<int>> dynamicProgramming(maxZeros + 1, vector<int>(maxOnes + 1));\n\n    for (int k = 0; k < binaryStrings.size(); ++k)\n    {\n        const string &binaryString = binaryStrings[k];\n        int countOnes = count(binaryString.begin(), binaryString.end(), '1');\n        int countZeros = binaryString.length() - countOnes;\n\n        for (int i = maxZeros; i >= countZeros; --i)\n        {\n            for (int j = maxOnes; j >= countOnes; --j)\n            {\n                dynamicProgramming[i][j] = max(dynamicProgramming[i][j], dynamicProgramming[i - countZeros][j - countOnes] + 1);\n            }\n        }\n    }\n    return dynamicProgramming[maxZeros][maxOnes];\n}",
    "output": "#include <bits/stdc++.h>\nint findMaxForm(std::vector<std::string> &binaryStrings, int maxZeros, int maxOnes)\n{\n    std::vector<std::vector<int>> dynamicProgramming(maxZeros + 1, std::vector<int>(maxOnes + 1));\n\n    for(const std::string &binaryString : binaryStrings)\n    {\n        int countOnes= std::count(binaryString.begin(), binaryString.end(), '1');\n        int countZeros= binaryString.length() - countOnes;\n\n        for(int i= maxZeros; i >= countZeros; --i)\n        {\n            for(int j= maxOnes; j >= countOnes; --j)\n            {\n                dynamicProgramming[i][j]= std::max(dynamicProgramming[i][j], dynamicProgramming[i - countZeros][j - countOnes] + 1);\n            }\n        }\n    }\n    return dynamicProgramming[maxZeros][maxOnes];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findRadius(vector<int> &housePositions, vector<int> &heaterPositions)\n{\n    sort(housePositions.begin(), housePositions.end());\n    sort(heaterPositions.begin(), heaterPositions.end());\n\n    int maxRadius = 0;\n    int heaterIndex = 0;\n\n    for (int i = 0; i < housePositions.size(); ++i)\n    {\n        int house = housePositions[i];\n        while (heaterIndex < heaterPositions.size() - 1 &&\n               abs(heaterPositions[heaterIndex + 1] - house) <= abs(heaterPositions[heaterIndex] - house))\n        {\n            heaterIndex++;\n        }\n        maxRadius = max(maxRadius, abs(heaterPositions[heaterIndex] - house));\n    }\n    return maxRadius;\n}",
    "output": "#include <bits/stdc++.h>\nint findRadius(std::vector<int> &housePositions, std::vector<int> &heaterPositions)\n{\n    std::sort(housePositions.begin(), housePositions.end());\n    std::sort(heaterPositions.begin(), heaterPositions.end());\n\n    int maxRadius= 0;\n    int heaterIndex= 0;\n\n    for(int house : housePositions)\n    {\n        while(heaterIndex < heaterPositions.size() - 1 &&\n              std::abs(heaterPositions[heaterIndex + 1] - house) <= std::abs(heaterPositions[heaterIndex] - house))\n        {\n            heaterIndex++;\n        }\n        maxRadius= std::max(maxRadius, std::abs(heaterPositions[heaterIndex] - house));\n    }\n    return maxRadius;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int findComplement(int inputNumber)\n{\n    int bitLength= 0;\n    int mask= inputNumber;\n    while(mask > 0)\n    {\n        mask>>= 1;\n        bitLength++;\n    }\n    int allOnes= (1 << bitLength) - 1;\n\n    return inputNumber ^ allOnes;\n}",
    "output": "int findComplement(int inputNumber)\n{\n    int bitLength= 0;\n    int mask= inputNumber;\n    while(mask > 0)\n    {\n        mask>>= 1;\n        bitLength++;\n    }\n    int allOnes= (1 << bitLength) - 1;\n\n    return inputNumber ^ allOnes;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateTotalHammingDistance(vector<int> &numbers)\n{\n    int totalDistance = 0, numberCount = numbers.size();\n\n    for(int bitPosition = 0; bitPosition < 32; ++bitPosition)\n    {\n        int bitCount = 0;\n        for (int i = 0; i < numberCount; ++i)\n        {\n            int number = numbers[i];\n            bitCount += (number >> bitPosition) & 1;\n        }\n        totalDistance += bitCount * (numberCount - bitCount);\n    }\n\n    return totalDistance;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateTotalHammingDistance(std::vector<int> &numbers)\n{\n    int totalDistance= 0, numberCount= numbers.size();\n\n    for(int bitPosition= 0; bitPosition < 32; ++bitPosition)\n    {\n        int bitCount= 0;\n        for(int number : numbers)\n        {\n            bitCount+= (number >> bitPosition) & 1;\n        }\n        totalDistance+= bitCount * (numberCount - bitCount);\n    }\n\n    return totalDistance;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution\n{\n  public:\n    default_random_engine randomEngine;\n    uniform_real_distribution<double> uniformDistribution;\n    double circleRadius, circleXCenter, circleYCenter;\n\n    Solution(double radius, double xCenter, double yCenter) : uniformDistribution(0, 1), circleRadius(radius), circleXCenter(xCenter), circleYCenter(yCenter) {}\n\n    vector<double> randPoint()\n    {\n        double randomRadius= sqrt(uniformDistribution(randomEngine)) * circleRadius;\n        double randomAngle= uniformDistribution(randomEngine) * 2 * M_PI;\n        return {circleXCenter + randomRadius * cos(randomAngle), circleYCenter + randomRadius * sin(randomAngle)};\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Solution\n{\n  public:\n    std::default_random_engine randomEngine;\n    std::uniform_real_distribution<double> uniformDistribution;\n    double circleRadius, circleXCenter, circleYCenter;\n\n    Solution(double radius, double xCenter, double yCenter) : uniformDistribution(0, 1), circleRadius(radius), circleXCenter(xCenter), circleYCenter(yCenter) {}\n\n    vector<double> randPoint()\n    {\n        double randomRadius= sqrt(uniformDistribution(randomEngine)) * circleRadius;\n        double randomAngle= uniformDistribution(randomEngine) * 2 * M_PI;\n        return {circleXCenter + randomRadius * cos(randomAngle), circleYCenter + randomRadius * sin(randomAngle)};\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int largestPalindrome(int numberOfDigits)\n{\n    if(numberOfDigits == 1)\n        return 9;\n    int upperLimit= pow(10, numberOfDigits) - 1;\n    int lowerLimit= upperLimit / 10;\n    for(int currentNumber= upperLimit; currentNumber > lowerLimit; --currentNumber)\n    {\n        long long temp= currentNumber;\n        long long reversedNumber= 0;\n        while(temp != 0)\n        {\n            reversedNumber= reversedNumber * 10 + temp % 10;\n            temp/= 10;\n        }\n        long long palindrome= currentNumber * pow(10, numberOfDigits) + reversedNumber;\n        for(long long factor= upperLimit; factor > lowerLimit; --factor)\n        {\n            long long product= palindrome / factor;\n            if(palindrome % factor == 0 && product <= upperLimit)\n            {\n                return palindrome % 1337;\n            }\n        }\n    }\n    return -1;\n}",
    "output": "int largestPalindrome(int numberOfDigits)\n{\n    if(numberOfDigits == 1)\n        return 9;\n    int upperLimit= pow(10, numberOfDigits) - 1;\n    int lowerLimit= upperLimit / 10;\n    for(int currentNumber= upperLimit; currentNumber > lowerLimit; --currentNumber)\n    {\n        long long temp= currentNumber;\n        long long reversedNumber= 0;\n        while(temp != 0)\n        {\n            reversedNumber= reversedNumber * 10 + temp % 10;\n            temp/= 10;\n        }\n        long long palindrome= currentNumber * pow(10, numberOfDigits) + reversedNumber;\n        for(long long factor= upperLimit; factor > lowerLimit; --factor)\n        {\n            long long product= palindrome / factor;\n            if(palindrome % factor == 0 && product <= upperLimit)\n            {\n                return palindrome % 1337;\n            }\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<double> medianSlidingWindow(vector<int> &numbers, int windowSize)\n{\n    multiset<int> slidingWindow(numbers.begin(), numbers.begin() + windowSize);\n    auto midpoint = next(slidingWindow.begin(), windowSize / 2);\n    vector<double> medians;\n\n    for(int index = windowSize;; index++)\n    {\n        medians.push_back((double(*midpoint) + *prev(midpoint, 1 - windowSize % 2)) / 2);\n\n        if(index == numbers.size())\n        {\n            return medians;\n        }\n        slidingWindow.insert(numbers[index]);\n        if(numbers[index] < *midpoint)\n        {\n            midpoint--;\n        }\n        if(numbers[index - windowSize] <= *midpoint)\n        {\n            midpoint++;\n        }\n        slidingWindow.erase(slidingWindow.lower_bound(numbers[index - windowSize]));\n    }\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<double> medianSlidingWindow(std::vector<int> &numbers, int windowSize)\n{\n    std::multiset<int> slidingWindow(numbers.begin(), numbers.begin() + windowSize);\n    auto midpoint= std::next(slidingWindow.begin(), windowSize / 2);\n    std::vector<double> medians;\n\n    for(int index= windowSize;; index++)\n    {\n        medians.push_back((double(*midpoint) + *std::prev(midpoint, 1 - windowSize % 2)) / 2);\n\n        if(index == numbers.size())\n        {\n            return medians;\n        }\n        slidingWindow.insert(numbers[index]);\n        if(numbers[index] < *midpoint)\n        {\n            midpoint--;\n        }\n        if(numbers[index - windowSize] <= *midpoint)\n        {\n            midpoint++;\n        }\n        slidingWindow.erase(slidingWindow.lower_bound(numbers[index - windowSize]));\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint magicalString(int length)\n{\n    if(length == 0)\n        return 0;\n    if(length <= 3)\n        return 1;\n\n    vector<int> magicalSequence= {1, 2, 2};\n    int countOnes= 1;\n    int currentIndex= 2;\n    int currentValue= 1;\n\n    while(magicalSequence.size() < length)\n    {\n        for(int i= 0; i < magicalSequence[currentIndex]; ++i)\n        {\n            magicalSequence.push_back(currentValue);\n            if(currentValue == 1 && magicalSequence.size() <= length)\n                countOnes++;\n        }\n        currentValue= 3 - currentValue;\n        currentIndex++;\n    }\n\n    return countOnes;\n}",
    "output": "#include <bits/stdc++.h>\nint magicalString(int length)\n{\n    if(length == 0)\n        return 0;\n    if(length <= 3)\n        return 1;\n\n    std::vector<int> magicalSequence= {1, 2, 2};\n    int countOnes= 1;\n    int currentIndex= 2;\n    int currentValue= 1;\n\n    while(magicalSequence.size() < length)\n    {\n        for(int i= 0; i < magicalSequence[currentIndex]; ++i)\n        {\n            magicalSequence.push_back(currentValue);\n            if(currentValue == 1 && magicalSequence.size() <= length)\n                countOnes++;\n        }\n        currentValue= 3 - currentValue;\n        currentIndex++;\n    }\n\n    return countOnes;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring formatLicenseKey(string licenseKey, int groupSize)\n{\n    string formattedKey= \"\";\n    int currentCount= 0;\n    for(int index= licenseKey.size() - 1; index >= 0; index--)\n    {\n        if(licenseKey[index] != '-')\n        {\n            if(currentCount == groupSize)\n            {\n                formattedKey.push_back('-');\n                currentCount= 0;\n            }\n            formattedKey.push_back(toupper(licenseKey[index]));\n            currentCount++;\n        }\n    }\n    reverse(formattedKey.begin(), formattedKey.end());\n    return formattedKey;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string formatLicenseKey(std::string licenseKey, int groupSize)\n{\n    std::string formattedKey= \"\";\n    int currentCount= 0;\n    for(int index= licenseKey.size() - 1; index >= 0; index--)\n    {\n        if(licenseKey[index] != '-')\n        {\n            if(currentCount == groupSize)\n            {\n                formattedKey.push_back('-');\n                currentCount= 0;\n            }\n            formattedKey.push_back(std::toupper(licenseKey[index]));\n            currentCount++;\n        }\n    }\n    std::reverse(formattedKey.begin(), formattedKey.end());\n    return formattedKey;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long longLong;\n\nlongLong smallestGoodBase(string numberString)\n{\n    longLong numberValue= stoll(numberString);\n\n    for(int exponent= log2(numberValue) + 1; exponent >= 1; exponent--)\n    {\n        longLong base= pow(numberValue, 1.0 / exponent);\n        longLong totalSum= 0;\n        for(int i= 0; i <= exponent; i++)\n        {\n            totalSum= totalSum * base + 1;\n        }\n        if(totalSum == numberValue)\n        {\n            return base;\n        }\n    }\n\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\ntypedef long long longLong;\n\nlongLong smallestGoodBase(std::string numberString)\n{\n    longLong numberValue = std::stoll(numberString);\n\n    for(int exponent = std::log2(numberValue) + 1; exponent >= 1; exponent--)\n    {\n        longLong base = std::pow(numberValue, 1.0 / exponent);\n        longLong totalSum = 0;\n        for(int i = 0; i <= exponent; i++)\n        {\n            totalSum = totalSum * base + 1;\n        }\n        if(totalSum == numberValue)\n        {\n            return base;\n        }\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findPermutation(string inputString)\n{\n    vector<int> permutationVector(inputString.length() + 1);\n    int nextNumber = 1;\n    for(int index = 0; index < inputString.length(); index++)\n    {\n        if(inputString[index] == 'I')\n        {\n            permutationVector[index] = nextNumber++;\n            while(index + 1 < inputString.length() && inputString[index + 1] == 'D')\n                index++;\n        }\n    }\n    permutationVector[inputString.length()] = nextNumber++;\n    for(int index = inputString.length() - 1; index >= 0; index--)\n        if(inputString[index] == 'D')\n            permutationVector[index] = nextNumber++;\n    return permutationVector;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findPermutation(std::string inputString)\n{\n    std::vector<int> permutationVector(inputString.length() + 1);\n    int nextNumber= 1;\n    for(int index= 0; index < inputString.length(); index++)\n    {\n        if(inputString[index] == 'I')\n        {\n            permutationVector[index]= nextNumber++;\n            while(index + 1 < inputString.length() && inputString[index + 1] == 'D')\n                index++;\n        }\n    }\n    permutationVector[inputString.length()]= nextNumber++;\n    for(int index= inputString.length() - 1; index >= 0; index--)\n        if(inputString[index] == 'D')\n            permutationVector[index]= nextNumber++;\n    return permutationVector;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMaxConsecutiveOnes(vector<int> &nums)\n{\n    int maxConsecutiveOnes = 0, currentConsecutiveOnes = 0;\n    for (int i = 0; i < nums.size(); ++i)\n    {\n        int currentNum = nums[i];\n        currentConsecutiveOnes = (currentNum == 1) ? currentConsecutiveOnes + 1 : 0;\n        maxConsecutiveOnes = max(maxConsecutiveOnes, currentConsecutiveOnes);\n    }\n    return maxConsecutiveOnes;\n}",
    "output": "#include <bits/stdc++.h>\nint findMaxConsecutiveOnes(std::vector<int> &nums)\n{\n    int maxConsecutiveOnes= 0, currentConsecutiveOnes= 0;\n    for(int currentNum : nums)\n    {\n        currentConsecutiveOnes= (currentNum == 1) ? currentConsecutiveOnes + 1 : 0;\n        maxConsecutiveOnes= std::max(maxConsecutiveOnes, currentConsecutiveOnes);\n    }\n    return maxConsecutiveOnes;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canWin(const vector<int> &gameScores)\n{\n    int numberOfScores = gameScores.size();\n    vector<vector<int>> scoreDifference(numberOfScores, vector<int>(numberOfScores));\n    for(int currentIndex = 0; currentIndex < numberOfScores; currentIndex++)\n    {\n        scoreDifference[currentIndex][currentIndex] = gameScores[currentIndex];\n    }\n    for(int length = 1; length < numberOfScores; length++)\n    {\n        for(int startIndex = 0; startIndex < numberOfScores - length; startIndex++)\n        {\n            int endIndex = startIndex + length;\n            scoreDifference[startIndex][endIndex] = max(gameScores[startIndex] - scoreDifference[startIndex + 1][endIndex], gameScores[endIndex] - scoreDifference[startIndex][endIndex - 1]);\n        }\n    }\n    return scoreDifference[0][numberOfScores - 1] >= 0;\n}",
    "output": "#include <bits/stdc++.h>\nbool canWin(const std::vector<int> &gameScores)\n{\n    int numberOfScores= gameScores.size();\n    std::vector<std::vector<int>> scoreDifference(numberOfScores, std::vector<int>(numberOfScores));\n    for(int currentIndex= 0; currentIndex < numberOfScores; currentIndex++)\n    {\n        scoreDifference[currentIndex][currentIndex]= gameScores[currentIndex];\n    }\n    for(int length= 1; length < numberOfScores; length++)\n    {\n        for(int startIndex= 0; startIndex < numberOfScores - length; startIndex++)\n        {\n            int endIndex= startIndex + length;\n            scoreDifference[startIndex][endIndex]= std::max(gameScores[startIndex] - scoreDifference[startIndex + 1][endIndex], gameScores[endIndex] - scoreDifference[startIndex][endIndex - 1]);\n        }\n    }\n    return scoreDifference[0][numberOfScores - 1] >= 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// for std::max\nusing namespace std;\n\nint findMaxConsecutiveOnes(vector<int> &binaryArray)\n{\n    int maxConsecutiveCount= 0, zeroCount= 0, leftIndex= 0;\n    for(int rightIndex= 0; rightIndex < binaryArray.size(); ++rightIndex)\n    {\n        if(binaryArray[rightIndex] == 0)\n            zeroCount++;\n        while(zeroCount > 1)\n        {\n            if(binaryArray[leftIndex++] == 0)\n                zeroCount--;\n        }\n        maxConsecutiveCount= max(maxConsecutiveCount, rightIndex - leftIndex + 1);\n    }\n    return maxConsecutiveCount;\n}",
    "output": "#include <bits/stdc++.h>\nint findMaxConsecutiveOnes(std::vector<int> &binaryArray)\n{\n    int maxConsecutiveCount= 0, zeroCount= 0, leftIndex= 0;\n    for(int rightIndex= 0; rightIndex < binaryArray.size(); ++rightIndex)\n    {\n        if(binaryArray[rightIndex] == 0)\n            zeroCount++;\n        while(zeroCount > 1)\n        {\n            if(binaryArray[leftIndex++] == 0)\n                zeroCount--;\n        }\n        maxConsecutiveCount= std::max(maxConsecutiveCount, rightIndex - leftIndex + 1);\n    }\n    return maxConsecutiveCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinStepHelper(string &currentBoard, unordered_map<string, int> &memoization, unordered_map<char, int> &handMap)\n{\n    if(currentBoard.empty())\n        return 0;\n    if(memoization.count(currentBoard))\n        return memoization[currentBoard];\n\n    int minimumSteps = INT_MAX;\n    for (int i = 0, j = 0; i < currentBoard.size(); i = j)\n    {\n        while (j < currentBoard.size() && currentBoard[i] == currentBoard[j])\n            ++j;\n        char color = currentBoard[i];\n        int requiredBalls = 3 - (j - i);\n        if (handMap[color] >= requiredBalls)\n        {\n            handMap[color] -= requiredBalls;\n            string nextBoard = currentBoard.substr(0, i) + currentBoard.substr(j);\n            int tempSteps = findMinStepHelper(nextBoard, memoization, handMap);\n            if (tempSteps != -1)\n                minimumSteps = min(minimumSteps, tempSteps + requiredBalls);\n            handMap[color] += requiredBalls;\n        }\n    }\n\n    memoization[currentBoard] = minimumSteps == INT_MAX ? -1 : minimumSteps;\n    return memoization[currentBoard];\n}\n\nint findMinStep(string currentBoard, string hand)\n{\n    unordered_map<char, int> handMap;\n    for (int i = 0; i < hand.size(); ++i)\n        ++handMap[hand[i]];\n    unordered_map<string, int> memoization;\n    return findMinStepHelper(currentBoard, memoization, handMap);\n}",
    "output": "#include <bits/stdc++.h>\nstd::string findMinStepHelper(std::string &currentBoard, std::unordered_map<std::string, int> &memoization, std::unordered_map<char, int> &handMap)\n{\n    if(currentBoard.empty())\n        return 0;\n    if(memoization.count(currentBoard))\n        return memoization[currentBoard];\n\n    int minimumSteps= INT_MAX;\n    for(int i= 0, j= 0; i < currentBoard.size(); i= j)\n    {\n        while(j < currentBoard.size() && currentBoard[i] == currentBoard[j])\n            ++j;\n        char color= currentBoard[i];\n        int requiredBalls= 3 - (j - i);\n        if(handMap[color] >= requiredBalls)\n        {\n            handMap[color]-= requiredBalls;\n            std::string nextBoard= currentBoard.substr(0, i) + currentBoard.substr(j);\n            int tempSteps= findMinStepHelper(nextBoard, memoization, handMap);\n            if(tempSteps != -1)\n                minimumSteps= std::min(minimumSteps, tempSteps + requiredBalls);\n            handMap[color]+= requiredBalls;\n        }\n    }\n\n    memoization[currentBoard]= minimumSteps == INT_MAX ? -1 : minimumSteps;\n    return memoization[currentBoard];\n}\n\nint findMinStep(std::string currentBoard, std::string hand)\n{\n    std::unordered_map<char, int> handMap;\n    for(char c : hand)\n        ++handMap[c];\n    std::unordered_map<std::string, int> memoization;\n    return findMinStepHelper(currentBoard, memoization, handMap);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint combination(int totalSteps, int stepsDown)\n{\n    if(stepsDown > totalSteps - stepsDown)\n        stepsDown = totalSteps - stepsDown;\n    long result = 1;\n    for(int i = 1; i <= stepsDown; i++)\n    {\n        result *= totalSteps - stepsDown + i;\n        result /= i;\n    }\n    return (int)result;\n}\n\nstring kthSmallestPath(vector<int> &destination, int k)\n{\n    int remainingRows = destination[0];\n    int remainingCols = destination[1];\n    string path;\n\n    for(int i = 0; i < remainingRows + remainingCols; i++)\n    {\n        if(remainingRows == 0)\n        {\n            path += 'H';\n            remainingCols--;\n        }\n        else if(remainingCols == 0)\n        {\n            path += 'V';\n            remainingRows--;\n        }\n        else if(k <= combination(remainingRows + remainingCols - 1, remainingRows - 1))\n        {\n            path += 'H';\n            remainingCols--;\n        }\n        else\n        {\n            path += 'V';\n            k -= combination(remainingRows + remainingCols - 1, remainingRows - 1);\n            remainingRows--;\n        }\n    }\n\n    return path;\n}",
    "output": "#include <bits/stdc++.h>\nint combination(int totalSteps, int stepsDown)\n{\n    if(stepsDown > totalSteps - stepsDown)\n        stepsDown= totalSteps - stepsDown;\n    long result= 1;\n    for(int i= 1; i <= stepsDown; i++)\n    {\n        result*= totalSteps - stepsDown + i;\n        result/= i;\n    }\n    return (int)result;\n}\n\nstd::string kthSmallestPath(std::vector<int> &destination, int k)\n{\n    int remainingRows= destination[0];\n    int remainingCols= destination[1];\n    std::string path;\n\n    for(int i= 0; i < remainingRows + remainingCols; i++)\n    {\n        if(remainingRows == 0)\n        {\n            path+= 'H';\n            remainingCols--;\n        }\n        else if(remainingCols == 0)\n        {\n            path+= 'V';\n            remainingRows--;\n        }\n        else if(k <= combination(remainingRows + remainingCols - 1, remainingRows - 1))\n        {\n            path+= 'H';\n            remainingCols--;\n        }\n        else\n        {\n            path+= 'V';\n            k-= combination(remainingRows + remainingCols - 1, remainingRows - 1);\n            remainingRows--;\n        }\n    }\n\n    return path;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool hasPath(vector<vector<int>> &maze, vector<int> &start, vector<int> &destination)\n{\n    vector<vector<int>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    queue<pair<int, int>> queue;\n    queue.push({start[0], start[1]});\n\n    while (!queue.empty())\n    {\n        auto [currentX, currentY] = queue.front();\n        queue.pop();\n        if (currentX == destination[0] && currentY == destination[1])\n            return true;\n\n        for (int i = 0; i < directions.size(); ++i)\n        {\n            int deltaX = directions[i][0];\n            int deltaY = directions[i][1];\n            int row = currentX, column = currentY;\n            while (row + deltaX >= 0 && row + deltaX < maze.size() && column + deltaY >= 0 && column + deltaY < maze[0].size() && maze[row + deltaX][column + deltaY] == 0)\n            {\n                row += deltaX, column += deltaY;\n            }\n            if (maze[row][column] == 0)\n            {\n                maze[row][column] = 1;\n                queue.push({row, column});\n            }\n        }\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool hasPath(std::vector<std::vector<int>> &maze, std::vector<int> &start, std::vector<int> &destination)\n{\n    std::vector<std::vector<int>> directions= {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::queue<std::pair<int, int>> queue;\n    queue.push({start[0], start[1]});\n\n    while(!queue.empty())\n    {\n        auto [currentX, currentY]= queue.front();\n        queue.pop();\n        if(currentX == destination[0] && currentY == destination[1])\n            return true;\n\n        for(auto [deltaX, deltaY] : directions)\n        {\n            int row= currentX, column= currentY;\n            while(row + deltaX >= 0 && row + deltaX < maze.size() && column + deltaY >= 0 && column + deltaY < maze[0].size() && maze[row + deltaX][column + deltaY] == 0)\n            {\n                row+= deltaX, column+= deltaY;\n            }\n            if(maze[row][column] == 0)\n            {\n                maze[row][column]= 1;\n                queue.push({row, column});\n            }\n        }\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> findSubsequences(vector<int> &inputNumbers)\n{\n    set<vector<int>> uniqueSubsequences;\n    vector<int> currentPath;\n    dfs(inputNumbers, 0, currentPath, uniqueSubsequences);\n    return vector<vector<int>>(uniqueSubsequences.begin(), uniqueSubsequences.end());\n}\n\nvoid dfs(vector<int> &inputNumbers, int startIndex, vector<int> &currentPath, set<vector<int>> &uniqueSubsequences)\n{\n    if(currentPath.size() >= 2)\n    {\n        uniqueSubsequences.insert(currentPath);\n    }\n    for(int i= startIndex; i < inputNumbers.size(); i++)\n    {\n        if(!currentPath.empty() && currentPath.back() > inputNumbers[i])\n        {\n            continue;\n        }\n        currentPath.push_back(inputNumbers[i]);\n        dfs(inputNumbers, i + 1, currentPath, uniqueSubsequences);\n        currentPath.pop_back();\n    }\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> findSubsequences(std::vector<int> &inputNumbers)\n{\n    std::set<std::vector<int>> uniqueSubsequences;\n    std::vector<int> currentPath;\n    dfs(inputNumbers, 0, currentPath, uniqueSubsequences);\n    return std::vector<std::vector<int>>(uniqueSubsequences.begin(), uniqueSubsequences.end());\n}\n\nvoid dfs(std::vector<int> &inputNumbers, int startIndex, std::vector<int> &currentPath, std::set<std::vector<int>> &uniqueSubsequences)\n{\n    if(currentPath.size() >= 2)\n    {\n        uniqueSubsequences.insert(currentPath);\n    }\n    for(int i= startIndex; i < inputNumbers.size(); i++)\n    {\n        if(!currentPath.empty() && currentPath.back() > inputNumbers[i])\n        {\n            continue;\n        }\n        currentPath.push_back(inputNumbers[i]);\n        dfs(inputNumbers, i + 1, currentPath, uniqueSubsequences);\n        currentPath.pop_back();\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> constructRectangle(int area)\n{\n    int width = sqrt(area);\n    while(area % width != 0)\n    {\n        width -= 1;\n    }\n    int length = area / width;\n    return {length, width};\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> constructRectangle(int area)\n{\n    int width= std::sqrt(area);\n    while(area % width != 0)\n    {\n        width-= 1;\n    }\n    int length= area / width;\n    return {length, width};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint merge(vector<int> &numbers, vector<int> &tempArray, int leftIndex, int midIndex, int rightIndex)\n{\n    int pairCount = 0;\n    int jIndex = midIndex;\n    for(int iIndex = leftIndex; iIndex < midIndex; iIndex++)\n    {\n        while(jIndex <= rightIndex && (long long)numbers[iIndex] > 2LL * numbers[jIndex])\n        {\n            jIndex++;\n        }\n        pairCount += jIndex - midIndex;\n    }\n    merge(numbers.begin() + leftIndex, numbers.begin() + midIndex, numbers.begin() + midIndex, numbers.begin() + rightIndex + 1, tempArray.begin() + leftIndex);\n\n    return pairCount;\n}\n\nint countReversePairs(vector<int> &numbers, vector<int> &tempArray, int leftIndex, int rightIndex)\n{\n    if(leftIndex >= rightIndex)\n    {\n        return 0;\n    }\n    int midIndex = leftIndex + (rightIndex - leftIndex) / 2;\n    int pairCount = countReversePairs(numbers, tempArray, leftIndex, midIndex) + countReversePairs(numbers, tempArray, midIndex + 1, rightIndex);\n    pairCount += merge(numbers, tempArray, leftIndex, midIndex + 1, rightIndex);\n    copy(tempArray.begin() + leftIndex, tempArray.begin() + rightIndex + 1, numbers.begin() + leftIndex);\n\n    return pairCount;\n}\n\nint reversePairs(vector<int> &numbers)\n{\n    vector<int> tempArray(numbers.size());\n    return countReversePairs(numbers, tempArray, 0, numbers.size() - 1);\n}",
    "output": "#include <bits/stdc++.h>\nint merge(std::vector<int> &numbers, std::vector<int> &tempArray, int leftIndex, int midIndex, int rightIndex)\n{\n    int pairCount= 0;\n    int jIndex= midIndex;\n    for(int iIndex= leftIndex; iIndex < midIndex; iIndex++)\n    {\n        while(jIndex <= rightIndex && (long long)numbers[iIndex] > 2LL * numbers[jIndex])\n        {\n            jIndex++;\n        }\n        pairCount+= jIndex - midIndex;\n    }\n    std::merge(numbers.begin() + leftIndex, numbers.begin() + midIndex, numbers.begin() + midIndex, numbers.begin() + rightIndex + 1, tempArray.begin() + leftIndex);\n\n    return pairCount;\n}\n\nint countReversePairs(std::vector<int> &numbers, std::vector<int> &tempArray, int leftIndex, int rightIndex)\n{\n    if(leftIndex >= rightIndex)\n    {\n        return 0;\n    }\n    int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n    int pairCount= countReversePairs(numbers, tempArray, leftIndex, midIndex) + countReversePairs(numbers, tempArray, midIndex + 1, rightIndex);\n    pairCount+= merge(numbers, tempArray, leftIndex, midIndex + 1, rightIndex);\n    std::copy(tempArray.begin() + leftIndex, tempArray.begin() + rightIndex + 1, numbers.begin() + leftIndex);\n\n    return pairCount;\n}\n\nint reversePairs(std::vector<int> &numbers)\n{\n    std::vector<int> tempArray(numbers.size());\n    return countReversePairs(numbers, tempArray, 0, numbers.size() - 1);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findTargetSumWays(vector<int> &numbers, int target)\n{\n    int totalSum = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n        totalSum += numbers[i];\n    \n    if (totalSum < target || (totalSum + target) % 2 != 0)\n        return 0;\n    \n    int targetSum = (totalSum + target) / 2;\n    vector<int> dynamicProgramming(targetSum + 1, 0);\n    dynamicProgramming[0] = 1;\n    \n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        for (int j = targetSum; j >= number; j--)\n        {\n            dynamicProgramming[j] += dynamicProgramming[j - number];\n        }\n    }\n    \n    return dynamicProgramming[targetSum];\n}",
    "output": "#include <bits/stdc++.h>\nint findTargetSumWays(std::vector<int> &numbers, int target)\n{\n    int totalSum= 0;\n    for(int number : numbers)\n        totalSum+= number;\n    if(totalSum < target || (totalSum + target) % 2 != 0)\n        return 0;\n    int targetSum= (totalSum + target) / 2;\n    std::vector<int> dynamicProgramming(targetSum + 1, 0);\n    dynamicProgramming[0]= 1;\n    for(int number : numbers)\n    {\n        for(int j= targetSum; j >= number; j--)\n        {\n            dynamicProgramming[j]+= dynamicProgramming[j - number];\n        }\n    }\n    return dynamicProgramming[targetSum];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findPoisonedDuration(vector<int> &timeSeries, int poisonDuration)\n{\n    if(timeSeries.empty())\n        return 0;\n    int totalPoisonedTime= 0;\n    for(int index= 1; index < timeSeries.size(); ++index)\n    {\n        totalPoisonedTime+= min(timeSeries[index] - timeSeries[index - 1], poisonDuration);\n    }\n    return totalPoisonedTime + poisonDuration;\n}",
    "output": "#include <bits/stdc++.h>\nint findPoisonedDuration(std::vector<int> &timeSeries, int poisonDuration)\n{\n    if(timeSeries.empty())\n        return 0;\n    int totalPoisonedTime= 0;\n    for(int index= 1; index < timeSeries.size(); ++index)\n    {\n        totalPoisonedTime+= std::min(timeSeries[index] - timeSeries[index - 1], poisonDuration);\n    }\n    return totalPoisonedTime + poisonDuration;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> nextGreaterElement(vector<int> &sourceArray, vector<int> &targetArray)\n{\n    unordered_map<int, int> nextGreaterMap;\n    stack<int> elementStack;\n\n    for (size_t i = 0; i < targetArray.size(); ++i)\n    {\n        int currentNumber = targetArray[i];\n        while (!elementStack.empty() && elementStack.top() < currentNumber)\n        {\n            nextGreaterMap[elementStack.top()] = currentNumber;\n            elementStack.pop();\n        }\n        elementStack.push(currentNumber);\n    }\n\n    vector<int> resultArray(sourceArray.size());\n    for (size_t index = 0; index < sourceArray.size(); ++index)\n    {\n        resultArray[index] = nextGreaterMap.count(sourceArray[index]) ? nextGreaterMap[sourceArray[index]] : -1;\n    }\n\n    return resultArray;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> nextGreaterElement(std::vector<int> &sourceArray, std::vector<int> &targetArray)\n{\n    std::unordered_map<int, int> nextGreaterMap;\n    std::stack<int> elementStack;\n\n    for(int currentNumber : targetArray)\n    {\n        while(!elementStack.empty() && elementStack.top() < currentNumber)\n        {\n            nextGreaterMap[elementStack.top()]= currentNumber;\n            elementStack.pop();\n        }\n        elementStack.push(currentNumber);\n    }\n\n    std::vector<int> resultArray(sourceArray.size());\n    for(size_t index= 0; index < sourceArray.size(); ++index)\n    {\n        resultArray[index]= nextGreaterMap.count(sourceArray[index]) ? nextGreaterMap[sourceArray[index]] : -1;\n    }\n\n    return resultArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution\n{\n    vector<vector<int>> rectangles;\n    vector<int> rectangleAreas;\n    int totalArea;\n\n  public:\n    Solution(vector<vector<int>> &rects) : rectangles(rects),\n                                             rectangleAreas(rects.size()),\n                                             totalArea(0)\n    {\n        for(int i= 0; i < rectangles.size(); ++i)\n        {\n            int area= (rectangles[i][2] - rectangles[i][0] + 1) * (rectangles[i][3] - rectangles[i][1] + 1);\n            rectangleAreas[i]= area;\n            totalArea+= area;\n        }\n    }\n\n    vector<int> pick()\n    {\n        default_random_engine generator;\n        uniform_int_distribution<int> distribution(0, totalArea - 1);\n        int randomNumber= distribution(generator);\n\n        int index= 0;\n        while(randomNumber >= rectangleAreas[index])\n        {\n            randomNumber-= rectangleAreas[index];\n            index++;\n        }\n\n        uniform_int_distribution<int> xDistribution(rectangles[index][0], rectangles[index][2]);\n        uniform_int_distribution<int> yDistribution(rectangles[index][1], rectangles[index][3]);\n\n        return {\n            xDistribution(generator),\n            yDistribution(generator)};\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Solution\n{\n    std::vector<std::vector<int>> rectangles;\n    std::vector<int> rectangleAreas;\n    int totalArea;\n\n  public:\n    Solution(std::vector<std::vector<int>> &rects) : rectangles(rects),\n                                                     rectangleAreas(rects.size()),\n                                                     totalArea(0)\n    {\n        for(int i= 0; i < rectangles.size(); ++i)\n        {\n            int area= (rectangles[i][2] - rectangles[i][0] + 1) * (rectangles[i][3] - rectangles[i][1] + 1);\n            rectangleAreas[i]= area;\n            totalArea+= area;\n        }\n    }\n\n    std::vector<int> pick()\n    {\n        std::default_random_engine generator;\n        std::uniform_int_distribution<int> distribution(0, totalArea - 1);\n        int randomNumber= distribution(generator);\n\n        int index= 0;\n        while(randomNumber >= rectangleAreas[index])\n        {\n            randomNumber-= rectangleAreas[index];\n            index++;\n        }\n\n        std::uniform_int_distribution<int> xDistribution(rectangles[index][0], rectangles[index][2]);\n        std::uniform_int_distribution<int> yDistribution(rectangles[index][1], rectangles[index][3]);\n\n        return {\n            xDistribution(generator),\n            yDistribution(generator)};\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDiagonalOrder(vector<vector<int>> &matrix)\n{\n    int rowCount= matrix.size();\n    int colCount= matrix[0].size();\n    vector<int> diagonalResult(rowCount * colCount);\n    int currentRow= 0, currentCol= 0;\n    for(int index= 0; index < rowCount * colCount; index++)\n    {\n        diagonalResult[index]= matrix[currentRow][currentCol];\n        if((currentRow + currentCol) % 2 == 0)\n        {\n            if(currentCol == colCount - 1)\n            {\n                currentRow++;\n            }\n            else if(currentRow == 0)\n            {\n                currentCol++;\n            }\n            else\n            {\n                currentRow--;\n                currentCol++;\n            }\n        }\n        else\n        {\n            if(currentRow == rowCount - 1)\n            {\n                currentCol++;\n            }\n            else if(currentCol == 0)\n            {\n                currentRow++;\n            }\n            else\n            {\n                currentRow++;\n                currentCol--;\n            }\n        }\n    }\n    return diagonalResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findDiagonalOrder(std::vector<std::vector<int>> &matrix)\n{\n    int rowCount= matrix.size();\n    int colCount= matrix[0].size();\n    std::vector<int> diagonalResult(rowCount * colCount);\n    int currentRow= 0, currentCol= 0;\n    for(int index= 0; index < rowCount * colCount; index++)\n    {\n        diagonalResult[index]= matrix[currentRow][currentCol];\n        if((currentRow + currentCol) % 2 == 0)\n        {\n            if(currentCol == colCount - 1)\n            {\n                currentRow++;\n            }\n            else if(currentRow == 0)\n            {\n                currentCol++;\n            }\n            else\n            {\n                currentRow--;\n                currentCol++;\n            }\n        }\n        else\n        {\n            if(currentRow == rowCount - 1)\n            {\n                currentCol++;\n            }\n            else if(currentCol == 0)\n            {\n                currentRow++;\n            }\n            else\n            {\n                currentRow++;\n                currentCol--;\n            }\n        }\n    }\n    return diagonalResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution\n{\n  public:\n    string findShortestWay(vector<vector<int>> &maze, vector<int> &ball, vector<int> &hole)\n    {\n        int rows = maze.size(), columns = maze[0].size();\n        vector<vector<int>> distance(rows, vector<int>(columns, INT_MAX));\n        vector<string> directions = {\"d\", \"l\", \"r\", \"u\"};\n        vector<vector<int>> directionVectors = {{1, 0}, {0, -1}, {0, 1}, {-1, 0}};\n        string result = \"\";\n        distance[ball[0]][ball[1]] = 0;\n        auto comparator = [&](const auto &pair1, const auto &pair2)\n        {\n            return pair1.first > pair2.first || (pair1.first == pair2.first && pair1.second > pair2.second);\n        };\n        priority_queue<pair<int, string>, vector<pair<int, string>>, decltype(comparator)> priorityQueue(comparator);\n        priorityQueue.push({0, \"\"});\n\n        while (!priorityQueue.empty())\n        {\n            int currentDistance = priorityQueue.top().first;\n            string currentPath = priorityQueue.top().second;\n            int x = ball[0], y = ball[1];\n            for (int i = 0; i < currentPath.size(); ++i)\n            {\n                char direction = currentPath[i];\n                if (direction == 'd')\n                    x += directionVectors[0][0];\n                if (direction == 'l')\n                    y += directionVectors[1][1];\n                if (direction == 'r')\n                    y += directionVectors[2][1];\n                if (direction == 'u')\n                    x += directionVectors[3][0];\n            }\n            priorityQueue.pop();\n            if (x == hole[0] && y == hole[1])\n                return currentPath;\n\n            for (int k = 0; k < 4; ++k)\n            {\n                int moveDistance = 0, row = x, column = y;\n                while (row >= 0 && row < rows && column >= 0 && column < columns && maze[row][column] == 0 && (row != hole[0] || column != hole[1]))\n                {\n                    row += directionVectors[k][0];\n                    column += directionVectors[k][1];\n                    ++moveDistance;\n                }\n                row -= directionVectors[k][0];\n                column -= directionVectors[k][1];\n                --moveDistance;\n\n                if (distance[x][y] + moveDistance < distance[row][column])\n                {\n                    distance[row][column] = distance[x][y] + moveDistance;\n                    priorityQueue.push({currentDistance + moveDistance, currentPath + directions[k]});\n                }\n            }\n        }\n\n        return \"impossible\";\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Solution\n{\n  public:\n    std::string findShortestWay(std::vector<std::vector<int>> &maze, std::vector<int> &ball, std::vector<int> &hole)\n    {\n        int rows = maze.size(), columns = maze[0].size();\n        std::vector<std::vector<int>> distance(rows, std::vector<int>(columns, INT_MAX));\n        std::vector<std::string> directions = {\"d\", \"l\", \"r\", \"u\"};\n        std::vector<std::vector<int>> directionVectors = {{1, 0}, {0, -1}, {0, 1}, {-1, 0}};\n        std::string result = \"\";\n        distance[ball[0]][ball[1]] = 0;\n\n        auto comparator = [&](const auto &pair1, const auto &pair2)\n        {\n            return pair1.first > pair2.first || (pair1.first == pair2.first && pair1.second > pair2.second);\n        };\n\n        std::priority_queue<std::pair<int, std::string>, std::vector<std::pair<int, std::string>>, decltype(comparator)> priorityQueue(comparator);\n        priorityQueue.push({0, \"\"});\n\n        while (!priorityQueue.empty())\n        {\n            int currentDistance = priorityQueue.top().first;\n            std::string currentPath = priorityQueue.top().second;\n            int x = ball[0], y = ball[1];\n\n            for (char direction : currentPath)\n            {\n                if (direction == 'd')\n                    x += directionVectors[0][0];\n                if (direction == 'l')\n                    y += directionVectors[1][1];\n                if (direction == 'r')\n                    y += directionVectors[2][1];\n                if (direction == 'u')\n                    x += directionVectors[3][0];\n            }\n\n            priorityQueue.pop();\n\n            if (x == hole[0] && y == hole[1])\n                return currentPath;\n\n            for (int k = 0; k < 4; ++k)\n            {\n                int moveDistance = 0, row = x, column = y;\n                while (row >= 0 && row < rows && column >= 0 && column < columns && maze[row][column] == 0 && (row != hole[0] || column != hole[1]))\n                {\n                    row += directionVectors[k][0];\n                    column += directionVectors[k][1];\n                    ++moveDistance;\n                }\n\n                row -= directionVectors[k][0];\n                column -= directionVectors[k][1];\n                --moveDistance;\n\n                if (distance[x][y] + moveDistance < distance[row][column])\n                {\n                    distance[row][column] = distance[x][y] + moveDistance;\n                    priorityQueue.push({currentDistance + moveDistance, currentPath + directions[k]});\n                }\n            }\n        }\n\n        return \"impossible\";\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> findWords(vector<string> &inputWords)\n{\n    vector<unordered_set<char>> keyboardRows = {\n        {'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'},\n        {'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l'},\n        {'z', 'x', 'c', 'v', 'b', 'n', 'm'}};\n    vector<string> validWords;\n\n    for (int i = 0; i < inputWords.size(); ++i)\n    {\n        const auto &currentWord = inputWords[i];\n        int matchingRow = -1;\n        for (int j = 0; j < 3; ++j)\n        {\n            if (keyboardRows[j].count(tolower(currentWord[0])) > 0)\n            {\n                matchingRow = j;\n                break;\n            }\n        }\n\n        bool isSingleRow = true;\n        for (int k = 0; k < currentWord.size(); ++k)\n        {\n            char currentLetter = currentWord[k];\n            if (keyboardRows[matchingRow].count(tolower(currentLetter)) == 0)\n            {\n                isSingleRow = false;\n                break;\n            }\n        }\n\n        if (isSingleRow)\n        {\n            validWords.push_back(currentWord);\n        }\n    }\n\n    return validWords;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> findWords(std::vector<std::string> &inputWords)\n{\n    std::vector<std::unordered_set<char>> keyboardRows= {\n        {'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'},\n        {'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l'},\n        {'z', 'x', 'c', 'v', 'b', 'n', 'm'}};\n    std::vector<std::string> validWords;\n\n    for(const auto &currentWord : inputWords)\n    {\n        int matchingRow= -1;\n        for(int i= 0; i < 3; ++i)\n        {\n            if(keyboardRows[i].count(tolower(currentWord[0])) > 0)\n            {\n                matchingRow= i;\n                break;\n            }\n        }\n\n        bool isSingleRow= true;\n        for(const auto &currentLetter : currentWord)\n        {\n            if(keyboardRows[matchingRow].count(tolower(currentLetter)) == 0)\n            {\n                isSingleRow= false;\n                break;\n            }\n        }\n\n        if(isSingleRow)\n        {\n            validWords.push_back(currentWord);\n        }\n    }\n\n    return validWords;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nvoid inOrder(TreeNode *currentNode, unordered_map<int, int> &valueFrequencies, int &maxFrequency)\n{\n    if(!currentNode)\n        return;\n    inOrder(currentNode->left, valueFrequencies, maxFrequency);\n    valueFrequencies[currentNode->val]++;\n    maxFrequency= max(maxFrequency, valueFrequencies[currentNode->val]);\n    inOrder(currentNode->right, valueFrequencies, maxFrequency);\n}\n\nvector<int> findMode(TreeNode *root)\n{\n    unordered_map<int, int> valueFrequencies;\n    int maxFrequency= 0;\n    inOrder(root, valueFrequencies, maxFrequency);\n    vector<int> modes;\n\n    for (auto it = valueFrequencies.begin(); it != valueFrequencies.end(); ++it)\n    {\n        if (it->second == maxFrequency)\n            modes.push_back(it->first);\n    }\n\n    return modes;\n}",
    "output": "#include <bits/stdc++.h>\nvoid inOrder(TreeNode *currentNode, std::unordered_map<int, int> &valueFrequencies, int &maxFrequency)\n{\n    if(!currentNode)\n        return;\n    inOrder(currentNode->left, valueFrequencies, maxFrequency);\n    valueFrequencies[currentNode->val]++;\n    maxFrequency= std::max(maxFrequency, valueFrequencies[currentNode->val]);\n    inOrder(currentNode->right, valueFrequencies, maxFrequency);\n}\n\nstd::vector<int> findMode(TreeNode *root)\n{\n    std::unordered_map<int, int> valueFrequencies;\n    int maxFrequency= 0;\n    inOrder(root, valueFrequencies, maxFrequency);\n    std::vector<int> modes;\n\n    for(const auto &frequency : valueFrequencies)\n    {\n        if(frequency.second == maxFrequency)\n            modes.push_back(frequency.first);\n    }\n\n    return modes;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMaximizedCapital(int numProjects, int initialCapital, vector<int> &projectProfits, vector<int> &projectCapital)\n{\n    vector<pair<int, int>> projectPool;\n\n    for(size_t projectIndex= 0; projectIndex < projectProfits.size(); projectIndex++)\n    {\n        projectPool.emplace_back(projectCapital[projectIndex], projectProfits[projectIndex]);\n    }\n\n    sort(projectPool.begin(), projectPool.end());\n\n    priority_queue<int> profitPool;\n    int currentIndex= 0;\n\n    for(int i= 0; i < numProjects; i++)\n    {\n        while(currentIndex < projectPool.size() &&\n              projectPool[currentIndex].first <= initialCapital)\n        {\n            profitPool.push(projectPool[currentIndex++].second);\n        }\n\n        if(!profitPool.empty())\n        {\n            initialCapital+= profitPool.top();\n            profitPool.pop();\n        }\n        else\n        {\n            break;\n        }\n    }\n\n    return initialCapital;\n}",
    "output": "#include <bits/stdc++.h>\nint findMaximizedCapital(int numProjects, int initialCapital, std::vector<int> &projectProfits, std::vector<int> &projectCapital)\n{\n    std::vector<std::pair<int, int>> projectPool;\n\n    for(size_t projectIndex= 0; projectIndex < projectProfits.size(); projectIndex++)\n    {\n        projectPool.emplace_back(projectCapital[projectIndex], projectProfits[projectIndex]);\n    }\n\n    std::sort(projectPool.begin(), projectPool.end());\n\n    std::priority_queue<int> profitPool;\n    int currentIndex= 0;\n\n    for(int i= 0; i < numProjects; i++)\n    {\n        while(currentIndex < projectPool.size() &&\n              projectPool[currentIndex].first <= initialCapital)\n        {\n            profitPool.push(projectPool[currentIndex++].second);\n        }\n\n        if(!profitPool.empty())\n        {\n            initialCapital+= profitPool.top();\n            profitPool.pop();\n        }\n        else\n        {\n            break;\n        }\n    }\n\n    return initialCapital;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findNextGreaterElements(vector<int> &inputNumbers)\n{\n    vector<int> nextGreaterResults(inputNumbers.size(), -1);\n    stack<int> indexStack;\n\n    for(int currentIndex= 0; currentIndex < inputNumbers.size() * 2; ++currentIndex)\n    {\n        int circularIndex= currentIndex % inputNumbers.size();\n        while(!indexStack.empty() && inputNumbers[indexStack.top()] < inputNumbers[circularIndex])\n        {\n            nextGreaterResults[indexStack.top()= inputNumbers[circularIndex];\n            indexStack.pop();\n        }\n        if(currentIndex < inputNumbers.size())\n        {\n            indexStack.push(circularIndex);\n        }\n    }\n    return nextGreaterResults;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findNextGreaterElements(std::vector<int> &inputNumbers)\n{\n    std::vector<int> nextGreaterResults(inputNumbers.size(), -1);\n    std::stack<int> indexStack;\n\n    for(int currentIndex= 0; currentIndex < inputNumbers.size() * 2; ++currentIndex)\n    {\n        int circularIndex= currentIndex % inputNumbers.size();\n        while(!indexStack.empty() && inputNumbers[indexStack.top()] < inputNumbers[circularIndex])\n        {\n            nextGreaterResults[indexStack.top()]= inputNumbers[circularIndex];\n            indexStack.pop();\n        }\n        if(currentIndex < inputNumbers.size())\n        {\n            indexStack.push(circularIndex);\n        }\n    }\n    return nextGreaterResults;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring convertToBase7(int number)\n{\n    if(number == 0)\n        return \"0\";\n    string base7Result= \"\";\n    bool isNegative= number < 0;\n    if(isNegative)\n        number*= -1;\n    while(number > 0)\n    {\n        base7Result= to_string(number % 7) + base7Result;\n        number/= 7;\n    }\n    return isNegative ? \"-\" + base7Result : base7Result;\n}",
    "output": "std::string convertToBase7(int number)\n{\n    if(number == 0)\n        return \"0\";\n    std::string base7Result= \"\";\n    bool isNegative= number < 0;\n    if(isNegative)\n        number*= -1;\n    while(number > 0)\n    {\n        base7Result= std::to_string(number % 7) + base7Result;\n        number/= 7;\n    }\n    return isNegative ? \"-\" + base7Result : base7Result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestDistance(vector<vector<int>> &maze, vector<int> &start, vector<int> &destination)\n{\n    int rows = maze.size(), columns = maze[0].size();\n    vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    vector<vector<int>> distance(rows, vector<int>(columns, -1));\n\n    queue<pair<int, int>> queue;\n\n    distance[start[0]][start[1]] = 0;\n    queue.push({start[0], start[1]});\n\n    while (!queue.empty())\n    {\n        int currentX = queue.front().first, currentY = queue.front().second;\n        queue.pop();\n\n        for (int i = 0; i < directions.size(); ++i)\n        {\n            auto direction = directions[i];\n            int newX = currentX + direction.first;\n            int newY = currentY + direction.second;\n            int stepCount = 0;\n\n            while (newX >= 0 && newX < rows && newY >= 0 && newY < columns && maze[newX][newY] == 0)\n            {\n                newX += direction.first;\n                newY += direction.second;\n                stepCount++;\n            }\n\n            newX -= direction.first;\n            newY -= direction.second;\n\n            if (distance[newX][newY] == -1 || distance[currentX][currentY] + stepCount < distance[newX][newY])\n            {\n                distance[newX][newY] = distance[currentX][currentY] + stepCount;\n                queue.push({newX, newY});\n            }\n        }\n    }\n\n    return distance[destination[0]][destination[1]];\n}",
    "output": "#include <bits/stdc++.h>\nint shortestDistance(std::vector<std::vector<int>> &maze, std::vector<int> &start, std::vector<int> &destination)\n{\n    int rows= maze.size(), columns= maze[0].size();\n    std::vector<std::pair<int, int>> directions= {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    std::vector<std::vector<int>> distance(rows, std::vector<int>(columns, -1));\n\n    std::queue<std::pair<int, int>> queue;\n\n    distance[start[0]][start[1]]= 0;\n    queue.push({start[0], start[1]});\n\n    while(!queue.empty())\n    {\n        int currentX= queue.front().first, currentY= queue.front().second;\n        queue.pop();\n\n        for(auto direction : directions)\n        {\n            int newX= currentX + direction.first;\n            int newY= currentY + direction.second;\n            int stepCount= 0;\n\n            while(newX >= 0 && newX < rows && newY >= 0 && newY < columns && maze[newX][newY] == 0)\n            {\n                newX+= direction.first;\n                newY+= direction.second;\n                stepCount++;\n            }\n\n            newX-= direction.first;\n            newY-= direction.second;\n\n            if(distance[newX][newY] == -1 || distance[currentX][currentY] + stepCount < distance[newX][newY])\n            {\n                distance[newX][newY]= distance[currentX][currentY] + stepCount;\n                queue.push({newX, newY});\n            }\n        }\n    }\n\n    return distance[destination[0]][destination[1]];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findRelativeRanks(vector<int> &scores)\n{\n    vector<int> rankIndices(scores.size());\n    for(int index= 0; index < scores.size(); ++index)\n        rankIndices[index]= index;\n    sort(rankIndices.begin(), rankIndices.end(), [&](int index1, int index2)\n              { return scores[index1] > scores[index2]; });\n    vector<int> result(scores.size());\n    for(int index= 0; index < rankIndices.size(); ++index)\n        result[rankIndices[index]]= index + 1;\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findRelativeRanks(std::vector<int> &scores)\n{\n    std::vector<int> rankIndices(scores.size());\n    for(int index= 0; index < scores.size(); ++index)\n        rankIndices[index]= index;\n    std::sort(rankIndices.begin(), rankIndices.end(), [&](int index1, int index2)\n              { return scores[index1] > scores[index2]; });\n    std::vector<int> result(scores.size());\n    for(int index= 0; index < rankIndices.size(); ++index)\n        result[rankIndices[index]]= index + 1;\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "bool checkPerfectNumber(int number)\n{\n    if(number <= 1)\n        return false;\n    int divisorSum= 1;\n    for(int divisor= 2; divisor * divisor <= number; ++divisor)\n    {\n        if(number % divisor == 0)\n        {\n            divisorSum+= divisor;\n            if(divisor * divisor != number)\n                divisorSum+= number / divisor;\n        }\n    }\n    return divisorSum == number;\n}",
    "output": "bool checkPerfectNumber(int number)\n{\n    if(number <= 1)\n        return false;\n    int divisorSum= 1;\n    for(int divisor= 2; divisor * divisor <= number; ++divisor)\n    {\n        if(number % divisor == 0)\n        {\n            divisorSum+= divisor;\n            if(divisor * divisor != number)\n                divisorSum+= number / divisor;\n        }\n    }\n    return divisorSum == number;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid calculateTreeSums(TreeNode *currentNode, map<int, int> &sumCounts, int &maxCount)\n{\n    if(!currentNode)\n        return;\n    int sum = currentNode->val + calculateTreeSums(currentNode->left, sumCounts, maxCount) + calculateTreeSums(currentNode->right, sumCounts, maxCount);\n    sumCounts[sum]++;\n    maxCount = max(maxCount, sumCounts[sum]);\n}\n\nvector<int> findFrequentTreeSum(TreeNode *rootNode)\n{\n    map<int, int> sumCounts;\n    int maxCount = 0;\n    calculateTreeSums(rootNode, sumCounts, maxCount);\n    vector<int> frequentSums;\n    \n    // Traditional for loop instead of range-based for loop\n    for (auto it = sumCounts.begin(); it != sumCounts.end(); ++it)\n    {\n        if (it->second == maxCount)\n            frequentSums.push_back(it->first);\n    }\n    return frequentSums;\n}",
    "output": "#include <bits/stdc++.h>\nvoid calculateTreeSums(TreeNode *currentNode, std::map<int, int> &sumCounts, int &maxCount)\n{\n    if(!currentNode)\n        return;\n    int sum= currentNode->val + calculateTreeSums(currentNode->left, sumCounts, maxCount) + calculateTreeSums(currentNode->right, sumCounts, maxCount);\n    sumCounts[sum]++;\n    maxCount= std::max(maxCount, sumCounts[sum]);\n}\n\nstd::vector<int> findFrequentTreeSum(TreeNode *rootNode)\n{\n    std::map<int, int> sumCounts;\n    int maxCount= 0;\n    calculateTreeSums(rootNode, sumCounts, maxCount);\n    std::vector<int> frequentSums;\n    for(const auto &sumPair : sumCounts)\n    {\n        if(sumPair.second == maxCount)\n            frequentSums.push_back(sumPair.first);\n    }\n    return frequentSums;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int fibonacci(int number)\n{\n    if(number < 2)\n    {\n        return number;\n    }\n    int previousNumber= 0, currentNumber= 1, nextNumber;\n    for(int index= 2; index <= number; ++index)\n    {\n        nextNumber= previousNumber + currentNumber;\n        previousNumber= currentNumber;\n        currentNumber= nextNumber;\n    }\n    return currentNumber;\n}",
    "output": "int fibonacci(int number)\n{\n    if(number < 2)\n    {\n        return number;\n    }\n    int previousNumber= 0, currentNumber= 1, nextNumber;\n    for(int index= 2; index <= number; ++index)\n    {\n        nextNumber= previousNumber + currentNumber;\n        previousNumber= currentNumber;\n        currentNumber= nextNumber;\n    }\n    return currentNumber;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode *parentNode;\n};\n\nTreeNode *inorderSuccessor(TreeNode *currentNode)\n{\n    if(currentNode->rightChild)\n    {\n        currentNode= currentNode->rightChild;\n        while(currentNode->leftChild)\n        {\n            currentNode= currentNode->leftChild;\n        }\n        return currentNode;\n    }\n    while(currentNode->parentNode && currentNode == currentNode->parentNode->rightChild)\n    {\n        currentNode= currentNode->parentNode;\n    }\n    return currentNode->parentNode;\n}",
    "output": "class TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode *parentNode;\n};\n\nTreeNode *inorderSuccessor(TreeNode *currentNode)\n{\n    if(currentNode->rightChild)\n    {\n        currentNode= currentNode->rightChild;\n        while(currentNode->leftChild)\n        {\n            currentNode= currentNode->leftChild;\n        }\n        return currentNode;\n    }\n    while(currentNode->parentNode && currentNode == currentNode->parentNode->rightChild)\n    {\n        currentNode= currentNode->parentNode;\n    }\n    return currentNode->parentNode;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int findBottomLeftValue(TreeNode *root)\n{\n    int bottomLeftValue= 0, currentMaxDepth= 0;\n    findBottomLeftValueHelper(root, 1, currentMaxDepth, bottomLeftValue);\n    return bottomLeftValue;\n}\n\nvoid findBottomLeftValueHelper(TreeNode *currentNode, int currentDepth, int &currentMaxDepth, int &bottomLeftValue)\n{\n    if(!currentNode)\n        return;\n    if(currentDepth > currentMaxDepth)\n    {\n        currentMaxDepth= currentDepth;\n        bottomLeftValue= currentNode->val;\n    }\n    findBottomLeftValueHelper(currentNode->left, currentDepth + 1, currentMaxDepth, bottomLeftValue);\n    findBottomLeftValueHelper(currentNode->right, currentDepth + 1, currentMaxDepth, bottomLeftValue);\n}",
    "output": "int findBottomLeftValue(TreeNode *root)\n{\n    int bottomLeftValue= 0, currentMaxDepth= 0;\n    findBottomLeftValueHelper(root, 1, currentMaxDepth, bottomLeftValue);\n    return bottomLeftValue;\n}\n\nvoid findBottomLeftValueHelper(TreeNode *currentNode, int currentDepth, int &currentMaxDepth, int &bottomLeftValue)\n{\n    if(!currentNode)\n        return;\n    if(currentDepth > currentMaxDepth)\n    {\n        currentMaxDepth= currentDepth;\n        bottomLeftValue= currentNode->val;\n    }\n    findBottomLeftValueHelper(currentNode->left, currentDepth + 1, currentMaxDepth, bottomLeftValue);\n    findBottomLeftValueHelper(currentNode->right, currentDepth + 1, currentMaxDepth, bottomLeftValue);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findRotateSteps(string ring, string key)\n{\n    int ringSize = ring.size(), keySize = key.size();\n    vector<vector<int>> dynamicProgramming(keySize + 1, vector<int>(ringSize, 0));\n\n    for(int keyIndex = keySize - 1; keyIndex >= 0; --keyIndex)\n    {\n        for(int ringIndex = 0; ringIndex < ringSize; ++ringIndex)\n        {\n            dynamicProgramming[keyIndex][ringIndex] = INT_MAX;\n            for(int positionIndex = 0; positionIndex < ringSize; ++positionIndex)\n            {\n                if(ring[positionIndex] == key[keyIndex])\n                {\n                    int difference = abs(ringIndex - positionIndex);\n                    int step = min(difference, ringSize - difference);\n                    dynamicProgramming[keyIndex][ringIndex] = min(dynamicProgramming[keyIndex][ringIndex], step + dynamicProgramming[keyIndex + 1][positionIndex]);\n                }\n            }\n        }\n    }\n\n    return dynamicProgramming[0][0] + keySize;\n}",
    "output": "#include <bits/stdc++.h>\nint findRotateSteps(std::string ring, std::string key)\n{\n    int ringSize= ring.size(), keySize= key.size();\n    std::vector<std::vector<int>> dynamicProgramming(keySize + 1, std::vector<int>(ringSize, 0));\n\n    for(int keyIndex= keySize - 1; keyIndex >= 0; --keyIndex)\n    {\n        for(int ringIndex= 0; ringIndex < ringSize; ++ringIndex)\n        {\n            dynamicProgramming[keyIndex][ringIndex]= INT_MAX;\n            for(int positionIndex= 0; positionIndex < ringSize; ++positionIndex)\n            {\n                if(ring[positionIndex] == key[keyIndex])\n                {\n                    int difference= abs(ringIndex - positionIndex);\n                    int step= std::min(difference, ringSize - difference);\n                    dynamicProgramming[keyIndex][ringIndex]= std::min(dynamicProgramming[keyIndex][ringIndex], step + dynamicProgramming[keyIndex + 1][positionIndex]);\n                }\n            }\n        }\n    }\n\n    return dynamicProgramming[0][0] + keySize;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nvector<int> findLargestValues(TreeNode *rootNode)\n{\n    if(!rootNode)\n        return {};\n    vector<int> largestValues;\n    queue<TreeNode *> nodeQueue;\n    nodeQueue.push(rootNode);\n\n    while(!nodeQueue.empty())\n    {\n        int levelSize= nodeQueue.size();\n        int maximumValue= INT_MIN;\n        for(int i= 0; i < levelSize; ++i)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n            maximumValue= max(maximumValue, currentNode->value);\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n        largestValues.push_back(maximumValue);\n    }\n    return largestValues;\n}",
    "output": "#include <bits/stdc++.h>\n// For INT_MIN\n // For std::max\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nstd::vector<int> findLargestValues(TreeNode *rootNode)\n{\n    if(!rootNode)\n        return {};\n    std::vector<int> largestValues;\n    std::queue<TreeNode *> nodeQueue;\n    nodeQueue.push(rootNode);\n\n    while(!nodeQueue.empty())\n    {\n        int levelSize= nodeQueue.size();\n        int maximumValue= std::numeric_limits<int>::min(); // Use std::numeric_limits for INT_MIN\n        for(int i= 0; i < levelSize; ++i)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n            maximumValue= std::max(maximumValue, currentNode->value);\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n        largestValues.push_back(maximumValue);\n    }\n    return largestValues;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint longestPalindromeSubseq(string inputString)\n{\n    int stringLength= inputString.size();\n    vector<vector<int>> palindromeDP(stringLength, vector<int>(stringLength, 0));\n    for(int startIndex= stringLength - 1; startIndex >= 0; startIndex--)\n    {\n        palindromeDP[startIndex][startIndex]= 1;\n        for(int endIndex= startIndex + 1; endIndex < stringLength; endIndex++)\n        {\n            if(inputString[startIndex] == inputString[endIndex])\n            {\n                palindromeDP[startIndex][endIndex]= 2 + palindromeDP[startIndex + 1][endIndex - 1];\n            }\n            else\n            {\n                palindromeDP[startIndex][endIndex]= max(palindromeDP[startIndex + 1][endIndex], palindromeDP[startIndex][endIndex - 1]);\n            }\n        }\n    }\n    return palindromeDP[0][stringLength - 1];\n}",
    "output": "#include <bits/stdc++.h>\nint longestPalindromeSubseq(std::string inputString)\n{\n    int stringLength = inputString.size();\n    std::vector<std::vector<int>> palindromeDP(stringLength, std::vector<int>(stringLength, 0));\n    for(int startIndex = stringLength - 1; startIndex >= 0; startIndex--)\n    {\n        palindromeDP[startIndex][startIndex] = 1;\n        for(int endIndex = startIndex + 1; endIndex < stringLength; endIndex++)\n        {\n            if(inputString[startIndex] == inputString[endIndex])\n            {\n                palindromeDP[startIndex][endIndex] = 2 + palindromeDP[startIndex + 1][endIndex - 1];\n            }\n            else\n            {\n                palindromeDP[startIndex][endIndex] = std::max(palindromeDP[startIndex + 1][endIndex], palindromeDP[startIndex][endIndex - 1]);\n            }\n        }\n    }\n    return palindromeDP[0][stringLength - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinMoves(vector<int> &machineDresses)\n{\n    int machineCount= machineDresses.size();\n    int totalDresses= accumulate(machineDresses.begin(), machineDresses.end(), 0);\n    if(totalDresses % machineCount != 0)\n        return -1;\n    int averageDresses= totalDresses / machineCount;\n    int totalMoves= 0, imbalance= 0;\n\n    for(int i= 0; i < machineCount; i++)\n    {\n        imbalance+= machineDresses[i] - averageDresses;\n        totalMoves= max(totalMoves, max(abs(imbalance), machineDresses[i] - averageDresses));\n    }\n\n    return totalMoves;\n}",
    "output": "#include <bits/stdc++.h>\nint findMinMoves(std::vector<int> &machineDresses)\n{\n    int machineCount= machineDresses.size();\n    int totalDresses= std::accumulate(machineDresses.begin(), machineDresses.end(), 0);\n    if(totalDresses % machineCount != 0)\n        return -1;\n    int averageDresses= totalDresses / machineCount;\n    int totalMoves= 0, imbalance= 0;\n\n    for(int i= 0; i < machineCount; i++)\n    {\n        imbalance+= machineDresses[i] - averageDresses;\n        totalMoves= std::max(totalMoves, std::max(abs(imbalance), machineDresses[i] - averageDresses));\n    }\n\n    return totalMoves;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint changeCoinCombinations(int targetAmount, vector<int> &coinDenominations)\n{\n    vector<int> waysToMakeChange(targetAmount + 1, 0);\n    waysToMakeChange[0] = 1;\n    for (int i = 0; i < coinDenominations.size(); ++i)\n    {\n        int coin = coinDenominations[i];\n        for (int currentAmount = coin; currentAmount <= targetAmount; currentAmount++)\n        {\n            waysToMakeChange[currentAmount] += waysToMakeChange[currentAmount - coin];\n        }\n    }\n    return waysToMakeChange[targetAmount];\n}",
    "output": "#include <bits/stdc++.h>\nint changeCoinCombinations(int targetAmount, std::vector<int> &coinDenominations)\n{\n    std::vector<int> waysToMakeChange(targetAmount + 1, 0);\n    waysToMakeChange[0] = 1;\n    for(int coin : coinDenominations)\n    {\n        for(int currentAmount = coin; currentAmount <= targetAmount; currentAmount++)\n        {\n            waysToMakeChange[currentAmount] += waysToMakeChange[currentAmount - coin];\n        }\n    }\n    return waysToMakeChange[targetAmount];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution\n{\n    int rowCount, columnCount;\n    int remainingCells;\n    vector<vector<int>> cellMatrix;\n\n  public:\n    Solution(int m, int n) : rowCount(m), columnCount(n), remainingCells(m * n)\n    {\n        cellMatrix = vector<vector<int>>(m, vector<int>(n, 0));\n    }\n\n    vector<int> flip()\n    {\n        int randomIndex = rand() % remainingCells;\n        remainingCells--;\n\n        for(int i = 0; i < rowCount; ++i)\n        {\n            for(int j = 0; j < columnCount; ++j)\n            {\n                if(cellMatrix[i][j] == 0)\n                {\n                    if(randomIndex == 0)\n                    {\n                        cellMatrix[i][j] = 1;\n                        return {i, j};\n                    }\n                    randomIndex--;\n                }\n            }\n        }\n        return {-1, -1}; // This line should never be reached\n    }\n\n    void reset()\n    {\n        remainingCells = rowCount * columnCount;\n        for(int i = 0; i < rowCount; ++i) // Changed to traditional for loop\n        {\n            for(int j = 0; j < columnCount; ++j) // Changed to traditional for loop\n            {\n                cellMatrix[i][j] = 0;\n            }\n        }\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Solution\n{\n    int rowCount, columnCount;\n    int remainingCells;\n    std::vector<std::vector<int>> cellMatrix;\n\n  public:\n    Solution(int m, int n) : rowCount(m), columnCount(n), remainingCells(m * n)\n    {\n        cellMatrix= std::vector<std::vector<int>>(m, std::vector<int>(n, 0));\n    }\n\n    std::vector<int> flip()\n    {\n        int randomIndex= rand() % remainingCells;\n        remainingCells--;\n\n        for(int i= 0; i < rowCount; ++i)\n        {\n            for(int j= 0; j < columnCount; ++j)\n            {\n                if(cellMatrix[i][j] == 0)\n                {\n                    if(randomIndex == 0)\n                    {\n                        cellMatrix[i][j]= 1;\n                        return {i, j};\n                    }\n                    randomIndex--;\n                }\n            }\n        }\n        return {-1, -1}; // This line should never be reached\n    }\n\n    void reset()\n    {\n        remainingCells= rowCount * columnCount;\n        for(auto &row : cellMatrix)\n        {\n            std::fill(row.begin(), row.end(), 0);\n        }\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool detectCapitalUse(string word)\n{\n    int capitalCount = 0;\n    for (int i = 0; i < word.size(); ++i)\n    {\n        char character = word[i];\n        if (isupper(character))\n            capitalCount++;\n    }\n    return capitalCount == 0 || capitalCount == word.size() || (capitalCount == 1 && isupper(word[0]));\n}",
    "output": "#include <bits/stdc++.h>\nbool detectCapitalUse(std::string word)\n{\n    int capitalCount= 0;\n    for(char character : word)\n    {\n        if(std::isupper(character))\n            capitalCount++;\n    }\n    return capitalCount == 0 || capitalCount == word.size() || (capitalCount == 1 && std::isupper(word[0]));\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findLusLength(string firstString, string secondString)\n{\n    if(firstString == secondString)\n    {\n        return -1;\n    }\n    return max(firstString.length(), secondString.length());\n}",
    "output": "#include <bits/stdc++.h>\nint findLusLength(std::string firstString, std::string secondString)\n{\n    if(firstString == secondString)\n    {\n        return -1;\n    }\n    return std::max(firstString.length(), secondString.length());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findLusLength(vector<string> &stringList)\n{\n    int maximumLength= -1;\n    for(int currentIndex= 0; currentIndex < stringList.size(); ++currentIndex)\n    {\n        bool isUncommon= true;\n        for(int comparisonIndex= 0; comparisonIndex < stringList.size(); ++comparisonIndex)\n        {\n            if(currentIndex != comparisonIndex && search(stringList[comparisonIndex].begin(), stringList[comparisonIndex].end(), stringList[currentIndex].begin(), stringList[currentIndex].end()) != stringList[comparisonIndex].end())\n            {\n                isUncommon= false;\n                break;\n            }\n        }\n        if(isUncommon)\n        {\n            maximumLength= max(maximumLength, static_cast<int>(stringList[currentIndex].length()));\n        }\n    }\n    return maximumLength;\n}",
    "output": "#include <bits/stdc++.h>\nint findLusLength(std::vector<std::string> &stringList)\n{\n    int maximumLength= -1;\n    for(int currentIndex= 0; currentIndex < stringList.size(); ++currentIndex)\n    {\n        bool isUncommon= true;\n        for(int comparisonIndex= 0; comparisonIndex < stringList.size(); ++comparisonIndex)\n        {\n            if(currentIndex != comparisonIndex && std::search(stringList[comparisonIndex].begin(), stringList[comparisonIndex].end(), stringList[currentIndex].begin(), stringList[currentIndex].end()) != stringList[comparisonIndex].end())\n            {\n                isUncommon= false;\n                break;\n            }\n        }\n        if(isUncommon)\n        {\n            maximumLength= std::max(maximumLength, static_cast<int>(stringList[currentIndex].length()));\n        }\n    }\n    return maximumLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool checkSubarraySum(vector<int> &numbers, int divisor)\n{\n    int size = numbers.size(), cumulativeSum = 0;\n    unordered_map<int, int> sumIndexMap;\n    sumIndexMap[0] = -1;\n    for(int currentIndex = 0; currentIndex < size; ++currentIndex)\n    {\n        cumulativeSum += numbers[currentIndex];\n        if(divisor != 0)\n            cumulativeSum %= divisor;\n        if(sumIndexMap.count(cumulativeSum))\n        {\n            if(currentIndex - sumIndexMap[cumulativeSum] > 1)\n                return true;\n        }\n        else\n        {\n            sumIndexMap[cumulativeSum] = currentIndex;\n        }\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool checkSubarraySum(std::vector<int> &numbers, int divisor)\n{\n    int size= numbers.size(), cumulativeSum= 0;\n    std::unordered_map<int, int> sumIndexMap;\n    sumIndexMap[0]= -1;\n    for(int currentIndex= 0; currentIndex < size; ++currentIndex)\n    {\n        cumulativeSum+= numbers[currentIndex];\n        if(divisor != 0)\n            cumulativeSum%= divisor;\n        if(sumIndexMap.count(cumulativeSum))\n        {\n            if(currentIndex - sumIndexMap[cumulativeSum] > 1)\n                return true;\n        }\n        else\n        {\n            sumIndexMap[cumulativeSum]= currentIndex;\n        }\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isSubsequence(const string &sourceString, const string &targetWord)\n{\n    int sourceIndex = 0, targetIndex = 0;\n    while(sourceIndex < sourceString.size() && targetIndex < targetWord.size())\n    {\n        if(sourceString[sourceIndex] == targetWord[targetIndex])\n        {\n            targetIndex++;\n        }\n        sourceIndex++;\n    }\n    return targetIndex == targetWord.size();\n}\n\nstring findLongestWord(string source, vector<string> &dictionary)\n{\n    string longestWord = \"\";\n    sort(dictionary.begin(), dictionary.end());\n    for (int i = 0; i < dictionary.size(); ++i)\n    {\n        const string &target = dictionary[i];\n        if(isSubsequence(source, target))\n        {\n            if(target.size() > longestWord.size())\n            {\n                longestWord = target;\n            }\n        }\n    }\n    return longestWord;\n}",
    "output": "#include <bits/stdc++.h>\nbool isSubsequence(const std::string &sourceString, const std::string &targetWord)\n{\n    int sourceIndex= 0, targetIndex= 0;\n    while(sourceIndex < sourceString.size() && targetIndex < targetWord.size())\n    {\n        if(sourceString[sourceIndex] == targetWord[targetIndex])\n        {\n            targetIndex++;\n        }\n        sourceIndex++;\n    }\n    return targetIndex == targetWord.size();\n}\n\nstd::string findLongestWord(std::string source, std::vector<std::string> &dictionary)\n{\n    std::string longestWord= \"\";\n    std::sort(dictionary.begin(), dictionary.end());\n    for(const std::string &target : dictionary)\n    {\n        if(isSubsequence(source, target))\n        {\n            if(target.size() > longestWord.size())\n            {\n                longestWord= target;\n            }\n        }\n    }\n    return longestWord;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMaxLength(vector<int> &numberArray)\n{\n    unordered_map<int, int> countMap;\n    countMap[0]= -1;\n    int maxLength= 0, runningCount= 0;\n\n    for(int index= 0; index < numberArray.size(); index++)\n    {\n        runningCount+= (numberArray[index] == 1) ? 1 : -1;\n        if(countMap.count(runningCount))\n            maxLength= max(maxLength, index - countMap[runningCount]);\n        else\n            countMap[runningCount]= index;\n    }\n\n    return maxLength;\n}",
    "output": "#include <bits/stdc++.h>\nint findMaxLength(std::vector<int> &numberArray)\n{\n    std::unordered_map<int, int> countMap;\n    countMap[0]= -1;\n    int maxLength= 0, runningCount= 0;\n\n    for(int index= 0; index < numberArray.size(); index++)\n    {\n        runningCount+= (numberArray[index] == 1) ? 1 : -1;\n        if(countMap.count(runningCount))\n            maxLength= std::max(maxLength, index - countMap[runningCount]);\n        else\n            countMap[runningCount]= index;\n    }\n\n    return maxLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countArrangement(int totalNumbers)\n{\n    int arrangementCount= 0;\n    vector<bool> isVisited(totalNumbers + 1, false);\n    helper(totalNumbers, 1, isVisited, arrangementCount);\n    return arrangementCount;\n}\n\nvoid helper(int totalNumbers, int currentIndex, vector<bool> &isVisited, int &arrangementCount)\n{\n    if(currentIndex > totalNumbers)\n    {\n        ++arrangementCount;\n    }\n\n    for(int i= 1; i <= totalNumbers; i++)\n    {\n        if(!isVisited[i] && (currentIndex % i == 0 || i % currentIndex == 0))\n        {\n            isVisited[i]= true;\n            helper(totalNumbers, currentIndex + 1, isVisited, arrangementCount);\n            isVisited[i]= false;\n        }\n    }\n}",
    "output": "#include <bits/stdc++.h>\nint countArrangement(int totalNumbers)\n{\n    int arrangementCount= 0;\n    std::vector<bool> isVisited(totalNumbers + 1, false);\n    helper(totalNumbers, 1, isVisited, arrangementCount);\n    return arrangementCount;\n}\n\nvoid helper(int totalNumbers, int currentIndex, std::vector<bool> &isVisited, int &arrangementCount)\n{\n    if(currentIndex > totalNumbers)\n    {\n        ++arrangementCount;\n    }\n\n    for(int i= 1; i <= totalNumbers; i++)\n    {\n        if(!isVisited[i] && (currentIndex % i == 0 || i % currentIndex == 0))\n        {\n            isVisited[i]= true;\n            helper(totalNumbers, currentIndex + 1, isVisited, arrangementCount);\n            isVisited[i]= false;\n        }\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring abbreviate(const string &originalWord, int prefixLength)\n{\n    int wordLength = originalWord.length();\n    if(prefixLength >= wordLength - 2)\n    {\n        return originalWord;\n    }\n    return originalWord.substr(0, prefixLength + 1) + to_string(wordLength - prefixLength - 2) + originalWord.back();\n}\n\nvector<string> wordsAbbreviation(vector<string> &words)\n{\n    int totalWords = words.size();\n    vector<string> abbreviatedWords;\n    vector<int> currentPrefixLength(totalWords, 1);\n\n    for(int i = 0; i < totalWords; ++i)\n    {\n        abbreviatedWords.push_back(abbreviate(words[i], 1));\n    }\n\n    for(int i = 0; i < totalWords; ++i)\n    {\n        while(true)\n        {\n            unordered_map<string, vector<int>> groups;\n            for(int j = i + 1; j < totalWords; ++j)\n            {\n                if(abbreviatedWords[i] == abbreviatedWords[j])\n                {\n                    groups[abbreviatedWords[j]].push_back(j);\n                }\n            }\n            if(groups.empty())\n            {\n                break;\n            }\n            for(const auto &group : groups)\n            {\n                for(int id : group.second)\n                {\n                    abbreviatedWords[id] = abbreviate(words[id], ++currentPrefixLength[id]);\n                }\n            }\n            abbreviatedWords[i] = abbreviate(words[i], ++currentPrefixLength[i]);\n        }\n    }\n\n    return abbreviatedWords;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string abbreviate(const std::string &originalWord, int prefixLength)\n{\n    int wordLength= originalWord.length();\n    if(prefixLength >= wordLength - 2)\n    {\n        return originalWord;\n    }\n    return originalWord.substr(0, prefixLength + 1) + std::to_string(wordLength - prefixLength - 2) + originalWord.back();\n}\n\nstd::vector<std::string> wordsAbbreviation(std::vector<std::string> &words)\n{\n    int totalWords= words.size();\n    std::vector<std::string> abbreviatedWords;\n    std::vector<int> currentPrefixLength(totalWords, 1);\n\n    for(int i= 0; i < totalWords; ++i)\n    {\n        abbreviatedWords.push_back(abbreviate(words[i], 1));\n    }\n\n    for(int i= 0; i < totalWords; ++i)\n    {\n        while(true)\n        {\n            std::unordered_map<std::string, std::vector<int>> groups;\n            for(int j= i + 1; j < totalWords; ++j)\n            {\n                if(abbreviatedWords[i] == abbreviatedWords[j])\n                {\n                    groups[abbreviatedWords[j]].push_back(j);\n                }\n            }\n            if(groups.empty())\n            {\n                break;\n            }\n            for(const auto &group : groups)\n            {\n                for(int id : group.second)\n                {\n                    abbreviatedWords[id]= abbreviate(words[id], ++currentPrefixLength[id]);\n                }\n            }\n            abbreviatedWords[i]= abbreviate(words[i], ++currentPrefixLength[i]);\n        }\n    }\n\n    return abbreviatedWords;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *swapNodes(ListNode *head, int k)\n{\n    ListNode *firstNode = head, *secondNode = head, *tempNode = head;\n    for(int i = 0; i < k - 1; i++)\n    {\n        tempNode = tempNode->next;\n    }\n    firstNode = tempNode;\n    tempNode = tempNode->next;\n    while(tempNode)\n    {\n        tempNode = tempNode->next;\n        secondNode = secondNode->next;\n    }\n    swap(firstNode->value, secondNode->value);\n    return head;\n}",
    "output": "#include <bits/stdc++.h>\nstruct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *swapNodes(ListNode *head, int k)\n{\n    ListNode *firstNode= head, *secondNode= head, *tempNode= head;\n    for(int i= 0; i < k - 1; i++)\n    {\n        tempNode= tempNode->next;\n    }\n    firstNode= tempNode;\n    tempNode= tempNode->next;\n    while(tempNode)\n    {\n        tempNode= tempNode->next;\n        secondNode= secondNode->next;\n    }\n    std::swap(firstNode->value, secondNode->value);\n    return head;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid reveal(vector<vector<char>> &gameBoard, int currentRow, int currentCol, vector<vector<int>> &directionVectors)\n{\n    if(currentRow < 0 || currentRow >= gameBoard.size() || currentCol < 0 || currentCol >= gameBoard[0].size() || gameBoard[currentRow][currentCol] != 'E')\n        return;\n\n    int mineCount = 0;\n    for (int i = 0; i < directionVectors.size(); ++i)\n    {\n        int newRow = currentRow + directionVectors[i][0], newCol = currentCol + directionVectors[i][1];\n        if (newRow >= 0 && newRow < gameBoard.size() && newCol >= 0 && newCol < gameBoard[0].size() && gameBoard[newRow][newCol] == 'M')\n            mineCount++;\n    }\n\n    if(mineCount > 0)\n    {\n        gameBoard[currentRow][currentCol] = '0' + mineCount;\n    }\n    else\n    {\n        gameBoard[currentRow][currentCol] = 'B';\n        for (int i = 0; i < directionVectors.size(); ++i)\n        {\n            reveal(gameBoard, currentRow + directionVectors[i][0], currentCol + directionVectors[i][1], directionVectors);\n        }\n    }\n}\n\nvector<vector<char>> updateBoard(vector<vector<char>> &gameBoard, vector<int> &clickPosition)\n{\n    int row = clickPosition[0], col = clickPosition[1];\n\n    ...\n}",
    "output": "#include <bits/stdc++.h>\nvoid reveal(std::vector<std::vector<char>> &gameBoard, int currentRow, int currentCol, std::vector<std::vector<int>> &directionVectors)\n{\n    if(currentRow < 0 || currentRow >= gameBoard.size() || currentCol < 0 || currentCol >= gameBoard[0].size() || gameBoard[currentRow][currentCol] != 'E')\n        return;\n\n    int mineCount= 0;\n    for(auto &direction : directionVectors)\n    {\n        int newRow= currentRow + direction[0], newCol= currentCol + direction[1];\n        if(newRow >= 0 && newRow < gameBoard.size() && newCol >= 0 && newCol < gameBoard[0].size() && gameBoard[newRow][newCol] == 'M')\n            mineCount++;\n    }\n\n    if(mineCount > 0)\n    {\n        gameBoard[currentRow][currentCol]= '0' + mineCount;\n    }\n    else\n    {\n        gameBoard[currentRow][currentCol]= 'B';\n        for(auto &direction : directionVectors)\n        {\n            reveal(gameBoard, currentRow + direction[0], currentCol + direction[1], directionVectors);\n        }\n    }\n}\n\nstd::vector<std::vector<char>> updateBoard(std::vector<std::vector<char>> &gameBoard, std::vector<int> &clickPosition)\n{\n    int row= clickPosition[0], col= clickPosition[1];\n\n    ...\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    int getMinimumDifference(TreeNode *rootNode)\n    {\n        int minimumDifferenceResult = INT_MAX, previousValue = -1;\n        calculateMinimumDifference(rootNode, minimumDifferenceResult, previousValue);\n        return minimumDifferenceResult;\n    }\n\n    void calculateMinimumDifference(TreeNode *currentNode, int &minimumDifferenceResult, int &previousValue)\n    {\n        if (!currentNode)\n            return;\n        calculateMinimumDifference(currentNode->leftChild, minimumDifferenceResult, previousValue);\n        if (previousValue != -1)\n        {\n            minimumDifferenceResult = min(minimumDifferenceResult, currentNode->value - previousValue);\n        }\n        previousValue = currentNode->value;\n        calculateMinimumDifference(currentNode->rightChild, minimumDifferenceResult, previousValue);\n    }\n};",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    int getMinimumDifference(TreeNode *rootNode)\n    {\n        int minimumDifferenceResult= INT_MAX, previousValue= -1;\n        calculateMinimumDifference(rootNode, minimumDifferenceResult, previousValue);\n        return minimumDifferenceResult;\n    }\n\n    void calculateMinimumDifference(TreeNode *currentNode, int &minimumDifferenceResult, int &previousValue)\n    {\n        if(!currentNode)\n            return;\n        calculateMinimumDifference(currentNode->leftChild, minimumDifferenceResult, previousValue);\n        if(previousValue != -1)\n        {\n            minimumDifferenceResult= std::min(minimumDifferenceResult, currentNode->value - previousValue);\n        }\n        previousValue= currentNode->value;\n        calculateMinimumDifference(currentNode->rightChild, minimumDifferenceResult, previousValue);\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findLonelyPixel(vector<vector<char>> &picture)\n{\n    int rows= picture.size(), columns= picture[0].size();\n    vector<int> rowCount(rows, 0), columnCount(columns, 0);\n\n    for(int rowIndex= 0; rowIndex < rows; ++rowIndex)\n    {\n        for(int columnIndex= 0; columnIndex < columns; ++columnIndex)\n        {\n            if(picture[rowIndex][columnIndex] == 'B')\n            {\n                rowCount[rowIndex]++;\n                columnCount[columnIndex]++;\n            }\n        }\n    }\n\n    int lonelyPixelCount= 0;\n    for(int rowIndex= 0; rowIndex < rows; ++rowIndex)\n    {\n        for(int columnIndex= 0; columnIndex < columns; ++columnIndex)\n        {\n            if(picture[rowIndex][columnIndex] == 'B' && rowCount[rowIndex] == 1 && columnCount[columnIndex] == 1)\n            {\n                lonelyPixelCount++;\n            }\n        }\n    }\n\n    return lonelyPixelCount;\n}",
    "output": "#include <bits/stdc++.h>\nint findLonelyPixel(std::vector<std::vector<char>> &picture)\n{\n    int rows= picture.size(), columns= picture[0].size();\n    std::vector<int> rowCount(rows, 0), columnCount(columns, 0);\n\n    for(int rowIndex= 0; rowIndex < rows; ++rowIndex)\n    {\n        for(int columnIndex= 0; columnIndex < columns; ++columnIndex)\n        {\n            if(picture[rowIndex][columnIndex] == 'B')\n            {\n                rowCount[rowIndex]++;\n                columnCount[columnIndex]++;\n            }\n        }\n    }\n\n    int lonelyPixelCount= 0;\n    for(int rowIndex= 0; rowIndex < rows; ++rowIndex)\n    {\n        for(int columnIndex= 0; columnIndex < columns; ++columnIndex)\n        {\n            if(picture[rowIndex][columnIndex] == 'B' && rowCount[rowIndex] == 1 && columnCount[columnIndex] == 1)\n            {\n                lonelyPixelCount++;\n            }\n        }\n    }\n\n    return lonelyPixelCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findPairs(vector<int> &numberList, int difference)\n{\n    if(difference < 0)\n        return 0;\n    unordered_set<int> uniquePairs;\n    unordered_map<int, int> numberOccurrences;\n    for (int i = 0; i < numberList.size(); ++i)\n    {\n        int currentNumber = numberList[i];\n        if(numberOccurrences.count(currentNumber + difference))\n            uniquePairs.insert(currentNumber);\n        if(numberOccurrences.count(currentNumber - difference))\n            uniquePairs.insert(currentNumber - difference);\n        numberOccurrences[currentNumber]++;\n    }\n    return uniquePairs.size();\n}",
    "output": "#include <bits/stdc++.h>\nint findPairs(std::vector<int> &numberList, int difference)\n{\n    if(difference < 0)\n        return 0;\n    std::unordered_set<int> uniquePairs;\n    std::unordered_map<int, int> numberOccurrences;\n    for(int currentNumber : numberList)\n    {\n        if(numberOccurrences.count(currentNumber + difference))\n            uniquePairs.insert(currentNumber);\n        if(numberOccurrences.count(currentNumber - difference))\n            uniquePairs.insert(currentNumber - difference);\n        numberOccurrences[currentNumber]++;\n    }\n    return uniquePairs.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findBlackPixel(vector<vector<char>> &picture, int target)\n{\n    int rowCount = picture.size();\n    int colCount = picture[0].size();\n    vector<int> rowBlackPixelCounts(rowCount, 0), colBlackPixelCounts(colCount, 0);\n    unordered_map<string, int> rowPatternCounts;\n\n    for(int rowIndex = 0; rowIndex < rowCount; ++rowIndex)\n    {\n        string rowPattern;\n        for(int colIndex = 0; colIndex < colCount; ++colIndex)\n        {\n            if(picture[rowIndex][colIndex] == 'B')\n            {\n                rowBlackPixelCounts[rowIndex]++;\n                colBlackPixelCounts[colIndex]++;\n            }\n            rowPattern.push_back(picture[rowIndex][colIndex]);\n        }\n        if(rowBlackPixelCounts[rowIndex] == target)\n            rowPatternCounts[rowPattern]++;\n    }\n\n    int totalCount = 0;\n    for(auto it = rowPatternCounts.begin(); it != rowPatternCounts.end(); ++it)\n    {\n        const string &rowPattern = it->first;\n        int patternCount = it->second;\n        if(patternCount == target)\n        {\n            for(int colIndex = 0; colIndex < colCount; ++colIndex)\n            {\n                if(rowPattern[colIndex] == 'B' && colBlackPixelCounts[colIndex] == target)\n                    totalCount += patternCount;\n            }\n        }\n    }\n    return totalCount;\n}",
    "output": "#include <bits/stdc++.h>\nint findBlackPixel(std::vector<std::vector<char>> &picture, int target)\n{\n    int rowCount= picture.size();\n    int colCount= picture[0].size();\n    std::vector<int> rowBlackPixelCounts(rowCount, 0), colBlackPixelCounts(colCount, 0);\n    std::unordered_map<std::string, int> rowPatternCounts;\n\n    for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n    {\n        std::string rowPattern;\n        for(int colIndex= 0; colIndex < colCount; ++colIndex)\n        {\n            if(picture[rowIndex][colIndex] == 'B')\n            {\n                rowBlackPixelCounts[rowIndex]++;\n                colBlackPixelCounts[colIndex]++;\n            }\n            rowPattern.push_back(picture[rowIndex][colIndex]);\n        }\n        if(rowBlackPixelCounts[rowIndex] == target)\n            rowPatternCounts[rowPattern]++;\n    }\n\n    int totalCount= 0;\n    for(auto &[rowPattern, patternCount] : rowPatternCounts)\n    {\n        if(patternCount == target)\n        {\n            for(int colIndex= 0; colIndex < colCount; ++colIndex)\n            {\n                if(rowPattern[colIndex] == 'B' && colBlackPixelCounts[colIndex] == target)\n                    totalCount+= patternCount;\n            }\n        }\n    }\n    return totalCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution\n{\n  public:\n    unordered_map<string, string> urlMap;\n    string characterSet= \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\n    // Encodes a URL to a shortened URL.\n    string encode(string longUrl)\n    {\n        string shortKey;\n        while(true)\n        {\n            shortKey.clear();\n            for(int i= 0; i < 6; i++)\n            {\n                shortKey+= characterSet[rand() % characterSet.length()];\n            }\n            if(urlMap.count(shortKey) == 0)\n            {\n                urlMap[shortKey]= longUrl;\n                break;\n            }\n        }\n        return \"http://tinyurl.com/\" + shortKey;\n    }\n\n    // Decodes a shortened URL to its original URL.\n    string decode(string shortUrl)\n    {\n        return urlMap[shortUrl.substr(19, 6)];\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Solution\n{\n  public:\n    std::unordered_map<std::string, std::string> urlMap;\n    std::string characterSet= \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\n    // Encodes a URL to a shortened URL.\n    std::string encode(std::string longUrl)\n    {\n        std::string shortKey;\n        while(true)\n        {\n            shortKey.clear();\n            for(int i= 0; i < 6; i++)\n            {\n                shortKey+= characterSet[rand() % characterSet.length()];\n            }\n            if(urlMap.count(shortKey) == 0)\n            {\n                urlMap[shortKey]= longUrl;\n                break;\n            }\n        }\n        return \"http://tinyurl.com/\" + shortKey;\n    }\n\n    // Decodes a shortened URL to its original URL.\n    std::string decode(std::string shortUrl)\n    {\n        return urlMap[shortUrl.substr(19, 6)];\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    TreeNode *stringToTree(string inputString)\n    {\n        int index = 0;\n        return stringToTreeHelper(inputString, index);\n    }\n\n    TreeNode *stringToTreeHelper(const string &inputString, int &index)\n    {\n        if(index >= inputString.length())\n            return NULL;\n\n        int sign = 1;\n        if(inputString[index] == '-')\n        {\n            sign = -1;\n            index++;\n        }\n\n        int number = 0;\n        while(index < inputString.length() && isdigit(inputString[index]))\n        {\n            number = number * 10 + (inputString[index] - '0');\n            index++;\n        }\n\n        TreeNode *node = new TreeNode(sign * number);\n\n        if(index < inputString.length() && inputString[index] == '(')\n        {\n            index++;\n            node->leftChild = stringToTreeHelper(inputString, index);\n            index++;\n        }\n        if(index < inputString.length() && inputString[index] == '(')\n        {\n            index++;\n            node->rightChild = stringToTreeHelper(inputString, index);\n            index++;\n        }\n\n        return node;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    TreeNode *stringToTree(std::string inputString)\n    {\n        int index= 0;\n        return stringToTreeHelper(inputString, index);\n    }\n\n    TreeNode *stringToTreeHelper(const std::string &inputString, int &index)\n    {\n        if(index >= inputString.length())\n            return NULL;\n\n        int sign= 1;\n        if(inputString[index] == '-')\n        {\n            sign= -1;\n            index++;\n        }\n\n        int number= 0;\n        while(index < inputString.length() && isdigit(inputString[index]))\n        {\n            number= number * 10 + (inputString[index] - '0');\n            index++;\n        }\n\n        TreeNode *node= new TreeNode(sign * number);\n\n        if(index < inputString.length() && inputString[index] == '(')\n        {\n            index++;\n            node->leftChild= stringToTreeHelper(inputString, index);\n            index++;\n        }\n        if(index < inputString.length() && inputString[index] == '(')\n        {\n            index++;\n            node->rightChild= stringToTreeHelper(inputString, index);\n            index++;\n        }\n\n        return node;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring complexNumberMultiply(string firstComplexNumber, string secondComplexNumber)\n{\n    int realPart1, imaginaryPart1, realPart2, imaginaryPart2;\n    sscanf(firstComplexNumber.c_str(), \"%d+%di\", &realPart1, &imaginaryPart1);\n    sscanf(secondComplexNumber.c_str(), \"%d+%di\", &realPart2, &imaginaryPart2);\n\n    int realResult= realPart1 * realPart2 - imaginaryPart1 * imaginaryPart2;\n    int imaginaryResult= realPart1 * imaginaryPart2 + realPart2 * imaginaryPart1;\n\n    return to_string(realResult) + \"+\" + to_string(imaginaryResult) + \"i\";\n}",
    "output": "#include <bits/stdc++.h>\nstd::string complexNumberMultiply(std::string firstComplexNumber, std::string secondComplexNumber)\n{\n    int realPart1, imaginaryPart1, realPart2, imaginaryPart2;\n    sscanf(firstComplexNumber.c_str(), \"%d+%di\", &realPart1, &imaginaryPart1);\n    sscanf(secondComplexNumber.c_str(), \"%d+%di\", &realPart2, &imaginaryPart2);\n\n    int realResult= realPart1 * realPart2 - imaginaryPart1 * imaginaryPart2;\n    int imaginaryResult= realPart1 * imaginaryPart2 + realPart2 * imaginaryPart1;\n\n    return std::to_string(realResult) + \"+\" + std::to_string(imaginaryResult) + \"i\";\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    int totalSum= 0;\n\n    TreeNode *convertBst(TreeNode *rootNode)\n    {\n        if(rootNode)\n        {\n            convertBst(rootNode->rightChild);\n            totalSum+= rootNode->value;\n            rootNode->value= totalSum;\n            convertBst(rootNode->leftChild);\n        }\n\n        return rootNode;\n    }\n};",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    int totalSum= 0;\n\n    TreeNode *convertBst(TreeNode *rootNode)\n    {\n        if(rootNode)\n        {\n            convertBst(rootNode->rightChild);\n            totalSum+= rootNode->value;\n            rootNode->value= totalSum;\n            convertBst(rootNode->leftChild);\n        }\n\n        return rootNode;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinDifference(vector<string> &timePoints)\n{\n    sort(timePoints.begin(), timePoints.end());\n    int minimumDifference = INT_MAX;\n\n    for(int index = 0; index < timePoints.size(); ++index)\n    {\n        int currentDifference = abs((stoi(timePoints[index].substr(0, 2)) * 60 + stoi(timePoints[index].substr(3, 2))) - (stoi(timePoints[(index + 1) % timePoints.size()].substr(0, 2)) * 60 + stoi(timePoints[(index + 1) % timePoints.size()].substr(3, 2))));\n        minimumDifference = min(minimumDifference, currentDifference > 720 ? 1440 - currentDifference : currentDifference);\n    }\n\n    return minimumDifference;\n}",
    "output": "#include <bits/stdc++.h>\nint findMinDifference(std::vector<std::string> &timePoints)\n{\n    std::sort(timePoints.begin(), timePoints.end());\n    int minimumDifference= INT_MAX;\n\n    for(int index= 0; index < timePoints.size(); ++index)\n    {\n        int currentDifference= abs((stoi(timePoints[index].substr(0, 2)) * 60 + stoi(timePoints[index].substr(3, 2))) - (stoi(timePoints[(index + 1) % timePoints.size()].substr(0, 2)) * 60 + stoi(timePoints[(index + 1) % timePoints.size()].substr(3, 2))));\n        minimumDifference= std::min(minimumDifference, currentDifference > 720 ? 1440 - currentDifference : currentDifference);\n    }\n\n    return minimumDifference;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findSingleNonDuplicate(vector<int> &numberList)\n{\n    int startIndex= 0, endIndex= numberList.size() - 1;\n    while(startIndex < endIndex)\n    {\n        int midIndex= startIndex + (endIndex - startIndex) / 2;\n        if(midIndex % 2 == 1)\n            midIndex--;\n        if(numberList[midIndex] == numberList[midIndex + 1])\n            startIndex= midIndex + 2;\n        else\n            endIndex= midIndex;\n    }\n    return numberList[startIndex];\n}",
    "output": "#include <bits/stdc++.h>\nint findSingleNonDuplicate(std::vector<int> &numberList)\n{\n    int startIndex= 0, endIndex= numberList.size() - 1;\n    while(startIndex < endIndex)\n    {\n        int midIndex= startIndex + (endIndex - startIndex) / 2;\n        if(midIndex % 2 == 1)\n            midIndex--;\n        if(numberList[midIndex] == numberList[midIndex + 1])\n            startIndex= midIndex + 2;\n        else\n            endIndex= midIndex;\n    }\n    return numberList[startIndex];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring reverseStringInChunks(string inputString, int chunkSize)\n{\n    for(int index= 0; index < inputString.size(); index+= 2 * chunkSize)\n    {\n        if(index + chunkSize <= inputString.size())\n        {\n            reverse(inputString.begin() + index, inputString.begin() + index + chunkSize);\n        }\n        else\n        {\n            reverse(inputString.begin() + index, inputString.end());\n        }\n    }\n    return inputString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string reverseStringInChunks(std::string inputString, int chunkSize)\n{\n    for(int index= 0; index < inputString.size(); index+= 2 * chunkSize)\n    {\n        if(index + chunkSize <= inputString.size())\n        {\n            std::reverse(inputString.begin() + index, inputString.begin() + index + chunkSize);\n        }\n        else\n        {\n            std::reverse(inputString.begin() + index, inputString.end());\n        }\n    }\n    return inputString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> updateMatrix(vector<vector<int>> &inputMatrix)\n{\n    int rowCount = inputMatrix.size();\n    int columnCount = inputMatrix[0].size();\n    vector<vector<int>> distanceMatrix(rowCount, vector<int>(columnCount, INT_MAX - 100000));\n\n    queue<pair<int, int>> coordinateQueue;\n    for (int rowIndex = 0; rowIndex < rowCount; rowIndex++)\n    {\n        for (int columnIndex = 0; columnIndex < columnCount; columnIndex++)\n        {\n            if (inputMatrix[rowIndex][columnIndex] == 0)\n            {\n                distanceMatrix[rowIndex][columnIndex] = 0;\n                coordinateQueue.push({rowIndex, columnIndex});\n            }\n        }\n    }\n\n    vector<pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    while (!coordinateQueue.empty())\n    {\n        int currentX = coordinateQueue.front().first;\n        int currentY = coordinateQueue.front().second;\n        coordinateQueue.pop();\n\n        for (int i = 0; i < directions.size(); ++i)\n        {\n            pair<int, int> &direction = directions[i];\n            int newX = currentX + direction.first;\n            int newY = currentY + direction.second;\n            if (newX >= 0 && newY >= 0 && newX < rowCount && newY < columnCount && distanceMatrix[newX][newY] > distanceMatrix[currentX][currentY] + 1)\n            {\n                distanceMatrix[newX][newY] = distanceMatrix[currentX][currentY] + 1;\n                coordinateQueue.push({newX, newY});\n            }\n        }\n    }\n    return distanceMatrix;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> updateMatrix(std::vector<std::vector<int>> &inputMatrix)\n{\n    int rowCount = inputMatrix.size();\n    int columnCount = inputMatrix[0].size();\n    std::vector<std::vector<int>> distanceMatrix(rowCount, std::vector<int>(columnCount, std::numeric_limits<int>::max() - 100000));\n\n    std::queue<std::pair<int, int>> coordinateQueue;\n    for(int rowIndex = 0; rowIndex < rowCount; rowIndex++)\n    {\n        for(int columnIndex = 0; columnIndex < columnCount; columnIndex++)\n        {\n            if(inputMatrix[rowIndex][columnIndex] == 0)\n            {\n                distanceMatrix[rowIndex][columnIndex] = 0;\n                coordinateQueue.push({rowIndex, columnIndex});\n            }\n        }\n    }\n\n    std::vector<std::pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    while(!coordinateQueue.empty())\n    {\n        int currentX = coordinateQueue.front().first;\n        int currentY = coordinateQueue.front().second;\n        coordinateQueue.pop();\n\n        for(std::pair<int, int> &direction : directions)\n        {\n            int newX = currentX + direction.first;\n            int newY = currentY + direction.second;\n            if(newX >= 0 && newY >= 0 && newX < rowCount && newY < columnCount && distanceMatrix[newX][newY] > distanceMatrix[currentX][currentY] + 1)\n            {\n                distanceMatrix[newX][newY] = distanceMatrix[currentX][currentY] + 1;\n                coordinateQueue.push({newX, newY});\n            }\n        }\n    }\n    return distanceMatrix;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// Include this for std::max\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nusing namespace std;\n\nint diameterOfBinaryTree(TreeNode *root, int *height)\n{\n    int leftHeight= 0, rightHeight= 0;\n    if(root == NULL)\n    {\n        *height= 0;\n        return 0;\n    }\n    int leftDiameter= diameterOfBinaryTree(root->leftChild, &leftHeight);\n    int rightDiameter= diameterOfBinaryTree(root->rightChild, &rightHeight);\n    *height= max(leftHeight, rightHeight) + 1;\n    return max(max(leftDiameter, rightDiameter), leftHeight + rightHeight);\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nint diameterOfBinaryTree(TreeNode *root, int *height)\n{\n    int leftHeight= 0, rightHeight= 0;\n    if(root == NULL)\n    {\n        *height= 0;\n        return 0;\n    }\n    int leftDiameter= diameterOfBinaryTree(root->leftChild, &leftHeight);\n    int rightDiameter= diameterOfBinaryTree(root->rightChild, &rightHeight);\n    *height= std::max(leftHeight, rightHeight) + 1;\n    return std::max(std::max(leftDiameter, rightDiameter), leftHeight + rightHeight);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring findContestMatch(int numberOfPlayers)\n{\n    vector<string> matchList(numberOfPlayers);\n    for(int playerIndex= 1; playerIndex <= numberOfPlayers; playerIndex++)\n    {\n        matchList[playerIndex - 1]= to_string(playerIndex);\n    }\n\n    while(numberOfPlayers > 1)\n    {\n        for(int matchIndex= 0; matchIndex < numberOfPlayers / 2; matchIndex++)\n        {\n            matchList[matchIndex]= \"(\" + matchList[matchIndex] + \",\" + matchList[numberOfPlayers - 1 - matchIndex] + \")\";\n        }\n        numberOfPlayers/= 2;\n    }\n\n    return matchList[0];\n}",
    "output": "#include <bits/stdc++.h>\nstd::string findContestMatch(int numberOfPlayers)\n{\n    std::vector<std::string> matchList(numberOfPlayers);\n    for(int playerIndex= 1; playerIndex <= numberOfPlayers; playerIndex++)\n    {\n        matchList[playerIndex - 1]= std::to_string(playerIndex);\n    }\n\n    while(numberOfPlayers > 1)\n    {\n        for(int matchIndex= 0; matchIndex < numberOfPlayers / 2; matchIndex++)\n        {\n            matchList[matchIndex]= \"(\" + matchList[matchIndex] + \",\" + matchList[numberOfPlayers - 1 - matchIndex] + \")\";\n        }\n        numberOfPlayers/= 2;\n    }\n\n    return matchList[0];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    void collectLeftBoundary(TreeNode *currentNode, vector<int> &boundaryValues)\n    {\n        if(!currentNode || (!currentNode->left && !currentNode->right))\n            return;\n        boundaryValues.push_back(currentNode->val);\n        if(currentNode->left)\n            collectLeftBoundary(currentNode->left, boundaryValues);\n        else\n            collectLeftBoundary(currentNode->right, boundaryValues);\n    }\n\n    void collectRightBoundary(TreeNode *currentNode, vector<int> &boundaryValues)\n    {\n        if(!currentNode || (!currentNode->left && !currentNode->right))\n            return;\n        if(currentNode->right)\n            collectRightBoundary(currentNode->right, boundaryValues);\n        else\n            collectRightBoundary(currentNode->left, boundaryValues);\n        boundaryValues.push_back(currentNode->val);\n    }\n\n    void collectLeaves(TreeNode *currentNode, vector<int> &boundaryValues)\n    {\n        if(!currentNode)\n            return;\n        if(!currentNode->left && !currentNode->right)\n        {\n            boundaryValues.push_back(currentNode->val);\n        }\n        collectLeaves(currentNode->left, boundaryValues);\n        collectLeaves(currentNode->right, boundaryValues);\n    }\n\n    vector<int> boundaryOfBinaryTree(TreeNode *rootNode)\n    {\n        vector<int> resultValues;\n        if(!rootNode)\n            return resultValues;\n        resultValues.push_back(rootNode->val);\n        collectLeftBoundary(rootNode->left, resultValues);\n        collectLeaves(rootNode, resultValues);\n        collectRightBoundary(rootNode->right, resultValues);\n        return resultValues;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Solution\n{\n  public:\n    void collectLeftBoundary(TreeNode *currentNode, std::vector<int> &boundaryValues)\n    {\n        if(!currentNode || (!currentNode->left && !currentNode->right))\n            return;\n        boundaryValues.push_back(currentNode->val);\n        if(currentNode->left)\n            collectLeftBoundary(currentNode->left, boundaryValues);\n        else\n            collectLeftBoundary(currentNode->right, boundaryValues);\n    }\n\n    void collectRightBoundary(TreeNode *currentNode, std::vector<int> &boundaryValues)\n    {\n        if(!currentNode || (!currentNode->left && !currentNode->right))\n            return;\n        if(currentNode->right)\n            collectRightBoundary(currentNode->right, boundaryValues);\n        else\n            collectRightBoundary(currentNode->left, boundaryValues);\n        boundaryValues.push_back(currentNode->val);\n    }\n\n    void collectLeaves(TreeNode *currentNode, std::vector<int> &boundaryValues)\n    {\n        if(!currentNode)\n            return;\n        if(!currentNode->left && !currentNode->right)\n        {\n            boundaryValues.push_back(currentNode->val);\n        }\n        collectLeaves(currentNode->left, boundaryValues);\n        collectLeaves(currentNode->right, boundaryValues);\n    }\n\n    std::vector<int> boundaryOfBinaryTree(TreeNode *rootNode)\n    {\n        std::vector<int> resultValues;\n        if(!rootNode)\n            return resultValues;\n        resultValues.push_back(rootNode->val);\n        collectLeftBoundary(rootNode->left, resultValues);\n        collectLeaves(rootNode, resultValues);\n        collectRightBoundary(rootNode->right, resultValues);\n        return resultValues;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dfs(vector<int> &boxes, int dp[100][100][100], int left, int right, int k);\n\nint removeBoxes(vector<int> &boxes)\n{\n    int dp[100][100][100]= {0};\n    return dfs(boxes, dp, 0, boxes.size() - 1, 0);\n}\n\nint dfs(vector<int> &boxes, int dp[100][100][100], int left, int right, int k)\n{\n    if(left > right)\n        return 0;\n    if(dp[left][right][k] != 0)\n        return dp[left][right][k];\n\n    while(right > left && boxes[right] == boxes[right - 1])\n    {\n        right--;\n        k++;\n    }\n\n    dp[left][right][k]= (k + 1) * (k + 1) + dfs(boxes, dp, left, right - 1, 0);\n\n    for(int i= left; i < right; i++)\n    {\n        if(boxes[i] == boxes[right])\n        {\n            dp[left][right][k]= max(dp[left][right][k], dfs(boxes, dp, left, i, k + 1) + dfs(boxes, dp, i + 1, right - 1, 0));\n        }\n    }\n\n    return dp[left][right][k];\n}",
    "output": "#include <bits/stdc++.h>\nint removeBoxes(std::vector<int> &boxes)\n{\n    int dp[100][100][100]= {0};\n    return dfs(boxes, dp, 0, boxes.size() - 1, 0);\n}\n\nint dfs(std::vector<int> &boxes, int dp[100][100][100], int left, int right, int k)\n{\n    if(left > right)\n        return 0;\n    if(dp[left][right][k] != 0)\n        return dp[left][right][k];\n\n    while(right > left && boxes[right] == boxes[right - 1])\n    {\n        right--;\n        k++;\n    }\n\n    dp[left][right][k]= (k + 1) * (k + 1) + dfs(boxes, dp, left, right - 1, 0);\n\n    for(int i= left; i < right; i++)\n    {\n        if(boxes[i] == boxes[right])\n        {\n            dp[left][right][k]= std::max(dp[left][right][k], dfs(boxes, dp, left, i, k + 1) + dfs(boxes, dp, i + 1, right - 1, 0));\n        }\n    }\n\n    return dp[left][right][k];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(vector<vector<int>> &connectionMatrix, vector<bool> &visitedCities, int cityIndex)\n{\n    visitedCities[cityIndex]= true;\n    for(int neighborIndex= 0; neighborIndex < connectionMatrix.size(); neighborIndex++)\n    {\n        if(connectionMatrix[cityIndex][neighborIndex] == 1 && !visitedCities[neighborIndex])\n        {\n            depthFirstSearch(connectionMatrix, visitedCities, neighborIndex);\n        }\n    }\n}\n\nint findCircleNum(vector<vector<int>> &isConnected)\n{\n    int provinceCount= 0;\n    vector<bool> visitedCities(isConnected.size(), false);\n    for(int cityIndex= 0; cityIndex < isConnected.size(); cityIndex++)\n    {\n        if(!visitedCities[cityIndex])\n        {\n            depthFirstSearch(isConnected, visitedCities, cityIndex);\n            provinceCount++;\n        }\n    }\n    return provinceCount;\n}",
    "output": "#include <bits/stdc++.h>\nvoid depthFirstSearch(std::vector<std::vector<int>> &connectionMatrix, std::vector<bool> &visitedCities, int cityIndex)\n{\n    visitedCities[cityIndex]= true;\n    for(int neighborIndex= 0; neighborIndex < connectionMatrix.size(); neighborIndex++)\n    {\n        if(connectionMatrix[cityIndex][neighborIndex] == 1 && !visitedCities[neighborIndex])\n        {\n            depthFirstSearch(connectionMatrix, visitedCities, neighborIndex);\n        }\n    }\n}\n\nint findCircleNum(std::vector<std::vector<int>> &isConnected)\n{\n    int provinceCount= 0;\n    std::vector<bool> visitedCities(isConnected.size(), false);\n    for(int cityIndex= 0; cityIndex < isConnected.size(); cityIndex++)\n    {\n        if(!visitedCities[cityIndex])\n        {\n            depthFirstSearch(isConnected, visitedCities, cityIndex);\n            provinceCount++;\n        }\n    }\n    return provinceCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool findTripletEqualSum(const vector<int> &numbers)\n{\n    int size = numbers.size();\n    vector<int> prefixSum(size + 1, 0);\n\n    for(int index = 0; index < size; ++index)\n    {\n        prefixSum[index + 1] = prefixSum[index] + numbers[index];\n    }\n\n    for(int firstIndex = 1; firstIndex + 2 < size; ++firstIndex)\n    {\n        for(int secondIndex = firstIndex + 2; secondIndex + 1 < size; ++secondIndex)\n        {\n            for(int thirdIndex = secondIndex + 2; thirdIndex < size; ++thirdIndex)\n            {\n                int sum1 = prefixSum[firstIndex];\n                int sum2 = prefixSum[secondIndex] - prefixSum[firstIndex + 1];\n                int sum3 = prefixSum[thirdIndex] - prefixSum[secondIndex + 1];\n                int sum4 = prefixSum[size] - prefixSum[thirdIndex + 1];\n                if(sum1 == sum2 && sum2 == sum3 && sum3 == sum4)\n                {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}",
    "output": "bool findTripletEqualSum(const std::vector<int> &numbers)\n{\n    int size= numbers.size();\n    std::vector<int> prefixSum(size + 1, 0);\n\n    for(int index= 0; index < size; ++index)\n    {\n        prefixSum[index + 1]= prefixSum[index] + numbers[index];\n    }\n\n    for(int firstIndex= 1; firstIndex + 2 < size; ++firstIndex)\n    {\n        for(int secondIndex= firstIndex + 2; secondIndex + 1 < size; ++secondIndex)\n        {\n            for(int thirdIndex= secondIndex + 2; thirdIndex < size; ++thirdIndex)\n            {\n                int sum1= prefixSum[firstIndex];\n                int sum2= prefixSum[secondIndex] - prefixSum[firstIndex + 1];\n                int sum3= prefixSum[thirdIndex] - prefixSum[secondIndex + 1];\n                int sum4= prefixSum[size] - prefixSum[thirdIndex + 1];\n                if(sum1 == sum2 && sum2 == sum3 && sum3 == sum4)\n                {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nint longestConsecutivePathUtil(TreeNode *currentNode, int &maxLength)\n{\n    if(currentNode == NULL)\n        return 0;\n    int leftPathLength = longestConsecutivePathUtil(currentNode->leftChild, maxLength) + 1;\n    int rightPathLength = longestConsecutivePathUtil(currentNode->rightChild, maxLength) + 1;\n    if(currentNode->leftChild != NULL && currentNode->leftChild->value != currentNode->value + 1)\n        leftPathLength = 1;\n    if(currentNode->rightChild != NULL && currentNode->rightChild->value != currentNode->value + 1)\n        rightPathLength = 1;\n    int currentLength = max(leftPathLength, rightPathLength);\n    maxLength = max(maxLength, leftPathLength + rightPathLength - 1);\n    return currentLength;\n}\n\nint longestConsecutive(TreeNode *root)\n{\n    int maxLength = 0;\n    longestConsecutivePathUtil(root, maxLength);\n    return maxLength;\n}",
    "output": "#include <bits/stdc++.h>\nclass TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nint longestConsecutivePathUtil(TreeNode *currentNode, int &maxLength)\n{\n    if(currentNode == NULL)\n        return 0;\n    int leftPathLength= longestConsecutivePathUtil(currentNode->leftChild, maxLength) + 1;\n    int rightPathLength= longestConsecutivePathUtil(currentNode->rightChild, maxLength) + 1;\n    if(currentNode->leftChild != NULL && currentNode->leftChild->value != currentNode->value + 1)\n        leftPathLength= 1;\n    if(currentNode->rightChild != NULL && currentNode->rightChild->value != currentNode->value + 1)\n        rightPathLength= 1;\n    int currentLength= std::max(leftPathLength, rightPathLength);\n    maxLength= std::max(maxLength, leftPathLength + rightPathLength - 1);\n    return currentLength;\n}\n\nint longestConsecutive(TreeNode *root)\n{\n    int maxLength= 0;\n    longestConsecutivePathUtil(root, maxLength);\n    return maxLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool checkRecord(string studentRecord)\n{\n    int lateCount= 0, absentCount= 0;\n    for(int currentIndex= 0; currentIndex < studentRecord.length(); currentIndex++)\n    {\n        if(studentRecord[currentIndex] == 'A')\n        {\n            absentCount++;\n            lateCount= 0;\n        }\n        else if(studentRecord[currentIndex] == 'L')\n        {\n            lateCount++;\n        }\n        else\n        {\n            lateCount= 0;\n        }\n\n        if(absentCount >= 2 || lateCount >= 3)\n            return false;\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool checkRecord(std::string studentRecord)\n{\n    int lateCount= 0, absentCount= 0;\n    for(int currentIndex= 0; currentIndex < studentRecord.length(); currentIndex++)\n    {\n        if(studentRecord[currentIndex] == 'A')\n        {\n            absentCount++;\n            lateCount= 0;\n        }\n        else if(studentRecord[currentIndex] == 'L')\n        {\n            lateCount++;\n        }\n        else\n        {\n            lateCount= 0;\n        }\n\n        if(absentCount >= 2 || lateCount >= 3)\n            return false;\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint checkRecord(int totalDays)\n{\n    int modulus= 1000000007;\n    vector<long long> currentState(6, 1); // {latent state 0, latent state 1, ..., latent state 5}\n    while(totalDays--)\n    {\n        vector<long long> nextState(6, 0);\n        nextState[0]= (currentState[0] + currentState[1] + currentState[2]) % modulus;\n        nextState[1]= currentState[0];\n        nextState[2]= currentState[1];\n        nextState[3]= (currentState[3] + currentState[4] + currentState[5]) % modulus;\n        nextState[4]= currentState[3];\n        nextState[5]= currentState[4];\n        currentState= nextState;\n    }\n    return (currentState[0] + currentState[1] + currentState[2] + currentState[3] + currentState[4] + currentState[5]) % modulus;\n}",
    "output": "#include <bits/stdc++.h>\nint checkRecord(int totalDays)\n{\n    int modulus= 1000000007;\n    std::vector<long long> currentState(6, 1); // {latent state 0, latent state 1, ..., latent state 5}\n    while(totalDays--)\n    {\n        std::vector<long long> nextState(6, 0);\n        nextState[0]= (currentState[0] + currentState[1] + currentState[2]) % modulus;\n        nextState[1]= currentState[0];\n        nextState[2]= currentState[1];\n        nextState[3]= (currentState[3] + currentState[4] + currentState[5]) % modulus;\n        nextState[4]= currentState[3];\n        nextState[5]= currentState[4];\n        currentState= nextState;\n    }\n    return (currentState[0] + currentState[1] + currentState[2] + currentState[3] + currentState[4] + currentState[5]) % modulus;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring optimalDivision(vector<int> &numbers)\n{\n    int numberCount = numbers.size();\n    if (numberCount == 1)\n        return to_string(numbers[0]);\n    if (numberCount == 2)\n        return to_string(numbers[0]) + \"/\" + to_string(numbers[1]);\n    string result = to_string(numbers[0]) + \"/(\";\n    for (int index = 1; index < numberCount - 1; ++index)\n    {\n        result += to_string(numbers[index]) + \"/\";\n    }\n    result += to_string(numbers[numberCount - 1]) + \")\";\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string optimalDivision(std::vector<int> &numbers)\n{\n    int numberCount= numbers.size();\n    if(numberCount == 1)\n        return std::to_string(numbers[0]);\n    if(numberCount == 2)\n        return std::to_string(numbers[0]) + \"/\" + std::to_string(numbers[1]);\n    std::string result= std::to_string(numbers[0]) + \"/(\";\n    for(int index= 1; index < numberCount - 1; ++index)\n    {\n        result+= std::to_string(numbers[index]) + \"/\";\n    }\n    result+= std::to_string(numbers[numberCount - 1]) + \")\";\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint leastBricks(vector<vector<int>> &wall)\n{\n    unordered_map<int, int> edgeCount;\n    int maxCount = 0;\n\n    for (size_t i = 0; i < wall.size(); ++i)\n    {\n        const auto &row = wall[i];\n        int edgePosition = 0;\n        for (size_t brickIndex = 0; brickIndex < row.size() - 1; ++brickIndex)\n        {\n            edgePosition += row[brickIndex];\n            ++edgeCount[edgePosition];\n            maxCount = max(maxCount, edgeCount[edgePosition]);\n        }\n    }\n\n    return wall.size() - maxCount;\n}",
    "output": "#include <bits/stdc++.h>\nint leastBricks(std::vector<std::vector<int>> &wall)\n{\n    std::unordered_map<int, int> edgeCount;\n    int maxCount= 0;\n\n    for(const auto &row : wall)\n    {\n        int edgePosition= 0;\n        for(size_t brickIndex= 0; brickIndex < row.size() - 1; ++brickIndex)\n        {\n            edgePosition+= row[brickIndex];\n            ++edgeCount[edgePosition];\n            maxCount= std::max(maxCount, edgeCount[edgePosition]);\n        }\n    }\n\n    return wall.size() - maxCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring splitLoopedString(vector<string> &stringList)\n{\n    string result;\n    string concatenatedString;\n    for (size_t i = 0; i < stringList.size(); ++i)\n    {\n        string &currentString = stringList[i];\n        string reversedString(currentString.rbegin(), currentString.rend());\n        concatenatedString += max(currentString, reversedString);\n    }\n\n    for (size_t index = 0, currentLength = 0; index < stringList.size(); ++index)\n    {\n        string reversedString(stringList[index].rbegin(), stringList[index].rend());\n        for (int variantIndex = 0; variantIndex < 2; ++variantIndex)\n        {\n            string currentVariant = (variantIndex == 0) ? stringList[index] : reversedString;\n            for (size_t subIndex = 0; subIndex < currentVariant.size(); ++subIndex)\n            {\n                string temporaryString = currentVariant.substr(subIndex) + concatenatedString.substr(currentLength + currentVariant.size()) + concatenatedString.substr(0, currentLength) + currentVariant.substr(0, subIndex);\n                result = max(result, temporaryString);\n            }\n        }\n        currentLength += stringList[index].size();\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string splitLoopedString(std::vector<std::string> &stringList)\n{\n    std::string result;\n    std::string concatenatedString;\n    for(auto &currentString : stringList)\n    {\n        std::string reversedString(currentString.rbegin(), currentString.rend());\n        concatenatedString+= std::max(currentString, reversedString);\n    }\n\n    for(size_t index= 0, currentLength= 0; index < stringList.size(); ++index)\n    {\n        std::string reversedString(stringList[index].rbegin(), stringList[index].rend());\n        for(auto &currentVariant : {stringList[index], reversedString})\n        {\n            for(size_t subIndex= 0; subIndex < currentVariant.size(); ++subIndex)\n            {\n                std::string temporaryString= currentVariant.substr(subIndex) + concatenatedString.substr(currentLength + currentVariant.size()) + concatenatedString.substr(0, currentLength) + currentVariant.substr(0, subIndex);\n                result= std::max(result, temporaryString);\n            }\n        }\n        currentLength+= stringList[index].size();\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint32_t nextGreaterElement(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    if(next_permutation(numberString.begin(), numberString.end()))\n    {\n        long long result= stoll(numberString);\n        if(result <= INT32_MAX)\n        {\n            return result;\n        }\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint32_t nextGreaterElement(int inputNumber)\n{\n    std::string numberString = std::to_string(inputNumber);\n    if(std::next_permutation(numberString.begin(), numberString.end()))\n    {\n        long long result = std::stoll(numberString);\n        if(result <= INT32_MAX)\n        {\n            return result;\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring reverseWordsInString(const string &inputString)\n{\n    istringstream stringStream(inputString);\n    ostringstream reversedStringStream;\n    string currentWord;\n    while(stringStream >> currentWord)\n    {\n        reverse(currentWord.begin(), currentWord.end());\n        reversedStringStream << currentWord << ' ';\n    }\n    string finalResult = reversedStringStream.str();\n    if(!finalResult.empty())\n        finalResult.pop_back();\n    return finalResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string reverseWordsInString(const std::string &inputString)\n{\n    std::istringstream stringStream(inputString);\n    std::ostringstream reversedStringStream;\n    std::string currentWord;\n    while(stringStream >> currentWord)\n    {\n        std::reverse(currentWord.begin(), currentWord.end());\n        reversedStringStream << currentWord << ' ';\n    }\n    std::string finalResult= reversedStringStream.str();\n    if(!finalResult.empty())\n        finalResult.pop_back();\n    return finalResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class Node\n{\n  public:\n    bool value;\n    bool isLeaf;\n    Node *topLeft;\n    Node *topRight;\n    Node *bottomLeft;\n    Node *bottomRight;\n};\n\nclass Solution\n{\n  public:\n    Node *intersect(Node *quadTree1, Node *quadTree2)\n    {\n        if(quadTree1->isLeaf)\n        {\n            return (quadTree1->value) ? quadTree1 : quadTree2;\n        }\n        else if(quadTree2->isLeaf)\n        {\n            return (quadTree2->value) ? quadTree2 : quadTree1;\n        }\n        else\n        {\n            Node *topLeft= intersect(quadTree1->topLeft, quadTree2->topLeft);\n            Node *topRight= intersect(quadTree1->topRight, quadTree2->topRight);\n            Node *bottomLeft= intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\n            Node *bottomRight= intersect(quadTree1->bottomRight, quadTree2->bottomRight);\n            if(topLeft->isLeaf && topRight->isLeaf && bottomLeft->isLeaf && bottomRight->isLeaf &&\n               topLeft->value == topRight->value && topLeft->value == bottomLeft->value && topLeft->value == bottomRight->value)\n            {\n                quadTree1->isLeaf= true;\n                quadTree1->value= topLeft->value;\n                delete quadTree1->topLeft;\n                delete quadTree1->topRight;\n                delete quadTree1->bottomLeft;\n                delete quadTree1->bottomRight;\n            }\n            else\n            {\n                quadTree1->topLeft= topLeft;\n                quadTree1->topRight= topRight;\n                quadTree1->bottomLeft= bottomLeft;\n                quadTree1->bottomRight= bottomRight;\n            }\n            return quadTree1;\n        }\n    }\n};",
    "output": "class Node\n{\n  public:\n    bool value;\n    bool isLeaf;\n    Node *topLeft;\n    Node *topRight;\n    Node *bottomLeft;\n    Node *bottomRight;\n};\n\nclass Solution\n{\n  public:\n    Node *intersect(Node *quadTree1, Node *quadTree2)\n    {\n        if(quadTree1->isLeaf)\n        {\n            return (quadTree1->value) ? quadTree1 : quadTree2;\n        }\n        else if(quadTree2->isLeaf)\n        {\n            return (quadTree2->value) ? quadTree2 : quadTree1;\n        }\n        else\n        {\n            Node *topLeft= intersect(quadTree1->topLeft, quadTree2->topLeft);\n            Node *topRight= intersect(quadTree1->topRight, quadTree2->topRight);\n            Node *bottomLeft= intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\n            Node *bottomRight= intersect(quadTree1->bottomRight, quadTree2->bottomRight);\n            if(topLeft->isLeaf && topRight->isLeaf && bottomLeft->isLeaf && bottomRight->isLeaf &&\n               topLeft->value == topRight->value && topLeft->value == bottomLeft->value && topLeft->value == bottomRight->value)\n            {\n                quadTree1->isLeaf= true;\n                quadTree1->value= topLeft->value;\n                delete quadTree1->topLeft;\n                delete quadTree1->topRight;\n                delete quadTree1->bottomLeft;\n                delete quadTree1->bottomRight;\n            }\n            else\n            {\n                quadTree1->topLeft= topLeft;\n                quadTree1->topRight= topRight;\n                quadTree1->bottomLeft= bottomLeft;\n                quadTree1->bottomRight= bottomRight;\n            }\n            return quadTree1;\n        }\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Node\n{\n  public:\n    int value;\n    vector<Node *> children;\n\n    Node() {}\n\n    Node(int valueIn)\n    {\n        value = valueIn;\n    }\n\n    Node(int valueIn, vector<Node *> childrenIn)\n    {\n        value = valueIn;\n        children = childrenIn;\n    }\n};\n\nint maxDepth(Node *root)\n{\n    if(!root)\n        return 0;\n    int maxDepthValue = 0;\n    for(int i = 0; i < root->children.size(); ++i)\n    {\n        Node *child = root->children[i];\n        maxDepthValue = max(maxDepthValue, maxDepth(child));\n    }\n    return maxDepthValue + 1;\n}",
    "output": "#include <bits/stdc++.h>\nclass Node\n{\n  public:\n    int value;\n    std::vector<Node *> children;\n\n    Node() {}\n\n    Node(int valueIn)\n    {\n        value= valueIn;\n    }\n\n    Node(int valueIn, std::vector<Node *> childrenIn)\n    {\n        value= valueIn;\n        children= childrenIn;\n    }\n};\n\nint maxDepth(Node *root)\n{\n    if(!root)\n        return 0;\n    int maxDepth= 0;\n    for(Node *child : root->children)\n    {\n        maxDepth= std::max(maxDepth, maxDepth(child));\n    }\n    return maxDepth + 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint subarraySum(vector<int> &numberArray, int targetSum)\n{\n    unordered_map<int, int> prefixSumFrequency;\n    prefixSumFrequency[0] = 1;\n    int currentPrefixSum = 0, totalCount = 0;\n\n    for (int i = 0; i < numberArray.size(); ++i)\n    {\n        int currentNumber = numberArray[i];\n        currentPrefixSum += currentNumber;\n        totalCount += prefixSumFrequency[currentPrefixSum - targetSum];\n        prefixSumFrequency[currentPrefixSum]++;\n    }\n\n    return totalCount;\n}",
    "output": "#include <bits/stdc++.h>\nint subarraySum(std::vector<int> &numberArray, int targetSum)\n{\n    std::unordered_map<int, int> prefixSumFrequency;\n    prefixSumFrequency[0] = 1;\n    int currentPrefixSum = 0, totalCount = 0;\n\n    for(int currentNumber : numberArray)\n    {\n        currentPrefixSum += currentNumber;\n        totalCount += prefixSumFrequency[currentPrefixSum - targetSum];\n        prefixSumFrequency[currentPrefixSum]++;\n    }\n\n    return totalCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint arrayPairSum(vector<int> &numberPairs)\n{\n    sort(numberPairs.begin(), numberPairs.end());\n    int totalSum = 0;\n    for(int index = 0; index < numberPairs.size(); index += 2)\n    {\n        totalSum += numberPairs[index];\n    }\n    return totalSum;\n}",
    "output": "#include <bits/stdc++.h>\nint arrayPairSum(std::vector<int> &numberPairs)\n{\n    std::sort(numberPairs.begin(), numberPairs.end());\n    int totalSum= 0;\n    for(int index= 0; index < numberPairs.size(); index+= 2)\n    {\n        totalSum+= numberPairs[index];\n    }\n    return totalSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint longestLine(vector<vector<int>> &matrix)\n{\n    int rowCount= matrix.size();\n    int colCount= matrix[0].size();\n    int maxLength= 0;\n    vector<vector<vector<int>>> dynamicProgramming(rowCount, vector<vector<int>>(colCount, vector<int>(4, 0)));\n\n    for(int row= 0; row < rowCount; ++row)\n    {\n        for(int col= 0; col < colCount; ++col)\n        {\n            if(matrix[row][col] == 1)\n            {\n                dynamicProgramming[row][col][0]= row > 0 ? dynamicProgramming[row - 1][col][0] + 1 : 1;\n                dynamicProgramming[row][col][1]= col > 0 ? dynamicProgramming[row][col - 1][1] + 1 : 1;\n                dynamicProgramming[row][col][2]= (row > 0 && col > 0) ? dynamicProgramming[row - 1][col - 1][2] + 1 : 1;\n                dynamicProgramming[row][col][3]= (row > 0 && col < colCount - 1) ? dynamicProgramming[row - 1][col + 1][3] + 1 : 1;\n                maxLength= max(maxLength, max(dynamicProgramming[row][col][0], max(dynamicProgramming[row][col][1], max(dynamicProgramming[row][col][2], dynamicProgramming[row][col][3]))));\n            }\n        }\n    }\n    return maxLength;\n}",
    "output": "#include <bits/stdc++.h>\nint longestLine(std::vector<std::vector<int>> &matrix)\n{\n    int rowCount = matrix.size();\n    int colCount = matrix[0].size();\n    int maxLength = 0;\n    std::vector<std::vector<std::vector<int>>> dynamicProgramming(rowCount, std::vector<std::vector<int>>(colCount, std::vector<int>(4, 0)));\n\n    for(int row = 0; row < rowCount; ++row)\n    {\n        for(int col = 0; col < colCount; ++col)\n        {\n            if(matrix[row][col] == 1)\n            {\n                dynamicProgramming[row][col][0] = row > 0 ? dynamicProgramming[row - 1][col][0] + 1 : 1;\n                dynamicProgramming[row][col][1] = col > 0 ? dynamicProgramming[row][col - 1][1] + 1 : 1;\n                dynamicProgramming[row][col][2] = (row > 0 && col > 0) ? dynamicProgramming[row - 1][col - 1][2] + 1 : 1;\n                dynamicProgramming[row][col][3] = (row > 0 && col < colCount - 1) ? dynamicProgramming[row - 1][col + 1][3] + 1 : 1;\n                maxLength = std::max(maxLength, std::max(dynamicProgramming[row][col][0], std::max(dynamicProgramming[row][col][1], std::max(dynamicProgramming[row][col][2], dynamicProgramming[row][col][3]))));\n            }\n        }\n    }\n    return maxLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int calculateTiltUtil(TreeNode *currentNode, int &totalTilt)\n{\n    if(!currentNode)\n        return 0;\n\n    int leftSubtreeSum= calculateTiltUtil(currentNode->left, totalTilt);\n    int rightSubtreeSum= calculateTiltUtil(currentNode->right, totalTilt);\n\n    totalTilt+= abs(leftSubtreeSum - rightSubtreeSum);\n    return currentNode->val + leftSubtreeSum + rightSubtreeSum;\n}\n\nint calculateTilt(TreeNode *root)\n{\n    int totalTilt= 0;\n    calculateTiltUtil(root, totalTilt);\n    return totalTilt;\n}",
    "output": "int calculateTiltUtil(TreeNode *currentNode, int &totalTilt)\n{\n    if(!currentNode)\n        return 0;\n\n    int leftSubtreeSum= calculateTiltUtil(currentNode->left, totalTilt);\n    int rightSubtreeSum= calculateTiltUtil(currentNode->right, totalTilt);\n\n    totalTilt+= abs(leftSubtreeSum - rightSubtreeSum);\n    return currentNode->val + leftSubtreeSum + rightSubtreeSum;\n}\n\nint calculateTilt(TreeNode *root)\n{\n    int totalTilt= 0;\n    calculateTiltUtil(root, totalTilt);\n    return totalTilt;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPalindrome(string inputString)\n{\n    int leftIndex= 0;\n    int rightIndex= inputString.length() - 1;\n    while(leftIndex < rightIndex)\n    {\n        if(inputString[leftIndex] != inputString[rightIndex])\n        {\n            return false;\n        }\n        leftIndex++;\n        rightIndex--;\n    }\n    return true;\n}\n\nint closestPalindrome(string numberString)\n{\n    int number= stoi(numberString);\n    int leftCandidate= number - 1;\n    int rightCandidate= number + 1;\n\n    while(true)\n    {\n        if(isPalindrome(to_string(leftCandidate)))\n        {\n            return leftCandidate;\n        }\n        if(isPalindrome(to_string(rightCandidate)))\n        {\n            return rightCandidate;\n        }\n        leftCandidate--;\n        rightCandidate++;\n    }\n}",
    "output": "#include <bits/stdc++.h>\nbool isPalindrome(std::string inputString)\n{\n    int leftIndex= 0;\n    int rightIndex= inputString.length() - 1;\n    while(leftIndex < rightIndex)\n    {\n        if(inputString[leftIndex] != inputString[rightIndex])\n        {\n            return false;\n        }\n        leftIndex++;\n        rightIndex--;\n    }\n    return true;\n}\n\nint closestPalindrome(std::string numberString)\n{\n    int number= std::stoi(numberString);\n    int leftCandidate= number - 1;\n    int rightCandidate= number + 1;\n\n    while(true)\n    {\n        if(isPalindrome(std::to_string(leftCandidate)))\n        {\n            return leftCandidate;\n        }\n        if(isPalindrome(std::to_string(rightCandidate)))\n        {\n            return rightCandidate;\n        }\n        leftCandidate--;\n        rightCandidate++;\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint arrayNesting(vector<int> &nums)\n{\n    int arraySize= nums.size();\n    int maxLength= 0;\n    for(int index= 0; index < arraySize; ++index)\n    {\n        if(nums[index] != -1)\n        {\n            int currentIndex= nums[index];\n            int count= 0;\n            while(nums[currentIndex] != -1)\n            {\n                int tempIndex= currentIndex;\n                currentIndex= nums[currentIndex];\n                count++;\n                nums[tempIndex]= -1;\n            }\n            maxLength= max(maxLength, count);\n        }\n    }\n    return maxLength;\n}",
    "output": "#include <bits/stdc++.h>\nint arrayNesting(std::vector<int> &nums)\n{\n    int arraySize= nums.size();\n    int maxLength= 0;\n    for(int index= 0; index < arraySize; ++index)\n    {\n        if(nums[index] != -1)\n        {\n            int currentIndex= nums[index];\n            int count= 0;\n            while(nums[currentIndex] != -1)\n            {\n                int tempIndex= currentIndex;\n                currentIndex= nums[currentIndex];\n                count++;\n                nums[tempIndex]= -1;\n            }\n            maxLength= std::max(maxLength, count);\n        }\n    }\n    return maxLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> matrixReshape(vector<vector<int>> &originalMatrix, int rows, int columns)\n{\n    int originalRows= originalMatrix.size();\n    int originalColumns= originalMatrix[0].size();\n    if(originalRows * originalColumns != rows * columns)\n    {\n        return originalMatrix;\n    }\n\n    vector<vector<int>> reshapedMatrix(rows, vector<int>(columns));\n    for(int index= 0; index < originalRows * originalColumns; ++index)\n    {\n        reshapedMatrix[index / columns][index % columns]= originalMatrix[index / originalColumns][index % originalColumns];\n    }\n\n    return reshapedMatrix;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> matrixReshape(std::vector<std::vector<int>> &originalMatrix, int rows, int columns)\n{\n    int originalRows = originalMatrix.size();\n    int originalColumns = originalMatrix[0].size();\n    if(originalRows * originalColumns != rows * columns)\n    {\n        return originalMatrix;\n    }\n\n    std::vector<std::vector<int>> reshapedMatrix(rows, std::vector<int>(columns));\n    for(int index = 0; index < originalRows * originalColumns; ++index)\n    {\n        reshapedMatrix[index / columns][index % columns] = originalMatrix[index / originalColumns][index % originalColumns];\n    }\n\n    return reshapedMatrix;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool checkInclusion(string sourceString, string targetString)\n{\n    vector<int> sourceCharCount(26, 0);\n    vector<int> targetCharCount(26, 0);\n    if(sourceString.length() > targetString.length())\n        return false;\n\n    for(int index= 0; index < sourceString.length(); ++index)\n    {\n        ++sourceCharCount[sourceString[index] - 'a'];\n        ++targetCharCount[targetString[index] - 'a'];\n    }\n\n    for(int index= 0; index <= targetString.length() - sourceString.length(); ++index)\n    {\n        if(sourceCharCount == targetCharCount)\n            return true;\n        --targetCharCount[targetString[index] - 'a'];\n        ++targetCharCount[targetString[index + sourceString.length()] - 'a'];\n    }\n\n    return sourceCharCount == targetCharCount;\n}",
    "output": "#include <bits/stdc++.h>\nbool checkInclusion(std::string sourceString, std::string targetString)\n{\n    std::vector<int> sourceCharCount(26, 0);\n    std::vector<int> targetCharCount(26, 0);\n    if(sourceString.length() > targetString.length())\n        return false;\n\n    for(int index= 0; index < sourceString.length(); ++index)\n    {\n        ++sourceCharCount[sourceString[index] - 'a'];\n        ++targetCharCount[targetString[index] - 'a'];\n    }\n\n    for(int index= 0; index <= targetString.length() - sourceString.length(); ++index)\n    {\n        if(sourceCharCount == targetCharCount)\n            return true;\n        --targetCharCount[targetString[index] - 'a'];\n        ++targetCharCount[targetString[index + sourceString.length()] - 'a'];\n    }\n\n    return sourceCharCount == targetCharCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(const vector<vector<int>> &flights, const vector<vector<int>> &days, int currentWeek, int currentCity, vector<vector<int>> &memo)\n{\n    if(currentWeek == days[currentCity].size())\n    {\n        return 0;\n    }\n    if(memo[currentCity][currentWeek] != -1)\n    {\n        return memo[currentCity][currentWeek];\n    }\n\n    int maxVacation= days[currentCity][currentWeek] + depthFirstSearch(flights, days, currentWeek + 1, currentCity, memo);\n\n    for(int i= 0; i < flights.size(); i++)\n    {\n        if(flights[currentCity][i] == 1)\n        {\n            maxVacation= max(maxVacation, days[i][currentWeek] + depthFirstSearch(flights, days, currentWeek + 1, i, memo));\n        }\n    }\n\n    memo[currentCity][currentWeek]= maxVacation;\n    return maxVacation;\n}\n\nint maxVacationDays(vector<vector<int>> &flights, vector<vector<int>> &days)\n{\n    vector<vector<int>> memo(flights.size(), vector<int>(days[0].size(), -1));\n    return depthFirstSearch(flights, days, 0, 0, memo);\n}",
    "output": "#include <bits/stdc++.h>\nint depthFirstSearch(const std::vector<std::vector<int>> &flights, const std::vector<std::vector<int>> &days, int currentWeek, int currentCity, std::vector<std::vector<int>> &memo)\n{\n    if(currentWeek == days[currentCity].size())\n    {\n        return 0;\n    }\n    if(memo[currentCity][currentWeek] != -1)\n    {\n        return memo[currentCity][currentWeek];\n    }\n\n    int maxVacation= days[currentCity][currentWeek] + depthFirstSearch(flights, days, currentWeek + 1, currentCity, memo);\n\n    for(int i= 0; i < flights.size(); i++)\n    {\n        if(flights[currentCity][i] == 1)\n        {\n            maxVacation= std::max(maxVacation, days[i][currentWeek] + depthFirstSearch(flights, days, currentWeek + 1, i, memo));\n        }\n    }\n\n    memo[currentCity][currentWeek]= maxVacation;\n    return maxVacation;\n}\n\nint maxVacationDays(std::vector<std::vector<int>> &flights, std::vector<std::vector<int>> &days)\n{\n    std::vector<std::vector<int>> memo(flights.size(), std::vector<int>(days[0].size(), -1));\n    return depthFirstSearch(flights, days, 0, 0, memo);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nbool isSubtree(TreeNode *mainTree, TreeNode *subTree)\n{\n    if(mainTree == NULL)\n        return false;\n    if(isIdentical(mainTree, subTree))\n        return true;\n    return isSubtree(mainTree->leftChild, subTree) || isSubtree(mainTree->rightChild, subTree);\n}\n\nbool isIdentical(TreeNode *node1, TreeNode *node2)\n{\n    if(node1 == NULL || node2 == NULL)\n        return node1 == node2;\n    if(node1->value != node2->value)\n        return false;\n    return isIdentical(node1->leftChild, node2->leftChild) && isIdentical(node1->rightChild, node2->rightChild);\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nbool isSubtree(TreeNode *mainTree, TreeNode *subTree)\n{\n    if(mainTree == NULL)\n        return false;\n    if(isIdentical(mainTree, subTree))\n        return true;\n    return isSubtree(mainTree->leftChild, subTree) || isSubtree(mainTree->rightChild, subTree);\n}\n\nbool isIdentical(TreeNode *node1, TreeNode *node2)\n{\n    if(node1 == NULL || node2 == NULL)\n        return node1 == node2;\n    if(node1->value != node2->value)\n        return false;\n    return isIdentical(node1->leftChild, node2->leftChild) && isIdentical(node1->rightChild, node2->rightChild);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minDistance(int height, int width, vector<int> &tree, vector<int> &squirrel, vector<vector<int>> &nuts)\n{\n    int totalDistance = 0;\n    int minDifference = INT_MAX;\n\n    for (int i = 0; i < nuts.size(); ++i)\n    {\n        vector<int> &nut = nuts[i];\n        int treeDistance = abs(tree[0] - nut[0]) + abs(tree[1] - nut[1]);\n        int squirrelDistance = abs(squirrel[0] - nut[0]) + abs(squirrel[1] - nut[1]);\n\n        totalDistance += 2 * treeDistance;\n        minDifference = min(minDifference, squirrelDistance - treeDistance);\n    }\n\n    return totalDistance + minDifference;\n}",
    "output": "#include <bits/stdc++.h>\nint minDistance(int height, int width, std::vector<int> &tree, std::vector<int> &squirrel, std::vector<std::vector<int>> &nuts)\n{\n    int totalDistance= 0;\n    int minDifference= INT_MAX;\n\n    for(std::vector<int> &nut : nuts)\n    {\n        int treeDistance= abs(tree[0] - nut[0]) + abs(tree[1] - nut[1]);\n        int squirrelDistance= abs(squirrel[0] - nut[0]) + abs(squirrel[1] - nut[1]);\n\n        totalDistance+= 2 * treeDistance;\n        minDifference= std::min(minDifference, squirrelDistance - treeDistance);\n    }\n\n    return totalDistance + minDifference;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCandies(vector<int> &candyTypes)\n{\n    unordered_set<int> uniqueCandies(candyTypes.begin(), candyTypes.end());\n    return min(uniqueCandies.size(), candyTypes.size() / 2);\n}",
    "output": "#include <bits/stdc++.h>\nint maxNumberOfCandies(std::vector<int> &candyTypes)\n{\n    std::unordered_set<int> uniqueCandies(candyTypes.begin(), candyTypes.end());\n    return std::min(uniqueCandies.size(), candyTypes.size() / 2);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findPaths(int rowCount, int columnCount, int maxMoves, int startRow, int startColumn)\n{\n    int modulus = 1e9 + 7;\n    vector<vector<vector<int>>> pathCount(maxMoves + 1, vector<vector<int>>(rowCount, vector<int>(columnCount, 0)));\n    int directions[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    for(int move = 1; move <= maxMoves; move++)\n    {\n        for(int row = 0; row < rowCount; row++)\n        {\n            for(int column = 0; column < columnCount; column++)\n            {\n                for(int d = 0; d < 4; d++) // Changed to traditional for loop\n                {\n                    int newRow = row + directions[d][0], newColumn = column + directions[d][1];\n                    if(newRow < 0 || newRow >= rowCount || newColumn < 0 || newColumn >= columnCount)\n                    {\n                        pathCount[move][row][column] = (pathCount[move][row][column] + 1) % modulus;\n                    }\n                    else\n                    {\n                        pathCount[move][row][column] = (pathCount[move][row][column] + pathCount[move - 1][newRow][newColumn]) % modulus;\n                    }\n                }\n            }\n        }\n    }\n    return pathCount[maxMoves][startRow][startColumn];\n}",
    "output": "#include <bits/stdc++.h>\nint findPaths(int rowCount, int columnCount, int maxMoves, int startRow, int startColumn)\n{\n    int modulus= 1e9 + 7;\n    std::vector<std::vector<std::vector<int>>> pathCount(maxMoves + 1, std::vector<std::vector<int>>(rowCount, std::vector<int>(columnCount, 0)));\n    int directions[4][2]= {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    for(int move= 1; move <= maxMoves; move++)\n    {\n        for(int row= 0; row < rowCount; row++)\n        {\n            for(int column= 0; column < columnCount; column++)\n            {\n                for(auto direction : directions)\n                {\n                    int newRow= row + direction[0], newColumn= column + direction[1];\n                    if(newRow < 0 || newRow >= rowCount || newColumn < 0 || newColumn >= columnCount)\n                    {\n                        pathCount[move][row][column]= (pathCount[move][row][column] + 1) % modulus;\n                    }\n                    else\n                    {\n                        pathCount[move][row][column]= (pathCount[move][row][column] + pathCount[move - 1][newRow][newColumn]) % modulus;\n                    }\n                }\n            }\n        }\n    }\n    return pathCount[maxMoves][startRow][startColumn];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findUnsortedSubarray(vector<int> &inputArray)\n{\n    vector<int> sortedArray(inputArray);\n    sort(sortedArray.begin(), sortedArray.end());\n    int startIndex= 0, endIndex= inputArray.size() - 1;\n    while(startIndex < inputArray.size() && inputArray[startIndex] == sortedArray[startIndex])\n        startIndex++;\n    while(endIndex > startIndex && inputArray[endIndex] == sortedArray[endIndex])\n        endIndex--;\n    return endIndex - startIndex + 1;\n}",
    "output": "#include <bits/stdc++.h>\nint findUnsortedSubarray(std::vector<int> &inputArray)\n{\n    std::vector<int> sortedArray(inputArray);\n    std::sort(sortedArray.begin(), sortedArray.end());\n    int startIndex= 0, endIndex= inputArray.size() - 1;\n    while(startIndex < inputArray.size() && inputArray[startIndex] == sortedArray[startIndex])\n        startIndex++;\n    while(endIndex > startIndex && inputArray[endIndex] == sortedArray[endIndex])\n        endIndex--;\n    return endIndex - startIndex + 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> killProcess(vector<int> &processIds, vector<int> &parentProcessIds, int killId)\n{\n    unordered_map<int, vector<int>> childProcesses;\n    for(int index = 0; index < processIds.size(); index++)\n    {\n        childProcesses[parentProcessIds[index]].push_back(processIds[index]);\n    }\n\n    vector<int> killedProcesses;\n    function<void(int)> depthFirstSearch = [&](int processId)\n    {\n        killedProcesses.push_back(processId);\n        for (int i = 0; i < childProcesses[processId].size(); ++i)\n        {\n            int childId = childProcesses[processId][i];\n            depthFirstSearch(childId);\n        }\n    };\n    depthFirstSearch(killId);\n\n    return killedProcesses;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> killProcess(std::vector<int> &processIds, std::vector<int> &parentProcessIds, int killId)\n{\n    std::unordered_map<int, std::vector<int>> childProcesses;\n    for(int index= 0; index < processIds.size(); index++)\n    {\n        childProcesses[parentProcessIds[index]].push_back(processIds[index]);\n    }\n\n    std::vector<int> killedProcesses;\n    std::function<void(int)> depthFirstSearch= [&](int processId)\n    {\n        killedProcesses.push_back(processId);\n        for(int childId : childProcesses[processId])\n        {\n            depthFirstSearch(childId);\n        }\n    };\n    depthFirstSearch(killId);\n\n    return killedProcesses;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumDistance(string sourceWord, string targetWord)\n{\n    int sourceLength = sourceWord.length(), targetLength = targetWord.length();\n    vector<vector<int>> editDistanceTable(sourceLength + 1, vector<int>(targetLength + 1, 0));\n\n    for(int sourceIndex = 0; sourceIndex <= sourceLength; sourceIndex++)\n    {\n        for(int targetIndex = 0; targetIndex <= targetLength; targetIndex++)\n        {\n            if(sourceIndex == 0 || targetIndex == 0)\n                editDistanceTable[sourceIndex][targetIndex] = sourceIndex + targetIndex;\n            else if(sourceWord[sourceIndex - 1] == targetWord[targetIndex - 1])\n                editDistanceTable[sourceIndex][targetIndex] = editDistanceTable[sourceIndex - 1][targetIndex - 1];\n            else\n                editDistanceTable[sourceIndex][targetIndex] = 1 + min(editDistanceTable[sourceIndex - 1][targetIndex], editDistanceTable[sourceIndex][targetIndex - 1]);\n        }\n    }\n\n    return editDistanceTable[sourceLength][targetLength];\n}",
    "output": "int calculateMinimumDistance(std::string sourceWord, std::string targetWord)\n{\n    int sourceLength= sourceWord.length(), targetLength= targetWord.length();\n    std::vector<std::vector<int>> editDistanceTable(sourceLength + 1, std::vector<int>(targetLength + 1, 0));\n\n    for(int sourceIndex= 0; sourceIndex <= sourceLength; sourceIndex++)\n    {\n        for(int targetIndex= 0; targetIndex <= targetLength; targetIndex++)\n        {\n            if(sourceIndex == 0 || targetIndex == 0)\n                editDistanceTable[sourceIndex][targetIndex]= sourceIndex + targetIndex;\n            else if(sourceWord[sourceIndex - 1] == targetWord[targetIndex - 1])\n                editDistanceTable[sourceIndex][targetIndex]= editDistanceTable[sourceIndex - 1][targetIndex - 1];\n            else\n                editDistanceTable[sourceIndex][targetIndex]= 1 + std::min(editDistanceTable[sourceIndex - 1][targetIndex], editDistanceTable[sourceIndex][targetIndex - 1]);\n        }\n    }\n\n    return editDistanceTable[sourceLength][targetLength];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool compare(const vector<int> &firstPoint, const vector<int> &secondPoint)\n{\n    return firstPoint[0] < secondPoint[0] || (firstPoint[0] == secondPoint[0] && firstPoint[1] < secondPoint[1]);\n}\n\nint crossProduct(const vector<int> &firstPoint, const vector<int> &secondPoint, const vector<int> &thirdPoint)\n{\n    return (secondPoint[1] - firstPoint[1]) * (thirdPoint[0] - secondPoint[0]) - (secondPoint[0] - firstPoint[0]) * (thirdPoint[1] - secondPoint[1]);\n}\n\nvector<vector<int>> createFence(vector<vector<int>> &treePoints)\n{\n    sort(treePoints.begin(), treePoints.end(), compare);\n    vector<vector<int>> convexHull;\n    \n    for (int i = 0; i < treePoints.size(); ++i)\n    {\n        const auto &currentPoint = treePoints[i];\n        while (convexHull.size() >= 2 && crossProduct(convexHull[convexHull.size() - 2], convexHull[convexHull.size() - 1], currentPoint) > 0)\n        {\n            convexHull.pop_back();\n        }\n        convexHull.push_back(currentPoint);\n    }\n    \n    for (int i = treePoints.size() - 1; i >= 0; --i)\n    {\n        const auto &currentPoint = treePoints[i];\n        while (convexHull.size() >= 2 && crossProduct(convexHull[convexHull.size() - 2], convexHull[convexHull.size() - 1], currentPoint) > 0)\n        {\n            convexHull.pop_back();\n        }\n        convexHull.push_back(currentPoint);\n    }\n    \n    return convexHull;\n}",
    "output": "#include <bits/stdc++.h>\nbool compare(const std::vector<int> &firstPoint, const std::vector<int> &secondPoint)\n{\n    return firstPoint[0] < secondPoint[0] || (firstPoint[0] == secondPoint[0] && firstPoint[1] < secondPoint[1]);\n}\n\nint crossProduct(const std::vector<int> &firstPoint, const std::vector<int> &secondPoint, const std::vector<int> &thirdPoint)\n{\n    return (secondPoint[1] - firstPoint[1]) * (thirdPoint[0] - secondPoint[0]) - (secondPoint[0] - firstPoint[0]) * (thirdPoint[1] - secondPoint[1]);\n}\n\nstd::vector<std::vector<int>> createFence(std::vector<std::vector<int>> &treePoints)\n{\n    std::sort(treePoints.begin(), treePoints.end(), compare);\n    std::vector<std::vector<int>> convexHull;\n    for(const auto &currentPoint : treePoints)\n    {\n        while(convexHull.size() >= 2 && crossProduct(convexHull[convexHull.size() - 2], convexHull[convexHull.size() - 1], currentPoint) > 0)\n        {\n            convexHull.pop_back();\n        }\n        convexHull.push_back(currentPoint);\n    }\n    for(int i= treePoints.size() - 1; i >= 0; --i)\n    {\n        const auto &currentPoint= treePoints[i];\n        while(convexHull.size() >= 2 && crossProduct(convexHull[convexHull.size() - 2], convexHull[convexHull.size() - 1], currentPoint) > 0)\n        {\n            convexHull.pop_back();\n        }\n        convexHull.push_back(currentPoint);\n    }\n    return convexHull;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass FileSystem\n{\n    struct Node\n    {\n        bool isFile = false;\n        string content;\n        map<string, Node *> children;\n    };\n\n    Node *root;\n\n  public:\n    FileSystem()\n    {\n        root = new Node();\n    }\n\n    vector<string> ls(string path)\n    {\n        Node *currentNode = root;\n        vector<string> pathParts = splitPath(path);\n\n        for (int i = 0; i < pathParts.size(); ++i)\n        {\n            currentNode = currentNode->children[pathParts[i]];\n        }\n\n        if (currentNode->isFile)\n        {\n            return {pathParts.back()};\n        }\n        else\n        {\n            vector<string> fileNames;\n            for (auto it = currentNode->children.begin(); it != currentNode->children.end(); ++it)\n            {\n                fileNames.push_back(it->first);\n            }\n            sort(fileNames.begin(), fileNames.end());\n            return fileNames;\n        }\n    }\n\n    void mkdir(string path)\n    {\n        Node *currentNode = root;\n        vector<string> pathParts = splitPath(path);\n\n        for (int i = 0; i < pathParts.size(); ++i)\n        {\n            const string &part = pathParts[i];\n            if (currentNode->children.find(part) == currentNode->children.end())\n            {\n                currentNode->children[part] = new Node();\n            }\n            currentNode = currentNode->children[part];\n        }\n    }\n\n    void addContentToFile(string filePath, string content)\n    {\n        Node *currentNode = root;\n        vector<string> pathParts = splitPath(filePath);\n\n        for (int i = 0; i < pathParts.size(); ++i)\n        {\n            const string &part = pathParts[i];\n            if (currentNode->children.find(part) == currentNode->children.end())\n            {\n                currentNode->children[part] = new Node();\n            }\n            currentNode = currentNode->children[part];\n        }\n\n        currentNode->isFile = true;\n        currentNode->content += content;\n    }\n\n    string readContentFromFile(string filePath)\n    {\n        Node *currentNode = root;\n        vector<string> pathParts = splitPath(filePath);\n\n        for (int i = 0; i < pathParts.size(); ++i)\n        {\n            currentNode = currentNode->children[pathParts[i]];\n        }\n\n        return currentNode->content;\n    }\n\n  private:\n    vector<string> splitPath(const string &path)\n    {\n        vector<string> parts;\n        istringstream stringStream(path);\n        string part;\n\n        while (getline(stringStream, part, '/'))\n        {\n            if (!part.empty())\n            {\n                parts.push_back(part);\n            }\n        }\n\n        return parts;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass FileSystem\n{\n    struct Node\n    {\n        bool isFile= false;\n        std::string content;\n        std::map<std::string, Node *> children;\n    };\n\n    Node *root;\n\n  public:\n    FileSystem()\n    {\n        root= new Node();\n    }\n\n    std::vector<std::string> ls(std::string path)\n    {\n        Node *currentNode= root;\n        std::vector<std::string> pathParts= splitPath(path);\n\n        for(const std::string &part : pathParts)\n        {\n            currentNode= currentNode->children[part];\n        }\n\n        if(currentNode->isFile)\n        {\n            return {pathParts.back()};\n        }\n        else\n        {\n            std::vector<std::string> fileNames;\n            for(const auto &child : currentNode->children)\n            {\n                fileNames.push_back(child.first);\n            }\n            std::sort(fileNames.begin(), fileNames.end());\n            return fileNames;\n        }\n    }\n\n    void mkdir(std::string path)\n    {\n        Node *currentNode= root;\n        std::vector<std::string> pathParts= splitPath(path);\n\n        for(const std::string &part : pathParts)\n        {\n            if(currentNode->children.find(part) == currentNode->children.end())\n            {\n                currentNode->children[part]= new Node();\n            }\n            currentNode= currentNode->children[part];\n        }\n    }\n\n    void addContentToFile(std::string filePath, std::string content)\n    {\n        Node *currentNode= root;\n        std::vector<std::string> pathParts= splitPath(filePath);\n\n        for(const std::string &part : pathParts)\n        {\n            if(currentNode->children.find(part) == currentNode->children.end())\n            {\n                currentNode->children[part]= new Node();\n            }\n            currentNode= currentNode->children[part];\n        }\n\n        currentNode->isFile= true;\n        currentNode->content+= content;\n    }\n\n    std::string readContentFromFile(std::string filePath)\n    {\n        Node *currentNode= root;\n        std::vector<std::string> pathParts= splitPath(filePath);\n\n        for(const std::string &part : pathParts)\n        {\n            currentNode= currentNode->children[part];\n        }\n\n        return currentNode->content;\n    }\n\n  private:\n    std::vector<std::string> splitPath(const std::string &path)\n    {\n        std::vector<std::string> parts;\n        std::istringstream stringStream(path);\n        std::string part;\n\n        while(std::getline(stringStream, part, '/'))\n        {\n            if(!part.empty())\n            {\n                parts.push_back(part);\n            }\n        }\n\n        return parts;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Node\n{\n  public:\n    int value;\n    vector<Node *> childNodes;\n\n    Node() {}\n\n    Node(int valueIn)\n    {\n        value= valueIn;\n    }\n\n    Node(int valueIn, vector<Node *> childNodesIn)\n    {\n        value= valueIn;\n        childNodes= childNodesIn;\n    }\n};\n\nvector<int> preorderTraversal(Node *rootNode)\n{\n    vector<int> result;\n    if(rootNode == NULL)\n        return result;\n    stack<Node *> nodeStack;\n    nodeStack.push(rootNode);\n\n    while(!nodeStack.empty())\n    {\n        Node *currentNode= nodeStack.top();\n        nodeStack.pop();\n        result.push_back(currentNode->value);\n        for(int i= currentNode->childNodes.size() - 1; i >= 0; i--)\n        {\n            nodeStack.push(currentNode->childNodes[i]);\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nclass Node\n{\n  public:\n    int value;\n    std::vector<Node *> childNodes;\n\n    Node() {}\n\n    Node(int valueIn)\n    {\n        value= valueIn;\n    }\n\n    Node(int valueIn, std::vector<Node *> childNodesIn)\n    {\n        value= valueIn;\n        childNodes= childNodesIn;\n    }\n};\n\nvector<int> preorderTraversal(Node *rootNode)\n{\n    vector<int> result;\n    if(rootNode == NULL)\n        return result;\n    stack<Node *> nodeStack;\n    nodeStack.push(rootNode);\n\n    while(!nodeStack.empty())\n    {\n        Node *currentNode= nodeStack.top();\n        nodeStack.pop();\n        result.push_back(currentNode->value);\n        for(int i= currentNode->childNodes.size() - 1; i >= 0; i--)\n        {\n            nodeStack.push(currentNode->childNodes[i]);\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For std::reverse\nusing namespace std;\n\nstruct Node\n{\n    int value;\n    vector<Node *> children;\n};\n\nvector<int> postorder(Node *root)\n{\n    vector<int> result;\n    if(!root)\n        return result;\n\n    stack<Node *> nodeStack;\n    nodeStack.push(root);\n\n    while(!nodeStack.empty())\n    {\n        Node *currentNode = nodeStack.top();\n        nodeStack.pop();\n        result.push_back(currentNode->value);\n\n        for (size_t i = 0; i < currentNode->children.size(); ++i)\n        {\n            Node *childNode = currentNode->children[i];\n            nodeStack.push(childNode);\n        }\n    }\n\n    reverse(result.begin(), result.end());\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstruct Node\n{\n    int value;\n    std::vector<Node *> children;\n};\n\nstd::vector<int> postorder(Node *root)\n{\n    std::vector<int> result;\n    if(!root)\n        return result;\n\n    std::stack<Node *> nodeStack;\n    nodeStack.push(root);\n\n    while(!nodeStack.empty())\n    {\n        Node *currentNode= nodeStack.top();\n        nodeStack.pop();\n        result.push_back(currentNode->value);\n\n        for(auto childNode : currentNode->children)\n            nodeStack.push(childNode);\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValid(const string &codeSnippet, size_t &currentIndex)\n{\n    if(currentIndex >= codeSnippet.size())\n        return false;\n    if(codeSnippet[currentIndex] != '<')\n        return false;\n    int nameLength= 0;\n    for(++currentIndex; currentIndex < codeSnippet.size() && nameLength < 9 && isupper(codeSnippet[currentIndex]); ++currentIndex)\n        ++nameLength;\n    if(nameLength < 1 || nameLength > 9 || codeSnippet[currentIndex++] != '>')\n        return false;\n\n    while(currentIndex < codeSnippet.size() && codeSnippet[currentIndex] != '<')\n        ++currentIndex;\n    if(currentIndex >= codeSnippet.size())\n        return false;\n\n    if(codeSnippet.substr(currentIndex, nameLength + 3) != \"</\" + codeSnippet.substr(currentIndex - nameLength - 1, nameLength) + \">\")\n        return false;\n    currentIndex+= nameLength + 3;\n    return true;\n}\n\nbool validateCodeSnippet(const string &codeSnippet)\n{\n    size_t currentIndex= 0;\n    return isValid(codeSnippet, currentIndex) && currentIndex == codeSnippet.size();\n}",
    "output": "bool isValid(const std::string &codeSnippet, size_t &currentIndex)\n{\n    if(currentIndex >= codeSnippet.size())\n        return false;\n    if(codeSnippet[currentIndex] != '<')\n        return false;\n    int nameLength= 0;\n    for(++currentIndex; currentIndex < codeSnippet.size() && nameLength < 9 && isupper(codeSnippet[currentIndex]); ++currentIndex)\n        ++nameLength;\n    if(nameLength < 1 || nameLength > 9 || codeSnippet[currentIndex++] != '>')\n        return false;\n\n    while(currentIndex < codeSnippet.size() && codeSnippet[currentIndex] != '<')\n        ++currentIndex;\n    if(currentIndex >= codeSnippet.size())\n        return false;\n\n    if(codeSnippet.substr(currentIndex, nameLength + 3) != \"</\" + codeSnippet.substr(currentIndex - nameLength - 1, nameLength) + \">\")\n        return false;\n    currentIndex+= nameLength + 3;\n    return true;\n}\n\nbool validateCodeSnippet(const std::string &codeSnippet)\n{\n    size_t currentIndex= 0;\n    return isValid(codeSnippet, currentIndex) && currentIndex == codeSnippet.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int num, int den)\n{\n    return den == 0 ? num : gcd(den, num % den);\n}\n\nstring fractionAddition(string expr)\n{\n    stringstream exprStream(expr);\n    int currentNum, currentDen, totalNum= 0, totalDen= 1;\n    char sep;\n\n    while(exprStream >> currentNum >> sep >> currentDen)\n    {\n        totalNum= totalNum * currentDen + totalDen * currentNum;\n        totalDen*= currentDen;\n        int greatestCommonDiv= gcd(abs(totalNum), abs(totalDen));\n        totalNum/= greatestCommonDiv;\n        totalDen/= greatestCommonDiv;\n    }\n\n    return to_string(totalNum) + \"/\" + to_string(totalDen);\n}",
    "output": "#include <bits/stdc++.h>\nint gcd(int num, int den)\n{\n    return den == 0 ? num : gcd(den, num % den);\n}\n\nstd::string fractionAddition(std::string expr)\n{\n    std::stringstream exprStream(expr);\n    int currentNum, currentDen, totalNum= 0, totalDen= 1;\n    char sep;\n\n    while(exprStream >> currentNum >> sep >> currentDen)\n    {\n        totalNum= totalNum * currentDen + totalDen * currentNum;\n        totalDen*= currentDen;\n        int greatestCommonDiv= gcd(abs(totalNum), abs(totalDen));\n        totalNum/= greatestCommonDiv;\n        totalDen/= greatestCommonDiv;\n    }\n\n    return std::to_string(totalNum) + \"/\" + std::to_string(totalDen);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidSquare(vector<int> &point1, vector<int> &point2, vector<int> &point3, vector<int> &point4)\n{\n    set<int> distanceSet;\n    vector<vector<int>> points{point1, point2, point3, point4};\n\n    for(int i= 0; i < 4; i++)\n    {\n        for(int j= i + 1; j < 4; j++)\n        {\n            distanceSet.insert(pow(points[i][0] - points[j][0], 2) + pow(points[i][1] - points[j][1], 2));\n        }\n    }\n\n    return distanceSet.size() == 2 && *distanceSet.begin() != 0;\n}",
    "output": "#include <bits/stdc++.h>\nbool isValidSquare(std::vector<int> &point1, std::vector<int> &point2, std::vector<int> &point3, std::vector<int> &point4)\n{\n    std::set<int> distanceSet;\n    std::vector<std::vector<int>> points{point1, point2, point3, point4};\n\n    for(int i= 0; i < 4; i++)\n    {\n        for(int j= i + 1; j < 4; j++)\n        {\n            distanceSet.insert(std::pow(points[i][0] - points[j][0], 2) + std::pow(points[i][1] - points[j][1], 2));\n        }\n    }\n\n    return distanceSet.size() == 2 && *distanceSet.begin() != 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findLhs(vector<int> &numberList)\n{\n    unordered_map<int, int> frequencyMap;\n    for(int number : numberList)\n        frequencyMap[number]++;\n\n    int longestSequence = 0;\n    for(auto it = frequencyMap.begin(); it != frequencyMap.end(); ++it)\n    {\n        if(frequencyMap.find(it->first + 1) != frequencyMap.end())\n            longestSequence = max(longestSequence, it->second + frequencyMap[it->first + 1]);\n    }\n\n    return longestSequence;\n}",
    "output": "#include <bits/stdc++.h>\nint findLhs(std::vector<int> &numberList)\n{\n    std::unordered_map<int, int> frequencyMap;\n    for(int number : numberList)\n        frequencyMap[number]++;\n\n    int longestSequence = 0;\n    for(auto &element : frequencyMap)\n    {\n        if(frequencyMap.find(element.first + 1) != frequencyMap.end())\n            longestSequence = std::max(longestSequence, element.second + frequencyMap[element.first + 1]);\n    }\n\n    return longestSequence;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxCount(int rows, int columns, vector<vector<int>> &operations)\n{\n    for (int i = 0; i < operations.size(); ++i)\n    {\n        vector<int> &operation = operations[i];\n        rows = min(rows, operation[0]);\n        columns = min(columns, operation[1]);\n    }\n    return rows * columns;\n}",
    "output": "#include <bits/stdc++.h>\nint maxCount(int rows, int columns, std::vector<std::vector<int>> &operations)\n{\n    for(std::vector<int> &operation : operations)\n    {\n        rows = std::min(rows, operation[0]);\n        columns = std::min(columns, operation[1]);\n    }\n    return rows * columns;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> findRestaurant(vector<string> &firstList, vector<string> &secondList)\n{\n    unordered_map<string, int> restaurantIndexMap;\n    for(int index= 0; index < firstList.size(); index++)\n    {\n        restaurantIndexMap[firstList[index]= index;\n    }\n\n    int minimumSum= INT_MAX;\n    vector<string> matchedRestaurants;\n    for(int indexSecond= 0; indexSecond < secondList.size(); indexSecond++)\n    {\n        if(restaurantIndexMap.count(secondList[indexSecond]))\n        {\n            int currentSum= indexSecond + restaurantIndexMap[secondList[indexSecond]];\n            if(currentSum < minimumSum)\n            {\n                matchedRestaurants.clear();\n                matchedRestaurants.push_back(secondList[indexSecond]);\n                minimumSum= currentSum;\n            }\n            else if(currentSum == minimumSum)\n            {\n                matchedRestaurants.push_back(secondList[indexSecond]);\n            }\n        }\n    }\n    return matchedRestaurants;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> findRestaurant(std::vector<std::string> &firstList, std::vector<std::string> &secondList)\n{\n    std::unordered_map<std::string, int> restaurantIndexMap;\n    for(int index= 0; index < firstList.size(); index++)\n    {\n        restaurantIndexMap[firstList[index]]= index;\n    }\n\n    int minimumSum= INT_MAX;\n    std::vector<std::string> matchedRestaurants;\n    for(int indexSecond= 0; indexSecond < secondList.size(); indexSecond++)\n    {\n        if(restaurantIndexMap.count(secondList[indexSecond]))\n        {\n            int currentSum= indexSecond + restaurantIndexMap[secondList[indexSecond]];\n            if(currentSum < minimumSum)\n            {\n                matchedRestaurants.clear();\n                matchedRestaurants.push_back(secondList[indexSecond]);\n                minimumSum= currentSum;\n            }\n            else if(currentSum == minimumSum)\n            {\n                matchedRestaurants.push_back(secondList[indexSecond]);\n            }\n        }\n    }\n    return matchedRestaurants;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int findIntegers(int inputNumber)\n{\n    int dynamicProgramming[32][2]= {0};\n    dynamicProgramming[0][0]= dynamicProgramming[0][1]= 1;\n\n    for(int index= 1; index < 32; index++)\n    {\n        dynamicProgramming[index][0]= dynamicProgramming[index - 1][0] + dynamicProgramming[index - 1][1];\n        dynamicProgramming[index][1]= dynamicProgramming[index - 1][0];\n    }\n\n    int result= 0, previousBit= 0;\n    for(int index= 30; index >= 0; index--)\n    {\n        if(inputNumber & (1 << index))\n        {\n            result+= dynamicProgramming[index][0];\n            if(previousBit)\n                break;\n            previousBit= 1;\n        }\n        else\n        {\n            previousBit= 0;\n        }\n    }\n\n    return result + 1;\n}",
    "output": "int findIntegers(int inputNumber)\n{\n    int dynamicProgramming[32][2]= {0};\n    dynamicProgramming[0][0]= dynamicProgramming[0][1]= 1;\n\n    for(int index= 1; index < 32; index++)\n    {\n        dynamicProgramming[index][0]= dynamicProgramming[index - 1][0] + dynamicProgramming[index - 1][1];\n        dynamicProgramming[index][1]= dynamicProgramming[index - 1][0];\n    }\n\n    int result= 0, previousBit= 0;\n    for(int index= 30; index >= 0; index--)\n    {\n        if(inputNumber & (1 << index))\n        {\n            result+= dynamicProgramming[index][0];\n            if(previousBit)\n                break;\n            previousBit= 1;\n        }\n        else\n        {\n            previousBit= 0;\n        }\n    }\n\n    return result + 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass StringIterator\n{\n  public:\n    StringIterator(const string &compressedString)\n    {\n        compressedData = compressedString;\n        currentIndex = 0;\n        characterCount = 0;\n        currentCharacter = ' ';\n    }\n    char next()\n    {\n        if(!hasNext())\n            return ' ';\n        if(characterCount == 0)\n        {\n            currentCharacter = compressedData[currentIndex++];\n            while(currentIndex < compressedData.size() && isdigit(compressedData[currentIndex]))\n            {\n                characterCount = characterCount * 10 + (compressedData[currentIndex++] - '0');\n            }\n        }\n        characterCount--;\n        return currentCharacter;\n    }\n    bool hasNext()\n    {\n        return currentIndex < compressedData.size() || characterCount != 0;\n    }\n\n  private:\n    string compressedData;\n    int currentIndex;\n    int characterCount;\n    char currentCharacter;\n};",
    "output": "#include <bits/stdc++.h>\nclass StringIterator\n{\n  public:\n    StringIterator(const std::string &compressedString)\n    {\n        compressedData= compressedString;\n        currentIndex= 0;\n        characterCount= 0;\n        currentCharacter= ' ';\n    }\n    char next()\n    {\n        if(!hasNext())\n            return ' ';\n        if(characterCount == 0)\n        {\n            currentCharacter= compressedData[currentIndex++];\n            while(currentIndex < compressedData.size() && isdigit(compressedData[currentIndex]))\n            {\n                characterCount= characterCount * 10 + (compressedData[currentIndex++] - '0');\n            }\n        }\n        characterCount--;\n        return currentCharacter;\n    }\n    bool hasNext()\n    {\n        return currentIndex < compressedData.size() || characterCount != 0;\n    }\n\n  private:\n    std::string compressedData;\n    int currentIndex;\n    int characterCount;\n    char currentCharacter;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canPlaceFlowers(vector<int> &flowerbed, int numberOfFlowers)\n{\n    int flowerCount= 0;\n    for(int index= 0; index < flowerbed.size(); index++)\n    {\n        if(flowerbed[index] == 0 && (index == 0 || flowerbed[index - 1] == 0) && (index == flowerbed.size() - 1 || flowerbed[index + 1] == 0))\n        {\n            flowerbed[index]= 1;\n            flowerCount++;\n        }\n        if(flowerCount >= numberOfFlowers)\n            return true;\n    }\n    return flowerCount >= numberOfFlowers;\n}",
    "output": "#include <bits/stdc++.h>\nbool canPlaceFlowers(std::vector<int> &flowerbed, int numberOfFlowers)\n{\n    int flowerCount= 0;\n    for(int index= 0; index < flowerbed.size(); index++)\n    {\n        if(flowerbed[index] == 0 && (index == 0 || flowerbed[index - 1] == 0) && (index == flowerbed.size() - 1 || flowerbed[index + 1] == 0))\n        {\n            flowerbed[index]= 1;\n            flowerCount++;\n        }\n        if(flowerCount >= numberOfFlowers)\n            return true;\n    }\n    return flowerCount >= numberOfFlowers;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nstring treeToString(TreeNode *currentNode)\n{\n    if(currentNode == NULL)\n    {\n        return \"\";\n    }\n    if(currentNode->leftChild == NULL && currentNode->rightChild == NULL)\n    {\n        return to_string(currentNode->value);\n    }\n    if(currentNode->rightChild == NULL)\n    {\n        return to_string(currentNode->value) + \"(\" + treeToString(currentNode->leftChild) + \")\";\n    }\n    return to_string(currentNode->value) + \"(\" + treeToString(currentNode->leftChild) + \")(\" + treeToString(currentNode->rightChild) + \")\";\n}",
    "output": "#include <bits/stdc++.h>\nclass TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nstd::string treeToString(TreeNode *currentNode)\n{\n    if(currentNode == NULL)\n    {\n        return \"\";\n    }\n    if(currentNode->leftChild == NULL && currentNode->rightChild == NULL)\n    {\n        return std::to_string(currentNode->value);\n    }\n    if(currentNode->rightChild == NULL)\n    {\n        return std::to_string(currentNode->value) + \"(\" + treeToString(currentNode->leftChild) + \")\";\n    }\n    return std::to_string(currentNode->value) + \"(\" + treeToString(currentNode->leftChild) + \")(\" + treeToString(currentNode->rightChild) + \")\";\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<string>> findDuplicate(vector<string> &filePaths)\n{\n    unordered_map<string, vector<string>> contentMap;\n    for (int i = 0; i < filePaths.size(); ++i)\n    {\n        const string &filePath = filePaths[i];\n        istringstream pathStream(filePath);\n        string directory;\n        pathStream >> directory;\n        string file;\n        while (pathStream >> file)\n        {\n            size_t start = file.find('(');\n            size_t end = file.find(')');\n            string content = file.substr(start + 1, end - start - 1);\n            string fullFilePath = directory + \"/\" + file.substr(0, start);\n            contentMap[content].push_back(fullFilePath);\n        }\n    }\n    vector<vector<string>> duplicates;\n    for (const auto &entry : contentMap)\n    {\n        if (entry.second.size() > 1)\n        {\n            duplicates.push_back(entry.second);\n        }\n    }\n    return duplicates;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<std::string>> findDuplicate(std::vector<std::string> &filePaths)\n{\n    std::unordered_map<std::string, std::vector<std::string>> contentMap;\n    for(const std::string &filePath : filePaths)\n    {\n        std::istringstream pathStream(filePath);\n        std::string directory;\n        pathStream >> directory;\n        std::string file;\n        while(pathStream >> file)\n        {\n            size_t start= file.find('(');\n            size_t end= file.find(')');\n            std::string content= file.substr(start + 1, end - start - 1);\n            std::string fullFilePath= directory + \"/\" + file.substr(0, start);\n            contentMap[content].push_back(fullFilePath);\n        }\n    }\n    std::vector<std::vector<std::string>> duplicates;\n    for(const auto &entry : contentMap)\n    {\n        if(entry.second.size() > 1)\n        {\n            duplicates.push_back(entry.second);\n        }\n    }\n    return duplicates;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countTriangleNumbers(vector<int> &sortedNumbers)\n{\n    sort(sortedNumbers.begin(), sortedNumbers.end());\n    int triangleCount= 0;\n    for(int firstIndex= 0; firstIndex < sortedNumbers.size(); ++firstIndex)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < sortedNumbers.size(); ++secondIndex)\n        {\n            for(int thirdIndex= secondIndex + 1; thirdIndex < sortedNumbers.size(); ++thirdIndex)\n            {\n                if(sortedNumbers[firstIndex] + sortedNumbers[secondIndex] > sortedNumbers[thirdIndex])\n                {\n                    ++triangleCount;\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n    }\n    return triangleCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countTriangleNumbers(std::vector<int> &sortedNumbers)\n{\n    std::sort(sortedNumbers.begin(), sortedNumbers.end());\n    int triangleCount= 0;\n    for(int firstIndex= 0; firstIndex < sortedNumbers.size(); ++firstIndex)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < sortedNumbers.size(); ++secondIndex)\n        {\n            for(int thirdIndex= secondIndex + 1; thirdIndex < sortedNumbers.size(); ++thirdIndex)\n            {\n                if(sortedNumbers[firstIndex] + sortedNumbers[secondIndex] > sortedNumbers[thirdIndex])\n                {\n                    ++triangleCount;\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n    }\n    return triangleCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring addBoldTag(string inputString, vector<string> &keywords)\n{\n    int stringLength = inputString.size();\n    vector<bool> isMarked(stringLength, false);\n    for (int i = 0; i < keywords.size(); ++i)\n    {\n        const auto &keyword = keywords[i];\n        int position = inputString.find(keyword, 0);\n        while (position != string::npos)\n        {\n            fill(isMarked.begin() + position, isMarked.begin() + position + keyword.size(), true);\n            position = inputString.find(keyword, position + 1);\n        }\n    }\n    string boldedString;\n    for (int index = 0; index < stringLength; ++index)\n    {\n        if (isMarked[index] && (index == 0 || !isMarked[index - 1]))\n        {\n            boldedString += \"<b>\";\n        }\n        boldedString += inputString[index];\n        if (isMarked[index] && (index == stringLength - 1 || !isMarked[index + 1]))\n        {\n            boldedString += \"</b>\";\n        }\n    }\n    return boldedString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string addBoldTag(std::string inputString, std::vector<std::string> &keywords)\n{\n    int stringLength= inputString.size();\n    std::vector<bool> isMarked(stringLength, false);\n    for(const auto &keyword : keywords)\n    {\n        int position= inputString.find(keyword, 0);\n        while(position != std::string::npos)\n        {\n            std::fill(isMarked.begin() + position, isMarked.begin() + position + keyword.size(), true);\n            position= inputString.find(keyword, position + 1);\n        }\n    }\n    std::string boldedString;\n    for(int index= 0; index < stringLength; ++index)\n    {\n        if(isMarked[index] && (index == 0 || !isMarked[index - 1]))\n        {\n            boldedString+= \"<b>\";\n        }\n        boldedString+= inputString[index];\n        if(isMarked[index] && (index == stringLength - 1 || !isMarked[index + 1]))\n        {\n            boldedString+= \"</b>\";\n        }\n    }\n    return boldedString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nTreeNode *mergeTrees(TreeNode *firstTreeRoot, TreeNode *secondTreeRoot)\n{\n    if(firstTreeRoot == NULL)\n        return secondTreeRoot;\n    if(secondTreeRoot == NULL)\n        return firstTreeRoot;\n\n    firstTreeRoot->value+= secondTreeRoot->value;\n    firstTreeRoot->leftChild= mergeTrees(firstTreeRoot->leftChild, secondTreeRoot->leftChild);\n    firstTreeRoot->rightChild= mergeTrees(firstTreeRoot->rightChild, secondTreeRoot->rightChild);\n    return firstTreeRoot;\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nTreeNode *mergeTrees(TreeNode *firstTreeRoot, TreeNode *secondTreeRoot)\n{\n    if(firstTreeRoot == NULL)\n        return secondTreeRoot;\n    if(secondTreeRoot == NULL)\n        return firstTreeRoot;\n\n    firstTreeRoot->value+= secondTreeRoot->value;\n    firstTreeRoot->leftChild= mergeTrees(firstTreeRoot->leftChild, secondTreeRoot->leftChild);\n    firstTreeRoot->rightChild= mergeTrees(firstTreeRoot->rightChild, secondTreeRoot->rightChild);\n    return firstTreeRoot;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint leastInterval(vector<char> &taskList, int cooldownPeriod)\n{\n    unordered_map<char, int> taskFrequency;\n    for (int i = 0; i < taskList.size(); ++i)\n    {\n        char currentTask = taskList[i];\n        taskFrequency[currentTask]++;\n    }\n\n    vector<int> frequencyList;\n    for (auto taskEntry : taskFrequency)\n    {\n        frequencyList.push_back(taskEntry.second);\n    }\n\n    sort(frequencyList.rbegin(), frequencyList.rend());\n\n    int maxFrequency = frequencyList[0] - 1;\n    int idleSlots = maxFrequency * cooldownPeriod;\n\n    for (int i = 1; i < frequencyList.size(); i++)\n    {\n        idleSlots -= min(frequencyList[i], maxFrequency);\n    }\n\n    return idleSlots > 0 ? idleSlots + taskList.size() : taskList.size();\n}",
    "output": "#include <bits/stdc++.h>\nint leastInterval(std::vector<char> &taskList, int cooldownPeriod)\n{\n    std::unordered_map<char, int> taskFrequency;\n    for(char currentTask : taskList)\n    {\n        taskFrequency[currentTask]++;\n    }\n\n    std::vector<int> frequencyList;\n    for(auto taskEntry : taskFrequency)\n    {\n        frequencyList.push_back(taskEntry.second);\n    }\n\n    std::sort(frequencyList.rbegin(), frequencyList.rend());\n\n    int maxFrequency= frequencyList[0] - 1;\n    int idleSlots= maxFrequency * cooldownPeriod;\n\n    for(int i= 1; i < frequencyList.size(); i++)\n    {\n        idleSlots-= std::min(frequencyList[i], maxFrequency);\n    }\n\n    return idleSlots > 0 ? idleSlots + taskList.size() : taskList.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass MyCircularQueue\n{\n  public:\n    MyCircularQueue(int capacity)\n    {\n        queueCapacity= capacity;\n        queueData.resize(capacity);\n        frontIndex= -1;\n        rearIndex= -1;\n    }\n\n    bool enQueue(int value)\n    {\n        if(isFull())\n            return false;\n        if(isEmpty())\n            frontIndex= 0;\n        rearIndex= (rearIndex + 1) % queueCapacity;\n        queueData[rearIndex]= value;\n        return true;\n    }\n\n    bool deQueue()\n    {\n        if(isEmpty())\n            return false;\n        if(frontIndex == rearIndex)\n        {\n            frontIndex= -1;\n            rearIndex= -1;\n        }\n        else\n        {\n            frontIndex= (frontIndex + 1) % queueCapacity;\n        }\n        return true;\n    }\n\n    int front()\n    {\n        if(isEmpty())\n            return -1;\n        return queueData[frontIndex];\n    }\n\n    int rear()\n    {\n        if(isEmpty())\n            return -1;\n        return queueData[rearIndex];\n    }\n\n    bool isEmpty()\n    {\n        return frontIndex == -1;\n    }\n\n    bool isFull()\n    {\n        return (rearIndex + 1) % queueCapacity == frontIndex;\n    }\n\n  private:\n    vector<int> queueData;\n    int frontIndex;\n    int rearIndex;\n    int queueCapacity;\n};",
    "output": "#include <bits/stdc++.h>\nclass MyCircularQueue\n{\n  public:\n    MyCircularQueue(int capacity)\n    {\n        queueCapacity= capacity;\n        queueData.resize(capacity);\n        frontIndex= -1;\n        rearIndex= -1;\n    }\n\n    bool enQueue(int value)\n    {\n        if(isFull())\n            return false;\n        if(isEmpty())\n            frontIndex= 0;\n        rearIndex= (rearIndex + 1) % queueCapacity;\n        queueData[rearIndex]= value;\n        return true;\n    }\n\n    bool deQueue()\n    {\n        if(isEmpty())\n            return false;\n        if(frontIndex == rearIndex)\n        {\n            frontIndex= -1;\n            rearIndex= -1;\n        }\n        else\n        {\n            frontIndex= (frontIndex + 1) % queueCapacity;\n        }\n        return true;\n    }\n\n    int front()\n    {\n        if(isEmpty())\n            return -1;\n        return queueData[frontIndex];\n    }\n\n    int rear()\n    {\n        if(isEmpty())\n            return -1;\n        return queueData[rearIndex];\n    }\n\n    bool isEmpty()\n    {\n        return frontIndex == -1;\n    }\n\n    bool isFull()\n    {\n        return (rearIndex + 1) % queueCapacity == frontIndex;\n    }\n\n  private:\n    std::vector<int> queueData;\n    int frontIndex;\n    int rearIndex;\n    int queueCapacity;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "void addOneRowHelper(TreeNode *currentNode, int newValue, int targetDepth, int currentDepth)\n{\n    if(currentNode == NULL)\n        return;\n    if(currentDepth == targetDepth - 1)\n    {\n        TreeNode *leftChild= currentNode->left;\n        TreeNode *rightChild= currentNode->right;\n        currentNode->left= new TreeNode(newValue);\n        currentNode->left->left= leftChild;\n        currentNode->right= new TreeNode(newValue);\n        currentNode->right->right= rightChild;\n    }\n    else\n    {\n        addOneRowHelper(currentNode->left, newValue, targetDepth, currentDepth + 1);\n        addOneRowHelper(currentNode->right, newValue, targetDepth, currentDepth + 1);\n    }\n}\n\nTreeNode *addOneRow(TreeNode *rootNode, int newValue, int targetDepth)\n{\n    if(targetDepth == 1)\n    {\n        TreeNode *newRootNode= new TreeNode(newValue);\n        newRootNode->left= rootNode;\n        return newRootNode;\n    }\n    addOneRowHelper(rootNode, newValue, targetDepth, 1);\n    return rootNode;\n}",
    "output": "void addOneRowHelper(TreeNode *currentNode, int newValue, int targetDepth, int currentDepth)\n{\n    if(currentNode == NULL)\n        return;\n    if(currentDepth == targetDepth - 1)\n    {\n        TreeNode *leftChild= currentNode->left;\n        TreeNode *rightChild= currentNode->right;\n        currentNode->left= new TreeNode(newValue);\n        currentNode->left->left= leftChild;\n        currentNode->right= new TreeNode(newValue);\n        currentNode->right->right= rightChild;\n    }\n    else\n    {\n        addOneRowHelper(currentNode->left, newValue, targetDepth, currentDepth + 1);\n        addOneRowHelper(currentNode->right, newValue, targetDepth, currentDepth + 1);\n    }\n}\n\nTreeNode *addOneRow(TreeNode *rootNode, int newValue, int targetDepth)\n{\n    if(targetDepth == 1)\n    {\n        TreeNode *newRootNode= new TreeNode(newValue);\n        newRootNode->left= rootNode;\n        return newRootNode;\n    }\n    addOneRowHelper(rootNode, newValue, targetDepth, 1);\n    return rootNode;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxDistance(vector<vector<int>> &arrays)\n{\n    int maxDistanceValue= 0, minValue= arrays[0][0], maxValue= arrays[0].back();\n    for(int i= 1; i < arrays.size(); i++)\n    {\n        maxDistanceValue= max(maxDistanceValue, max(abs(arrays[i].back() - minValue), abs(maxValue - arrays[i][0])));\n        minValue= min(minValue, arrays[i][0]);\n        maxValue= max(maxValue, arrays[i].back());\n    }\n    return maxDistanceValue;\n}",
    "output": "#include <bits/stdc++.h>\nint maxDistance(std::vector<std::vector<int>> &arrays)\n{\n    int maxDistanceValue= 0, minValue= arrays[0][0], maxValue= arrays[0].back();\n    for(int i= 1; i < arrays.size(); i++)\n    {\n        maxDistanceValue= std::max(maxDistanceValue, std::max(std::abs(arrays[i].back() - minValue), std::abs(maxValue - arrays[i][0])));\n        minValue= std::min(minValue, arrays[i][0]);\n        maxValue= std::max(maxValue, arrays[i].back());\n    }\n    return maxDistanceValue;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int smallestFactorization(int inputNumber)\n{\n    if(inputNumber == 1)\n        return 1;\n    long result= 0, factor= 1;\n    for(int digit= 9; digit > 1; --digit)\n    {\n        while(inputNumber % digit == 0)\n        {\n            inputNumber/= digit;\n            result+= digit * factor;\n            factor*= 10;\n            if(result > INT_MAX)\n                return 0;\n        }\n    }\n    return inputNumber == 1 ? result : 0;\n}",
    "output": "int smallestFactorization(int inputNumber)\n{\n    if(inputNumber == 1)\n        return 1;\n    long result= 0, factor= 1;\n    for(int digit= 9; digit > 1; --digit)\n    {\n        while(inputNumber % digit == 0)\n        {\n            inputNumber/= digit;\n            result+= digit * factor;\n            factor*= 10;\n            if(result > INT_MAX)\n                return 0;\n        }\n    }\n    return inputNumber == 1 ? result : 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maximumProduct(vector<int> &numberList)\n{\n    sort(numberList.begin(), numberList.end());\n    int numberCount= numberList.size();\n    return max(numberList[0] * numberList[1] * numberList[numberCount - 1],\n               numberList[numberCount - 1] * numberList[numberCount - 2] * numberList[numberCount - 3]);\n}",
    "output": "#include <bits/stdc++.h>\nint maximumProduct(std::vector<int> &numberList)\n{\n    std::sort(numberList.begin(), numberList.end());\n    int numberCount = numberList.size();\n    return std::max(numberList[0] * numberList[1] * numberList[numberCount - 1],\n                    numberList[numberCount - 1] * numberList[numberCount - 2] * numberList[numberCount - 3]);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateKInversePairs(int numberOfElements, int kInversePairs)\n{\n    int modulus= 1e9 + 7;\n    vector<vector<int>> dynamicProgrammingTable(numberOfElements + 1, vector<int>(kInversePairs + 1, 0));\n    for(int currentElement= 1; currentElement <= numberOfElements; ++currentElement)\n    {\n        dynamicProgrammingTable[currentElement][0]= 1;\n        for(int currentK= 1; currentK <= kInversePairs; ++currentK)\n        {\n            dynamicProgrammingTable[currentElement][currentK]= (dynamicProgrammingTable[currentElement][currentK - 1] + dynamicProgrammingTable[currentElement - 1][currentK]) % modulus;\n            if(currentK - currentElement >= 0)\n            {\n                dynamicProgrammingTable[currentElement][currentK]= (dynamicProgrammingTable[currentElement][currentK] - dynamicProgrammingTable[currentElement - 1][currentK - currentElement] + modulus) % modulus;\n            }\n        }\n    }\n    return dynamicProgrammingTable[numberOfElements][kInversePairs];\n}",
    "output": "#include <bits/stdc++.h>\nint calculateKInversePairs(int numberOfElements, int kInversePairs)\n{\n    int modulus= 1e9 + 7;\n    std::vector<std::vector<int>> dynamicProgrammingTable(numberOfElements + 1, std::vector<int>(kInversePairs + 1, 0));\n    for(int currentElement= 1; currentElement <= numberOfElements; ++currentElement)\n    {\n        dynamicProgrammingTable[currentElement][0]= 1;\n        for(int currentK= 1; currentK <= kInversePairs; ++currentK)\n        {\n            dynamicProgrammingTable[currentElement][currentK]= (dynamicProgrammingTable[currentElement][currentK - 1] + dynamicProgrammingTable[currentElement - 1][currentK]) % modulus;\n            if(currentK - currentElement >= 0)\n            {\n                dynamicProgrammingTable[currentElement][currentK]= (dynamicProgrammingTable[currentElement][currentK] - dynamicProgrammingTable[currentElement - 1][currentK - currentElement] + modulus) % modulus;\n            }\n        }\n    }\n    return dynamicProgrammingTable[numberOfElements][kInversePairs];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint scheduleCourse(vector<vector<int>> &courseList)\n{\n    sort(courseList.begin(), courseList.end(), [](const vector<int> &firstCourse, const vector<int> &secondCourse)\n              { return firstCourse[1] < secondCourse[1]; });\n\n    priority_queue<int> courseDurationQueue;\n    int totalTime = 0;\n\n    for (int i = 0; i < courseList.size(); ++i)\n    {\n        const auto &currentCourse = courseList[i];\n        totalTime += currentCourse[0];\n        courseDurationQueue.push(currentCourse[0]);\n\n        if (totalTime > currentCourse[1])\n        {\n            totalTime -= courseDurationQueue.top();\n            courseDurationQueue.pop();\n        }\n    }\n\n    return courseDurationQueue.size();\n}",
    "output": "#include <bits/stdc++.h>\nint scheduleCourse(std::vector<std::vector<int>> &courseList)\n{\n    std::sort(courseList.begin(), courseList.end(), [](const std::vector<int> &firstCourse, const std::vector<int> &secondCourse)\n              { return firstCourse[1] < secondCourse[1]; });\n\n    std::priority_queue<int> courseDurationQueue;\n    int totalTime= 0;\n\n    for(const auto &currentCourse : courseList)\n    {\n        totalTime+= currentCourse[0];\n        courseDurationQueue.push(currentCourse[0]);\n\n        if(totalTime > currentCourse[1])\n        {\n            totalTime-= courseDurationQueue.top();\n            courseDurationQueue.pop();\n        }\n    }\n\n    return courseDurationQueue.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Excel\n{\n  public:\n    vector<vector<int>> cellValues;\n    unordered_map<string, pair<string, vector<string>>> formulas;\n\n    Excel(int height, char width)\n    {\n        cellValues.resize(height, vector<int>(width - 'A' + 1));\n    }\n\n    void set(int row, char column, int value)\n    {\n        row--;\n        column -= 'A';\n        string position = string(1, column + 'A') + to_string(row + 1);\n        formulas.erase(position);\n        cellValues[row][column] = value;\n    }\n\n    int get(int row, char column)\n    {\n        row--;\n        column -= 'A';\n        string position = string(1, column + 'A') + to_string(row + 1);\n        if (formulas.count(position))\n        {\n            int sum = 0;\n            for (string &reference : formulas[position].second)\n            {\n                auto separator = reference.find(':');\n                if (separator == string::npos)\n                {\n                    int referenceRow = stoi(reference.substr(1)) - 1;\n                    int referenceColumn = reference[0] - 'A';\n                    sum += get(referenceRow + 1, referenceColumn + 'A');\n                }\n                else\n                {\n                    int startRow = stoi(reference.substr(1, separator - 1)) - 1;\n                    int startColumn = reference[0] - 'A';\n                    int endRow = stoi(reference.substr(separator + 2)) - 1;\n                    int endColumn = reference[separator + 1] - 'A';\n                    for (int i = startRow; i <= endRow; ++i)\n                        for (int j = startColumn; j <= endColumn; ++j)\n                            sum += get(i + 1, j + 'A');\n                }\n            }\n            return sum;\n        }\n        return cellValues[row][column];\n    }\n\n    int sum(int row, char column, vector<string> numbers)\n    {\n        int total = 0;\n        string position = string(1, column) + to_string(row);\n        for (int i = 0; i < numbers.size(); ++i)\n            total += get(stoi(numbers[i].substr(1)), numbers[i][0]);\n        formulas[position] = make_pair(position, numbers);\n        set(row, column, total);\n        return total;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Excel\n{\n  public:\n    std::vector<std::vector<int>> cellValues;\n    std::unordered_map<std::string, std::pair<std::string, std::vector<std::string>>> formulas;\n\n    Excel(int height, char width)\n    {\n        cellValues.resize(height, std::vector<int>(width - 'A' + 1));\n    }\n\n    void set(int row, char column, int value)\n    {\n        row--;\n        column -= 'A';\n        std::string position = std::string(1, column + 'A') + std::to_string(row + 1);\n        formulas.erase(position);\n        cellValues[row][column] = value;\n    }\n\n    int get(int row, char column)\n    {\n        row--;\n        column -= 'A';\n        std::string position = std::string(1, column + 'A') + std::to_string(row + 1);\n        if(formulas.count(position))\n        {\n            int sum = 0;\n            for(std::string &reference : formulas[position].second)\n            {\n                auto separator = reference.find(':');\n                if(separator == std::string::npos)\n                {\n                    int referenceRow = std::stoi(reference.substr(1)) - 1;\n                    int referenceColumn = reference[0] - 'A';\n                    sum += get(referenceRow + 1, referenceColumn + 'A');\n                }\n                else\n                {\n                    int startRow = std::stoi(reference.substr(1, separator - 1)) - 1;\n                    int startColumn = reference[0] - 'A';\n                    int endRow = std::stoi(reference.substr(separator + 2)) - 1;\n                    int endColumn = reference[separator + 1] - 'A';\n                    for(int i = startRow; i <= endRow; ++i)\n                        for(int j = startColumn; j <= endColumn; ++j)\n                            sum += get(i + 1, j + 'A');\n                }\n            }\n            return sum;\n        }\n        return cellValues[row][column];\n    }\n\n    int sum(int row, char column, std::vector<std::string> numbers)\n    {\n        int total = 0;\n        std::string position = std::string(1, column) + std::to_string(row);\n        for(auto &number : numbers)\n            total += get(std::stoi(number.substr(1)), number[0]);\n        formulas[position] = std::make_pair(position, numbers);\n        set(row, column, total);\n        return total;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\npair<int, int> smallestRange(vector<vector<int>> &numberLists)\n{\n    auto listComparator = [](const auto &a, const auto &b)\n    {\n        return a.first > b.first;\n    };\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(listComparator)> minHeap(listComparator);\n\n    int maxValue = numeric_limits<int>::min();\n    for(int listIndex = 0; listIndex < numberLists.size(); listIndex++)\n    {\n        minHeap.push({numberLists[listIndex][0], listIndex});\n        maxValue = max(maxValue, numberLists[listIndex][0]);\n    }\n\n    vector<int> currentIndices(numberLists.size(), 0);\n    int minRange = numeric_limits<int>::max();\n    int rangeStart = -1, rangeEnd = -1;\n\n    while(minHeap.size() == numberLists.size())\n    {\n        auto entry = minHeap.top();\n        minHeap.pop();\n        int currentValue = entry.first;\n        int currentListIndex = entry.second;\n        int range = maxValue - currentValue;\n\n        if(range < minRange)\n        {\n            minRange = range;\n            rangeStart = currentValue;\n            rangeEnd = maxValue;\n        }\n\n        currentIndices[currentListIndex]++;\n        if(currentIndices[currentListIndex] < numberLists[currentListIndex].size())\n        {\n            int newValue = numberLists[currentListIndex][currentIndices[currentListIndex]];\n            minHeap.push({newValue, currentListIndex});\n            maxValue = max(maxValue, newValue);\n        }\n    }\n\n    return {rangeStart, rangeEnd};\n}",
    "output": "#include <bits/stdc++.h>\nstd::pair<int, int> smallestRange(std::vector<std::vector<int>> &numberLists)\n{\n    auto listComparator= [](const auto &a, const auto &b)\n    {\n        return a.first > b.first;\n    };\n\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, decltype(listComparator)> minHeap(listComparator);\n\n    int maxValue= std::numeric_limits<int>::min();\n    for(int listIndex= 0; listIndex < numberLists.size(); listIndex++)\n    {\n        minHeap.push({numberLists[listIndex][0], listIndex});\n        maxValue= std::max(maxValue, numberLists[listIndex][0]);\n    }\n\n    std::vector<int> currentIndices(numberLists.size(), 0);\n    int minRange= std::numeric_limits<int>::max();\n    int rangeStart= -1, rangeEnd= -1;\n\n    while(minHeap.size() == numberLists.size())\n    {\n        auto entry= minHeap.top();\n        minHeap.pop();\n        int currentValue= entry.first;\n        int currentListIndex= entry.second;\n        int range= maxValue - currentValue;\n\n        if(range < minRange)\n        {\n            minRange= range;\n            rangeStart= currentValue;\n            rangeEnd= maxValue;\n        }\n\n        currentIndices[currentListIndex]++;\n        if(currentIndices[currentListIndex] < numberLists[currentListIndex].size())\n        {\n            int newValue= numberLists[currentListIndex][currentIndices[currentListIndex]];\n            minHeap.push({newValue, currentListIndex});\n            maxValue= std::max(maxValue, newValue);\n        }\n    }\n\n    return {rangeStart, rangeEnd};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// Optional: Include for input/output if needed\nusing namespace std;\n\nbool judgeSquareSum(int target)\n{\n    for(int baseA= 0; baseA <= sqrt(target); ++baseA)\n    {\n        int baseB= sqrt(target - baseA * baseA);\n        if(baseA * baseA + baseB * baseB == target)\n        {\n            return true;\n        }\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool judgeSquareSum(int target)\n{\n    for(int baseA= 0; baseA <= std::sqrt(target); ++baseA)\n    {\n        int baseB= std::sqrt(target - baseA * baseA);\n        if(baseA * baseA + baseB * baseB == target)\n        {\n            return true;\n        }\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findDerangement(int totalItems)\n{\n    long modulus = 1e9 + 7;\n    vector<long> derangementCount(totalItems + 1, 0);\n    derangementCount[2] = 1;\n    for(int currentItem = 3; currentItem <= totalItems; ++currentItem)\n    {\n        derangementCount[currentItem] = (currentItem - 1) * (derangementCount[currentItem - 1] + derangementCount[currentItem - 2]) % modulus;\n    }\n    return (int)derangementCount[totalItems];\n}",
    "output": "#include <bits/stdc++.h>\nint findDerangement(int totalItems)\n{\n    long modulus= 1e9 + 7;\n    std::vector<long> derangementCount(totalItems + 1, 0);\n    derangementCount[2]= 1;\n    for(int currentItem= 3; currentItem <= totalItems; ++currentItem)\n    {\n        derangementCount[currentItem]= (currentItem - 1) * (derangementCount[currentItem - 1] + derangementCount[currentItem - 2]) % modulus;\n    }\n    return (int)derangementCount[totalItems];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass LogSystem\n{\n  public:\n    LogSystem()\n    {\n    }\n\n    void putLog(int logId, string timestamp)\n    {\n        logEntries[timestamp] = logId;\n    }\n\n    vector<int> retrieveLogs(string startTime, string endTime, string timeGranularity)\n    {\n        vector<int> result;\n        string minTimestamp, maxTimestamp;\n        int granularitySize[] = {4, 7, 10, 13, 16, 19};\n        map<string, int> granularityMap = {{\"Year\", 0}, {\"Month\", 1}, {\"Day\", 2}, {\"Hour\", 3}, {\"Minute\", 4}, {\"Second\", 5}};\n        int substringSize = granularitySize[granularityMap[timeGranularity]];\n\n        minTimestamp = startTime.substr(0, substringSize);\n        maxTimestamp = endTime.substr(0, substringSize);\n\n        for (auto it = logEntries.begin(); it != logEntries.end(); ++it)\n        {\n            if (minTimestamp <= it->first.substr(0, substringSize) && maxTimestamp >= it->first.substr(0, substringSize))\n            {\n                result.push_back(it->second);\n            }\n        }\n        return result;\n    }\n\n  private:\n    map<string, int> logEntries;\n};",
    "output": "#include <bits/stdc++.h>\nclass LogSystem\n{\n  public:\n    LogSystem()\n    {\n    }\n\n    void putLog(int logId, std::string timestamp)\n    {\n        logEntries[timestamp]= logId;\n    }\n\n    std::vector<int> retrieveLogs(std::string startTime, std::string endTime, std::string timeGranularity)\n    {\n        std::vector<int> result;\n        std::string minTimestamp, maxTimestamp;\n        int granularitySize[]= {4, 7, 10, 13, 16, 19};\n        std::map<std::string, int> granularityMap= {{\"Year\", 0}, {\"Month\", 1}, {\"Day\", 2}, {\"Hour\", 3}, {\"Minute\", 4}, {\"Second\", 5}};\n        int substringSize= granularitySize[granularityMap[timeGranularity]];\n\n        minTimestamp= startTime.substr(0, substringSize);\n        maxTimestamp= endTime.substr(0, substringSize);\n\n        for(const auto &logEntry : logEntries)\n        {\n            if(minTimestamp <= logEntry.first.substr(0, substringSize) && maxTimestamp >= logEntry.first.substr(0, substringSize))\n            {\n                result.push_back(logEntry.second);\n            }\n        }\n        return result;\n    }\n\n  private:\n    std::map<std::string, int> logEntries;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> exclusiveTime(int functionCount, vector<string> &logs)\n{\n    vector<int> executionTime(functionCount, 0);\n    stack<int> functionStack;\n    int previousTime = 0;\n\n    for (int i = 0; i < logs.size(); ++i)\n    {\n        const auto &logEntry = logs[i];\n        auto firstColon = logEntry.find(':');\n        auto secondColon = logEntry.rfind(':');\n\n        int functionId = stoi(logEntry.substr(0, firstColon));\n        string logType = logEntry.substr(firstColon + 1, secondColon - firstColon - 1);\n        int currentTime = stoi(logEntry.substr(secondColon + 1));\n\n        if (logType == \"start\")\n        {\n            if (!functionStack.empty())\n            {\n                executionTime[functionStack.top()] += currentTime - previousTime;\n            }\n            functionStack.push(functionId);\n            previousTime = currentTime;\n        }\n        else\n        {\n            executionTime[functionStack.top()] += currentTime - previousTime + 1;\n            functionStack.pop();\n            previousTime = currentTime + 1;\n        }\n    }\n\n    return executionTime;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> exclusiveTime(int functionCount, std::vector<std::string> &logs)\n{\n    std::vector<int> executionTime(functionCount, 0);\n    std::stack<int> functionStack;\n    int previousTime= 0;\n\n    for(const auto &logEntry : logs)\n    {\n        auto firstColon= logEntry.find(':');\n        auto secondColon= logEntry.rfind(':');\n\n        int functionId= std::stoi(logEntry.substr(0, firstColon));\n        std::string logType= logEntry.substr(firstColon + 1, secondColon - firstColon - 1);\n        int currentTime= std::stoi(logEntry.substr(secondColon + 1));\n\n        if(logType == \"start\")\n        {\n            if(!functionStack.empty())\n            {\n                executionTime[functionStack.top()]+= currentTime - previousTime;\n            }\n            functionStack.push(functionId);\n            previousTime= currentTime;\n        }\n        else\n        {\n            executionTime[functionStack.top()]+= currentTime - previousTime + 1;\n            functionStack.pop();\n            previousTime= currentTime + 1;\n        }\n    }\n\n    return executionTime;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nvector<double> averageOfLevels(TreeNode *rootNode)\n{\n    vector<double> levelAverages;\n    queue<TreeNode *> nodeQueue;\n    nodeQueue.push(rootNode);\n\n    while(!nodeQueue.empty())\n    {\n        long long levelSum= 0;\n        int nodeCount= 0;\n        queue<TreeNode *> tempQueue;\n        while(!nodeQueue.empty())\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n            levelSum+= currentNode->value;\n            nodeCount++;\n            if(currentNode->leftChild)\n                tempQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                tempQueue.push(currentNode->rightChild);\n        }\n        nodeQueue= tempQueue;\n        levelAverages.push_back(static_cast<double>(levelSum) / nodeCount);\n    }\n\n    return levelAverages;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nstd::vector<double> averageOfLevels(TreeNode *rootNode)\n{\n    std::vector<double> levelAverages;\n    std::queue<TreeNode *> nodeQueue;\n    nodeQueue.push(rootNode);\n\n    while(!nodeQueue.empty())\n    {\n        long long levelSum= 0;\n        int nodeCount= 0;\n        std::queue<TreeNode *> tempQueue;\n        while(!nodeQueue.empty())\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n            levelSum+= currentNode->value;\n            nodeCount++;\n            if(currentNode->leftChild)\n                tempQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                tempQueue.push(currentNode->rightChild);\n        }\n        nodeQueue= tempQueue;\n        levelAverages.push_back(static_cast<double>(levelSum) / nodeCount);\n    }\n\n    return levelAverages;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateShoppingOffers(vector<int> &itemPrices, vector<vector<int>> &specialOffers, vector<int> &itemNeeds, int offerIndex)\n{\n    if(offerIndex == specialOffers.size())\n    {\n        int totalCost= 0;\n        for(int i= 0; i < itemNeeds.size(); ++i)\n        {\n            totalCost+= itemPrices[i] * itemNeeds[i];\n        }\n        return totalCost;\n    }\n\n    int costWithoutOffer= calculateShoppingOffers(itemPrices, specialOffers, itemNeeds, offerIndex + 1);\n    bool canApplyOffer= true;\n    for(int i= 0; i < itemNeeds.size(); ++i)\n    {\n        itemNeeds[i]-= specialOffers[offerIndex][i];\n        if(itemNeeds[i] < 0)\n            canApplyOffer= false;\n    }\n\n    int costWithOffer= INT_MAX;\n    if(canApplyOffer)\n    {\n        int offerCost= specialOffers[offerIndex][itemNeeds.size()] + calculateShoppingOffers(itemPrices, specialOffers, itemNeeds, offerIndex);\n        costWithOffer= min(costWithoutOffer, offerCost);\n    }\n\n    for(int i= 0; i < itemNeeds.size(); ++i)\n    {\n        itemNeeds[i]+= specialOffers[offerIndex][i];\n    }\n\n    return canApplyOffer ? costWithOffer : costWithoutOffer;\n}\n\nint shoppingOffers(vector<int> &itemPrices, vector<vector<int>> &specialOffers, vector<int> &itemNeeds)\n{\n    return calculateShoppingOffers(itemPrices, specialOffers, itemNeeds, 0);\n}",
    "output": "#include <bits/stdc++.h>\nint calculateShoppingOffers(std::vector<int> &itemPrices, std::vector<std::vector<int>> &specialOffers, std::vector<int> &itemNeeds, int offerIndex)\n{\n    if(offerIndex == specialOffers.size())\n    {\n        int totalCost= 0;\n        for(int i= 0; i < itemNeeds.size(); ++i)\n        {\n            totalCost+= itemPrices[i] * itemNeeds[i];\n        }\n        return totalCost;\n    }\n\n    int costWithoutOffer= calculateShoppingOffers(itemPrices, specialOffers, itemNeeds, offerIndex + 1);\n    bool canApplyOffer= true;\n    for(int i= 0; i < itemNeeds.size(); ++i)\n    {\n        itemNeeds[i]-= specialOffers[offerIndex][i];\n        if(itemNeeds[i] < 0)\n            canApplyOffer= false;\n    }\n\n    int costWithOffer= INT_MAX;\n    if(canApplyOffer)\n    {\n        int offerCost= specialOffers[offerIndex][itemNeeds.size()] + calculateShoppingOffers(itemPrices, specialOffers, itemNeeds, offerIndex);\n        costWithOffer= std::min(costWithoutOffer, offerCost);\n    }\n\n    for(int i= 0; i < itemNeeds.size(); ++i)\n    {\n        itemNeeds[i]+= specialOffers[offerIndex][i];\n    }\n\n    return canApplyOffer ? costWithOffer : costWithoutOffer;\n}\n\nint shoppingOffers(std::vector<int> &itemPrices, std::vector<std::vector<int>> &specialOffers, std::vector<int> &itemNeeds)\n{\n    return calculateShoppingOffers(itemPrices, specialOffers, itemNeeds, 0);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numDecodings(const string &encodedString)\n{\n    const int modulus = 1e9 + 7;\n    int stringLength = encodedString.size();\n    vector<long long> decodingWays(stringLength + 1, 0);\n    decodingWays[0] = 1;\n    decodingWays[1] = encodedString[0] == '*' ? 9 : (encodedString[0] == '0' ? 0 : 1);\n\n    for(int index = 2; index <= stringLength; ++index)\n    {\n        if(encodedString[index - 1] == '*')\n        {\n            decodingWays[index] = 9 * decodingWays[index - 1];\n            if(encodedString[index - 2] == '1')\n                decodingWays[index] += 9 * decodingWays[index - 2];\n            else if(encodedString[index - 2] == '2')\n                decodingWays[index] += 6 * decodingWays[index - 2];\n            else if(encodedString[index - 2] == '*')\n                decodingWays[index] += 15 * decodingWays[index - 2];\n        }\n        else\n        {\n            decodingWays[index] = (encodedString[index - 1] != '0') ? decodingWays[index - 1] : 0;\n            int twoDigitNumber = stoi(encodedString.substr(index - 2, 2));\n            if(encodedString[index - 2] == '1' || (encodedString[index - 2] == '2' && twoDigitNumber <= 26))\n                decodingWays[index] += decodingWays[index - 2];\n            else if(encodedString[index - 2] == '*')\n                decodingWays[index] += (twoDigitNumber <= 26 && twoDigitNumber >= 10) ? 2 * decodingWays[index - 2] : decodingWays[index - 2];\n        }\n        decodingWays[index] %= modulus;\n    }\n    return decodingWays[stringLength];\n}",
    "output": "int numDecodings(const std::string &encodedString)\n{\n    const int modulus= 1e9 + 7;\n    int stringLength= encodedString.size();\n    std::vector<long long> decodingWays(stringLength + 1, 0);\n    decodingWays[0]= 1;\n    decodingWays[1]= encodedString[0] == '*' ? 9 : (encodedString[0] == '0' ? 0 : 1);\n\n    for(int index= 2; index <= stringLength; ++index)\n    {\n        if(encodedString[index - 1] == '*')\n        {\n            decodingWays[index]= 9 * decodingWays[index - 1];\n            if(encodedString[index - 2] == '1')\n                decodingWays[index]+= 9 * decodingWays[index - 2];\n            else if(encodedString[index - 2] == '2')\n                decodingWays[index]+= 6 * decodingWays[index - 2];\n            else if(encodedString[index - 2] == '*')\n                decodingWays[index]+= 15 * decodingWays[index - 2];\n        }\n        else\n        {\n            decodingWays[index]= (encodedString[index - 1] != '0') ? decodingWays[index - 1] : 0;\n            int twoDigitNumber= std::stoi(encodedString.substr(index - 2, 2));\n            if(encodedString[index - 2] == '1' || (encodedString[index - 2] == '2' && twoDigitNumber <= 26))\n                decodingWays[index]+= decodingWays[index - 2];\n            else if(encodedString[index - 2] == '*')\n                decodingWays[index]+= (twoDigitNumber <= 26 && twoDigitNumber >= 10) ? 2 * decodingWays[index - 2] : decodingWays[index - 2];\n        }\n        decodingWays[index]%= modulus;\n    }\n    return decodingWays[stringLength];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring solveEquation(string equation)\n{\n    int coefficient= 0, value= 0, leftSide= 1, operation= 1;\n    istringstream inputStream(equation + \"+\");\n    char operatorChar;\n    int number;\n    string variable;\n    while(inputStream >> operatorChar)\n    {\n        if(operatorChar == '=')\n        {\n            leftSide= -1;\n            operation= 1;\n        }\n        else\n        {\n            inputStream >> number >> variable;\n            (variable.size() == 0 ? value : coefficient)+= (operatorChar == '+' ? 1 : -1) * leftSide * operation * number;\n            operation= variable.size();\n        }\n    }\n\n    if(coefficient == 0)\n    {\n        return value == 0 ? \"Infinite solutions\" : \"No solution\";\n    }\n    else\n    {\n        return \"x=\" + to_string(-value / coefficient);\n    }\n}",
    "output": "#include <bits/stdc++.h>\nstd::string solveEquation(std::string equation)\n{\n    int coefficient= 0, value= 0, leftSide= 1, operation= 1;\n    std::istringstream inputStream(equation + \"+\");\n    char operatorChar;\n    int number;\n    std::string variable;\n    while(inputStream >> operatorChar)\n    {\n        if(operatorChar == '=')\n        {\n            leftSide= -1;\n            operation= 1;\n        }\n        else\n        {\n            inputStream >> number >> variable;\n            (variable.size() == 0 ? value : coefficient)+= (operatorChar == '+' ? 1 : -1) * leftSide * operation * number;\n            operation= variable.size();\n        }\n    }\n\n    if(coefficient == 0)\n    {\n        return value == 0 ? \"Infinite solutions\" : \"No solution\";\n    }\n    else\n    {\n        return \"x=\" + std::to_string(-value / coefficient);\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass MyCircularDeque\n{\n    vector<int> buffer;\n    int frontIndex, rearIndex, capacity;\n\n  public:\n    MyCircularDeque(int cap)\n    {\n        buffer.resize(cap);\n        frontIndex= -1;\n        rearIndex= 0;\n        capacity= cap;\n    }\n\n    bool insertFront(int val)\n    {\n        if(isFull())\n        {\n            return false;\n        }\n        if(frontIndex == -1)\n        {\n            frontIndex= 0;\n        }\n        else\n        {\n            frontIndex= (frontIndex - 1 + capacity) % capacity;\n        }\n        buffer[frontIndex]= val;\n        return true;\n    }\n\n    bool insertLast(int val)\n    {\n        if(isFull())\n        {\n            return false;\n        }\n        buffer[rearIndex]= val;\n        rearIndex= (rearIndex + 1) % capacity;\n        if(frontIndex == -1)\n        {\n            frontIndex= 0;\n        }\n        return true;\n    }\n\n    bool deleteFront()\n    {\n        if(isEmpty())\n        {\n            return false;\n        }\n        if(frontIndex == rearIndex - 1)\n        {\n            frontIndex= -1;\n        }\n        else\n        {\n            frontIndex= (frontIndex + 1) % capacity;\n        }\n        return true;\n    }\n\n    bool deleteLast()\n    {\n        if(isEmpty())\n        {\n            return false;\n        }\n        if(frontIndex == rearIndex - 1)\n        {\n            rearIndex= 0;\n            frontIndex= -1;\n        }\n        else\n        {\n            rearIndex= (rearIndex - 1 + capacity) % capacity;\n        }\n        return true;\n    }\n\n    int getFront()\n    {\n        if(isEmpty())\n        {\n            return -1;\n        }\n        return buffer[frontIndex];\n    }\n\n    int getRear()\n    {\n        if(isEmpty())\n        {\n            return -1;\n        }\n        return buffer[(rearIndex - 1 + capacity) % capacity];\n    }\n\n    bool isEmpty()\n    {\n        return frontIndex == -1;\n    }\n\n    bool isFull()\n    {\n        return frontIndex == rearIndex;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass MyCircularDeque\n{\n    std::vector<int> buffer;\n    int frontIndex, rearIndex, capacity;\n\npublic:\n    MyCircularDeque(int cap)\n    {\n        buffer.resize(cap);\n        frontIndex= -1;\n        rearIndex= 0;\n        capacity= cap;\n    }\n\n    bool insertFront(int val)\n    {\n        if(isFull())\n        {\n            return false;\n        }\n        if(frontIndex == -1)\n        {\n            frontIndex= 0;\n        }\n        else\n        {\n            frontIndex= (frontIndex - 1 + capacity) % capacity;\n        }\n        buffer[frontIndex]= val;\n        return true;\n    }\n\n    bool insertLast(int val)\n    {\n        if(isFull())\n        {\n            return false;\n        }\n        buffer[rearIndex]= val;\n        rearIndex= (rearIndex + 1) % capacity;\n        if(frontIndex == -1)\n        {\n            frontIndex= 0;\n        }\n        return true;\n    }\n\n    bool deleteFront()\n    {\n        if(isEmpty())\n        {\n            return false;\n        }\n        if(frontIndex == rearIndex - 1)\n        {\n            frontIndex= -1;\n        }\n        else\n        {\n            frontIndex= (frontIndex + 1) % capacity;\n        }\n        return true;\n    }\n\n    bool deleteLast()\n    {\n        if(isEmpty())\n        {\n            return false;\n        }\n        if(frontIndex == rearIndex - 1)\n        {\n            rearIndex= 0;\n            frontIndex= -1;\n        }\n        else\n        {\n            rearIndex= (rearIndex - 1 + capacity) % capacity;\n        }\n        return true;\n    }\n\n    int getFront()\n    {\n        if(isEmpty())\n        {\n            return -1;\n        }\n        return buffer[frontIndex];\n    }\n\n    int getRear()\n    {\n        if(isEmpty())\n        {\n            return -1;\n        }\n        return buffer[(rearIndex - 1 + capacity) % capacity];\n    }\n\n    bool isEmpty()\n    {\n        return frontIndex == -1;\n    }\n\n    bool isFull()\n    {\n        return frontIndex == rearIndex;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass AutocompleteSystem\n{\n    struct TrieNode\n    {\n        unordered_map<char, TrieNode *> children;\n        string sentence;\n        int frequency;\n        TrieNode() : frequency(0) {}\n    };\n\n    void insert(const string &sentence, int times)\n    {\n        TrieNode *currentNode = root;\n        for (char character : sentence)\n        {\n            if (!currentNode->children[character])\n            {\n                currentNode->children[character] = new TrieNode();\n            }\n            currentNode = currentNode->children[character];\n        }\n        currentNode->frequency += times;\n        currentNode->sentence = sentence;\n    }\n\n    struct Comparator\n    {\n        bool operator()(const TrieNode *a, const TrieNode *b) const\n        {\n            if (a->frequency == b->frequency)\n            {\n                return a->sentence > b->sentence;\n            }\n            return a->frequency < b->frequency;\n        }\n    };\n\n    TrieNode *root;\n    TrieNode *currentNode;\n    string searchTerm;\n\npublic:\n    AutocompleteSystem(vector<string> &sentences, vector<int> &times)\n    {\n        root = new TrieNode();\n        for (int i = 0; i < sentences.size(); ++i)\n        {\n            insert(sentences[i], times[i]);\n        }\n        currentNode = root;\n    }\n\n    vector<string> input(char character)\n    {\n        if (character == '#')\n        {\n            insert(searchTerm, 1);\n            searchTerm = \"\";\n            currentNode = root;\n            return {};\n        }\n        searchTerm += character;\n        if (!currentNode)\n        {\n            return {};\n        }\n        currentNode = currentNode->children[character];\n        if (!currentNode)\n        {\n            return {};\n        }\n        priority_queue<TrieNode *, vector<TrieNode *>, Comparator> priorityQueue;\n        for (auto it = currentNode->children.begin(); it != currentNode->children.end(); ++it)\n        {\n            char characterKey = it->first;\n            TrieNode *node = it->second;\n            if (node->frequency)\n            {\n                priorityQueue.push(node);\n            }\n        }\n\n        vector<string> results;\n        while (!priorityQueue.empty() && results.size() < 3)\n        {\n            results.push_back(priorityQueue.top()->sentence);\n            priorityQueue.pop();\n        }\n        return results;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass AutocompleteSystem\n{\n    struct TrieNode\n    {\n        std::unordered_map<char, TrieNode *> children;\n        std::string sentence;\n        int frequency;\n        TrieNode() : frequency(0) {}\n    };\n\n    void insert(const std::string &sentence, int times)\n    {\n        TrieNode *currentNode= root;\n        for(char character : sentence)\n        {\n            if(!currentNode->children[character])\n            {\n                currentNode->children[character]= new TrieNode();\n            }\n            currentNode= currentNode->children[character];\n        }\n        currentNode->frequency+= times;\n        currentNode->sentence= sentence;\n    }\n\n    struct Comparator\n    {\n        bool operator()(const TrieNode *a, const TrieNode *b) const\n        {\n            if(a->frequency == b->frequency)\n            {\n                return a->sentence > b->sentence;\n            }\n            return a->frequency < b->frequency;\n        }\n    };\n\n    TrieNode *root;\n    TrieNode *currentNode;\n    std::string searchTerm;\n\n  public:\n    AutocompleteSystem(std::vector<std::string> &sentences, std::vector<int> &times)\n    {\n        root= new TrieNode();\n        for(int i= 0; i < sentences.size(); ++i)\n        {\n            insert(sentences[i], times[i]);\n        }\n        currentNode= root;\n    }\n\n    std::vector<std::string> input(char character)\n    {\n        if(character == '#')\n        {\n            insert(searchTerm, 1);\n            searchTerm= \"\";\n            currentNode= root;\n            return {};\n        }\n        searchTerm+= character;\n        if(!currentNode)\n        {\n            return {};\n        }\n        currentNode= currentNode->children[character];\n        if(!currentNode)\n        {\n            return {};\n        }\n        std::priority_queue<TrieNode *, std::vector<TrieNode *>, Comparator> priorityQueue;\n        for(auto &[characterKey, node] : currentNode->children)\n        {\n            if(node->frequency)\n            {\n                priorityQueue.push(node);\n            }\n        }\n\n        std::vector<std::string> results;\n        while(!priorityQueue.empty() && results.size() < 3)\n        {\n            results.push_back(priorityQueue.top()->sentence);\n            priorityQueue.pop();\n        }\n        return results;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble findMaxAverage(vector<int> &numberList, int subarraySize)\n{\n    int totalNumbers= numberList.size();\n    double currentSum= 0;\n    for(int index= 0; index < subarraySize; ++index)\n    {\n        currentSum+= numberList[index];\n    }\n    double maximumAverage= currentSum / subarraySize;\n    for(int index= subarraySize; index < totalNumbers; ++index)\n    {\n        currentSum= currentSum - numberList[index - subarraySize] + numberList[index];\n        maximumAverage= max(maximumAverage, currentSum / subarraySize);\n    }\n    return maximumAverage;\n}",
    "output": "#include <bits/stdc++.h>\ndouble findMaxAverage(std::vector<int> &numberList, int subarraySize)\n{\n    int totalNumbers= numberList.size();\n    double currentSum= 0;\n    for(int index= 0; index < subarraySize; ++index)\n    {\n        currentSum+= numberList[index];\n    }\n    double maximumAverage= currentSum / subarraySize;\n    for(int index= subarraySize; index < totalNumbers; ++index)\n    {\n        currentSum= currentSum - numberList[index - subarraySize] + numberList[index];\n        maximumAverage= std::max(maximumAverage, currentSum / subarraySize);\n    }\n    return maximumAverage;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble findMaxAverage(vector<int> &numbers, int subarraySize)\n{\n    long totalSum= 0;\n    int totalNumbers= numbers.size();\n    for(int index= 0; index < subarraySize; index++)\n    {\n        totalSum+= numbers[index];\n    }\n\n    double maximumAverage= static_cast<double>(totalSum) / subarraySize;\n\n    for(int index= subarraySize; index < totalNumbers; index++)\n    {\n        totalSum+= numbers[index] - numbers[index - subarraySize];\n        maximumAverage= max(maximumAverage, static_cast<double>(totalSum) / subarraySize);\n    }\n\n    return maximumAverage;\n}",
    "output": "#include <bits/stdc++.h>\ndouble findMaxAverage(std::vector<int> &numbers, int subarraySize)\n{\n    long totalSum= 0;\n    int totalNumbers= numbers.size();\n    for(int index= 0; index < subarraySize; index++)\n    {\n        totalSum+= numbers[index];\n    }\n\n    double maximumAverage= static_cast<double>(totalSum) / subarraySize;\n\n    for(int index= subarraySize; index < totalNumbers; index++)\n    {\n        totalSum+= numbers[index] - numbers[index - subarraySize];\n        maximumAverage= std::max(maximumAverage, static_cast<double>(totalSum) / subarraySize);\n    }\n\n    return maximumAverage;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findErrorNums(vector<int> &numbers)\n{\n    vector<int> errorNumbers;\n    for(int index= 0; index < numbers.size(); index++)\n    {\n        int valueIndex= abs(numbers[index]) - 1;\n        if(numbers[valueIndex] > 0)\n        {\n            numbers[valueIndex]= -numbers[valueIndex];\n        }\n        else\n        {\n            errorNumbers.push_back(valueIndex + 1);\n        }\n    }\n    for(int index= 0; index < numbers.size(); index++)\n    {\n        if(numbers[index] > 0)\n        {\n            errorNumbers.push_back(index + 1);\n            break;\n        }\n    }\n    return errorNumbers;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findErrorNums(std::vector<int> &numbers)\n{\n    std::vector<int> errorNumbers;\n    for(int index= 0; index < numbers.size(); index++)\n    {\n        int valueIndex= abs(numbers[index]) - 1;\n        if(numbers[valueIndex] > 0)\n        {\n            numbers[valueIndex]= -numbers[valueIndex];\n        }\n        else\n        {\n            errorNumbers.push_back(valueIndex + 1);\n        }\n    }\n    for(int index= 0; index < numbers.size(); index++)\n    {\n        if(numbers[index] > 0)\n        {\n            errorNumbers.push_back(index + 1);\n            break;\n        }\n    }\n    return errorNumbers;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findLongestChain(vector<vector<int>> &pairs)\n{\n    sort(pairs.begin(), pairs.end(), [](const vector<int> &firstPair, const vector<int> &secondPair)\n              { return firstPair[1] < secondPair[1]; });\n\n    int maxChainLength = 0, lastRightEndpoint = INT_MIN;\n    for (int i = 0; i < pairs.size(); ++i)\n    {\n        const auto &currentPair = pairs[i];\n        if (currentPair[0] > lastRightEndpoint)\n        {\n            lastRightEndpoint = currentPair[1];\n            maxChainLength++;\n        }\n    }\n\n    return maxChainLength;\n}",
    "output": "#include <bits/stdc++.h>\nint findLongestChain(std::vector<std::vector<int>> &pairs)\n{\n    std::sort(pairs.begin(), pairs.end(), [](const std::vector<int> &firstPair, const std::vector<int> &secondPair)\n              { return firstPair[1] < secondPair[1]; });\n\n    int maxChainLength= 0, lastRightEndpoint= INT_MIN;\n    for(const auto &currentPair : pairs)\n    {\n        if(currentPair[0] > lastRightEndpoint)\n        {\n            lastRightEndpoint= currentPair[1];\n            maxChainLength++;\n        }\n    }\n\n    return maxChainLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "using namespace std;\n\nint countPalindromicSubstrings(string inputString)\n{\n    int stringLength = inputString.size(), palindromeCount = 0;\n    for(int centerIndex = 0; centerIndex < 2 * stringLength - 1; ++centerIndex)\n    {\n        int leftIndex = centerIndex / 2;\n        int rightIndex = leftIndex + centerIndex % 2;\n        while(leftIndex >= 0 && rightIndex < stringLength && inputString[leftIndex] == inputString[rightIndex])\n        {\n            ++palindromeCount;\n            --leftIndex;\n            ++rightIndex;\n        }\n    }\n    return palindromeCount;\n}",
    "output": "int countPalindromicSubstrings(std::string inputString)\n{\n    int stringLength= inputString.size(), palindromeCount= 0;\n    for(int centerIndex= 0; centerIndex < 2 * stringLength - 1; ++centerIndex)\n    {\n        int leftIndex= centerIndex / 2;\n        int rightIndex= leftIndex + centerIndex % 2;\n        while(leftIndex >= 0 && rightIndex < stringLength && inputString[leftIndex] == inputString[rightIndex])\n        {\n            ++palindromeCount;\n            --leftIndex;\n            ++rightIndex;\n        }\n    }\n    return palindromeCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring replaceWords(vector<string> &dictionary, string sentence)\n{\n    unordered_set<string> roots(dictionary.begin(), dictionary.end());\n    istringstream inputStream(sentence);\n    string currentWord, resultString;\n\n    while(inputStream >> currentWord)\n    {\n        string prefix;\n        for(int index= 1; index <= currentWord.length(); ++index)\n        {\n            prefix= currentWord.substr(0, index);\n            if(roots.count(prefix))\n            {\n                break;\n            }\n        }\n        resultString+= prefix + \" \";\n    }\n    resultString.pop_back();\n    return resultString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string replaceWords(std::vector<std::string> &dictionary, std::string sentence)\n{\n    std::unordered_set<std::string> roots(dictionary.begin(), dictionary.end());\n    std::istringstream inputStream(sentence);\n    std::string currentWord, resultString;\n\n    while(inputStream >> currentWord)\n    {\n        std::string prefix;\n        for(int index= 1; index <= currentWord.length(); ++index)\n        {\n            prefix= currentWord.substr(0, index);\n            if(roots.count(prefix))\n            {\n                break;\n            }\n        }\n        resultString+= prefix + \" \";\n    }\n    resultString.pop_back();\n    return resultString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring predictPartyVictory(string senate)\n{\n    queue<int> radiantQueue, direQueue;\n    int senateSize = senate.size();\n\n    for(int i = 0; i < senateSize; i++)\n    {\n        if(senate[i] == 'R')\n            radiantQueue.push(i);\n        else\n            direQueue.push(i);\n    }\n\n    while(!radiantQueue.empty() && !direQueue.empty())\n    {\n        int radiantIndex = radiantQueue.front();\n        int direIndex = direQueue.front();\n        radiantQueue.pop();\n        direQueue.pop();\n\n        if(radiantIndex < direIndex)\n            radiantQueue.push(radiantIndex + senateSize);\n        else\n            direQueue.push(direIndex + senateSize);\n    }\n\n    return radiantQueue.empty() ? \"Dire\" : \"Radiant\";\n}",
    "output": "#include <bits/stdc++.h>\nstd::string predictPartyVictory(std::string senate)\n{\n    std::queue<int> radiantQueue, direQueue;\n    int senateSize= senate.size();\n\n    for(int i= 0; i < senateSize; i++)\n    {\n        if(senate[i] == 'R')\n            radiantQueue.push(i);\n        else\n            direQueue.push(i);\n    }\n\n    while(!radiantQueue.empty() && !direQueue.empty())\n    {\n        int radiantIndex= radiantQueue.front();\n        int direIndex= direQueue.front();\n        radiantQueue.pop();\n        direQueue.pop();\n\n        if(radiantIndex < direIndex)\n            radiantQueue.push(radiantIndex + senateSize);\n        else\n            direQueue.push(direIndex + senateSize);\n    }\n\n    return radiantQueue.empty() ? \"Dire\" : \"Radiant\";\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int minSteps(int inputNumber)\n{\n    int totalSteps= 0;\n    for(int currentDivisor= 2; currentDivisor <= inputNumber; ++currentDivisor)\n    {\n        while(inputNumber % currentDivisor == 0)\n        {\n            totalSteps+= currentDivisor;\n            inputNumber/= currentDivisor;\n        }\n    }\n    return totalSteps;\n}",
    "output": "int minSteps(int inputNumber)\n{\n    int totalSteps= 0;\n    for(int currentDivisor= 2; currentDivisor <= inputNumber; ++currentDivisor)\n    {\n        while(inputNumber % currentDivisor == 0)\n        {\n            totalSteps+= currentDivisor;\n            inputNumber/= currentDivisor;\n        }\n    }\n    return totalSteps;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxA(int total)\n{\n    vector<int> dynamicProgramming(total + 1);\n    for(int current= 1; current <= total; ++current)\n    {\n        dynamicProgramming[current]= current;\n        for(int previous= 1; previous <= current - 3; ++previous)\n            dynamicProgramming[current]= max(dynamicProgramming[current], dynamicProgramming[previous] * (current - previous - 1));\n    }\n    return dynamicProgramming[total];\n}",
    "output": "#include <bits/stdc++.h>\nint maxA(int total)\n{\n    std::vector<int> dynamicProgramming(total + 1);\n    for(int current= 1; current <= total; ++current)\n    {\n        dynamicProgramming[current]= current;\n        for(int previous= 1; previous <= current - 3; ++previous)\n            dynamicProgramming[current]= std::max(dynamicProgramming[current], dynamicProgramming[previous] * (current - previous - 1));\n    }\n    return dynamicProgramming[total];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nstring findDuplicateSubtreesHelper(TreeNode *currentNode, unordered_map<string, int> &subtreeCount, vector<TreeNode *> &duplicateSubtrees)\n{\n    if(!currentNode)\n        return \"\";\n    string subtreeRepresentation= to_string(currentNode->value) + \",\" + findDuplicateSubtreesHelper(currentNode->leftChild, subtreeCount, duplicateSubtrees) + \",\" + findDuplicateSubtreesHelper(currentNode->rightChild, subtreeCount, duplicateSubtrees);\n    if(++subtreeCount[subtreeRepresentation] == 2)\n    {\n        duplicateSubtrees.push_back(currentNode);\n    }\n    return subtreeRepresentation;\n}\n\nvector<TreeNode *> findDuplicateSubtrees(TreeNode *rootNode)\n{\n    unordered_map<string, int> subtreeCount;\n    vector<TreeNode *> duplicateSubtrees;\n    findDuplicateSubtreesHelper(rootNode, subtreeCount, duplicateSubtrees);\n    return duplicateSubtrees;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nstd::string findDuplicateSubtreesHelper(TreeNode *currentNode, std::unordered_map<std::string, int> &subtreeCount, std::vector<TreeNode *> &duplicateSubtrees)\n{\n    if(!currentNode)\n        return \"\";\n    std::string subtreeRepresentation = std::to_string(currentNode->value) + \",\" + findDuplicateSubtreesHelper(currentNode->leftChild, subtreeCount, duplicateSubtrees) + \",\" + findDuplicateSubtreesHelper(currentNode->rightChild, subtreeCount, duplicateSubtrees);\n    if(++subtreeCount[subtreeRepresentation] == 2)\n    {\n        duplicateSubtrees.push_back(currentNode);\n    }\n    return subtreeRepresentation;\n}\n\nstd::vector<TreeNode *> findDuplicateSubtrees(TreeNode *rootNode)\n{\n    std::unordered_map<std::string, int> subtreeCount;\n    std::vector<TreeNode *> duplicateSubtrees;\n    findDuplicateSubtreesHelper(rootNode, subtreeCount, duplicateSubtrees);\n    return duplicateSubtrees;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Assuming TreeNode is defined elsewhere\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nbool findTarget(TreeNode *rootNode, int targetSum)\n{\n    unordered_set<int> nodeValues;\n    return findNode(rootNode, targetSum, nodeValues);\n}\n\nbool findNode(TreeNode *rootNode, int targetSum, unordered_set<int> &nodeValues)\n{\n    if(!rootNode)\n        return false;\n    if(nodeValues.count(targetSum - rootNode->val))\n        return true;\n    nodeValues.insert(rootNode->val);\n    return findNode(rootNode->left, targetSum, nodeValues) || findNode(rootNode->right, targetSum, nodeValues);\n}",
    "output": "#include <bits/stdc++.h>\n// Assuming TreeNode is defined elsewhere\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nbool findTarget(TreeNode *rootNode, int targetSum)\n{\n    std::unordered_set<int> nodeValues;\n    return findNode(rootNode, targetSum, nodeValues);\n}\n\nbool findNode(TreeNode *rootNode, int targetSum, std::unordered_set<int> &nodeValues)\n{\n    if(!rootNode)\n        return false;\n    if(nodeValues.count(targetSum - rootNode->val))\n        return true;\n    nodeValues.insert(rootNode->val);\n    return findNode(rootNode->left, targetSum, nodeValues) || findNode(rootNode->right, targetSum, nodeValues);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nTreeNode *helper(vector<int> &numberArray, int leftIndex, int rightIndex);\n\nTreeNode *constructMaximumBinaryTree(vector<int> &numberArray)\n{\n    return helper(numberArray, 0, numberArray.size() - 1);\n}\n\nTreeNode *helper(vector<int> &numberArray, int leftIndex, int rightIndex)\n{\n    if(leftIndex > rightIndex)\n    {\n        return NULL;\n    }\n\n    int maxIndex= leftIndex;\n    for(int i= leftIndex + 1; i <= rightIndex; i++)\n    {\n        if(numberArray[i] > numberArray[maxIndex])\n        {\n            maxIndex= i;\n        }\n    }\n\n    TreeNode *rootNode= new TreeNode(numberArray[maxIndex]);\n    rootNode->leftChild= helper(numberArray, leftIndex, maxIndex - 1);\n    rootNode->rightChild= helper(numberArray, maxIndex + 1, rightIndex);\n    return rootNode;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nTreeNode *constructMaximumBinaryTree(std::vector<int> &numberArray)\n{\n    return helper(numberArray, 0, numberArray.size() - 1);\n}\n\nTreeNode *helper(std::vector<int> &numberArray, int leftIndex, int rightIndex)\n{\n    if(leftIndex > rightIndex)\n    {\n        return NULL;\n    }\n\n    int maxIndex= leftIndex;\n    for(int i= leftIndex + 1; i <= rightIndex; i++)\n    {\n        if(numberArray[i] > numberArray[maxIndex])\n        {\n            maxIndex= i;\n        }\n    }\n\n    TreeNode *rootNode= new TreeNode(numberArray[maxIndex]);\n    rootNode->leftChild= helper(numberArray, leftIndex, maxIndex - 1);\n    rootNode->rightChild= helper(numberArray, maxIndex + 1, rightIndex);\n    return rootNode;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int Value;\n    TreeNode *LeftChild;\n    TreeNode *RightChild;\n    TreeNode(int x) : Value(x), LeftChild(NULL), RightChild(NULL) {}\n};\n\nvector<vector<string>> printTree(TreeNode *rootNode)\n{\n    if(!rootNode)\n        return {{}};\n\n    // Calculate Depth\n    int treeDepth= 0;\n    queue<TreeNode *> nodeQueue;\n    nodeQueue.push(rootNode);\n    while(!nodeQueue.empty())\n    {\n        int currentLevelSize= nodeQueue.size();\n        treeDepth++;\n        for(int i= 0; i < currentLevelSize; i++)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n            if(currentNode->LeftChild)\n                nodeQueue.push(currentNode->LeftChild);\n            if(currentNode->RightChild)\n                nodeQueue.push(currentNode->RightChild);\n        }\n    }\n\n    // Initialize matrix\n    vector<vector<string>> result(treeDepth, vector<string>((1 << treeDepth) - 1, \"\"));\n\n    // Fill in matrix\n    nodeQueue.push(rootNode);\n    int currentLevel= 0;\n    int positionStep= (1 << (treeDepth - 1));\n    while(!nodeQueue.empty())\n    {\n        int currentLevelSize= nodeQueue.size();\n        int currentPosition= positionStep - 1;\n        for(int i= 0; i < currentLevelSize; i++)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n            result[currentLevel][currentPosition]= to_string(currentNode->Value);\n            currentPosition+= (positionStep << 1);\n            if(currentNode->LeftChild)\n                nodeQueue.push(currentNode->LeftChild);\n            if(currentNode->RightChild)\n                nodeQueue.push(currentNode->RightChild);\n        }\n        positionStep>>= 1;\n        currentLevel++;\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int Value;\n    TreeNode *LeftChild;\n    TreeNode *RightChild;\n    TreeNode(int x) : Value(x), LeftChild(NULL), RightChild(NULL) {}\n};\n\nstd::vector<std::vector<std::string>> printTree(TreeNode *rootNode)\n{\n    if(!rootNode)\n        return {{}};\n\n    // Calculate Depth\n    int treeDepth= 0;\n    std::queue<TreeNode *> nodeQueue;\n    nodeQueue.push(rootNode);\n    while(!nodeQueue.empty())\n    {\n        int currentLevelSize= nodeQueue.size();\n        treeDepth++;\n        for(int i= 0; i < currentLevelSize; i++)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n            if(currentNode->LeftChild)\n                nodeQueue.push(currentNode->LeftChild);\n            if(currentNode->RightChild)\n                nodeQueue.push(currentNode->RightChild);\n        }\n    }\n\n    // Initialize matrix\n    std::vector<std::vector<std::string>> result(treeDepth, std::vector<std::string>((1 << treeDepth) - 1, \"\"));\n\n    // Fill in matrix\n    nodeQueue.push(rootNode);\n    int currentLevel= 0;\n    int positionStep= (1 << (treeDepth - 1));\n    while(!nodeQueue.empty())\n    {\n        int currentLevelSize= nodeQueue.size();\n        int currentPosition= positionStep - 1;\n        for(int i= 0; i < currentLevelSize; i++)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n            result[currentLevel][currentPosition]= std::to_string(currentNode->Value);\n            currentPosition+= (positionStep << 1);\n            if(currentNode->LeftChild)\n                nodeQueue.push(currentNode->LeftChild);\n            if(currentNode->RightChild)\n                nodeQueue.push(currentNode->RightChild);\n        }\n        positionStep>>= 1;\n        currentLevel++;\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> cheapestJump(vector<int> &coinValues, int maxJumpDistance)\n{\n    int numberOfCoins= coinValues.size();\n    vector<int> minimumCost(numberOfCoins, 1e9), parentIndex(numberOfCoins, -1);\n    minimumCost[0]= coinValues[0];\n    for(int currentIndex= 0; currentIndex < numberOfCoins; ++currentIndex)\n    {\n        if(coinValues[currentIndex] == -1)\n            continue;\n        for(int jumpDistance= 1; jumpDistance <= maxJumpDistance && currentIndex + jumpDistance < numberOfCoins; ++jumpDistance)\n        {\n            int nextIndex= currentIndex + jumpDistance;\n            int cost= coinValues[nextIndex] + minimumCost[currentIndex];\n            if(cost < minimumCost[nextIndex])\n            {\n                minimumCost[nextIndex]= cost;\n                parentIndex[nextIndex]= currentIndex;\n            }\n        }\n    }\n    vector<int> result;\n    if(minimumCost[numberOfCoins - 1] == 1e9)\n        return result;\n    int currentPosition= numberOfCoins - 1;\n    while(currentPosition != -1)\n    {\n        result.push_back(currentPosition + 1);\n        currentPosition= parentIndex[currentPosition];\n    }\n    reverse(result.begin(), result.end());\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\n// Needed for std::reverse\n\nstd::vector<int> cheapestJump(std::vector<int> &coinValues, int maxJumpDistance)\n{\n    int numberOfCoins= coinValues.size();\n    std::vector<int> minimumCost(numberOfCoins, 1e9), parentIndex(numberOfCoins, -1);\n    minimumCost[0]= coinValues[0];\n    for(int currentIndex= 0; currentIndex < numberOfCoins; ++currentIndex)\n    {\n        if(coinValues[currentIndex] == -1)\n            continue;\n        for(int jumpDistance= 1; jumpDistance <= maxJumpDistance && currentIndex + jumpDistance < numberOfCoins; ++jumpDistance)\n        {\n            int nextIndex= currentIndex + jumpDistance;\n            int cost= coinValues[nextIndex] + minimumCost[currentIndex];\n            if(cost < minimumCost[nextIndex])\n            {\n                minimumCost[nextIndex]= cost;\n                parentIndex[nextIndex]= currentIndex;\n            }\n        }\n    }\n    std::vector<int> result;\n    if(minimumCost[numberOfCoins - 1] == 1e9)\n        return result;\n    int currentPosition= numberOfCoins - 1;\n    while(currentPosition != -1)\n    {\n        result.push_back(currentPosition + 1);\n        currentPosition= parentIndex[currentPosition];\n    }\n    std::reverse(result.begin(), result.end());\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool judgeCircle(string moves)\n{\n    int horizontalPosition = 0, verticalPosition = 0;\n    for (int i = 0; i < moves.size(); ++i)\n    {\n        char move = moves[i];\n        if (move == 'U')\n            verticalPosition++;\n        else if (move == 'D')\n            verticalPosition--;\n        else if (move == 'R')\n            horizontalPosition++;\n        else if (move == 'L')\n            horizontalPosition--;\n    }\n    return horizontalPosition == 0 && verticalPosition == 0;\n}",
    "output": "#include <bits/stdc++.h>\nbool judgeCircle(std::string moves)\n{\n    int horizontalPosition= 0, verticalPosition= 0;\n    for(char move : moves)\n    {\n        if(move == 'U')\n            verticalPosition++;\n        else if(move == 'D')\n            verticalPosition--;\n        else if(move == 'R')\n            horizontalPosition++;\n        else if(move == 'L')\n            horizontalPosition--;\n    }\n    return horizontalPosition == 0 && verticalPosition == 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findClosestElements(vector<int> &sortedArray, int numberOfElements, int targetValue)\n{\n    int leftIndex= 0;\n    int rightIndex= sortedArray.size() - numberOfElements;\n\n    while(leftIndex < rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(targetValue - sortedArray[midIndex] > sortedArray[midIndex + numberOfElements] - targetValue)\n        {\n            leftIndex= midIndex + 1;\n        }\n        else\n        {\n            rightIndex= midIndex;\n        }\n    }\n\n    return vector<int>(sortedArray.begin() + leftIndex, sortedArray.begin() + leftIndex + numberOfElements);\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findClosestElements(std::vector<int> &sortedArray, int numberOfElements, int targetValue)\n{\n    int leftIndex= 0;\n    int rightIndex= sortedArray.size() - numberOfElements;\n\n    while(leftIndex < rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(targetValue - sortedArray[midIndex] > sortedArray[midIndex + numberOfElements] - targetValue)\n        {\n            leftIndex= midIndex + 1;\n        }\n        else\n        {\n            rightIndex= midIndex;\n        }\n    }\n\n    return std::vector<int>(sortedArray.begin() + leftIndex, sortedArray.begin() + leftIndex + numberOfElements);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canSplit(vector<int> &numberList)\n{\n    vector<int> frequency(20001, 0), neededCount(20001, 0);\n    for (int i = 0; i < numberList.size(); ++i)\n        frequency[numberList[i]]++;\n    for (int i = 0; i < numberList.size(); ++i)\n    {\n        int number = numberList[i];\n        if (!frequency[number])\n            continue;\n        if (!neededCount[number - 1])\n        {\n            if (frequency[number + 1] && frequency[number + 2])\n            {\n                frequency[number]--;\n                frequency[number + 1]--;\n                frequency[number + 2]--;\n                neededCount[number + 2]++;\n            }\n            else\n                return false;\n        }\n        else\n        {\n            frequency[number]--;\n            neededCount[number - 1]--;\n            neededCount[number]++;\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool canSplit(std::vector<int> &numberList)\n{\n    std::vector<int> frequency(20001, 0), neededCount(20001, 0);\n    for(int number : numberList)\n        frequency[number]++;\n    for(int number : numberList)\n    {\n        if(!frequency[number])\n            continue;\n        if(!neededCount[number - 1])\n        {\n            if(frequency[number + 1] && frequency[number + 2])\n            {\n                frequency[number]--;\n                frequency[number + 1]--;\n                frequency[number + 2]--;\n                neededCount[number + 2]++;\n            }\n            else\n                return false;\n        }\n        else\n        {\n            frequency[number]--;\n            neededCount[number - 1]--;\n            neededCount[number]++;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int convertToBaseNine(int inputNumber)\n{\n    int convertedResult= 0, baseMultiplier= 1;\n    while(inputNumber)\n    {\n        convertedResult+= inputNumber % 9 * baseMultiplier;\n        inputNumber/= 9;\n        baseMultiplier*= 10;\n    }\n    return convertedResult;\n}",
    "output": "int convertToBaseNine(int inputNumber)\n{\n    int convertedResult= 0, baseMultiplier= 1;\n    while(inputNumber)\n    {\n        convertedResult+= inputNumber % 9 * baseMultiplier;\n        inputNumber/= 9;\n        baseMultiplier*= 10;\n    }\n    return convertedResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> imageSmoother(vector<vector<int>> &inputImage)\n{\n    int imageHeight= inputImage.size(), imageWidth= inputImage[0].size();\n    vector<vector<int>> smoothedImage(imageHeight, vector<int>(imageWidth, 0));\n\n    for(int currentRow= 0; currentRow < imageHeight; currentRow++)\n    {\n        for(int currentCol= 0; currentCol < imageWidth; currentCol++)\n        {\n            int pixelCount= 0, pixelSum= 0;\n            for(int neighborRow= currentRow - 1; neighborRow <= currentRow + 1; neighborRow++)\n            {\n                for(int neighborCol= currentCol - 1; neighborCol <= currentCol + 1; neighborCol++)\n                {\n                    if(neighborRow >= 0 && neighborRow < imageHeight && neighborCol >= 0 && neighborCol < imageWidth)\n                    {\n                        pixelSum+= inputImage[neighborRow][neighborCol];\n                        pixelCount++;\n                    }\n                }\n            }\n            smoothedImage[currentRow][currentCol]= pixelSum / pixelCount;\n        }\n    }\n\n    return smoothedImage;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> imageSmoother(std::vector<std::vector<int>> &inputImage)\n{\n    int imageHeight = inputImage.size(), imageWidth = inputImage[0].size();\n    std::vector<std::vector<int>> smoothedImage(imageHeight, std::vector<int>(imageWidth, 0));\n\n    for(int currentRow = 0; currentRow < imageHeight; currentRow++)\n    {\n        for(int currentCol = 0; currentCol < imageWidth; currentCol++)\n        {\n            int pixelCount = 0, pixelSum = 0;\n            for(int neighborRow = currentRow - 1; neighborRow <= currentRow + 1; neighborRow++)\n            {\n                for(int neighborCol = currentCol - 1; neighborCol <= currentCol + 1; neighborCol++)\n                {\n                    if(neighborRow >= 0 && neighborRow < imageHeight && neighborCol >= 0 && neighborCol < imageWidth)\n                    {\n                        pixelSum += inputImage[neighborRow][neighborCol];\n                        pixelCount++;\n                    }\n                }\n            }\n            smoothedImage[currentRow][currentCol] = pixelSum / pixelCount;\n        }\n    }\n\n    return smoothedImage;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint widthOfBinaryTree(TreeNode *root)\n{\n    if(!root)\n        return 0;\n    int maxWidth= 0;\n    queue<pair<TreeNode *, int>> nodeQueue;\n    nodeQueue.push(make_pair(root, 1));\n\n    while(!nodeQueue.empty())\n    {\n        int levelSize= nodeQueue.size();\n        int leftmostIndex= nodeQueue.front().second;\n        int rightmostIndex= leftmostIndex;\n        for(int i= 0; i < levelSize; i++)\n        {\n            TreeNode *currentNode= nodeQueue.front().first;\n            rightmostIndex= nodeQueue.front().second;\n            nodeQueue.pop();\n\n            if(currentNode->left)\n            {\n                nodeQueue.push(make_pair(currentNode->left, 2 * rightmostIndex));\n            }\n            if(currentNode->right)\n            {\n                nodeQueue.push(make_pair(currentNode->right, 2 * rightmostIndex + 1));\n            }\n        }\n        maxWidth= max(maxWidth, rightmostIndex - leftmostIndex + 1);\n    }\n    return maxWidth;\n}",
    "output": "#include <bits/stdc++.h>\nint widthOfBinaryTree(TreeNode *root)\n{\n    if(!root)\n        return 0;\n    int maxWidth= 0;\n    std::queue<std::pair<TreeNode *, int>> nodeQueue;\n    nodeQueue.push(std::make_pair(root, 1));\n\n    while(!nodeQueue.empty())\n    {\n        int levelSize= nodeQueue.size();\n        int leftmostIndex= nodeQueue.front().second;\n        int rightmostIndex= leftmostIndex;\n        for(int i= 0; i < levelSize; i++)\n        {\n            TreeNode *currentNode= nodeQueue.front().first;\n            rightmostIndex= nodeQueue.front().second;\n            nodeQueue.pop();\n\n            if(currentNode->left)\n            {\n                nodeQueue.push(std::make_pair(currentNode->left, 2 * rightmostIndex));\n            }\n            if(currentNode->right)\n            {\n                nodeQueue.push(std::make_pair(currentNode->right, 2 * rightmostIndex + 1));\n            }\n        }\n        maxWidth= std::max(maxWidth, rightmostIndex - leftmostIndex + 1);\n    }\n    return maxWidth;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    bool checkEqualTree(TreeNode *root)\n    {\n        unordered_set<int> seenSums;\n        int totalSum= calculateSum(root, seenSums);\n        if(totalSum % 2 == 0)\n        {\n            seenSums.erase(totalSum);\n            return seenSums.count(totalSum / 2);\n        }\n        return false;\n    }\n    int calculateSum(TreeNode *node, unordered_set<int> &seenSums)\n    {\n        if(!node)\n            return 0;\n        int currentSum= node->value + calculateSum(node->leftChild, seenSums) + calculateSum(node->rightChild, seenSums);\n        seenSums.insert(currentSum);\n        return currentSum;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    bool checkEqualTree(TreeNode *root)\n    {\n        std::unordered_set<int> seenSums;\n        int totalSum = calculateSum(root, seenSums);\n        if(totalSum % 2 == 0)\n        {\n            seenSums.erase(totalSum);\n            return seenSums.count(totalSum / 2);\n        }\n        return false;\n    }\n    int calculateSum(TreeNode *node, std::unordered_set<int> &seenSums)\n    {\n        if(!node)\n            return 0;\n        int currentSum = node->value + calculateSum(node->leftChild, seenSums) + calculateSum(node->rightChild, seenSums);\n        seenSums.insert(currentSum);\n        return currentSum;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint strangePrinter(string inputString)\n{\n    int stringLength= inputString.size();\n    if(stringLength == 0)\n        return 0;\n    vector<vector<int>> dynamicProgrammingTable(stringLength, vector<int>(stringLength, 0));\n\n    for(int index= 0; index < stringLength; index++)\n        dynamicProgrammingTable[index][index]= 1;\n\n    for(int length= 1; length < stringLength; length++)\n    {\n        for(int startIndex= 0; startIndex < stringLength - length; startIndex++)\n        {\n            int endIndex= startIndex + length;\n            dynamicProgrammingTable[startIndex][endIndex]= dynamicProgrammingTable[startIndex + 1][endIndex] + 1;\n            for(int kIndex= startIndex + 1; kIndex <= endIndex; kIndex++)\n            {\n                if(inputString[startIndex] == inputString[kIndex])\n                {\n                    dynamicProgrammingTable[startIndex][endIndex]= min(dynamicProgrammingTable[startIndex][endIndex], dynamicProgrammingTable[startIndex + 1][kIndex - 1] + dynamicProgrammingTable[kIndex][endIndex]);\n                }\n            }\n        }\n    }\n\n    return dynamicProgrammingTable[0][stringLength - 1];\n}",
    "output": "#include <bits/stdc++.h>\nint strangePrinter(std::string inputString)\n{\n    int stringLength= inputString.size();\n    if(stringLength == 0)\n        return 0;\n    std::vector<std::vector<int>> dynamicProgrammingTable(stringLength, std::vector<int>(stringLength, 0));\n\n    for(int index= 0; index < stringLength; index++)\n        dynamicProgrammingTable[index][index]= 1;\n\n    for(int length= 1; length < stringLength; length++)\n    {\n        for(int startIndex= 0; startIndex < stringLength - length; startIndex++)\n        {\n            int endIndex= startIndex + length;\n            dynamicProgrammingTable[startIndex][endIndex]= dynamicProgrammingTable[startIndex + 1][endIndex] + 1;\n            for(int kIndex= startIndex + 1; kIndex <= endIndex; kIndex++)\n            {\n                if(inputString[startIndex] == inputString[kIndex])\n                {\n                    dynamicProgrammingTable[startIndex][endIndex]= std::min(dynamicProgrammingTable[startIndex][endIndex], dynamicProgrammingTable[startIndex + 1][kIndex - 1] + dynamicProgrammingTable[kIndex][endIndex]);\n                }\n            }\n        }\n    }\n\n    return dynamicProgrammingTable[0][stringLength - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool checkPossibility(vector<int> &numberList)\n{\n    int modificationCount= 0;\n    for(int currentIndex= 1; currentIndex < numberList.size(); currentIndex++)\n    {\n        if(numberList[currentIndex] < numberList[currentIndex - 1])\n        {\n            modificationCount++;\n            if(currentIndex == 1 || numberList[currentIndex] >= numberList[currentIndex - 2])\n            {\n                numberList[currentIndex - 1]= numberList[currentIndex];\n            }\n            else\n            {\n                numberList[currentIndex]= numberList[currentIndex - 1];\n            }\n            if(modificationCount > 1)\n                return false;\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool checkPossibility(std::vector<int> &numberList)\n{\n    int modificationCount= 0;\n    for(int currentIndex= 1; currentIndex < numberList.size(); currentIndex++)\n    {\n        if(numberList[currentIndex] < numberList[currentIndex - 1])\n        {\n            modificationCount++;\n            if(currentIndex == 1 || numberList[currentIndex] >= numberList[currentIndex - 2])\n            {\n                numberList[currentIndex - 1]= numberList[currentIndex];\n            }\n            else\n            {\n                numberList[currentIndex]= numberList[currentIndex - 1];\n            }\n            if(modificationCount > 1)\n                return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nint calculateSum(TreeNode *currentNode, int currentValue)\n{\n    if(!currentNode)\n        return 0;\n    currentValue = currentValue * 10 + currentNode->val;\n    if(!currentNode->left && !currentNode->right)\n        return currentValue;\n    return calculateSum(currentNode->left, currentValue) + calculateSum(currentNode->right, currentValue);\n}\n\nint calculatePathSum(vector<int> &numberList)\n{\n    TreeNode *rootNode = new TreeNode(numberList[0] % 10);\n    for (int i = 0; i < numberList.size(); ++i)\n    {\n        int number = numberList[i];\n        int depth = number / 100, position = number % 100 / 10, value = number % 10;\n        TreeNode *currentNode = rootNode;\n        for (int d = depth - 2; d >= 0; --d)\n        {\n            if ((position >> d) & 1)\n            {\n                if (!currentNode->right)\n                    currentNode->right = new TreeNode(value);\n                currentNode = currentNode->right;\n            }\n            else\n            {\n                if (!currentNode->left)\n                    currentNode->left = new TreeNode(value);\n                currentNode = currentNode->left;\n            }\n        }\n    }\n    return calculateSum(rootNode, 0);\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nint calculateSum(TreeNode *currentNode, int currentValue)\n{\n    if(!currentNode)\n        return 0;\n    currentValue= currentValue * 10 + currentNode->val;\n    if(!currentNode->left && !currentNode->right)\n        return currentValue;\n    return calculateSum(currentNode->left, currentValue) + calculateSum(currentNode->right, currentValue);\n}\n\nint calculatePathSum(std::vector<int> &numberList)\n{\n    TreeNode *rootNode= new TreeNode(numberList[0] % 10);\n    for(int number : numberList)\n    {\n        int depth= number / 100, position= number % 100 / 10, value= number % 10;\n        TreeNode *currentNode= rootNode;\n        for(int d= depth - 2; d >= 0; --d)\n        {\n            if((position >> d) & 1)\n            {\n                if(!currentNode->right)\n                    currentNode->right= new TreeNode(value);\n                currentNode= currentNode->right;\n            }\n            else\n            {\n                if(!currentNode->left)\n                    currentNode->left= new TreeNode(value);\n                currentNode= currentNode->left;\n            }\n        }\n    }\n    return calculateSum(rootNode, 0);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> constructArray(int length, int allowedDifferences)\n{\n    vector<int> resultArray(length);\n    for(int index= 0; index < length; ++index)\n    {\n        if(index % 2 == 0)\n        {\n            resultArray[index]= index / 2 + 1;\n        }\n        else\n        {\n            resultArray[index]= length - (index - 1) / 2;\n            --allowedDifferences;\n        }\n    }\n    if(allowedDifferences > 0)\n    {\n        for(int index= length - 2; index >= 0 && allowedDifferences > 0; --index)\n        {\n            resultArray[index]= resultArray[index + 1] - resultArray[index];\n            --allowedDifferences;\n        }\n    }\n    return resultArray;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> constructArray(int length, int allowedDifferences)\n{\n    std::vector<int> resultArray(length);\n    for(int index= 0; index < length; ++index)\n    {\n        if(index % 2 == 0)\n        {\n            resultArray[index]= index / 2 + 1;\n        }\n        else\n        {\n            resultArray[index]= length - (index - 1) / 2;\n            --allowedDifferences;\n        }\n    }\n    if(allowedDifferences > 0)\n    {\n        for(int index= length - 2; index >= 0 && allowedDifferences > 0; --index)\n        {\n            resultArray[index]= resultArray[index + 1] - resultArray[index];\n            --allowedDifferences;\n        }\n    }\n    return resultArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "using namespace std;\n\nint findKthNumber(int numRows, int numCols, int k)\n{\n    int low = 1, high = numRows * numCols;\n    while (low < high)\n    {\n        int mid = low + (high - low) / 2;\n        int count = 0;\n        for (int i = 1; i <= numRows; i++)\n        {\n            count += min(mid / i, numCols);\n        }\n        if (count < k)\n        {\n            low = mid + 1;\n        }\n        else\n        {\n            high = mid;\n        }\n    }\n    return low;\n}",
    "output": "int findKthNumber(int numRows, int numCols, int k)\n{\n    int low= 1, high= numRows * numCols;\n    while(low < high)\n    {\n        int mid= low + (high - low) / 2;\n        int count= 0;\n        for(int i= 1; i <= numRows; i++)\n        {\n            count+= std::min(mid / i, numCols);\n        }\n        if(count < k)\n        {\n            low= mid + 1;\n        }\n        else\n        {\n            high= mid;\n        }\n    }\n    return low;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nTreeNode *trimBST(TreeNode *rootNode, int lowValue, int highValue)\n{\n    if(!rootNode)\n        return NULL;\n\n    if(rootNode->value < lowValue)\n    {\n        return trimBST(rootNode->rightChild, lowValue, highValue);\n    }\n    else if(rootNode->value > highValue)\n    {\n        return trimBST(rootNode->leftChild, lowValue, highValue);\n    }\n    else\n    {\n        rootNode->leftChild= trimBST(rootNode->leftChild, lowValue, highValue);\n        rootNode->rightChild= trimBST(rootNode->rightChild, lowValue, highValue);\n    }\n\n    return rootNode;\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nTreeNode *trimBST(TreeNode *rootNode, int lowValue, int highValue)\n{\n    if(!rootNode)\n        return NULL;\n\n    if(rootNode->value < lowValue)\n    {\n        return trimBST(rootNode->rightChild, lowValue, highValue);\n    }\n    else if(rootNode->value > highValue)\n    {\n        return trimBST(rootNode->leftChild, lowValue, highValue);\n    }\n    else\n    {\n        rootNode->leftChild= trimBST(rootNode->leftChild, lowValue, highValue);\n        rootNode->rightChild= trimBST(rootNode->rightChild, lowValue, highValue);\n    }\n\n    return rootNode;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maximumSwap(int originalNumber)\n{\n    string numberString= to_string(originalNumber);\n    vector<int> lastPosition(10, 0);\n\n    for(int index= 0; index < numberString.size(); index++)\n    {\n        lastPosition[numberString[index] - '0']= index;\n    }\n\n    for(int index= 0; index < numberString.size(); index++)\n    {\n        for(int digit= 9; digit > numberString[index] - '0'; digit--)\n        {\n            if(lastPosition[digit] > index)\n            {\n                swap(numberString[index], numberString[lastPosition[digit]]);\n                return stoi(numberString);\n            }\n        }\n    }\n\n    return originalNumber;\n}",
    "output": "#include <bits/stdc++.h>\nint maximumSwap(int originalNumber)\n{\n    std::string numberString = std::to_string(originalNumber);\n    std::vector<int> lastPosition(10, 0);\n\n    for(int index = 0; index < numberString.size(); index++)\n    {\n        lastPosition[numberString[index] - '0'] = index;\n    }\n\n    for(int index = 0; index < numberString.size(); index++)\n    {\n        for(int digit = 9; digit > numberString[index] - '0'; digit--)\n        {\n            if(lastPosition[digit] > index)\n            {\n                std::swap(numberString[index], numberString[lastPosition[digit]]);\n                return std::stoi(numberString);\n            }\n        }\n    }\n\n    return originalNumber;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nint findSecondMinimumValue(TreeNode *rootNode, int currentMinimum= -1)\n{\n    if(!rootNode)\n        return currentMinimum;\n    if(currentMinimum == -1 || rootNode->value < currentMinimum)\n        currentMinimum= rootNode->value;\n    if(rootNode->leftChild && rootNode->rightChild)\n    {\n        if(rootNode->value == rootNode->leftChild->value)\n        {\n            currentMinimum= findSecondMinimumValue(rootNode->leftChild, currentMinimum);\n            if(rootNode->value != rootNode->rightChild->value)\n                currentMinimum= (currentMinimum == -1) ? rootNode->rightChild->value : min(currentMinimum, rootNode->rightChild->value);\n        }\n        else\n        {\n            currentMinimum= findSecondMinimumValue(rootNode->rightChild, currentMinimum);\n            if(rootNode->value != rootNode->leftChild->value)\n                currentMinimum= (currentMinimum == -1) ? rootNode->leftChild->value : min(currentMinimum, rootNode->leftChild->value);\n        }\n    }\n    return currentMinimum;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nint findSecondMinimumValue(TreeNode *rootNode, int currentMinimum= -1)\n{\n    if(!rootNode)\n        return currentMinimum;\n    if(currentMinimum == -1 || rootNode->value < currentMinimum)\n        currentMinimum= rootNode->value;\n    if(rootNode->leftChild && rootNode->rightChild)\n    {\n        if(rootNode->value == rootNode->leftChild->value)\n        {\n            currentMinimum= findSecondMinimumValue(rootNode->leftChild, currentMinimum);\n            if(rootNode->value != rootNode->rightChild->value)\n                currentMinimum= (currentMinimum == -1) ? rootNode->rightChild->value : std::min(currentMinimum, rootNode->rightChild->value);\n        }\n        else\n        {\n            currentMinimum= findSecondMinimumValue(rootNode->rightChild, currentMinimum);\n            if(rootNode->value != rootNode->leftChild->value)\n                currentMinimum= (currentMinimum == -1) ? rootNode->leftChild->value : std::min(currentMinimum, rootNode->leftChild->value);\n        }\n    }\n    return currentMinimum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateLightConfigurations(int totalLights, int totalPresses)\n{\n    vector<vector<int>> configurationCount(totalLights + 1, vector<int>(totalPresses + 1, 0));\n    configurationCount[0][0] = 1;\n\n    for(int currentLights = 0; currentLights <= totalLights; ++currentLights)\n    {\n        for(int currentPress = 1; currentPress <= totalPresses; ++currentPress)\n        {\n            configurationCount[currentLights][currentPress] = configurationCount[currentLights][currentPress - 1] * (currentLights + 1) + (currentLights > 0 ? configurationCount[currentLights - 1][currentPress - 1] : 0);\n        }\n    }\n\n    return configurationCount[totalLights][totalPresses];\n}",
    "output": "#include <bits/stdc++.h>\nint calculateLightConfigurations(int totalLights, int totalPresses)\n{\n    std::vector<std::vector<int>> configurationCount(totalLights + 1, std::vector<int>(totalPresses + 1, 0));\n    configurationCount[0][0]= 1;\n\n    for(int currentLights= 0; currentLights <= totalLights; ++currentLights)\n    {\n        for(int currentPress= 1; currentPress <= totalPresses; ++currentPress)\n        {\n            configurationCount[currentLights][currentPress]= configurationCount[currentLights][currentPress - 1] * (currentLights + 1) + (currentLights > 0 ? configurationCount[currentLights - 1][currentPress - 1] : 0);\n        }\n    }\n\n    return configurationCount[totalLights][totalPresses];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findNumberOfLIS(vector<int> &sequence)\n{\n    int sequenceSize= sequence.size(), maxLength= 0, totalCount= 0;\n    vector<int> lengths(sequenceSize, 0), counts(sequenceSize, 0);\n\n    for(int currentIndex= 0; currentIndex < sequenceSize; ++currentIndex)\n    {\n        lengths[currentIndex]= counts[currentIndex]= 1;\n        for(int previousIndex= 0; previousIndex < currentIndex; ++previousIndex)\n        {\n            if(sequence[currentIndex] > sequence[previousIndex])\n            {\n                if(lengths[currentIndex] == lengths[previousIndex] + 1)\n                {\n                    counts[currentIndex]+= counts[previousIndex];\n                }\n                else if(lengths[currentIndex] < lengths[previousIndex] + 1)\n                {\n                    lengths[currentIndex]= lengths[previousIndex] + 1;\n                    counts[currentIndex]= counts[previousIndex];\n                }\n            }\n        }\n        if(maxLength == lengths[currentIndex])\n        {\n            totalCount+= counts[currentIndex];\n        }\n        else if(maxLength < lengths[currentIndex])\n        {\n            maxLength= lengths[currentIndex];\n            totalCount= counts[currentIndex];\n        }\n    }\n\n    return totalCount;\n}",
    "output": "#include <bits/stdc++.h>\nint findNumberOfLIS(std::vector<int> &sequence)\n{\n    int sequenceSize= sequence.size(), maxLength= 0, totalCount= 0;\n    std::vector<int> lengths(sequenceSize, 0), counts(sequenceSize, 0);\n\n    for(int currentIndex= 0; currentIndex < sequenceSize; ++currentIndex)\n    {\n        lengths[currentIndex]= counts[currentIndex]= 1;\n        for(int previousIndex= 0; previousIndex < currentIndex; ++previousIndex)\n        {\n            if(sequence[currentIndex] > sequence[previousIndex])\n            {\n                if(lengths[currentIndex] == lengths[previousIndex] + 1)\n                {\n                    counts[currentIndex]+= counts[previousIndex];\n                }\n                else if(lengths[currentIndex] < lengths[previousIndex] + 1)\n                {\n                    lengths[currentIndex]= lengths[previousIndex] + 1;\n                    counts[currentIndex]= counts[previousIndex];\n                }\n            }\n        }\n        if(maxLength == lengths[currentIndex])\n        {\n            totalCount+= counts[currentIndex];\n        }\n        else if(maxLength < lengths[currentIndex])\n        {\n            maxLength= lengths[currentIndex];\n            totalCount= counts[currentIndex];\n        }\n    }\n\n    return totalCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findLengthOfLCIS(vector<int> &numberList)\n{\n    if(numberList.empty())\n        return 0;\n    int longestIncreasingCount= 1, currentCount= 1;\n    for(int index= 1; index < numberList.size(); ++index)\n    {\n        currentCount= numberList[index] > numberList[index - 1] ? currentCount + 1 : 1;\n        longestIncreasingCount= max(longestIncreasingCount, currentCount);\n    }\n    return longestIncreasingCount;\n}",
    "output": "#include <bits/stdc++.h>\nint findLengthOfLCIS(std::vector<int> &numberList)\n{\n    if(numberList.empty())\n        return 0;\n    int longestIncreasingCount= 1, currentCount= 1;\n    for(int index= 1; index < numberList.size(); ++index)\n    {\n        currentCount= numberList[index] > numberList[index - 1] ? currentCount + 1 : 1;\n        longestIncreasingCount= std::max(longestIncreasingCount, currentCount);\n    }\n    return longestIncreasingCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint cutOffTree(vector<vector<int>> &forest)\n{\n    if(forest.empty() || forest[0].empty())\n        return 0;\n    int rowCount = forest.size(), columnCount = forest[0].size();\n    vector<pair<int, int>> treeLocations;\n\n    for(int rowIndex = 0; rowIndex < rowCount; rowIndex++)\n        for(int columnIndex = 0; columnIndex < columnCount; columnIndex++)\n            if(forest[rowIndex][columnIndex] > 1)\n                treeLocations.push_back({rowIndex, columnIndex});\n\n    sort(treeLocations.begin(), treeLocations.end(), [&forest](pair<int, int> &a, pair<int, int> &b)\n              { return forest[a.first][a.second] < forest[b.first][b.second]; });\n\n    int currentX = 0, currentY = 0;\n    int totalSteps = 0;\n    for(int i = 0; i < treeLocations.size(); i++)\n    {\n        pair<int, int> &treeLocation = treeLocations[i];\n        int targetX = treeLocation.first, targetY = treeLocation.second;\n        int steps = bfs(forest, currentX, currentY, targetX, targetY);\n        if(steps == -1)\n            return -1;\n        totalSteps += steps;\n        currentX = targetX;\n        currentY = targetY;\n    }\n\n    return totalSteps;\n}\n\nint bfs(vector<vector<int>> &forest, int startX, int startY, int endX, int endY)\n{\n    int rowCount = forest.size(), columnCount = forest[0].size();\n    vector<vector<int>> visited(rowCount, vector<int>(columnCount, 0));\n    queue<pair<int, int>> queue;\n    queue.push({startX, startY});\n    visited[startX][startY] = 1;\n    int steps = 0;\n    vector<int> directions{-1, 0, 1, 0, -1};\n\n    while(!queue.empty())\n    {\n        int size = queue.size();\n        for(int i = 0; i < size; i++)\n        {\n            int currentX = queue.front().first;\n            int currentY = queue.front().second;\n            queue.pop();\n\n            if(currentX == endX && currentY == endY)\n                return steps;\n\n            for(int directionIndex = 0; directionIndex < 4; directionIndex++)\n            {\n                int newX = currentX + directions[directionIndex];\n                int newY = currentY + directions[directionIndex + 1];\n                if(newX >= 0 && newX < rowCount && newY >= 0 && newY < columnCount && !visited[newX][newY] && forest[newX][newY] != 0)\n                {\n                    queue.push({newX, newY});\n                    visited[newX][newY] = 1;\n                }\n            }\n        }\n        steps++;\n    }\n\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint cutOffTree(std::vector<std::vector<int>> &forest)\n{\n    if(forest.empty() || forest[0].empty())\n        return 0;\n    int rowCount= forest.size(), columnCount= forest[0].size();\n    std::vector<std::pair<int, int>> treeLocations;\n\n    for(int rowIndex= 0; rowIndex < rowCount; rowIndex++)\n        for(int columnIndex= 0; columnIndex < columnCount; columnIndex++)\n            if(forest[rowIndex][columnIndex] > 1)\n                treeLocations.push_back({rowIndex, columnIndex});\n\n    std::sort(treeLocations.begin(), treeLocations.end(), [&forest](std::pair<int, int> &a, std::pair<int, int> &b)\n              { return forest[a.first][a.second] < forest[b.first][b.second]; });\n\n    int currentX= 0, currentY= 0;\n    int totalSteps= 0;\n    for(std::pair<int, int> &treeLocation : treeLocations)\n    {\n        int targetX= treeLocation.first, targetY= treeLocation.second;\n        int steps= bfs(forest, currentX, currentY, targetX, targetY);\n        if(steps == -1)\n            return -1;\n        totalSteps+= steps;\n        currentX= targetX;\n        currentY= targetY;\n    }\n\n    return totalSteps;\n}\n\nint bfs(std::vector<std::vector<int>> &forest, int startX, int startY, int endX, int endY)\n{\n    int rowCount= forest.size(), columnCount= forest[0].size();\n    std::vector<std::vector<int>> visited(rowCount, std::vector<int>(columnCount, 0));\n    std::queue<std::pair<int, int>> queue;\n    queue.push({startX, startY});\n    visited[startX][startY]= 1;\n    int steps= 0;\n    std::vector<int> directions{-1, 0, 1, 0, -1};\n\n    while(!queue.empty())\n    {\n        int size= queue.size();\n        for(int i= 0; i < size; i++)\n        {\n            int currentX= queue.front().first;\n            int currentY= queue.front().second;\n            queue.pop();\n\n            if(currentX == endX && currentY == endY)\n                return steps;\n\n            for(int directionIndex= 0; directionIndex < 4; directionIndex++)\n            {\n                int newX= currentX + directions[directionIndex];\n                int newY= currentY + directions[directionIndex + 1];\n                if(newX >= 0 && newX < rowCount && newY >= 0 && newY < columnCount && !visited[newX][newY] && forest[newX][newY] != 0)\n                {\n                    queue.push({newX, newY});\n                    visited[newX][newY]= 1;\n                }\n            }\n        }\n        steps++;\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass MagicDictionary\n{\n  public:\n    unordered_map<int, vector<string>> wordsByLength;\n\n    MagicDictionary() {}\n\n    void buildDict(vector<string> dictionary)\n    {\n        for (int i = 0; i < dictionary.size(); ++i)\n        {\n            string word = dictionary[i];\n            wordsByLength[word.size()].push_back(word);\n        }\n    }\n\n    bool search(string searchWord)\n    {\n        if (wordsByLength.count(searchWord.size()))\n        {\n            for (int j = 0; j < wordsByLength[searchWord.size()].size(); ++j)\n            {\n                string word = wordsByLength[searchWord.size()][j];\n                int differenceCount = 0;\n                for (int i = 0; i < searchWord.size(); i++)\n                {\n                    if (searchWord[i] != word[i])\n                        differenceCount++;\n                }\n                if (differenceCount == 1)\n                    return true;\n            }\n        }\n        return false;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass MagicDictionary\n{\n  public:\n    std::unordered_map<int, std::vector<std::string>> wordsByLength;\n\n    MagicDictionary() {}\n\n    void buildDict(std::vector<std::string> dictionary)\n    {\n        for(std::string word : dictionary)\n        {\n            wordsByLength[word.size()].push_back(word);\n        }\n    }\n\n    bool search(std::string searchWord)\n    {\n        if(wordsByLength.count(searchWord.size()))\n        {\n            for(std::string word : wordsByLength[searchWord.size()])\n            {\n                int differenceCount= 0;\n                for(int i= 0; i < searchWord.size(); i++)\n                {\n                    if(searchWord[i] != word[i])\n                        differenceCount++;\n                }\n                if(differenceCount == 1)\n                    return true;\n            }\n        }\n        return false;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass MapSum\n{\n    unordered_map<string, int> keyValueMap;\n\n  public:\n    MapSum() {}\n\n    void insert(string key, int value)\n    {\n        keyValueMap[key] = value;\n    }\n\n    int sum(string prefix)\n    {\n        int totalSum = 0;\n        for (auto it = keyValueMap.begin(); it != keyValueMap.end(); ++it)\n        {\n            if (it->first.compare(0, prefix.size(), prefix) == 0)\n                totalSum += it->second;\n        }\n        return totalSum;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass MapSum\n{\n    std::unordered_map<std::string, int> keyValueMap;\n\n  public:\n    MapSum() {}\n\n    void insert(std::string key, int value)\n    {\n        keyValueMap[key] = value;\n    }\n\n    int sum(std::string prefix)\n    {\n        int totalSum = 0;\n        for (auto &keyValuePair : keyValueMap)\n            if (keyValuePair.first.compare(0, prefix.size(), prefix) == 0)\n                totalSum += keyValuePair.second;\n        return totalSum;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool checkValidString(string inputString)\n{\n    int leftBalance= 0, rightBalance= 0;\n\n    for(int index= 0; index < inputString.size(); index++)\n    {\n        leftBalance+= (inputString[index] == '(' || inputString[index] == '*') ? 1 : -1;\n        rightBalance+= (inputString[inputString.size() - 1 - index] == ')' || inputString[inputString.size() - 1 - index] == '*') ? 1 : -1;\n\n        if(leftBalance < 0 || rightBalance < 0)\n            return false;\n    }\n\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool checkValidString(std::string inputString)\n{\n    int leftBalance= 0, rightBalance= 0;\n\n    for(int index= 0; index < inputString.size(); index++)\n    {\n        leftBalance+= (inputString[index] == '(' || inputString[index] == '*') ? 1 : -1;\n        rightBalance+= (inputString[inputString.size() - 1 - index] == ')' || inputString[inputString.size() - 1 - index] == '*') ? 1 : -1;\n\n        if(leftBalance < 0 || rightBalance < 0)\n            return false;\n    }\n\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool evaluateCards(vector<double> &cardValues)\n{\n    if(cardValues.size() == 1)\n    {\n        return abs(cardValues[0] - 24) < 1e-6;\n    }\n\n    for(int firstIndex = 0; firstIndex < cardValues.size(); ++firstIndex)\n    {\n        for(int secondIndex = firstIndex + 1; secondIndex < cardValues.size(); ++secondIndex)\n        {\n            double firstCard = cardValues[firstIndex], secondCard = cardValues[secondIndex];\n            vector<double> possibleResults = {firstCard + secondCard, firstCard - secondCard, firstCard * secondCard, firstCard / secondCard};\n\n            cardValues.erase(cardValues.begin() + secondIndex);\n            cardValues.erase(cardValues.begin() + firstIndex);\n\n            for(int resultIndex = 0; resultIndex < possibleResults.size(); ++resultIndex)\n            {\n                double result = possibleResults[resultIndex];\n                cardValues.push_back(result);\n                if(evaluateCards(cardValues))\n                {\n                    return true;\n                }\n                cardValues.pop_back();\n            }\n\n            cardValues.insert(cardValues.begin() + firstIndex, firstCard);\n            cardValues.insert(cardValues.begin() + secondIndex, secondCard);\n        }\n    }\n    return false;\n}\n\nbool canAchieve24(vector<int> &cardValues)\n{\n    vector<double> doubleCardValues(cardValues.begin(), cardValues.end());\n    return evaluateCards(doubleCardValues);\n}",
    "output": "#include <bits/stdc++.h>\nbool evaluateCards(std::vector<double> &cardValues)\n{\n    if(cardValues.size() == 1)\n    {\n        return std::abs(cardValues[0] - 24) < 1e-6;\n    }\n\n    for(int firstIndex= 0; firstIndex < cardValues.size(); ++firstIndex)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < cardValues.size(); ++secondIndex)\n        {\n            double firstCard= cardValues[firstIndex], secondCard= cardValues[secondIndex];\n            std::vector<double> possibleResults= {firstCard + secondCard, firstCard - secondCard, firstCard * secondCard, firstCard / secondCard};\n\n            cardValues.erase(cardValues.begin() + secondIndex);\n            cardValues.erase(cardValues.begin() + firstIndex);\n\n            for(auto &result : possibleResults)\n            {\n                cardValues.push_back(result);\n                if(evaluateCards(cardValues))\n                {\n                    return true;\n                }\n                cardValues.pop_back();\n            }\n\n            cardValues.insert(cardValues.begin() + firstIndex, firstCard);\n            cardValues.insert(cardValues.begin() + secondIndex, secondCard);\n        }\n    }\n    return false;\n}\n\nbool canAchieve24(std::vector<int> &cardValues)\n{\n    std::vector<double> doubleCardValues(cardValues.begin(), cardValues.end());\n    return evaluateCards(doubleCardValues);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidPalindrome(string inputString)\n{\n    for(int leftIndex= 0, rightIndex= inputString.size() - 1; leftIndex < rightIndex; leftIndex++, rightIndex--)\n    {\n        if(inputString[leftIndex] != inputString[rightIndex])\n        {\n            int skipLeftIndex= leftIndex + 1, skipRightIndex= rightIndex;\n            while(skipLeftIndex < skipRightIndex && inputString[skipLeftIndex] == inputString[skipRightIndex])\n            {\n                skipLeftIndex++;\n                skipRightIndex--;\n            }\n            if(skipLeftIndex >= skipRightIndex)\n                return true;\n\n            skipLeftIndex= leftIndex;\n            skipRightIndex= rightIndex - 1;\n            while(skipLeftIndex < skipRightIndex && inputString[skipLeftIndex] == inputString[skipRightIndex])\n            {\n                skipLeftIndex++;\n                skipRightIndex--;\n            }\n            if(skipLeftIndex >= skipRightIndex)\n                return true;\n\n            return false;\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isValidPalindrome(std::string inputString)\n{\n    for(int leftIndex= 0, rightIndex= inputString.size() - 1; leftIndex < rightIndex; leftIndex++, rightIndex--)\n    {\n        if(inputString[leftIndex] != inputString[rightIndex])\n        {\n            int skipLeftIndex= leftIndex + 1, skipRightIndex= rightIndex;\n            while(skipLeftIndex < skipRightIndex && inputString[skipLeftIndex] == inputString[skipRightIndex])\n            {\n                skipLeftIndex++;\n                skipRightIndex--;\n            }\n            if(skipLeftIndex >= skipRightIndex)\n                return true;\n\n            skipLeftIndex= leftIndex;\n            skipRightIndex= rightIndex - 1;\n            while(skipLeftIndex < skipRightIndex && inputString[skipLeftIndex] == inputString[skipRightIndex])\n            {\n                skipLeftIndex++;\n                skipRightIndex--;\n            }\n            if(skipLeftIndex >= skipRightIndex)\n                return true;\n\n            return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring nextClosestTime(string currentTime)\n{\n    string timeDigits = currentTime.substr(0, 2) + currentTime.substr(3);\n    string nextTime = currentTime;\n    int minimumElapsed = INT_MAX;\n\n    for (int i = 0; i < timeDigits.size(); ++i) // modified\n    {\n        char hourTens = timeDigits[i];\n        for (int j = 0; j < timeDigits.size(); ++j) // modified\n        {\n            char hourOnes = timeDigits[j];\n            for (int k = 0; k < timeDigits.size(); ++k) // modified\n            {\n                char minuteTens = timeDigits[k];\n                for (int l = 0; l < timeDigits.size(); ++l) // modified\n                {\n                    char minuteOnes = timeDigits[l];\n                    string candidateTime = string({hourTens, hourOnes, ':', minuteTens, minuteOnes});\n                    int candidateElapsed = (stoi(candidateTime.substr(0, 2)) * 60 + stoi(candidateTime.substr(3)) -\n                                           stoi(currentTime.substr(0, 2)) * 60 - stoi(currentTime.substr(3)) + 1440) %\n                                          1440;\n                    if (0 < candidateElapsed && candidateElapsed < minimumElapsed)\n                    {\n                        minimumElapsed = candidateElapsed;\n                        nextTime = candidateTime;\n                    }\n                }\n            }\n        }\n    }\n\n    return nextTime;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string nextClosestTime(std::string currentTime)\n{\n    std::string timeDigits= currentTime.substr(0, 2) + currentTime.substr(3);\n    std::string nextTime= currentTime;\n    int minimumElapsed= INT_MAX;\n\n    for(char hourTens : timeDigits)\n    {\n        for(char hourOnes : timeDigits)\n        {\n            for(char minuteTens : timeDigits)\n            {\n                for(char minuteOnes : timeDigits)\n                {\n                    std::string candidateTime= std::string({hourTens, hourOnes, ':', minuteTens, minuteOnes});\n                    int candidateElapsed= (std::stoi(candidateTime.substr(0, 2)) * 60 + std::stoi(candidateTime.substr(3)) -\n                                           std::stoi(currentTime.substr(0, 2)) * 60 - std::stoi(currentTime.substr(3)) + 1440) %\n                                          1440;\n                    if(0 < candidateElapsed && candidateElapsed < minimumElapsed)\n                    {\n                        minimumElapsed= candidateElapsed;\n                        nextTime= candidateTime;\n                    }\n                }\n            }\n        }\n    }\n\n    return nextTime;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calPoints(vector<string> &operations)\n{\n    vector<int> scoreRecord;\n    for (int i = 0; i < operations.size(); ++i)\n    {\n        const string &operation = operations[i];\n        if (operation == \"+\")\n        {\n            scoreRecord.push_back(scoreRecord[scoreRecord.size() - 1] + scoreRecord[scoreRecord.size() - 2]);\n        }\n        else if (operation == \"D\")\n        {\n            scoreRecord.push_back(2 * scoreRecord.back());\n        }\n        else if (operation == \"C\")\n        {\n            scoreRecord.pop_back();\n        }\n        else\n        {\n            scoreRecord.push_back(stoi(operation));\n        }\n    }\n    return accumulate(scoreRecord.begin(), scoreRecord.end(), 0);\n}",
    "output": "#include <bits/stdc++.h>\nint calPoints(std::vector<std::string> &operations)\n{\n    std::vector<int> scoreRecord;\n    for(const std::string &operation : operations)\n    {\n        if(operation == \"+\")\n        {\n            scoreRecord.push_back(scoreRecord[scoreRecord.size() - 1] + scoreRecord[scoreRecord.size() - 2]);\n        }\n        else if(operation == \"D\")\n        {\n            scoreRecord.push_back(2 * scoreRecord.back());\n        }\n        else if(operation == \"C\")\n        {\n            scoreRecord.pop_back();\n        }\n        else\n        {\n            scoreRecord.push_back(stoi(operation));\n        }\n    }\n    return std::accumulate(scoreRecord.begin(), scoreRecord.end(), 0);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findKEmptySlots(vector<int> &bulbs, int k)\n{\n    vector<int> days(bulbs.size());\n    for(int index= 0; index < bulbs.size(); ++index)\n    {\n        days[bulbs[index] - 1]= index;\n    }\n\n    int minimumDays= INT_MAX;\n    int leftIndex= 0;\n    int rightIndex= k + 1;\n    while(rightIndex < days.size())\n    {\n        int currentIndex= leftIndex + 1;\n        for(; currentIndex < rightIndex; ++currentIndex)\n        {\n            if(days[currentIndex] < days[leftIndex] || days[currentIndex] < days[rightIndex])\n            {\n                leftIndex= currentIndex;\n                break;\n            }\n        }\n        if(currentIndex == rightIndex)\n        {\n            minimumDays= min(minimumDays, max(days[leftIndex], days[rightIndex]));\n            leftIndex++;\n            rightIndex++;\n        }\n    }\n\n    return minimumDays == INT_MAX ? -1 : minimumDays + 1;\n}",
    "output": "#include <bits/stdc++.h>\nint findKEmptySlots(std::vector<int> &bulbs, int k)\n{\n    std::vector<int> days(bulbs.size());\n    for(int index= 0; index < bulbs.size(); ++index)\n    {\n        days[bulbs[index] - 1]= index;\n    }\n\n    int minimumDays= INT_MAX;\n    int leftIndex= 0;\n    int rightIndex= k + 1;\n    while(rightIndex < days.size())\n    {\n        int currentIndex= leftIndex + 1;\n        for(; currentIndex < rightIndex; ++currentIndex)\n        {\n            if(days[currentIndex] < days[leftIndex] || days[currentIndex] < days[rightIndex])\n            {\n                leftIndex= currentIndex;\n                break;\n            }\n        }\n        if(currentIndex == rightIndex)\n        {\n            minimumDays= std::min(minimumDays, std::max(days[leftIndex], days[rightIndex]));\n            leftIndex++;\n            rightIndex++;\n        }\n    }\n\n    return minimumDays == INT_MAX ? -1 : minimumDays + 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findRedundantConnection(vector<vector<int>> &edgeList)\n{\n    vector<int> nodeParent(edgeList.size() + 1);\n    for(int currentNodeIndex = 1; currentNodeIndex <= edgeList.size(); ++currentNodeIndex)\n    {\n        nodeParent[currentNodeIndex] = currentNodeIndex;\n    }\n\n    for (int i = 0; i < edgeList.size(); ++i) // modified to traditional for loop\n    {\n        const auto &currentEdge = edgeList[i]; // accessing currentEdge using index\n        int rootNode1 = find(nodeParent, currentEdge[0]);\n        int rootNode2 = find(nodeParent, currentEdge[1]);\n        if (rootNode1 == rootNode2)\n        {\n            return currentEdge;\n        }\n        nodeParent[rootNode1] = rootNode2;\n    }\n\n    return {};\n}\n\nint find(vector<int> &nodeParent, int currentNodeIndex)\n{\n    if (nodeParent[currentNodeIndex] != currentNodeIndex)\n    {\n        nodeParent[currentNodeIndex] = find(nodeParent, nodeParent[currentNodeIndex]);\n    }\n    return nodeParent[currentNodeIndex];\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findRedundantConnection(std::vector<std::vector<int>> &edgeList)\n{\n    std::vector<int> nodeParent(edgeList.size() + 1);\n    for(int currentNodeIndex= 1; currentNodeIndex <= edgeList.size(); ++currentNodeIndex)\n    {\n        nodeParent[currentNodeIndex]= currentNodeIndex;\n    }\n\n    for(const auto &currentEdge : edgeList)\n    {\n        int rootNode1= find(nodeParent, currentEdge[0]);\n        int rootNode2= find(nodeParent, currentEdge[1]);\n        if(rootNode1 == rootNode2)\n        {\n            return currentEdge;\n        }\n        nodeParent[rootNode1]= rootNode2;\n    }\n\n    return {};\n}\n\nint find(std::vector<int> &nodeParent, int currentNodeIndex)\n{\n    if(nodeParent[currentNodeIndex] != currentNodeIndex)\n    {\n        nodeParent[currentNodeIndex]= find(nodeParent, nodeParent[currentNodeIndex]);\n    }\n    return nodeParent[currentNodeIndex];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findRedundantDirectedConnection(vector<vector<int>> &edges)\n{\n    vector<int> parent(edges.size() + 1, 0);\n    vector<int> candidateA, candidateB;\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        const auto &edge = edges[i];\n        int source = edge[0], target = edge[1];\n        if (parent[target] > 0)\n        {\n            candidateA = {parent[target], target};\n            candidateB = edge;\n        }\n        else\n        {\n            parent[target] = source;\n        }\n    }\n\n    for (int i = 1; i <= edges.size(); ++i)\n    {\n        int currentNode = i, remainingSteps = edges.size();\n        while (parent[currentNode] != 0 && remainingSteps-- > 0)\n        {\n            currentNode = parent[currentNode];\n        }\n        if (remainingSteps == -1)\n        {\n            if (candidateA.empty())\n                return {parent[i], i};\n            else\n                return candidateA;\n        }\n    }\n\n    return candidateB;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findRedundantDirectedConnection(std::vector<std::vector<int>> &edges)\n{\n    std::vector<int> parent(edges.size() + 1, 0);\n    std::vector<int> candidateA, candidateB;\n\n    for(const auto &edge : edges)\n    {\n        int source= edge[0], target= edge[1];\n        if(parent[target] > 0)\n        {\n            candidateA= {parent[target], target};\n            candidateB= edge;\n        }\n        else\n        {\n            parent[target]= source;\n        }\n    }\n\n    for(int i= 1; i <= edges.size(); ++i)\n    {\n        int currentNode= i, remainingSteps= edges.size();\n        while(parent[currentNode] != 0 && remainingSteps-- > 0)\n        {\n            currentNode= parent[currentNode];\n        }\n        if(remainingSteps == -1)\n        {\n            if(candidateA.empty())\n                return {parent[i], i};\n            else\n                return candidateA;\n        }\n    }\n\n    return candidateB;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minRepeatsToSubstring(const string &sourceString, const string &substring)\n{\n    int requiredRepeats= (substring.length() + sourceString.length() - 1) / sourceString.length();\n\n    for(int i= 0; i < 2; i++)\n    {\n        string repeatedSourceString= \"\";\n        for(int j= 0; j < requiredRepeats + i; j++)\n        {\n            repeatedSourceString+= sourceString;\n        }\n\n        if(repeatedSourceString.find(substring) != string::npos)\n            return requiredRepeats + i;\n    }\n\n    return -1;\n}",
    "output": "int minRepeatsToSubstring(const std::string &sourceString, const std::string &substring)\n{\n    int requiredRepeats= (substring.length() + sourceString.length() - 1) / sourceString.length();\n\n    for(int i= 0; i < 2; i++)\n    {\n        std::string repeatedSourceString= \"\";\n        for(int j= 0; j < requiredRepeats + i; j++)\n        {\n            repeatedSourceString+= sourceString;\n        }\n\n        if(repeatedSourceString.find(substring) != std::string::npos)\n            return requiredRepeats + i;\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int findUnivaluePath(TreeNode *currentNode, int &maximumLength)\n{\n    if(!currentNode)\n        return 0;\n    int leftPathLength= findUnivaluePath(currentNode->left, maximumLength);\n    int rightPathLength= findUnivaluePath(currentNode->right, maximumLength);\n    leftPathLength= (currentNode->left && currentNode->left->val == currentNode->val) ? leftPathLength + 1 : 0;\n    rightPathLength= (currentNode->right && currentNode->right->val == currentNode->val) ? rightPathLength + 1 : 0;\n    maximumLength= max(maximumLength, leftPathLength + rightPathLength);\n    return max(leftPathLength, rightPathLength);\n}\n\nint longestUnivaluePath(TreeNode *rootNode)\n{\n    int maximumLength= 0;\n    findUnivaluePath(rootNode, maximumLength);\n    return maximumLength;\n}",
    "output": "int findUnivaluePath(TreeNode *currentNode, int &maximumLength)\n{\n    if(!currentNode)\n        return 0;\n    int leftPathLength= findUnivaluePath(currentNode->left, maximumLength);\n    int rightPathLength= findUnivaluePath(currentNode->right, maximumLength);\n    leftPathLength= (currentNode->left && currentNode->left->val == currentNode->val) ? leftPathLength + 1 : 0;\n    rightPathLength= (currentNode->right && currentNode->right->val == currentNode->val) ? rightPathLength + 1 : 0;\n    maximumLength= max(maximumLength, leftPathLength + rightPathLength);\n    return max(leftPathLength, rightPathLength);\n}\n\nint longestUnivaluePath(TreeNode *rootNode)\n{\n    int maximumLength= 0;\n    findUnivaluePath(rootNode, maximumLength);\n    return maximumLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble knightProbability(int boardSize, int remainingMoves, int knightRow, int knightColumn)\n{\n    vector<vector<vector<double>>> memoization(boardSize, vector<vector<double>>(boardSize, vector<double>(remainingMoves + 1, -1.0)));\n    return calculateProbability(boardSize, remainingMoves, knightRow, knightColumn, memoization);\n}\n\ndouble calculateProbability(int boardSize, int remainingMoves, int knightRow, int knightColumn, vector<vector<vector<double>>> &memoization)\n{\n    if(knightRow < 0 || knightRow >= boardSize || knightColumn < 0 || knightColumn >= boardSize)\n        return 0.0;\n    if(remainingMoves == 0)\n        return 1.0;\n    if(memoization[knightRow][knightColumn][remainingMoves] >= 0)\n        return memoization[knightRow][knightColumn][remainingMoves];\n\n    double probability= 0.0;\n    int knightMoves[8][2]= {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};\n    for(int i= 0; i < 8; ++i)\n        probability+= calculateProbability(boardSize, remainingMoves - 1, knightRow + knightMoves[i][0], knightColumn + knightMoves[i][1], memoization) / 8;\n\n    memoization[knightRow][knightColumn][remainingMoves]= probability;\n    return probability;\n}",
    "output": "#include <bits/stdc++.h>\ndouble knightProbability(int boardSize, int remainingMoves, int knightRow, int knightColumn)\n{\n    std::vector<std::vector<std::vector<double>>> memoization(boardSize, std::vector<std::vector<double>>(boardSize, std::vector<double>(remainingMoves + 1, -1.0)));\n    return calculateProbability(boardSize, remainingMoves, knightRow, knightColumn, memoization);\n}\n\ndouble calculateProbability(int boardSize, int remainingMoves, int knightRow, int knightColumn, std::vector<std::vector<std::vector<double>>> &memoization)\n{\n    if(knightRow < 0 || knightRow >= boardSize || knightColumn < 0 || knightColumn >= boardSize)\n        return 0.0;\n    if(remainingMoves == 0)\n        return 1.0;\n    if(memoization[knightRow][knightColumn][remainingMoves] >= 0)\n        return memoization[knightRow][knightColumn][remainingMoves];\n\n    double probability= 0.0;\n    int knightMoves[8][2]= {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};\n    for(int i= 0; i < 8; ++i)\n        probability+= calculateProbability(boardSize, remainingMoves - 1, knightRow + knightMoves[i][0], knightColumn + knightMoves[i][1], memoization) / 8;\n\n    memoization[knightRow][knightColumn][remainingMoves]= probability;\n    return probability;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> maxSumOfThreeSubarrays(vector<int> &inputArray, int subarraySize)\n{\n    int arraySize= inputArray.size();\n    vector<int> subarraySums(arraySize - subarraySize + 1);\n    vector<int> leftIndices(arraySize), rightIndices(arraySize), resultIndices(3);\n    int accumulatedSum= 0;\n\n    for(int i= 0; i < arraySize; ++i)\n    {\n        accumulatedSum+= inputArray[i];\n        if(i >= subarraySize)\n        {\n            accumulatedSum-= inputArray[i - subarraySize];\n        }\n        if(i >= subarraySize - 1)\n        {\n            subarraySums[i - subarraySize + 1]= accumulatedSum;\n        }\n    }\n\n    leftIndices[0]= 0;\n    rightIndices[arraySize - subarraySize]= arraySize - subarraySize;\n\n    for(int i= 1; i < arraySize - subarraySize + 1; ++i)\n    {\n        leftIndices[i]= subarraySums[i] > subarraySums[leftIndices[i - 1]] ? i : leftIndices[i - 1];\n    }\n\n    for(int i= arraySize - subarraySize - 1; i >= 0; --i)\n    {\n        rightIndices[i]= subarraySums[i] >= subarraySums[rightIndices[i + 1]] ? i : rightIndices[i + 1];\n    }\n\n    int maxTotalSum= 0;\n\n    for(int i= subarraySize; i < arraySize - 2 * subarraySize + 1; ++i)\n    {\n        int leftIndex= leftIndices[i - subarraySize], rightIndex= rightIndices[i + subarraySize], totalSum= subarraySums[leftIndex] + subarraySums[i] + subarraySums[rightIndex];\n        if(totalSum > maxTotalSum)\n        {\n            maxTotalSum= totalSum;\n            resultIndices= {leftIndex, i, rightIndex};\n        }\n    }\n\n    return resultIndices;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> maxSumOfThreeSubarrays(std::vector<int> &inputArray, int subarraySize)\n{\n    int arraySize= inputArray.size();\n    std::vector<int> subarraySums(arraySize - subarraySize + 1);\n    std::vector<int> leftIndices(arraySize), rightIndices(arraySize), resultIndices(3);\n    int accumulatedSum= 0;\n\n    for(int i= 0; i < arraySize; ++i)\n    {\n        accumulatedSum+= inputArray[i];\n        if(i >= subarraySize)\n        {\n            accumulatedSum-= inputArray[i - subarraySize];\n        }\n        if(i >= subarraySize - 1)\n        {\n            subarraySums[i - subarraySize + 1]= accumulatedSum;\n        }\n    }\n\n    leftIndices[0]= 0;\n    rightIndices[arraySize - subarraySize]= arraySize - subarraySize;\n\n    for(int i= 1; i < arraySize - subarraySize + 1; ++i)\n    {\n        leftIndices[i]= subarraySums[i] > subarraySums[leftIndices[i - 1]] ? i : leftIndices[i - 1];\n    }\n\n    for(int i= arraySize - subarraySize - 1; i >= 0; --i)\n    {\n        rightIndices[i]= subarraySums[i] >= subarraySums[rightIndices[i + 1]] ? i : rightIndices[i + 1];\n    }\n\n    int maxTotalSum= 0;\n\n    for(int i= subarraySize; i < arraySize - 2 * subarraySize + 1; ++i)\n    {\n        int leftIndex= leftIndices[i - subarraySize], rightIndex= rightIndices[i + subarraySize], totalSum= subarraySums[leftIndex] + subarraySums[i] + subarraySums[rightIndex];\n        if(totalSum > maxTotalSum)\n        {\n            maxTotalSum= totalSum;\n            resultIndices= {leftIndex, i, rightIndex};\n        }\n    }\n\n    return resultIndices;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Employee\n{\n  public:\n    int id;\n    int importance;\n    vector<int> subordinateIds;\n};\n\nint getTotalImportance(vector<Employee *> employeeList, int employeeId)\n{\n    unordered_map<int, Employee *> employeeMap;\n    for(auto employeePtr : employeeList)\n    {\n        employeeMap[employeePtr->id] = employeePtr;\n    }\n    return calculateTotalImportance(employeeMap, employeeId);\n}\n\nint calculateTotalImportance(unordered_map<int, Employee *> &employeeMap, int employeeId)\n{\n    int totalImportance = employeeMap[employeeId]->importance;\n    for(int i = 0; i < employeeMap[employeeId]->subordinateIds.size(); ++i)\n    {\n        int subordinateId = employeeMap[employeeId]->subordinateIds[i];\n        totalImportance += calculateTotalImportance(employeeMap, subordinateId);\n    }\n    return totalImportance;\n}",
    "output": "#include <bits/stdc++.h>\nclass Employee\n{\n  public:\n    int id;\n    int importance;\n    std::vector<int> subordinateIds;\n};\n\nint getTotalImportance(std::vector<Employee *> employeeList, int employeeId)\n{\n    std::unordered_map<int, Employee *> employeeMap;\n    for(auto employeePtr : employeeList)\n    {\n        employeeMap[employeePtr->id] = employeePtr;\n    }\n    return calculateTotalImportance(employeeMap, employeeId);\n}\n\nint calculateTotalImportance(std::unordered_map<int, Employee *> &employeeMap, int employeeId)\n{\n    int totalImportance = employeeMap[employeeId]->importance;\n    for(int subordinateId : employeeMap[employeeId]->subordinateIds)\n    {\n        totalImportance += calculateTotalImportance(employeeMap, subordinateId);\n    }\n    return totalImportance;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minStickers(vector<string> &stickers, string target)\n{\n    unordered_map<string, int> memo;\n    vector<int> targetCount(26, 0);\n    for(char character : target)\n        targetCount[character - 'a']++;\n\n    for(int i = 0; i < stickers.size(); ++i)\n    {\n        string &sticker = stickers[i];\n        vector<int> stickerCount(26, 0);\n        int hasConnection = 0;\n        for(char character : sticker)\n        {\n            if(!targetCount[character - 'a'])\n                continue;\n            hasConnection = 1;\n            stickerCount[character - 'a']++;\n        }\n        if(!hasConnection)\n            continue;\n\n        string state = \"\";\n        for(int index = 0; index < 26; ++index)\n            state += string(stickerCount[index], 'a' + index);\n        memo[state] = 1;\n    }\n\n    function<int(const string &)> dynamicProgramming = [&](const string &state)\n    {\n        if(memo.count(state))\n            return memo[state];\n        vector<int> counts(26, 0);\n        for(char character : state)\n            counts[character - 'a']++;\n        int result = INT_MAX;\n        for(const auto &keyValue : memo)\n        {\n            bool isValid = true;\n            for(int index = 0; index < 26 && isValid; ++index)\n                isValid = counts[index] >= keyValue.first[index] - 'a';\n            if(!isValid)\n                continue;\n            result = min(result, dynamicProgramming(state.substr(keyValue.first.size())) + keyValue.second);\n        }\n        memo[state] = result == INT_MAX ? -1 : result;\n        return memo[state];\n    };\n\n    string startState = \"\";\n    for(int index = 0; index < 26; ++index)\n        startState += string(targetCount[index], 'a' + index);\n    return dynamicProgramming(startState);\n}",
    "output": "#include <bits/stdc++.h>\nint minStickers(std::vector<std::string> &stickers, std::string target)\n{\n    std::unordered_map<std::string, int> memo;\n    std::vector<int> targetCount(26, 0);\n    for(char character : target)\n        targetCount[character - 'a']++;\n\n    for(std::string &sticker : stickers)\n    {\n        std::vector<int> stickerCount(26, 0);\n        int hasConnection= 0;\n        for(char character : sticker)\n        {\n            if(!targetCount[character - 'a'])\n                continue;\n            hasConnection= 1;\n            stickerCount[character - 'a']++;\n        }\n        if(!hasConnection)\n            continue;\n\n        std::string state= \"\";\n        for(int index= 0; index < 26; ++index)\n            state+= std::string(stickerCount[index], 'a' + index);\n        memo[state]= 1;\n    }\n\n    std::function<int(const std::string &)> dynamicProgramming= [&](const std::string &state)\n    {\n        if(memo.count(state))\n            return memo[state];\n        std::vector<int> counts(26, 0);\n        for(char character : state)\n            counts[character - 'a']++;\n        int result= INT_MAX;\n        for(const auto &keyValue : memo)\n        {\n            bool isValid= true;\n            for(int index= 0; index < 26 && isValid; ++index)\n                isValid= counts[index] >= keyValue.first[index] - 'a';\n            if(!isValid)\n                continue;\n            result= std::min(result, dynamicProgramming(state.substr(keyValue.first.size())) + keyValue.second);\n        }\n        memo[state]= result == INT_MAX ? -1 : result;\n        return memo[state];\n    };\n\n    std::string startState= \"\";\n    for(int index= 0; index < 26; ++index)\n        startState+= std::string(targetCount[index], 'a' + index);\n    return dynamicProgramming(startState);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> getKFrequentWords(vector<string> &inputWords, int k)\n{\n    unordered_map<string, int> wordFrequency;\n    for (int i = 0; i < inputWords.size(); ++i)\n    {\n        wordFrequency[inputWords[i]]++;\n    }\n\n    auto comparator = [](const pair<string, int> &a, const pair<string, int> &b)\n    {\n        if (a.second == b.second)\n        {\n            return a.first > b.first;\n        }\n        return a.second < b.second;\n    };\n    priority_queue<pair<string, int>, vector<pair<string, int>>, decltype(comparator)> priorityQueue(comparator);\n\n    for (auto it = wordFrequency.begin(); it != wordFrequency.end(); ++it)\n    {\n        priorityQueue.push(*it);\n    }\n\n    vector<string> result;\n    for (int i = 0; i < k; ++i)\n    {\n        result.push_back(priorityQueue.top().first);\n        priorityQueue.pop();\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> getKFrequentWords(std::vector<std::string> &inputWords, int k)\n{\n    std::unordered_map<std::string, int> wordFrequency;\n    for(const auto &word : inputWords)\n    {\n        wordFrequency[word]++;\n    }\n\n    auto comparator= [](const std::pair<std::string, int> &a, const std::pair<std::string, int> &b)\n    {\n        if(a.second == b.second)\n        {\n            return a.first > b.first;\n        }\n        return a.second < b.second;\n    };\n    std::priority_queue<std::pair<std::string, int>, std::vector<std::pair<std::string, int>>, decltype(comparator)> priorityQueue(comparator);\n\n    for(const auto &wordCount : wordFrequency)\n    {\n        priorityQueue.push(wordCount);\n    }\n\n    std::vector<std::string> result;\n    for(int i= 0; i < k; ++i)\n    {\n        result.push_back(priorityQueue.top().first);\n        priorityQueue.pop();\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "bool hasAlternatingBits(int inputNumber)\n{\n    int previousBit= inputNumber % 2;\n    inputNumber/= 2;\n    while(inputNumber > 0)\n    {\n        int currentBit= inputNumber % 2;\n        if(currentBit == previousBit)\n            return false;\n        previousBit= currentBit;\n        inputNumber/= 2;\n    }\n    return true;\n}",
    "output": "bool hasAlternatingBits(int inputNumber)\n{\n    int previousBit= inputNumber % 2;\n    inputNumber/= 2;\n    while(inputNumber > 0)\n    {\n        int currentBit= inputNumber % 2;\n        if(currentBit == previousBit)\n            return false;\n        previousBit= currentBit;\n        inputNumber/= 2;\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(vector<vector<int>> &grid, int rowIndex, int columnIndex, int initialRow, int initialColumn, vector<pair<int, int>> &islandShape)\n{\n    if(rowIndex >= 0 && rowIndex < grid.size() && columnIndex >= 0 && columnIndex < grid[0].size() && grid[rowIndex][columnIndex] == 1)\n    {\n        grid[rowIndex][columnIndex]= 2;\n        islandShape.push_back({rowIndex - initialRow, columnIndex - initialColumn});\n        depthFirstSearch(grid, rowIndex - 1, columnIndex, initialRow, initialColumn, islandShape);\n        depthFirstSearch(grid, rowIndex + 1, columnIndex, initialRow, initialColumn, islandShape);\n        depthFirstSearch(grid, rowIndex, columnIndex - 1, initialRow, initialColumn, islandShape);\n        depthFirstSearch(grid, rowIndex, columnIndex + 1, initialRow, initialColumn, islandShape);\n    }\n}\n\nint countDistinctIslands(vector<vector<int>> &grid)\n{\n    set<vector<pair<int, int>>> uniqueIslands;\n    for(int rowIndex= 0; rowIndex < grid.size(); ++rowIndex)\n    {\n        for(int columnIndex= 0; columnIndex < grid[0].size(); ++columnIndex)\n        {\n            if(grid[rowIndex][columnIndex] == 1)\n            {\n                vector<pair<int, int>> islandShape;\n                depthFirstSearch(grid, rowIndex, columnIndex, rowIndex, columnIndex, islandShape);\n                sort(islandShape.begin(), islandShape.end());\n                uniqueIslands.insert(islandShape);\n            }\n        }\n    }\n    return uniqueIslands.size();\n}",
    "output": "#include <bits/stdc++.h>\nvoid depthFirstSearch(std::vector<std::vector<int>> &grid, int rowIndex, int columnIndex, int initialRow, int initialColumn, std::vector<std::pair<int, int>> &islandShape)\n{\n    if(rowIndex >= 0 && rowIndex < grid.size() && columnIndex >= 0 && columnIndex < grid[0].size() && grid[rowIndex][columnIndex] == 1)\n    {\n        grid[rowIndex][columnIndex]= 2;\n        islandShape.push_back({rowIndex - initialRow, columnIndex - initialColumn});\n        depthFirstSearch(grid, rowIndex - 1, columnIndex, initialRow, initialColumn, islandShape);\n        depthFirstSearch(grid, rowIndex + 1, columnIndex, initialRow, initialColumn, islandShape);\n        depthFirstSearch(grid, rowIndex, columnIndex - 1, initialRow, initialColumn, islandShape);\n        depthFirstSearch(grid, rowIndex, columnIndex + 1, initialRow, initialColumn, islandShape);\n    }\n}\n\nint countDistinctIslands(std::vector<std::vector<int>> &grid)\n{\n    std::set<std::vector<std::pair<int, int>>> uniqueIslands;\n    for(int rowIndex= 0; rowIndex < grid.size(); ++rowIndex)\n    {\n        for(int columnIndex= 0; columnIndex < grid[0].size(); ++columnIndex)\n        {\n            if(grid[rowIndex][columnIndex] == 1)\n            {\n                std::vector<std::pair<int, int>> islandShape;\n                depthFirstSearch(grid, rowIndex, columnIndex, rowIndex, columnIndex, islandShape);\n                std::sort(islandShape.begin(), islandShape.end());\n                uniqueIslands.insert(islandShape);\n            }\n        }\n    }\n    return uniqueIslands.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAreaOfIsland(vector<vector<int>> &grid)\n{\n    int maxArea= 0;\n\n    function<int(int, int)> dfs= [&](int row, int column)\n    {\n        if(row < 0 || row >= grid.size() || column < 0 || column >= grid[0].size() || grid[row][column] == 0)\n        {\n            return 0;\n        }\n        grid[row][column]= 0;\n        return 1 + dfs(row - 1, column) + dfs(row + 1, column) + dfs(row, column - 1) + dfs(row, column + 1);\n    };\n\n    for(int row= 0; row < grid.size(); row++)\n    {\n        for(int column= 0; column < grid[0].size(); column++)\n        {\n            if(grid[row][column])\n            {\n                maxArea= max(maxArea, dfs(row, column));\n            }\n        }\n    }\n    return maxArea;\n}",
    "output": "#include <bits/stdc++.h>\nint maxAreaOfIsland(std::vector<std::vector<int>> &grid)\n{\n    int maxArea= 0;\n\n    std::function<int(int, int)> dfs= [&](int row, int column)\n    {\n        if(row < 0 || row >= grid.size() || column < 0 || column >= grid[0].size() || grid[row][column] == 0)\n        {\n            return 0;\n        }\n        grid[row][column]= 0;\n        return 1 + dfs(row - 1, column) + dfs(row + 1, column) + dfs(row, column - 1) + dfs(row, column + 1);\n    };\n\n    for(int row= 0; row < grid.size(); row++)\n    {\n        for(int column= 0; column < grid[0].size(); column++)\n        {\n            if(grid[row][column])\n            {\n                maxArea= std::max(maxArea, dfs(row, column));\n            }\n        }\n    }\n    return maxArea;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countBinarySubstrings(string binaryString)\n{\n    int previousCount= 0, currentCount= 1, totalSubstrings= 0;\n    for(int index= 1; index < binaryString.length(); index++)\n    {\n        if(binaryString[index] == binaryString[index - 1])\n        {\n            currentCount++;\n        }\n        else\n        {\n            totalSubstrings+= min(previousCount, currentCount);\n            previousCount= currentCount;\n            currentCount= 1;\n        }\n    }\n    return totalSubstrings + min(previousCount, currentCount);\n}",
    "output": "#include <bits/stdc++.h>\nint countBinarySubstrings(std::string binaryString)\n{\n    int previousCount= 0, currentCount= 1, totalSubstrings= 0;\n    for(int index= 1; index < binaryString.length(); index++)\n    {\n        if(binaryString[index] == binaryString[index - 1])\n        {\n            currentCount++;\n        }\n        else\n        {\n            totalSubstrings+= std::min(previousCount, currentCount);\n            previousCount= currentCount;\n            currentCount= 1;\n        }\n    }\n    return totalSubstrings + std::min(previousCount, currentCount);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findShortestSubArray(vector<int> &numberList)\n{\n    unordered_map<int, int> frequencyMap, startIndexMap;\n    int maxFrequency = 0, minLength = numberList.size();\n\n    for(int index = 0; index < numberList.size(); ++index)\n    {\n        if(startIndexMap.count(numberList[index]) == 0)\n        {\n            startIndexMap[numberList[index]] = index;\n        }\n        frequencyMap[numberList[index]]++;\n\n        int frequency = frequencyMap[numberList[index]];\n        if(frequency > maxFrequency)\n        {\n            maxFrequency = frequency;\n            minLength = index - startIndexMap[numberList[index]] + 1;\n        }\n        else if(frequency == maxFrequency)\n        {\n            minLength = min(minLength, index - startIndexMap[numberList[index]] + 1);\n        }\n    }\n\n    return minLength;\n}",
    "output": "#include <bits/stdc++.h>\nint findShortestSubArray(std::vector<int> &numberList)\n{\n    std::unordered_map<int, int> frequencyMap, startIndexMap;\n    int maxFrequency= 0, minLength= numberList.size();\n\n    for(int index= 0; index < numberList.size(); ++index)\n    {\n        if(startIndexMap.count(numberList[index]) == 0)\n        {\n            startIndexMap[numberList[index]]= index;\n        }\n        frequencyMap[numberList[index]]++;\n\n        int frequency= frequencyMap[numberList[index]];\n        if(frequency > maxFrequency)\n        {\n            maxFrequency= frequency;\n            minLength= index - startIndexMap[numberList[index]] + 1;\n        }\n        else if(frequency == maxFrequency)\n        {\n            minLength= std::min(minLength, index - startIndexMap[numberList[index]] + 1);\n        }\n    }\n\n    return minLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canPartitionKSubsets(vector<int> &numbers, int subsetCount)\n{\n    int totalSum = accumulate(numbers.begin(), numbers.end(), 0);\n    if(totalSum % subsetCount != 0)\n        return false;\n    int targetSum = totalSum / subsetCount;\n    vector<bool> visited(numbers.size(), false);\n    return depthFirstSearch(numbers, visited, 0, targetSum, 0, subsetCount);\n}\n\nbool depthFirstSearch(vector<int> &numbers, vector<bool> &visited, int startIndex, int targetSum, int currentSum, int subsetCount)\n{\n    if(subsetCount == 1)\n        return true;\n    if(currentSum == targetSum)\n        return depthFirstSearch(numbers, visited, 0, targetSum, 0, subsetCount - 1);\n    for(int i = startIndex; i < numbers.size(); i++)\n    {\n        if(!visited[i] && currentSum + numbers[i] <= targetSum)\n        {\n            visited[i] = true;\n            if(depthFirstSearch(numbers, visited, i + 1, targetSum, currentSum + numbers[i], subsetCount))\n                return true;\n            visited[i] = false;\n        }\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool canPartitionKSubsets(std::vector<int> &numbers, int subsetCount)\n{\n    int totalSum= std::accumulate(numbers.begin(), numbers.end(), 0);\n    if(totalSum % subsetCount != 0)\n        return false;\n    int targetSum= totalSum / subsetCount;\n    std::vector<bool> visited(numbers.size(), false);\n    return depthFirstSearch(numbers, visited, 0, targetSum, 0, subsetCount);\n}\n\nbool depthFirstSearch(std::vector<int> &numbers, std::vector<bool> &visited, int startIndex, int targetSum, int currentSum, int subsetCount)\n{\n    if(subsetCount == 1)\n        return true;\n    if(currentSum == targetSum)\n        return depthFirstSearch(numbers, visited, 0, targetSum, 0, subsetCount - 1);\n    for(int i= startIndex; i < numbers.size(); i++)\n    {\n        if(!visited[i] && currentSum + numbers[i] <= targetSum)\n        {\n            visited[i]= true;\n            if(depthFirstSearch(numbers, visited, i + 1, targetSum, currentSum + numbers[i], subsetCount))\n                return true;\n            visited[i]= false;\n        }\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> fallingSquares(vector<vector<int>> &squarePositions)\n{\n    vector<int> heights;\n    vector<pair<int, int>> heightIntervals;\n\n    for (int i = 0; i < squarePositions.size(); ++i)\n    {\n        vector<int> square = squarePositions[i];\n        int leftPosition = square[0];\n        int rightPosition = square[0] + square[1];\n        int currentHeight = square[1];\n        for (int j = 0; j < heightIntervals.size(); ++j)\n        {\n            auto interval = heightIntervals[j];\n            if (interval.first < rightPosition && leftPosition < interval.second)\n            {\n                currentHeight = max(currentHeight, square[1] + interval.first);\n            }\n        }\n\n        int maxHeight = currentHeight;\n        for (int j = 0; j < heightIntervals.size(); ++j)\n        {\n            auto interval = heightIntervals[j];\n            maxHeight = max(maxHeight, interval.first);\n        }\n\n        heights.push_back(maxHeight);\n        heightIntervals.push_back(make_pair(currentHeight, rightPosition));\n    }\n\n    return heights;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> fallingSquares(std::vector<std::vector<int>> &squarePositions)\n{\n    std::vector<int> heights;\n    std::vector<std::pair<int, int>> heightIntervals;\n\n    for(auto square : squarePositions)\n    {\n        int leftPosition= square[0];\n        int rightPosition= square[0] + square[1];\n        int currentHeight= square[1];\n        for(auto interval : heightIntervals)\n        {\n            if(interval.first < rightPosition && leftPosition < interval.second)\n            {\n                currentHeight= std::max(currentHeight, square[1] + interval.first);\n            }\n        }\n\n        int maxHeight= currentHeight;\n        for(auto interval : heightIntervals)\n        {\n            maxHeight= std::max(maxHeight, interval.first);\n        }\n\n        heights.push_back(maxHeight);\n        heightIntervals.push_back(std::make_pair(currentHeight, rightPosition));\n    }\n\n    return heights;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int Value;\n    TreeNode *LeftChild;\n    TreeNode *RightChild;\n};\n\nTreeNode *searchBst(TreeNode *rootNode, int searchValue)\n{\n    if(!rootNode || rootNode->Value == searchValue)\n        return rootNode;\n    return (rootNode->Value < searchValue) ? searchBst(rootNode->RightChild, searchValue) : searchBst(rootNode->LeftChild, searchValue);\n}",
    "output": "struct TreeNode\n{\n    int Value;\n    TreeNode *LeftChild;\n    TreeNode *RightChild;\n};\n\nTreeNode *searchBst(TreeNode *rootNode, int searchValue)\n{\n    if(!rootNode || rootNode->Value == searchValue)\n        return rootNode;\n    return (rootNode->Value < searchValue) ? searchBst(rootNode->RightChild, searchValue) : searchBst(rootNode->LeftChild, searchValue);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int value) : value(value), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int value, TreeNode *leftChild, TreeNode *rightChild) : value(value), leftChild(leftChild), rightChild(rightChild) {}\n};\n\nTreeNode *insertIntoBST(TreeNode *rootNode, int value)\n{\n    if(!rootNode)\n        return new TreeNode(value);\n\n    if(value < rootNode->value)\n    {\n        rootNode->leftChild= insertIntoBST(rootNode->leftChild, value);\n    }\n    else\n    {\n        rootNode->rightChild= insertIntoBST(rootNode->rightChild, value);\n    }\n\n    return rootNode;\n}",
    "output": "class TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int value) : value(value), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int value, TreeNode *leftChild, TreeNode *rightChild) : value(value), leftChild(leftChild), rightChild(rightChild) {}\n};\n\nTreeNode *insertIntoBST(TreeNode *rootNode, int value)\n{\n    if(!rootNode)\n        return new TreeNode(value);\n\n    if(value < rootNode->value)\n    {\n        rootNode->leftChild= insertIntoBST(rootNode->leftChild, value);\n    }\n    else\n    {\n        rootNode->rightChild= insertIntoBST(rootNode->rightChild, value);\n    }\n\n    return rootNode;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass ArrayReader {\npublic:\n    int get(int index) const;\n    // Other members and methods of ArrayReader...\n};\n\nint search(const ArrayReader &arrayReader, int targetValue)\n{\n    int leftIndex= 0, rightIndex= 1;\n    while(arrayReader.get(rightIndex) < targetValue)\n    {\n        leftIndex= rightIndex;\n        rightIndex<<= 1;\n    }\n\n    while(leftIndex <= rightIndex)\n    {\n        int midIndex= leftIndex + ((rightIndex - leftIndex) >> 1);\n        int currentValue= arrayReader.get(midIndex);\n        if(currentValue == targetValue)\n            return midIndex;\n        if(currentValue > targetValue)\n            rightIndex= midIndex - 1;\n        else\n            leftIndex= midIndex + 1;\n    }\n    return -1;\n}",
    "output": "int search(const ArrayReader &arrayReader, int targetValue)\n{\n    int leftIndex= 0, rightIndex= 1;\n    while(arrayReader.get(rightIndex) < targetValue)\n    {\n        leftIndex= rightIndex;\n        rightIndex<<= 1;\n    }\n\n    while(leftIndex <= rightIndex)\n    {\n        int midIndex= leftIndex + ((rightIndex - leftIndex) >> 1);\n        int currentValue= arrayReader.get(midIndex);\n        if(currentValue == targetValue)\n            return midIndex;\n        if(currentValue > targetValue)\n            rightIndex= midIndex - 1;\n        else\n            leftIndex= midIndex + 1;\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass KthLargest\n{\n  public:\n    int k;\n    priority_queue<int, vector<int>, greater<int>> minHeap;\n\n    KthLargest(int k, vector<int> &numbers)\n    {\n        this->k = k;\n        for (int i = 0; i < numbers.size(); ++i)\n        {\n            add(numbers[i]);\n        }\n    }\n\n    int add(int value)\n    {\n        minHeap.push(value);\n        if (minHeap.size() > k)\n        {\n            minHeap.pop();\n        }\n        return minHeap.top();\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass KthLargest\n{\n  public:\n    int k;\n    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;\n\n    KthLargest(int k, std::vector<int> &numbers)\n    {\n        this->k= k;\n        for(int number : numbers)\n        {\n            add(number);\n        }\n    }\n\n    int add(int value)\n    {\n        minHeap.push(value);\n        if(minHeap.size() > k)\n        {\n            minHeap.pop();\n        }\n        return minHeap.top();\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint search(vector<int> &numberList, int targetNumber)\n{\n    int leftIndex= 0, rightIndex= numberList.size() - 1;\n    while(leftIndex <= rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(numberList[midIndex] == targetNumber)\n            return midIndex;\n        if(numberList[midIndex] < targetNumber)\n            leftIndex= midIndex + 1;\n        else\n            rightIndex= midIndex - 1;\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint search(std::vector<int> &numberList, int targetNumber)\n{\n    int leftIndex= 0, rightIndex= numberList.size() - 1;\n    while(leftIndex <= rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(numberList[midIndex] == targetNumber)\n            return midIndex;\n        if(numberList[midIndex] < targetNumber)\n            leftIndex= midIndex + 1;\n        else\n            rightIndex= midIndex - 1;\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass MyHashSet\n{\n  public:\n    vector<bool> storage;\n\n    MyHashSet() : storage(1000001, false) {}\n\n    void add(int key)\n    {\n        storage[key] = true;\n    }\n\n    void remove(int key)\n    {\n        storage[key] = false;\n    }\n\n    bool contains(int key)\n    {\n        return storage[key];\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass MyHashSet\n{\n  public:\n    std::vector<bool> storage;\n\n    MyHashSet() : storage(1000001, false) {}\n\n    void add(int key)\n    {\n        storage[key] = true;\n    }\n\n    void remove(int key)\n    {\n        storage[key] = false;\n    }\n\n    bool contains(int key)\n    {\n        return storage[key];\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass MyHashMap\n{\n  public:\n    vector<list<pair<int, int>>> buckets;\n    static const int hashMapSize = 10007;\n\n    MyHashMap()\n    {\n        buckets = vector<list<pair<int, int>>>(hashMapSize);\n    }\n\n    void put(int key, int value)\n    {\n        auto &bucket = buckets[key % hashMapSize];\n        for (auto it = bucket.begin(); it != bucket.end(); ++it)\n        {\n            if (it->first == key)\n            {\n                it->second = value;\n                return;\n            }\n        }\n        bucket.emplace_back(key, value);\n    }\n\n    int get(int key)\n    {\n        const auto &bucket = buckets[key % hashMapSize];\n        for (auto it = bucket.begin(); it != bucket.end(); ++it)\n        {\n            if (it->first == key)\n            {\n                return it->second;\n            }\n        }\n        return -1;\n    }\n\n    void remove(int key)\n    {\n        auto &bucket = buckets[key % hashMapSize];\n        bucket.remove_if([key](const auto &keyValuePair)\n                         { return keyValuePair.first == key; });\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass MyHashMap\n{\n  public:\n    std::vector<std::list<std::pair<int, int>>> buckets;\n    static const int hashMapSize= 10007;\n\n    MyHashMap()\n    {\n        buckets= std::vector<std::list<std::pair<int, int>>>(hashMapSize);\n    }\n\n    void put(int key, int value)\n    {\n        auto &bucket= buckets[key % hashMapSize];\n        for(auto &keyValuePair : bucket)\n        {\n            if(keyValuePair.first == key)\n            {\n                keyValuePair.second= value;\n                return;\n            }\n        }\n        bucket.emplace_back(key, value);\n    }\n\n    int get(int key)\n    {\n        const auto &bucket= buckets[key % hashMapSize];\n        for(const auto &keyValuePair : bucket)\n        {\n            if(keyValuePair.first == key)\n            {\n                return keyValuePair.second;\n            }\n        }\n        return -1;\n    }\n\n    void remove(int key)\n    {\n        auto &bucket= buckets[key % hashMapSize];\n        bucket.remove_if([key](const auto &keyValuePair)\n                         { return keyValuePair.first == key; });\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class Node\n{\n  public:\n    int value;\n    Node *next;\n    Node(int value) : value(value), next(NULL) {}\n};\n\nclass MyLinkedList\n{\n  public:\n    MyLinkedList() : head(NULL), size(0) {}\n\n    int get(int index)\n    {\n        if(index < 0 || index >= size)\n            return -1;\n        Node *current= head;\n        for(int i= 0; i < index; ++i)\n        {\n            current= current->next;\n        }\n        return current->value;\n    }\n\n    void addAtHead(int value)\n    {\n        Node *newNode= new Node(value);\n        newNode->next= head;\n        head= newNode;\n        size++;\n    }\n\n    void addAtTail(int value)\n    {\n        if(size == 0)\n        {\n            addAtHead(value);\n        }\n        else\n        {\n            Node *current= head;\n            while(current->next)\n            {\n                current= current->next;\n            }\n            current->next= new Node(value);\n            size++;\n        }\n    }\n\n    void addAtIndex(int index, int value)\n    {\n        if(index < 0 || index > size)\n            return;\n        if(index == 0)\n        {\n            addAtHead(value);\n        }\n        else\n        {\n            Node *current= head;\n            for(int i= 0; i < index - 1; ++i)\n            {\n                current= current->next;\n            }\n            Node *newNode= new Node(value);\n            newNode->next= current->next;\n            current->next= newNode;\n            size++;\n        }\n    }\n\n    void deleteAtIndex(int index)\n    {\n        if(index < 0 || index >= size)\n            return;\n        if(index == 0)\n        {\n            Node *temp= head;\n            head= head->next;\n            delete temp;\n        }\n        else\n        {\n            Node *current= head;\n            for(int i= 0; i < index - 1; ++i)\n            {\n                current= current->next;\n            }\n            Node *temp= current->next;\n            current->next= temp->next;\n            delete temp;\n        }\n        size--;\n    }\n\n  private:\n    Node *head;\n    int size;\n};",
    "output": "class Node\n{\n  public:\n    int value;\n    Node *next;\n    Node(int value) : value(value), next(NULL) {}\n};\n\nclass MyLinkedList\n{\n  public:\n    MyLinkedList() : head(NULL), size(0) {}\n\n    int get(int index)\n    {\n        if(index < 0 || index >= size)\n            return -1;\n        Node *current= head;\n        for(int i= 0; i < index; ++i)\n        {\n            current= current->next;\n        }\n        return current->value;\n    }\n\n    void addAtHead(int value)\n    {\n        Node *newNode= new Node(value);\n        newNode->next= head;\n        head= newNode;\n        size++;\n    }\n\n    void addAtTail(int value)\n    {\n        if(size == 0)\n        {\n            addAtHead(value);\n        }\n        else\n        {\n            Node *current= head;\n            while(current->next)\n            {\n                current= current->next;\n            }\n            current->next= new Node(value);\n            size++;\n        }\n    }\n\n    void addAtIndex(int index, int value)\n    {\n        if(index < 0 || index > size)\n            return;\n        if(index == 0)\n        {\n            addAtHead(value);\n        }\n        else\n        {\n            Node *current= head;\n            for(int i= 0; i < index - 1; ++i)\n            {\n                current= current->next;\n            }\n            Node *newNode= new Node(value);\n            newNode->next= current->next;\n            current->next= newNode;\n            size++;\n        }\n    }\n\n    void deleteAtIndex(int index)\n    {\n        if(index < 0 || index >= size)\n            return;\n        if(index == 0)\n        {\n            Node *temp= head;\n            head= head->next;\n            delete temp;\n        }\n        else\n        {\n            Node *current= head;\n            for(int i= 0; i < index - 1; ++i)\n            {\n                current= current->next;\n            }\n            Node *temp= current->next;\n            current->next= temp->next;\n            delete temp;\n        }\n        size--;\n    }\n\n  private:\n    Node *head;\n    int size;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class Node\n{\n  public:\n    int value;\n    Node *nextNode;\n    Node() : value(0), nextNode(NULL) {}\n    Node(int initialValue) : value(initialValue), nextNode(NULL) {}\n    Node(int initialValue, Node *nextNode) : value(initialValue), nextNode(nextNode) {}\n};\n\nNode *insert(Node *headNode, int valueToInsert)\n{\n    if(headNode == NULL)\n    {\n        Node *newNode= new Node(valueToInsert);\n        newNode->nextNode= newNode;\n        return newNode;\n    }\n\n    Node *previousNode= headNode;\n    Node *currentNode= headNode->nextNode;\n    bool isInserted= false;\n\n    do\n    {\n        if(previousNode->value <= valueToInsert && valueToInsert <= currentNode->value)\n        {\n            previousNode->nextNode= new Node(valueToInsert, currentNode);\n            isInserted= true;\n        }\n        else if(previousNode->value > currentNode->value)\n        {\n            if(valueToInsert >= previousNode->value || valueToInsert <= currentNode->value)\n            {\n                previousNode->nextNode= new Node(valueToInsert, currentNode);\n                isInserted= true;\n            }\n        }\n        previousNode= currentNode;\n        currentNode= currentNode->nextNode;\n    } while(previousNode != headNode && !isInserted);\n\n    if(!isInserted)\n    {\n        previousNode->nextNode= new Node(valueToInsert, currentNode);\n    }\n\n    return headNode;\n}",
    "output": "class Node\n{\n  public:\n    int value;\n    Node *nextNode;\n    Node() : value(0), nextNode(NULL) {}\n    Node(int initialValue) : value(initialValue), nextNode(NULL) {}\n    Node(int initialValue, Node *nextNode) : value(initialValue), nextNode(nextNode) {}\n};\n\nNode *insert(Node *headNode, int valueToInsert)\n{\n    if(headNode == NULL)\n    {\n        Node *newNode= new Node(valueToInsert);\n        newNode->nextNode= newNode;\n        return newNode;\n    }\n\n    Node *previousNode= headNode;\n    Node *currentNode= headNode->nextNode;\n    bool isInserted= false;\n\n    do\n    {\n        if(previousNode->value <= valueToInsert && valueToInsert <= currentNode->value)\n        {\n            previousNode->nextNode= new Node(valueToInsert, currentNode);\n            isInserted= true;\n        }\n        else if(previousNode->value > currentNode->value)\n        {\n            if(valueToInsert >= previousNode->value || valueToInsert <= currentNode->value)\n            {\n                previousNode->nextNode= new Node(valueToInsert, currentNode);\n                isInserted= true;\n            }\n        }\n        previousNode= currentNode;\n        currentNode= currentNode->nextNode;\n    } while(previousNode != headNode && !isInserted);\n\n    if(!isInserted)\n    {\n        previousNode->nextNode= new Node(valueToInsert, currentNode);\n    }\n\n    return headNode;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring convertToLowerCase(string inputString)\n{\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char &currentCharacter = inputString[i];\n        if (currentCharacter >= 'A' && currentCharacter <= 'Z')\n        {\n            currentCharacter = currentCharacter - 'A' + 'a';\n        }\n    }\n    return inputString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string convertToLowerCase(std::string inputString)\n{\n    for(char &currentCharacter : inputString)\n    {\n        if(currentCharacter >= 'A' && currentCharacter <= 'Z')\n        {\n            currentCharacter= currentCharacter - 'A' + 'a';\n        }\n    }\n    return inputString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution\n{\n  public:\n    Solution(int totalNumbers, vector<int> &blacklist)\n    {\n        sort(blacklist.begin(), blacklist.end());\n        auto blacklistIterator = blacklist.begin();\n        int currentIndex = 0;\n        for (int i = 0; i < blacklist.size(); ++i)\n        {\n            int blacklistedNumber = *blacklistIterator++;\n            while (currentIndex < blacklistedNumber)\n            {\n                mapping[currentIndex++] = totalNumbers - 1;\n                --totalNumbers;\n            }\n            ++currentIndex;\n            --totalNumbers;\n        }\n        lastAvailableNumber = totalNumbers;\n    }\n\n    int pick()\n    {\n        int randomNumber = rand() % lastAvailableNumber;\n        auto result = mapping.find(randomNumber);\n        return result == mapping.end() ? randomNumber : result->second;\n    }\n\n  private:\n    unordered_map<int, int> mapping;\n    int lastAvailableNumber;\n};",
    "output": "#include <bits/stdc++.h>\nclass Solution\n{\n  public:\n    Solution(int totalNumbers, std::vector<int> &blacklist)\n    {\n        std::sort(blacklist.begin(), blacklist.end());\n        auto blacklistIterator= blacklist.begin();\n        int currentIndex= 0;\n        for(int i= 0; i < blacklist.size(); ++i)\n        {\n            int blacklistedNumber= *blacklistIterator++;\n            while(currentIndex < blacklistedNumber)\n            {\n                mapping[currentIndex++]= totalNumbers - 1;\n                --totalNumbers;\n            }\n            ++currentIndex;\n            --totalNumbers;\n        }\n        lastAvailableNumber= totalNumbers;\n    }\n\n    int pick()\n    {\n        int randomNumber= rand() % lastAvailableNumber;\n        auto result= mapping.find(randomNumber);\n        return result == mapping.end() ? randomNumber : result->second;\n    }\n\n  private:\n    std::unordered_map<int, int> mapping;\n    int lastAvailableNumber;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// Include this for std::sort\n\nusing namespace std;\n\nclass Solution\n{\n  private:\n    void depthFirstSearch(int currentRow, int currentColumn, int originRow, int originColumn, vector<vector<int>> &grid, vector<pair<int, int>> &islandShape)\n    {\n        if(currentRow >= 0 && currentColumn >= 0 && currentRow < grid.size() && currentColumn < grid[currentRow].size() && grid[currentRow][currentColumn] == 1)\n        {\n            grid[currentRow][currentColumn]= 0;\n            islandShape.push_back({currentRow - originRow, currentColumn - originColumn});\n            depthFirstSearch(currentRow + 1, currentColumn, originRow, originColumn, grid, islandShape);\n            depthFirstSearch(currentRow - 1, currentColumn, originRow, originColumn, grid, islandShape);\n            depthFirstSearch(currentRow, currentColumn + 1, originRow, originColumn, grid, islandShape);\n            depthFirstSearch(currentRow, currentColumn - 1, originRow, originColumn, grid, islandShape);\n        }\n    }\n\n    vector<pair<int, int>> normalizeIslandShape(vector<pair<int, int>> &islandShape)\n    {\n        vector<vector<pair<int, int>>> transformations(8);\n        for(auto it = islandShape.begin(); it != islandShape.end(); ++it)\n        {\n            int x = it->first;\n            int y = it->second;\n            transformations[0].push_back({x, y});\n            transformations[1].push_back({x, -y});\n            transformations[2].push_back({-x, y});\n            transformations[3].push_back({-x, -y});\n            transformations[4].push_back({y, x});\n            transformations[5].push_back({y, -x});\n            transformations[6].push_back({-y, x});\n            transformations[7].push_back({-y, -x});\n        }\n        for(auto &list : transformations)\n        {\n            sort(list.begin(), list.end());\n        }\n        sort(transformations.begin(), transformations.end());\n        return transformations[0];\n    }\n\n  public:\n    int numDistinctIslands(vector<vector<int>> &grid)\n    {\n        unordered_set<string> distinctIslandShapes;\n        for(int row = 0; row < grid.size(); ++row)\n        {\n            for(int column = 0; column < grid[row].size(); ++column)\n            {\n                if(grid[row][column] == 1)\n                {\n                    vector<pair<int, int>> islandShape;\n                    depthFirstSearch(row, column, row, column, grid, islandShape);\n                    distinctIslandShapes.insert(normalizeIslandShape(islandShape));\n                }\n            }\n        }\n        return distinctIslandShapes.size();\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Solution\n{\n  private:\n    void depthFirstSearch(int currentRow, int currentColumn, int originRow, int originColumn, std::vector<std::vector<int>> &grid, std::vector<std::pair<int, int>> &islandShape)\n    {\n        if(currentRow >= 0 && currentColumn >= 0 && currentRow < grid.size() && currentColumn < grid[currentRow].size() && grid[currentRow][currentColumn] == 1)\n        {\n            grid[currentRow][currentColumn]= 0;\n            islandShape.push_back({currentRow - originRow, currentColumn - originColumn});\n            depthFirstSearch(currentRow + 1, currentColumn, originRow, originColumn, grid, islandShape);\n            depthFirstSearch(currentRow - 1, currentColumn, originRow, originColumn, grid, islandShape);\n            depthFirstSearch(currentRow, currentColumn + 1, originRow, originColumn, grid, islandShape);\n            depthFirstSearch(currentRow, currentColumn - 1, originRow, originColumn, grid, islandShape);\n        }\n    }\n\n    std::vector<std::pair<int, int>> normalizeIslandShape(std::vector<std::pair<int, int>> &islandShape)\n    {\n        std::vector<std::vector<std::pair<int, int>>> transformations(8);\n        for(const auto &point : islandShape)\n        {\n            int x= point.first;\n            int y= point.second;\n            transformations[0].push_back({x, y});\n            transformations[1].push_back({x, -y});\n            transformations[2].push_back({-x, y});\n            transformations[3].push_back({-x, -y});\n            transformations[4].push_back({y, x});\n            transformations[5].push_back({y, -x});\n            transformations[6].push_back({-y, x});\n            transformations[7].push_back({-y, -x});\n        }\n        for(auto &list : transformations)\n        {\n            std::sort(list.begin(), list.end());\n        }\n        std::sort(transformations.begin(), transformations.end());\n        return transformations[0];\n    }\n\n  public:\n    int numDistinctIslands(std::vector<std::vector<int>> &grid)\n    {\n        std::unordered_set<std::string> distinctIslandShapes;\n        for(int row= 0; row < grid.size(); ++row)\n        {\n            for(int column= 0; column < grid[row].size(); ++column)\n            {\n                if(grid[row][column] == 1)\n                {\n                    std::vector<std::pair<int, int>> islandShape;\n                    depthFirstSearch(row, column, row, column, grid, islandShape);\n                    distinctIslandShapes.insert(normalizeIslandShape(islandShape));\n                }\n            }\n        }\n        return distinctIslandShapes.size();\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumDeleteSum(string sourceString, string targetString)\n{\n    int dynamicProgrammingTable[1001][1001]= {0};\n    for(int sourceIndex= 1; sourceIndex <= sourceString.size(); sourceIndex++)\n    {\n        dynamicProgrammingTable[sourceIndex][0]= dynamicProgrammingTable[sourceIndex - 1][0] + sourceString[sourceIndex - 1];\n    }\n    for(int targetIndex= 1; targetIndex <= targetString.size(); targetIndex++)\n    {\n        dynamicProgrammingTable[0][targetIndex]= dynamicProgrammingTable[0][targetIndex - 1] + targetString[targetIndex - 1];\n    }\n    for(int sourceIndex= 1; sourceIndex <= sourceString.size(); sourceIndex++)\n    {\n        for(int targetIndex= 1; targetIndex <= targetString.size(); targetIndex++)\n        {\n            if(sourceString[sourceIndex - 1] == targetString[targetIndex - 1])\n            {\n                dynamicProgrammingTable[sourceIndex][targetIndex]= dynamicProgrammingTable[sourceIndex - 1][targetIndex - 1];\n            }\n            else\n            {\n                dynamicProgrammingTable[sourceIndex][targetIndex]= min(dynamicProgrammingTable[sourceIndex - 1][targetIndex] + sourceString[sourceIndex - 1], dynamicProgrammingTable[sourceIndex][targetIndex - 1] + targetString[targetIndex - 1]);\n            }\n        }\n    }\n    return dynamicProgrammingTable[sourceString.size()][targetString.size()];\n}",
    "output": "int minimumDeleteSum(std::string sourceString, std::string targetString)\n{\n    int dynamicProgrammingTable[1001][1001]= {0};\n    for(int sourceIndex= 1; sourceIndex <= sourceString.size(); sourceIndex++)\n    {\n        dynamicProgrammingTable[sourceIndex][0]= dynamicProgrammingTable[sourceIndex - 1][0] + sourceString[sourceIndex - 1];\n    }\n    for(int targetIndex= 1; targetIndex <= targetString.size(); targetIndex++)\n    {\n        dynamicProgrammingTable[0][targetIndex]= dynamicProgrammingTable[0][targetIndex - 1] + targetString[targetIndex - 1];\n    }\n    for(int sourceIndex= 1; sourceIndex <= sourceString.size(); sourceIndex++)\n    {\n        for(int targetIndex= 1; targetIndex <= targetString.size(); targetIndex++)\n        {\n            if(sourceString[sourceIndex - 1] == targetString[targetIndex - 1])\n            {\n                dynamicProgrammingTable[sourceIndex][targetIndex]= dynamicProgrammingTable[sourceIndex - 1][targetIndex - 1];\n            }\n            else\n            {\n                dynamicProgrammingTable[sourceIndex][targetIndex]= std::min(dynamicProgrammingTable[sourceIndex - 1][targetIndex] + sourceString[sourceIndex - 1], dynamicProgrammingTable[sourceIndex][targetIndex - 1] + targetString[targetIndex - 1]);\n            }\n        }\n    }\n    return dynamicProgrammingTable[sourceString.size()][targetString.size()];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countSubarraysWithProductLessThanK(vector<int> &numbers, int threshold)\n{\n    if(threshold <= 1)\n        return 0;\n    int product= 1, subarrayCount= 0, leftIndex= 0;\n    for(int rightIndex= 0; rightIndex < numbers.size(); rightIndex++)\n    {\n        product*= numbers[rightIndex];\n        while(product >= threshold)\n            product/= numbers[leftIndex++];\n        subarrayCount+= rightIndex - leftIndex + 1;\n    }\n    return subarrayCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countSubarraysWithProductLessThanK(std::vector<int> &numbers, int threshold)\n{\n    if(threshold <= 1)\n        return 0;\n    int product= 1, subarrayCount= 0, leftIndex= 0;\n    for(int rightIndex= 0; rightIndex < numbers.size(); rightIndex++)\n    {\n        product*= numbers[rightIndex];\n        while(product >= threshold)\n            product/= numbers[leftIndex++];\n        subarrayCount+= rightIndex - leftIndex + 1;\n    }\n    return subarrayCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxProfit(vector<int> &stockPrices, int transactionFee)\n{\n    int cashOnHand = 0, stockHoldings = -stockPrices[0];\n    for (int i = 0; i < stockPrices.size(); ++i)\n    {\n        int currentPrice = stockPrices[i];\n        int previousCash = cashOnHand;\n        cashOnHand = max(cashOnHand, stockHoldings + currentPrice - transactionFee);\n        stockHoldings = max(stockHoldings, previousCash - currentPrice);\n    }\n    return cashOnHand;\n}",
    "output": "#include <bits/stdc++.h>\nint maxProfit(std::vector<int> &stockPrices, int transactionFee)\n{\n    int cashOnHand= 0, stockHoldings= -stockPrices[0];\n    for(int currentPrice : stockPrices)\n    {\n        int previousCash= cashOnHand;\n        cashOnHand= std::max(cashOnHand, stockHoldings + currentPrice - transactionFee);\n        stockHoldings= std::max(stockHoldings, previousCash - currentPrice);\n    }\n    return cashOnHand;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass MaxStack\n{\n    stack<int> mainStack;\n    multiset<int> maxSet;\n\n  public:\n    MaxStack() {}\n\n    void push(int value)\n    {\n        mainStack.push(value);\n        maxSet.insert(value);\n    }\n\n    int pop()\n    {\n        int topValue = mainStack.top();\n        mainStack.pop();\n        maxSet.erase(maxSet.find(topValue));\n        return topValue;\n    }\n\n    int top()\n    {\n        return mainStack.top();\n    }\n\n    int peekMax()\n    {\n        return *maxSet.rbegin();\n    }\n\n    int popMax()\n    {\n        int maxValue = *maxSet.rbegin();\n        maxSet.erase(maxSet.find(maxValue));\n\n        stack<int> tempStack;\n        while (mainStack.top() != maxValue)\n        {\n            tempStack.push(mainStack.top());\n            mainStack.pop();\n        }\n        mainStack.pop();\n        while (!tempStack.empty())\n        {\n            mainStack.push(tempStack.top());\n            tempStack.pop();\n        }\n\n        return maxValue;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass MaxStack\n{\n    std::stack<int> mainStack;\n    std::multiset<int> maxSet;\n\n  public:\n    MaxStack() {}\n\n    void push(int value)\n    {\n        mainStack.push(value);\n        maxSet.insert(value);\n    }\n\n    int pop()\n    {\n        int topValue= mainStack.top();\n        mainStack.pop();\n        maxSet.erase(maxSet.find(topValue));\n        return topValue;\n    }\n\n    int top()\n    {\n        return mainStack.top();\n    }\n\n    int peekMax()\n    {\n        return *maxSet.rbegin();\n    }\n\n    int popMax()\n    {\n        int maxValue= *maxSet.rbegin();\n        maxSet.erase(maxSet.find(maxValue));\n\n        std::stack<int> tempStack;\n        while(mainStack.top() != maxValue)\n        {\n            tempStack.push(mainStack.top());\n            mainStack.pop();\n        }\n        mainStack.pop();\n        while(!tempStack.empty())\n        {\n            mainStack.push(tempStack.top());\n            tempStack.pop();\n        }\n\n        return maxValue;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isOneBitCharacter(vector<int> &bitSequence)\n{\n    int currentIndex;\n    for(currentIndex = 0; currentIndex < bitSequence.size() - 1; currentIndex++)\n    {\n        currentIndex += bitSequence[currentIndex];\n    }\n    return currentIndex == bitSequence.size() - 1;\n}",
    "output": "bool isOneBitCharacter(std::vector<int> &bitSequence)\n{\n    int currentIndex;\n    for(currentIndex= 0; currentIndex < bitSequence.size() - 1; currentIndex++)\n    {\n        currentIndex+= bitSequence[currentIndex];\n    }\n    return currentIndex == bitSequence.size() - 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findLength(vector<int> &firstArray, vector<int> &secondArray)\n{\n    int firstArraySize= firstArray.size();\n    int secondArraySize= secondArray.size();\n    vector<vector<int>> dynamicProgrammingTable(firstArraySize + 1, vector<int>(secondArraySize + 1, 0));\n    int longestLength= 0;\n\n    for(int i= firstArraySize - 1; i >= 0; i--)\n    {\n        for(int j= secondArraySize - 1; j >= 0; j--)\n        {\n            if(firstArray[i] == secondArray[j])\n            {\n                dynamicProgrammingTable[i][j]= dynamicProgrammingTable[i + 1][j + 1] + 1;\n                longestLength= max(longestLength, dynamicProgrammingTable[i][j]);\n            }\n        }\n    }\n\n    return longestLength;\n}",
    "output": "#include <bits/stdc++.h>\nint findLength(std::vector<int> &firstArray, std::vector<int> &secondArray)\n{\n    int firstArraySize= firstArray.size();\n    int secondArraySize= secondArray.size();\n    std::vector<std::vector<int>> dynamicProgrammingTable(firstArraySize + 1, std::vector<int>(secondArraySize + 1, 0));\n    int longestLength= 0;\n\n    for(int i= firstArraySize - 1; i >= 0; i--)\n    {\n        for(int j= secondArraySize - 1; j >= 0; j--)\n        {\n            if(firstArray[i] == secondArray[j])\n            {\n                dynamicProgrammingTable[i][j]= dynamicProgrammingTable[i + 1][j + 1] + 1;\n                longestLength= std::max(longestLength, dynamicProgrammingTable[i][j]);\n            }\n        }\n    }\n\n    return longestLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint smallestDistancePair(vector<int> &numbers, int k)\n{\n    sort(numbers.begin(), numbers.end());\n    int minimumDistance= 0, maximumDistance= numbers.back() - numbers.front();\n\n    while(minimumDistance < maximumDistance)\n    {\n        int midDistance= (minimumDistance + maximumDistance) / 2;\n        int countPairs= 0, leftIndex= 0;\n\n        for(int rightIndex= 0; rightIndex < numbers.size(); ++rightIndex)\n        {\n            while(numbers[rightIndex] - numbers[leftIndex] > midDistance)\n            {\n                ++leftIndex;\n            }\n            countPairs+= (rightIndex - leftIndex);\n        }\n\n        if(countPairs < k)\n        {\n            minimumDistance= midDistance + 1;\n        }\n        else\n        {\n            maximumDistance= midDistance;\n        }\n    }\n\n    return minimumDistance;\n}",
    "output": "#include <bits/stdc++.h>\nint smallestDistancePair(std::vector<int> &numbers, int k)\n{\n    std::sort(numbers.begin(), numbers.end());\n    int minimumDistance= 0, maximumDistance= numbers.back() - numbers.front();\n\n    while(minimumDistance < maximumDistance)\n    {\n        int midDistance= (minimumDistance + maximumDistance) / 2;\n        int countPairs= 0, leftIndex= 0;\n\n        for(int rightIndex= 0; rightIndex < numbers.size(); ++rightIndex)\n        {\n            while(numbers[rightIndex] - numbers[leftIndex] > midDistance)\n            {\n                ++leftIndex;\n            }\n            countPairs+= (rightIndex - leftIndex);\n        }\n\n        if(countPairs < k)\n        {\n            minimumDistance= midDistance + 1;\n        }\n        else\n        {\n            maximumDistance= midDistance;\n        }\n    }\n\n    return minimumDistance;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring longestWord(vector<string> &words)\n{\n    sort(words.begin(), words.end());\n    set<string> builtWords;\n    string longest = \"\";\n\n    for (int i = 0; i < words.size(); ++i)\n    {\n        const auto &currentWord = words[i];\n        if (currentWord.size() == 1 || builtWords.find(currentWord.substr(0, currentWord.size() - 1)) != builtWords.end())\n        {\n            longest = (currentWord.size() > longest.size()) ? currentWord : longest;\n            builtWords.insert(currentWord);\n        }\n    }\n\n    return longest;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string longestWord(std::vector<std::string> &words)\n{\n    std::sort(words.begin(), words.end());\n    std::set<std::string> builtWords;\n    std::string longest= \"\";\n\n    for(const auto &currentWord : words)\n    {\n        if(currentWord.size() == 1 || builtWords.find(currentWord.substr(0, currentWord.size() - 1)) != builtWords.end())\n        {\n            longest= (currentWord.size() > longest.size()) ? currentWord : longest;\n            builtWords.insert(currentWord);\n        }\n    }\n\n    return longest;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(int accountId, const vector<vector<string>> &accounts, vector<bool> &visitedAccounts, set<string> &mergedEmails, map<string, int> &emailToAccountId)\n{\n    if(visitedAccounts[accountId])\n        return;\n    visitedAccounts[accountId]= true;\n    for(int j= 1; j < accounts[accountId].size(); ++j)\n    {\n        const string &email= accounts[accountId][j];\n        mergedEmails.insert(email);\n        int nextAccountId= emailToAccountId[email];\n        depthFirstSearch(nextAccountId, accounts, visitedAccounts, mergedEmails, emailToAccountId);\n    }\n}\n\nvector<vector<string>> accountsMerge(vector<vector<string>> &accounts)\n{\n    map<string, int> emailToAccountId;\n    for(int i= 0; i < accounts.size(); ++i)\n        for(int j= 1; j < accounts[i].size(); ++j)\n            emailToAccountId[accounts[i][j]]= i;\n\n    vector<vector<string>> mergedAccounts;\n    vector<bool> visitedAccounts(accounts.size(), false);\n    for(int i= 0; i < accounts.size(); ++i)\n    {\n        if(!visitedAccounts[i])\n        {\n            set<string> mergedEmails;\n            depthFirstSearch(i, accounts, visitedAccounts, mergedEmails, emailToAccountId);\n            vector<string> mergedAccount(mergedEmails.begin(), mergedEmails.end());\n            mergedAccount.insert(mergedAccount.begin(), accounts[i][0]);\n            mergedAccounts.push_back(mergedAccount);\n        }\n    }\n    return mergedAccounts;\n}",
    "output": "#include <bits/stdc++.h>\nvoid depthFirstSearch(int accountId, const std::vector<std::vector<std::string>> &accounts, std::vector<bool> &visitedAccounts, std::set<std::string> &mergedEmails, std::map<std::string, int> &emailToAccountId)\n{\n    if(visitedAccounts[accountId])\n        return;\n    visitedAccounts[accountId]= true;\n    for(int j= 1; j < accounts[accountId].size(); ++j)\n    {\n        const std::string &email= accounts[accountId][j];\n        mergedEmails.insert(email);\n        int nextAccountId= emailToAccountId[email];\n        depthFirstSearch(nextAccountId, accounts, visitedAccounts, mergedEmails, emailToAccountId);\n    }\n}\n\nstd::vector<std::vector<std::string>> accountsMerge(std::vector<std::vector<std::string>> &accounts)\n{\n    std::map<std::string, int> emailToAccountId;\n    for(int i= 0; i < accounts.size(); ++i)\n        for(int j= 1; j < accounts[i].size(); ++j)\n            emailToAccountId[accounts[i][j]]= i;\n\n    std::vector<std::vector<std::string>> mergedAccounts;\n    std::vector<bool> visitedAccounts(accounts.size(), false);\n    for(int i= 0; i < accounts.size(); ++i)\n    {\n        if(!visitedAccounts[i])\n        {\n            std::set<std::string> mergedEmails;\n            depthFirstSearch(i, accounts, visitedAccounts, mergedEmails, emailToAccountId);\n            std::vector<std::string> mergedAccount(mergedEmails.begin(), mergedEmails.end());\n            mergedAccount.insert(mergedAccount.begin(), accounts[i][0]);\n            mergedAccounts.push_back(mergedAccount);\n        }\n    }\n    return mergedAccounts;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> removeComments(vector<string> &sourceCode)\n{\n    vector<string> cleanedSource;\n    string currentLine;\n    bool isInBlockComment = false;\n\n    for (size_t i = 0; i < sourceCode.size(); ++i)\n    {\n        const auto &line = sourceCode[i];\n        for (size_t index = 0; index < line.size(); ++index)\n        {\n            if (isInBlockComment)\n            {\n                if (index < line.size() - 1 && line[index] == '*' && line[index + 1] == '/')\n                {\n                    isInBlockComment = false;\n                    ++index;\n                }\n            }\n            else\n            {\n                if (index < line.size() - 1 && line[index] == '/' && line[index + 1] == '*')\n                {\n                    isInBlockComment = true;\n                    ++index;\n                }\n                else if (index < line.size() - 1 && line[index] == '/' && line[index + 1] == '/')\n                {\n                    break;\n                }\n                else\n                {\n                    currentLine.push_back(line[index]);\n                }\n            }\n        }\n        if (!isInBlockComment && !currentLine.empty())\n        {\n            cleanedSource.push_back(currentLine);\n            currentLine.clear();\n        }\n    }\n    return cleanedSource;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> removeComments(std::vector<std::string> &sourceCode)\n{\n    std::vector<std::string> cleanedSource;\n    std::string currentLine;\n    bool isInBlockComment= false;\n\n    for(const auto &line : sourceCode)\n    {\n        for(size_t index= 0; index < line.size(); ++index)\n        {\n            if(isInBlockComment)\n            {\n                if(index < line.size() - 1 && line[index] == '*' && line[index + 1] == '/')\n                {\n                    isInBlockComment= false;\n                    ++index;\n                }\n            }\n            else\n            {\n                if(index < line.size() - 1 && line[index] == '/' && line[index + 1] == '*')\n                {\n                    isInBlockComment= true;\n                    ++index;\n                }\n                else if(index < line.size() - 1 && line[index] == '/' && line[index + 1] == '/')\n                {\n                    break;\n                }\n                else\n                {\n                    currentLine.push_back(line[index]);\n                }\n            }\n        }\n        if(!isInBlockComment && !currentLine.empty())\n        {\n            cleanedSource.push_back(currentLine);\n            currentLine.clear();\n        }\n    }\n    return cleanedSource;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> candyCrush(vector<vector<int>> &gameBoard)\n{\n    int totalRows= gameBoard.size(), totalCols= gameBoard[0].size();\n    bool hasCrush= false;\n\n    for(int row= 0; row < totalRows; row++)\n    {\n        for(int col= 0; col < totalCols - 2; col++)\n        {\n            int candyValue= abs(gameBoard[row][col]);\n            if(candyValue && candyValue == abs(gameBoard[row][col + 1]) && candyValue == abs(gameBoard[row][col + 2]))\n            {\n                gameBoard[row][col]= gameBoard[row][col + 1]= gameBoard[row][col + 2]= -candyValue;\n                hasCrush= true;\n            }\n        }\n    }\n\n    for(int row= 0; row < totalRows - 2; row++)\n    {\n        for(int col= 0; col < totalCols; col++)\n        {\n            int candyValue= abs(gameBoard[row][col]);\n            if(candyValue && candyValue == abs(gameBoard[row + 1][col]) && candyValue == abs(gameBoard[row + 2][col]))\n            {\n                gameBoard[row][col]= gameBoard[row + 1][col]= gameBoard[row + 2][col]= -candyValue;\n                hasCrush= true;\n            }\n        }\n    }\n\n    for(int col= 0; col < totalCols; col++)\n    {\n        int writeRow= totalRows - 1;\n        for(int row= totalRows - 1; row >= 0; row--)\n            if(gameBoard[row][col] > 0)\n                gameBoard[writeRow--][col]= gameBoard[row][col];\n        while(writeRow >= 0)\n            gameBoard[writeRow--][col]= 0;\n    }\n\n    return hasCrush ? candyCrush(gameBoard) : gameBoard;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> candyCrush(std::vector<std::vector<int>> &gameBoard)\n{\n    int totalRows = gameBoard.size(), totalCols = gameBoard[0].size();\n    bool hasCrush = false;\n\n    for(int row = 0; row < totalRows; row++)\n    {\n        for(int col = 0; col < totalCols - 2; col++)\n        {\n            int candyValue = std::abs(gameBoard[row][col]);\n            if(candyValue && candyValue == std::abs(gameBoard[row][col + 1]) && candyValue == std::abs(gameBoard[row][col + 2]))\n            {\n                gameBoard[row][col] = gameBoard[row][col + 1] = gameBoard[row][col + 2] = -candyValue;\n                hasCrush = true;\n            }\n        }\n    }\n\n    for(int row = 0; row < totalRows - 2; row++)\n    {\n        for(int col = 0; col < totalCols; col++)\n        {\n            int candyValue = std::abs(gameBoard[row][col]);\n            if(candyValue && candyValue == std::abs(gameBoard[row + 1][col]) && candyValue == std::abs(gameBoard[row + 2][col]))\n            {\n                gameBoard[row][col] = gameBoard[row + 1][col] = gameBoard[row + 2][col] = -candyValue;\n                hasCrush = true;\n            }\n        }\n    }\n\n    for(int col = 0; col < totalCols; col++)\n    {\n        int writeRow = totalRows - 1;\n        for(int row = totalRows - 1; row >= 0; row--)\n            if(gameBoard[row][col] > 0)\n                gameBoard[writeRow--][col] = gameBoard[row][col];\n        while(writeRow >= 0)\n            gameBoard[writeRow--][col] = 0;\n    }\n\n    return hasCrush ? candyCrush(gameBoard) : gameBoard;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint pivotIndex(vector<int> &numbers)\n{\n    int totalSum = 0, leftSum = 0;\n    for (int number : numbers)\n        totalSum += number;\n    for (int index = 0; index < numbers.size(); ++index)\n    {\n        if (leftSum == totalSum - leftSum - numbers[index])\n            return index;\n        leftSum += numbers[index];\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint pivotIndex(std::vector<int> &numbers)\n{\n    int totalSum= 0, leftSum= 0;\n    for(int number : numbers)\n        totalSum+= number;\n    for(int index= 0; index < numbers.size(); ++index)\n    {\n        if(leftSum == totalSum - leftSum - numbers[index])\n            return index;\n        leftSum+= numbers[index];\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nvector<ListNode *> splitListToParts(ListNode *root, int partCount)\n{\n    vector<ListNode *> result(partCount, NULL);\n    int listSize= 0;\n    ListNode *currentNode= root;\n    while(currentNode)\n    {\n        listSize++;\n        currentNode= currentNode->next;\n    }\n\n    int baseSize= listSize / partCount;\n    int extraParts= listSize % partCount;\n\n    currentNode= root;\n    for(int i= 0; i < partCount && currentNode; ++i)\n    {\n        result[i]= currentNode;\n        int currentPartSize= baseSize + (i < extraParts ? 1 : 0);\n        for(int j= 1; j < currentPartSize; ++j)\n        {\n            currentNode= currentNode->next;\n        }\n        ListNode *nextNode= currentNode->next;\n        currentNode->next= NULL;\n        currentNode= nextNode;\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nclass ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nstd::vector<ListNode *> splitListToParts(ListNode *root, int partCount)\n{\n    std::vector<ListNode *> result(partCount, NULL);\n    int listSize= 0;\n    ListNode *currentNode= root;\n    while(currentNode)\n    {\n        listSize++;\n        currentNode= currentNode->next;\n    }\n\n    int baseSize= listSize / partCount;\n    int extraParts= listSize % partCount;\n\n    currentNode= root;\n    for(int i= 0; i < partCount && currentNode; ++i)\n    {\n        result[i]= currentNode;\n        int currentPartSize= baseSize + (i < extraParts ? 1 : 0);\n        for(int j= 1; j < currentPartSize; ++j)\n        {\n            currentNode= currentNode->next;\n        }\n        ListNode *nextNode= currentNode->next;\n        currentNode->next= NULL;\n        currentNode= nextNode;\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nmap<string, int> parseFormula(const string &chemicalFormula, int &index)\n{\n    map<string, int> elementCounts;\n    while(index < chemicalFormula.size())\n    {\n        if(chemicalFormula[index] == '(')\n        {\n            map<string, int> tempCounts = parseFormula(chemicalFormula, ++index);\n            int multiplier = 0;\n            while(isdigit(chemicalFormula[index]))\n            {\n                multiplier = multiplier * 10 + (chemicalFormula[index++] - '0');\n            }\n            if(multiplier == 0)\n                multiplier = 1;\n            for(auto it = tempCounts.begin(); it != tempCounts.end(); ++it)\n            {\n                elementCounts[it->first] += it->second * multiplier;\n            }\n        }\n        else if(chemicalFormula[index] == ')')\n        {\n            ++index;\n            return elementCounts;\n        }\n        else\n        {\n            string elementName;\n            elementName += chemicalFormula[index++];\n            while(islower(chemicalFormula[index]))\n            {\n                elementName += chemicalFormula[index++];\n            }\n            int count = 0;\n            while(isdigit(chemicalFormula[index]))\n            {\n                count = count * 10 + (chemicalFormula[index++] - '0');\n            }\n            if(count == 0)\n                count = 1;\n            elementCounts[elementName] += count;\n        }\n    }\n    return elementCounts;\n}\n\nstring countOfAtoms(string chemicalFormula)\n{\n    int index = 0;\n    map<string, int> elementCounts = parseFormula(chemicalFormula, index);\n    string result;\n    for(auto it = elementCounts.begin(); it != elementCounts.end(); ++it)\n    {\n        result += it->first;\n        if(it->second > 1)\n            result += to_string(it->second);\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::map<std::string, int> parseFormula(const std::string &chemicalFormula, int &index)\n{\n    std::map<std::string, int> elementCounts;\n    while(index < chemicalFormula.size())\n    {\n        if(chemicalFormula[index] == '(')\n        {\n            std::map<std::string, int> tempCounts = parseFormula(chemicalFormula, ++index);\n            int multiplier = 0;\n            while(std::isdigit(chemicalFormula[index]))\n            {\n                multiplier = multiplier * 10 + (chemicalFormula[index++] - '0');\n            }\n            if(multiplier == 0)\n                multiplier = 1;\n            for(const auto &element : tempCounts)\n            {\n                elementCounts[element.first] += element.second * multiplier;\n            }\n        }\n        else if(chemicalFormula[index] == ')')\n        {\n            ++index;\n            return elementCounts;\n        }\n        else\n        {\n            std::string elementName;\n            elementName += chemicalFormula[index++];\n            while(std::islower(chemicalFormula[index]))\n            {\n                elementName += chemicalFormula[index++];\n            }\n            int count = 0;\n            while(std::isdigit(chemicalFormula[index]))\n            {\n                count = count * 10 + (chemicalFormula[index++] - '0');\n            }\n            if(count == 0)\n                count = 1;\n            elementCounts[elementName] += count;\n        }\n    }\n    return elementCounts;\n}\n\nstd::string countOfAtoms(std::string chemicalFormula)\n{\n    int index = 0;\n    std::map<std::string, int> elementCounts = parseFormula(chemicalFormula, index);\n    std::string result;\n    for(const auto &element : elementCounts)\n    {\n        result += element.first;\n        if(element.second > 1)\n            result += std::to_string(element.second);\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring minWindowSubSequence(string sourceString, string targetString)\n{\n    int sourceLength= sourceString.length(), targetLength= targetString.length();\n    vector<vector<int>> dynamicProgrammingTable(targetLength + 1, vector<int>(sourceLength + 1, -1));\n\n    for(int columnIndex= 0; columnIndex <= sourceLength; ++columnIndex)\n    {\n        dynamicProgrammingTable[0][columnIndex]= columnIndex;\n    }\n\n    for(int rowIndex= 1; rowIndex <= targetLength; ++rowIndex)\n    {\n        for(int columnIndex= 1; columnIndex <= sourceLength; ++columnIndex)\n        {\n            if(sourceString[columnIndex - 1] == targetString[rowIndex - 1])\n            {\n                dynamicProgrammingTable[rowIndex][columnIndex]= dynamicProgrammingTable[rowIndex - 1][columnIndex - 1];\n            }\n            else\n            {\n                dynamicProgrammingTable[rowIndex][columnIndex]= dynamicProgrammingTable[rowIndex][columnIndex - 1];\n            }\n        }\n    }\n\n    int startIndex= 0, minimumLength= sourceLength + 1;\n    for(int columnIndex= 1; columnIndex <= sourceLength; ++columnIndex)\n    {\n        if(dynamicProgrammingTable[targetLength][columnIndex] != -1 && columnIndex - dynamicProgrammingTable[targetLength][columnIndex] < minimumLength)\n        {\n            startIndex= dynamicProgrammingTable[targetLength][columnIndex];\n            minimumLength= columnIndex - startIndex;\n        }\n    }\n\n    return minimumLength == sourceLength + 1 ? \"\" : sourceString.substr(startIndex, minimumLength);\n}",
    "output": "#include <bits/stdc++.h>\nstd::string minWindowSubSequence(std::string sourceString, std::string targetString)\n{\n    int sourceLength= sourceString.length(), targetLength= targetString.length();\n    std::vector<std::vector<int>> dynamicProgrammingTable(targetLength + 1, std::vector<int>(sourceLength + 1, -1));\n\n    for(int columnIndex= 0; columnIndex <= sourceLength; ++columnIndex)\n    {\n        dynamicProgrammingTable[0][columnIndex]= columnIndex;\n    }\n\n    for(int rowIndex= 1; rowIndex <= targetLength; ++rowIndex)\n    {\n        for(int columnIndex= 1; columnIndex <= sourceLength; ++columnIndex)\n        {\n            if(sourceString[columnIndex - 1] == targetString[rowIndex - 1])\n            {\n                dynamicProgrammingTable[rowIndex][columnIndex]= dynamicProgrammingTable[rowIndex - 1][columnIndex - 1];\n            }\n            else\n            {\n                dynamicProgrammingTable[rowIndex][columnIndex]= dynamicProgrammingTable[rowIndex][columnIndex - 1];\n            }\n        }\n    }\n\n    int startIndex= 0, minimumLength= sourceLength + 1;\n    for(int columnIndex= 1; columnIndex <= sourceLength; ++columnIndex)\n    {\n        if(dynamicProgrammingTable[targetLength][columnIndex] != -1 && columnIndex - dynamicProgrammingTable[targetLength][columnIndex] < minimumLength)\n        {\n            startIndex= dynamicProgrammingTable[targetLength][columnIndex];\n            minimumLength= columnIndex - startIndex;\n        }\n    }\n\n    return minimumLength == sourceLength + 1 ? \"\" : sourceString.substr(startIndex, minimumLength);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isSelfDividing(int number)\n{\n    int currentNumber= number;\n    while(currentNumber)\n    {\n        int digit= currentNumber % 10;\n        if(digit == 0 || number % digit != 0)\n            return false;\n        currentNumber/= 10;\n    }\n    return true;\n}\n\nvector<int> getSelfDividingNumbers(int lowerBound, int upperBound)\n{\n    vector<int> selfDividingNumbersList;\n    for(int currentNumber= lowerBound; currentNumber <= upperBound; ++currentNumber)\n    {\n        if(isSelfDividing(currentNumber))\n            selfDividingNumbersList.push_back(currentNumber);\n    }\n    return selfDividingNumbersList;\n}",
    "output": "#include <bits/stdc++.h>\nbool isSelfDividing(int number)\n{\n    int currentNumber= number;\n    while(currentNumber)\n    {\n        int digit= currentNumber % 10;\n        if(digit == 0 || number % digit != 0)\n            return false;\n        currentNumber/= 10;\n    }\n    return true;\n}\n\nstd::vector<int> getSelfDividingNumbers(int lowerBound, int upperBound)\n{\n    std::vector<int> selfDividingNumbersList;\n    for(int currentNumber= lowerBound; currentNumber <= upperBound; ++currentNumber)\n    {\n        if(isSelfDividing(currentNumber))\n            selfDividingNumbersList.push_back(currentNumber);\n    }\n    return selfDividingNumbersList;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass MyCalendar\n{\n  public:\n    map<int, int> eventSchedule;\n\n    bool book(int startTime, int endTime)\n    {\n        auto iterator= eventSchedule.lower_bound(startTime);\n        if(iterator != eventSchedule.begin() && (--iterator)->second > startTime)\n            return false;\n        if(iterator != eventSchedule.end() && endTime > iterator->first)\n            return false;\n        eventSchedule[startTime]= endTime;\n        return true;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass MyCalendar\n{\n  public:\n    std::map<int, int> eventSchedule;\n\n    bool book(int startTime, int endTime)\n    {\n        auto iterator= eventSchedule.lower_bound(startTime);\n        if(iterator != eventSchedule.begin() && (--iterator)->second > startTime)\n            return false;\n        if(iterator != eventSchedule.end() && endTime > iterator->first)\n            return false;\n        eventSchedule[startTime]= endTime;\n        return true;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countPalindromicSubsequences(string inputString)\n{\n    int stringLength= inputString.length();\n    int modulus= 1000000007;\n    vector<vector<int>> dynamicProgramming(4, vector<int>(stringLength + 1, 0));\n\n    for(int currentIndex= stringLength - 1; currentIndex >= 0; currentIndex--)\n    {\n        for(int endIndex= currentIndex + 1; endIndex <= stringLength; endIndex++)\n        {\n            int charIndex= inputString[currentIndex] - 'a';\n            dynamicProgramming[charIndex][endIndex]= dynamicProgramming[0][endIndex - 1] + dynamicProgramming[1][endIndex - 1] + dynamicProgramming[2][endIndex - 1] + dynamicProgramming[3][endIndex - 1] - dynamicProgramming[charIndex][currentIndex] + 2;\n            dynamicProgramming[charIndex][endIndex]= (dynamicProgramming[charIndex][endIndex] + modulus) % modulus;\n        }\n    }\n\n    return (dynamicProgramming[0][stringLength] + dynamicProgramming[1][stringLength] + dynamicProgramming[2][stringLength] + dynamicProgramming[3][stringLength]) % modulus;\n}",
    "output": "#include <bits/stdc++.h>\nint countPalindromicSubsequences(std::string inputString)\n{\n    int stringLength= inputString.length();\n    int modulus= 1000000007;\n    std::vector<std::vector<int>> dynamicProgramming(4, std::vector<int>(stringLength + 1, 0));\n\n    for(int currentIndex= stringLength - 1; currentIndex >= 0; currentIndex--)\n    {\n        for(int endIndex= currentIndex + 1; endIndex <= stringLength; endIndex++)\n        {\n            int charIndex= inputString[currentIndex] - 'a';\n            dynamicProgramming[charIndex][endIndex]= dynamicProgramming[0][endIndex - 1] + dynamicProgramming[1][endIndex - 1] + dynamicProgramming[2][endIndex - 1] + dynamicProgramming[3][endIndex - 1] - dynamicProgramming[charIndex][currentIndex] + 2;\n            dynamicProgramming[charIndex][endIndex]= (dynamicProgramming[charIndex][endIndex] + modulus) % modulus;\n        }\n    }\n\n    return (dynamicProgramming[0][stringLength] + dynamicProgramming[1][stringLength] + dynamicProgramming[2][stringLength] + dynamicProgramming[3][stringLength]) % modulus;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass MyCalendarTwo\n{\n    vector<pair<int, int>> singleBookings, doubleBookings;\n\n  public:\n    bool book(int startTime, int endTime)\n    {\n        for (int i = 0; i < doubleBookings.size(); ++i)\n        {\n            auto doubleBooking = doubleBookings[i];\n            if (startTime < doubleBooking.second && endTime > doubleBooking.first)\n                return false;\n        }\n        for (int i = 0; i < singleBookings.size(); ++i)\n        {\n            auto singleBooking = singleBookings[i];\n            if (startTime < singleBooking.second && endTime > singleBooking.first)\n            {\n                doubleBookings.emplace_back(max(startTime, singleBooking.first), min(endTime, singleBooking.second));\n            }\n        }\n        singleBookings.emplace_back(startTime, endTime);\n        return true;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass MyCalendarTwo\n{\n    std::vector<std::pair<int, int>> singleBookings, doubleBookings;\n\n  public:\n    bool book(int startTime, int endTime)\n    {\n        for(auto doubleBooking : doubleBookings)\n        {\n            if(startTime < doubleBooking.second && endTime > doubleBooking.first)\n                return false;\n        }\n        for(auto singleBooking : singleBookings)\n        {\n            if(startTime < singleBooking.second && endTime > singleBooking.first)\n            {\n                doubleBookings.emplace_back(std::max(startTime, singleBooking.first), std::min(endTime, singleBooking.second));\n            }\n        }\n        singleBookings.emplace_back(startTime, endTime);\n        return true;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass MyCalendarThree\n{\n  public:\n    map<int, int> eventTimeline;\n\n    int book(int startTime, int endTime)\n    {\n        eventTimeline[startTime]++;\n        eventTimeline[endTime]--;\n        int ongoingEvents = 0, maxConcurrentEvents = 0;\n        \n        // Modifying the range-based for loop to a traditional for loop\n        auto it = eventTimeline.begin();\n        while (it != eventTimeline.end())\n        {\n            maxConcurrentEvents = max(maxConcurrentEvents, ongoingEvents += it->second);\n            ++it;\n        }\n        \n        return maxConcurrentEvents;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass MyCalendarThree\n{\n  public:\n    std::map<int, int> eventTimeline;\n\n    int book(int startTime, int endTime)\n    {\n        eventTimeline[startTime]++;\n        eventTimeline[endTime]--;\n        int ongoingEvents= 0, maxConcurrentEvents= 0;\n        for(auto &timeEntry : eventTimeline)\n        {\n            maxConcurrentEvents= std::max(maxConcurrentEvents, ongoingEvents+= timeEntry.second);\n        }\n        return maxConcurrentEvents;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid fill(vector<vector<int>> &image, int startRow, int startCol, int newColor, int originalColor)\n{\n    if(startRow < 0 || startCol < 0 || startRow >= image.size() || startCol >= image[0].size() || image[startRow][startCol] != originalColor || image[startRow][startCol] == newColor)\n        return;\n    image[startRow][startCol]= newColor;\n    fill(image, startRow - 1, startCol, newColor, originalColor);\n    fill(image, startRow + 1, startCol, newColor, originalColor);\n    fill(image, startRow, startCol - 1, newColor, originalColor);\n    fill(image, startRow, startCol + 1, newColor, originalColor);\n}\n\nvector<vector<int>> floodFill(vector<vector<int>> &image, int startRow, int startCol, int newColor)\n{\n    int originalColor= image[startRow][startCol];\n    fill(image, startRow, startCol, newColor, originalColor);\n    return image;\n}",
    "output": "#include <bits/stdc++.h>\nvoid fill(std::vector<std::vector<int>> &image, int startRow, int startCol, int newColor, int originalColor)\n{\n    if(startRow < 0 || startCol < 0 || startRow >= image.size() || startCol >= image[0].size() || image[startRow][startCol] != originalColor || image[startRow][startCol] == newColor)\n        return;\n    image[startRow][startCol]= newColor;\n    fill(image, startRow - 1, startCol, newColor, originalColor);\n    fill(image, startRow + 1, startCol, newColor, originalColor);\n    fill(image, startRow, startCol - 1, newColor, originalColor);\n    fill(image, startRow, startCol + 1, newColor, originalColor);\n}\n\nstd::vector<std::vector<int>> floodFill(std::vector<std::vector<int>> &image, int startRow, int startCol, int newColor)\n{\n    int originalColor= image[startRow][startCol];\n    fill(image, startRow, startCol, newColor, originalColor);\n    return image;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool areSentencesSimilar(vector<string> &firstSentence, vector<string> &secondSentence, vector<vector<string>> &similarPairs)\n{\n    if(firstSentence.size() != secondSentence.size())\n        return false;\n    unordered_map<string, unordered_set<string>> similarityMap;\n    for (int i = 0; i < similarPairs.size(); ++i)\n    {\n        similarityMap[similarPairs[i][0]].insert(similarPairs[i][1]);\n        similarityMap[similarPairs[i][1]].insert(similarPairs[i][0]);\n    }\n    for (int index = 0; index < firstSentence.size(); ++index)\n    {\n        if (firstSentence[index] != secondSentence[index] && !similarityMap[firstSentence[index]].count(secondSentence[index]))\n            return false;\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool areSentencesSimilar(std::vector<std::string> &firstSentence, std::vector<std::string> &secondSentence, std::vector<std::vector<std::string>> &similarPairs)\n{\n    if(firstSentence.size() != secondSentence.size())\n        return false;\n\n    std::unordered_map<std::string, std::unordered_set<std::string>> similarityMap;\n    for(const auto &pair : similarPairs)\n    {\n        similarityMap[pair[0]].insert(pair[1]);\n        similarityMap[pair[1]].insert(pair[0]);\n    }\n    for(int index= 0; index < firstSentence.size(); ++index)\n    {\n        if(firstSentence[index] != secondSentence[index] && !similarityMap[firstSentence[index]].count(secondSentence[index]))\n            return false;\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> asteroidCollision(vector<int> &asteroids)\n{\n    vector<int> survivingAsteroids;\n    for(int index= 0; index < asteroids.size(); index++)\n    {\n        if(asteroids[index] > 0 || survivingAsteroids.empty() || survivingAsteroids.back() < 0)\n        {\n            survivingAsteroids.push_back(asteroids[index]);\n        }\n        else if(survivingAsteroids.back() <= -asteroids[index])\n        {\n            if(survivingAsteroids.back() < -asteroids[index])\n                index--;\n            survivingAsteroids.pop_back();\n        }\n    }\n    return survivingAsteroids;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> asteroidCollision(std::vector<int> &asteroids)\n{\n    std::vector<int> survivingAsteroids;\n    for(int index= 0; index < asteroids.size(); index++)\n    {\n        if(asteroids[index] > 0 || survivingAsteroids.empty() || survivingAsteroids.back() < 0)\n        {\n            survivingAsteroids.push_back(asteroids[index]);\n        }\n        else if(survivingAsteroids.back() <= -asteroids[index])\n        {\n            if(survivingAsteroids.back() < -asteroids[index])\n                index--;\n            survivingAsteroids.pop_back();\n        }\n    }\n    return survivingAsteroids;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculate(string &expression, const int &start, int &end, unordered_map<string, int> &variables)\n{\n    if(expression[start] == '(')\n    {\n        if(expression.substr(start + 1, 3) == \"add\")\n        {\n            int firstOperand= start + 5;\n            int secondOperand= firstOperand;\n            calculate(expression, firstOperand, secondOperand, variables);\n            int value1= variables[\" \"];\n            calculate(expression, secondOperand + 1, end, variables);\n            int value2= variables[\" \"];\n            end++;\n            return value1 + value2;\n        }\n        else if(expression.substr(start + 1, 4) == \"mult\")\n        {\n            int firstOperand= start + 6;\n            int secondOperand= firstOperand;\n            calculate(expression, firstOperand, secondOperand, variables);\n            int value1= variables[\" \"];\n            calculate(expression, secondOperand + 1, end, variables);\n            int value2= variables[\" \"];\n            end++;\n            return value1 * value2;\n        }\n        else\n        {\n            unordered_map<string, int> innerVariables= unordered_map<string, int>(variables);\n            int index= start + 5;\n            while(index < end - 1 && expression[index] != '(')\n            {\n                int tempIndex= index;\n                index= expression.find(' ', index + 1);\n                string variableName= expression.substr(tempIndex, index - tempIndex);\n                tempIndex= index + 1;\n                if(expression[tempIndex] == '(')\n                {\n                    index++;\n                }\n                else\n                {\n                    index= expression.find(' ', index + 1);\n                }\n                int result= calculate(expression, tempIndex, index, variables);\n                innerVariables[variableName]= result;\n                variables= innerVariables;\n            }\n            return calculate(expression, index, end, variables);\n        }\n    }\n    else\n    {\n        if(isdigit(expression[start]) || expression[start] == '-')\n        {\n            end= expression.find(' ', start);\n            return stoi(expression.substr(start, end - start));\n        }\n        else\n        {\n            int index= expression.find(' ', start);\n            end= (index == -1) ? end : index;\n            return variables[expression.substr(start, end - start)];\n        }\n    }\n}\n\nint evaluate(string expression)\n{\n    int end= expression.size();\n    unordered_map<string, int> variables;\n    int result= calculate(expression, 0, end, variables);\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nint calculate(std::string &expression, const int &start, int &end, std::unordered_map<std::string, int> &variables)\n{\n    if(expression[start] == '(')\n    {\n        if(expression.substr(start + 1, 3) == \"add\")\n        {\n            int firstOperand= start + 5;\n            int secondOperand= firstOperand;\n            calculate(expression, firstOperand, secondOperand, variables);\n            int value1= variables[\" \"];\n            calculate(expression, secondOperand + 1, end, variables);\n            int value2= variables[\" \"];\n            end++;\n            return value1 + value2;\n        }\n        else if(expression.substr(start + 1, 4) == \"mult\")\n        {\n            int firstOperand= start + 6;\n            int secondOperand= firstOperand;\n            calculate(expression, firstOperand, secondOperand, variables);\n            int value1= variables[\" \"];\n            calculate(expression, secondOperand + 1, end, variables);\n            int value2= variables[\" \"];\n            end++;\n            return value1 * value2;\n        }\n        else\n        {\n            std::unordered_map<std::string, int> innerVariables= std::unordered_map<std::string, int>(variables);\n            int index= start + 5;\n            while(index < end - 1 && expression[index] != '(')\n            {\n                int tempIndex= index;\n                index= expression.find(' ', index + 1);\n                std::string variableName= expression.substr(tempIndex, index - tempIndex);\n                tempIndex= index + 1;\n                if(expression[tempIndex] == '(')\n                {\n                    index++;\n                }\n                else\n                {\n                    index= expression.find(' ', index + 1);\n                }\n                int result= calculate(expression, tempIndex, index, variables);\n                innerVariables[variableName]= result;\n                variables= innerVariables;\n            }\n            return calculate(expression, index, end, variables);\n        }\n    }\n    else\n    {\n        if(isdigit(expression[start]) || expression[start] == '-')\n        {\n            end= expression.find(' ', start);\n            return std::stoi(expression.substr(start, end - start));\n        }\n        else\n        {\n            int index= expression.find(' ', start);\n            end= (index == -1) ? end : index;\n            return variables[expression.substr(start, end - start)];\n        }\n    }\n}\n\nint evaluate(std::string expression)\n{\n    int end= expression.size();\n    std::unordered_map<std::string, int> variables;\n    int result= calculate(expression, 0, end, variables);\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool areSentencesSimilar(vector<string> &firstSentence, vector<string> &secondSentence, vector<vector<string>> &similarityPairs)\n{\n    if(firstSentence.size() != secondSentence.size())\n        return false;\n\n    unordered_map<string, unordered_set<string>> similarityGraph;\n    for (int i = 0; i < similarityPairs.size(); ++i)\n    {\n        const auto &pair = similarityPairs[i];\n        similarityGraph[pair[0]].insert(pair[1]);\n        similarityGraph[pair[1]].insert(pair[0]);\n    }\n\n    for (int index = 0; index < firstSentence.size(); ++index)\n    {\n        if (firstSentence[index] == secondSentence[index])\n            continue;\n        if (similarityGraph[firstSentence[index]].find(secondSentence[index]) == similarityGraph[firstSentence[index]].end())\n            return false;\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool areSentencesSimilar(std::vector<std::string> &firstSentence, std::vector<std::string> &secondSentence, std::vector<std::vector<std::string>> &similarityPairs)\n{\n    if(firstSentence.size() != secondSentence.size())\n        return false;\n\n    std::unordered_map<std::string, std::unordered_set<std::string>> similarityGraph;\n    for(const auto &pair : similarityPairs)\n    {\n        similarityGraph[pair[0]].insert(pair[1]);\n        similarityGraph[pair[1]].insert(pair[0]);\n    }\n\n    for(int index= 0; index < firstSentence.size(); ++index)\n    {\n        if(firstSentence[index] == secondSentence[index])\n            continue;\n        if(similarityGraph[firstSentence[index]].find(secondSentence[index]) == similarityGraph[firstSentence[index]].end())\n            return false;\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint getMonotoneIncreasingDigits(int number)\n{\n    string numberString= to_string(number);\n    int numberLength= numberString.size();\n\n    int index= numberLength - 1;\n    while(index > 0)\n    {\n        if(numberString[index] < numberString[index - 1])\n        {\n            numberString[index - 1]-= 1;\n            for(int j= index; j < numberLength; ++j)\n            {\n                numberString[j]= '9';\n            }\n        }\n        --index;\n    }\n\n    return stoi(numberString);\n}",
    "output": "#include <bits/stdc++.h>\nint getMonotoneIncreasingDigits(int number)\n{\n    std::string numberString= std::to_string(number);\n    int numberLength= numberString.size();\n\n    int index= numberLength - 1;\n    while(index > 0)\n    {\n        if(numberString[index] < numberString[index - 1])\n        {\n            numberString[index - 1]-= 1;\n            for(int j= index; j < numberLength; ++j)\n            {\n                numberString[j]= '9';\n            }\n        }\n        --index;\n    }\n\n    return std::stoi(numberString);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> dailyTemperatures(vector<int> &temperatureList)\n{\n    vector<int> daysUntilWarmer(temperatureList.size(), 0);\n    stack<int> indexStack;\n\n    for(size_t currentIndex= 0; currentIndex < temperatureList.size(); ++currentIndex)\n    {\n        while(!indexStack.empty() && temperatureList[currentIndex] > temperatureList[indexStack.top()])\n        {\n            int previousIndex= indexStack.top();\n            indexStack.pop();\n            daysUntilWarmer[previousIndex]= currentIndex - previousIndex;\n        }\n        indexStack.push(currentIndex);\n    }\n\n    return daysUntilWarmer;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> dailyTemperatures(std::vector<int> &temperatureList)\n{\n    std::vector<int> daysUntilWarmer(temperatureList.size(), 0);\n    std::stack<int> indexStack;\n\n    for(size_t currentIndex= 0; currentIndex < temperatureList.size(); ++currentIndex)\n    {\n        while(!indexStack.empty() && temperatureList[currentIndex] > temperatureList[indexStack.top()])\n        {\n            int previousIndex= indexStack.top();\n            indexStack.pop();\n            daysUntilWarmer[previousIndex]= currentIndex - previousIndex;\n        }\n        indexStack.push(currentIndex);\n    }\n\n    return daysUntilWarmer;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPoints(vector<int> &numbers)\n{\n    vector<int> points(100001, 0);\n    int maximumPoints = 0;\n    for (int number : numbers)\n    {\n        points[number]++;\n    }\n    for (int i = 2; i < points.size(); i++)\n    {\n        points[i] = max(points[i - 1], points[i - 2] + i * points[i]);\n        maximumPoints = max(maximumPoints, points[i]);\n    }\n    return maximumPoints;\n}",
    "output": "#include <bits/stdc++.h>\nint maxPoints(std::vector<int> &numbers)\n{\n    std::vector<int> points(100001, 0);\n    int maximumPoints= 0;\n    for(int number : numbers)\n    {\n        points[number]++;\n    }\n    for(int i= 2; i < points.size(); i++)\n    {\n        points[i]= std::max(points[i - 1], points[i - 2] + i * points[i]);\n        maximumPoints= std::max(maximumPoints, points[i]);\n    }\n    return maximumPoints;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxCherries(vector<vector<int>> &grid, vector<vector<vector<int>>> &memo, int row1, int col1, int row2)\n{\n    int col2= row1 + col1 - row2;\n    if(row1 == grid.size() || row2 == grid.size() || col1 == grid.size() || col2 == grid.size() ||\n       grid[row1][col1] == -1 || grid[row2][col2] == -1)\n    {\n        return INT_MIN;\n    }\n    else if(row1 == grid.size() - 1 && col1 == grid.size() - 1)\n    {\n        return grid[row1][col1];\n    }\n    else if(memo[row1][col1][row2] != INT_MIN)\n    {\n        return memo[row1][col1][row2];\n    }\n    else\n    {\n        memo[row1][col1][row2]= grid[row1][col1] + (row1 != row2 ? grid[row2][col2] : 0);\n        int maxCherries= max(max(calculateMaxCherries(grid, memo, row1 + 1, col1, row2 + 1), calculateMaxCherries(grid, memo, row1, col1 + 1, row2 + 1)),\n                             max(calculateMaxCherries(grid, memo, row1 + 1, col1, row2), calculateMaxCherries(grid, memo, row1, col1 + 1, row2)));\n        memo[row1][col1][row2]+= maxCherries;\n    }\n    return memo[row1][col1][row2];\n}\n\nint cherryPickup(vector<vector<int>> &grid)\n{\n    int gridSize= grid.size();\n    vector<vector<vector<int>>> memo(gridSize, vector<vector<int>>(gridSize, vector<int>(gridSize, INT_MIN)));\n    return max(0, calculateMaxCherries(grid, memo, 0, 0, 0));\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMaxCherries(std::vector<std::vector<int>> &grid, std::vector<std::vector<std::vector<int>>> &memo, int row1, int col1, int row2)\n{\n    int col2= row1 + col1 - row2;\n    if(row1 == grid.size() || row2 == grid.size() || col1 == grid.size() || col2 == grid.size() ||\n       grid[row1][col1] == -1 || grid[row2][col2] == -1)\n    {\n        return INT_MIN;\n    }\n    else if(row1 == grid.size() - 1 && col1 == grid.size() - 1)\n    {\n        return grid[row1][col1];\n    }\n    else if(memo[row1][col1][row2] != INT_MIN)\n    {\n        return memo[row1][col1][row2];\n    }\n    else\n    {\n        memo[row1][col1][row2]= grid[row1][col1] + (row1 != row2 ? grid[row2][col2] : 0);\n        int maxCherries= std::max(std::max(calculateMaxCherries(grid, memo, row1 + 1, col1, row2 + 1), calculateMaxCherries(grid, memo, row1, col1 + 1, row2 + 1)),\n                             std::max(calculateMaxCherries(grid, memo, row1 + 1, col1, row2), calculateMaxCherries(grid, memo, row1, col1 + 1, row2)));\n        memo[row1][col1][row2]+= maxCherries;\n    }\n    return memo[row1][col1][row2];\n}\n\nint cherryPickup(std::vector<std::vector<int>> &grid)\n{\n    int gridSize= grid.size();\n    std::vector<std::vector<std::vector<int>>> memo(gridSize, std::vector<std::vector<int>>(gridSize, std::vector<int>(gridSize, INT_MIN)));\n    return std::max(0, calculateMaxCherries(grid, memo, 0, 0, 0));\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring convertToLowerCase(string inputString)\n{\n    transform(inputString.begin(), inputString.end(), inputString.begin(), ::tolower);\n    return inputString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string convertToLowerCase(std::string inputString)\n{\n    std::transform(inputString.begin(), inputString.end(), inputString.begin(), ::tolower);\n    return inputString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint networkDelayTime(vector<vector<int>> &travelTimes, int totalNodes, int startingNode)\n{\n    vector<vector<pair<int, int>>> adjacencyList(totalNodes + 1);\n    for (int i = 0; i < travelTimes.size(); ++i)\n    {\n        adjacencyList[travelTimes[i][0]].push_back({travelTimes[i][1], travelTimes[i][2]});\n    }\n\n    vector<int> distance(totalNodes + 1, INT_MAX);\n    distance[startingNode] = 0;\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minHeap;\n    minHeap.push({0, startingNode});\n\n    while (!minHeap.empty())\n    {\n        int currentNode = minHeap.top().second;\n        int currentDistance = minHeap.top().first;\n        minHeap.pop();\n\n        for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n        {\n            int adjacentNode = adjacencyList[currentNode][i].first;\n            int edgeWeight = adjacencyList[currentNode][i].second;\n            if (currentDistance + edgeWeight < distance[adjacentNode])\n            {\n                distance[adjacentNode] = currentDistance + edgeWeight;\n                minHeap.push({distance[adjacentNode], adjacentNode});\n            }\n        }\n    }\n\n    int maxTravelTime = 0;\n    for (int nodeIndex = 1; nodeIndex <= totalNodes; ++nodeIndex)\n    {\n        if (distance[nodeIndex] == INT_MAX)\n            return -1;\n        maxTravelTime = max(maxTravelTime, distance[nodeIndex]);\n    }\n\n    return maxTravelTime;\n}",
    "output": "#include <bits/stdc++.h>\nint networkDelayTime(std::vector<std::vector<int>> &travelTimes, int totalNodes, int startingNode)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(totalNodes + 1);\n    for(auto &edge : travelTimes)\n    {\n        adjacencyList[edge[0]].push_back({edge[1], edge[2]});\n    }\n\n    std::vector<int> distance(totalNodes + 1, std::numeric_limits<int>::max());\n    distance[startingNode] = 0;\n\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> minHeap;\n    minHeap.push({0, startingNode});\n\n    while(!minHeap.empty())\n    {\n        int currentNode = minHeap.top().second;\n        int currentDistance = minHeap.top().first;\n        minHeap.pop();\n\n        for(auto &neighbor : adjacencyList[currentNode])\n        {\n            int adjacentNode = neighbor.first;\n            int edgeWeight = neighbor.second;\n            if(currentDistance + edgeWeight < distance[adjacentNode])\n            {\n                distance[adjacentNode] = currentDistance + edgeWeight;\n                minHeap.push({distance[adjacentNode], adjacentNode});\n            }\n        }\n    }\n\n    int maxTravelTime = 0;\n    for(int nodeIndex = 1; nodeIndex <= totalNodes; ++nodeIndex)\n    {\n        if(distance[nodeIndex] == std::numeric_limits<int>::max())\n            return -1;\n        maxTravelTime = std::max(maxTravelTime, distance[nodeIndex]);\n    }\n\n    return maxTravelTime;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint networkDelayTime(vector<vector<int>> &travelTimes, int numberOfNodes, int startingNode)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numberOfNodes + 1);\n    for (int i = 0; i < travelTimes.size(); ++i)\n        adjacencyList[travelTimes[i][0]].emplace_back(travelTimes[i][1], travelTimes[i][2]);\n\n    vector<int> shortestDistances(numberOfNodes + 1, numeric_limits<int>::max());\n    shortestDistances[startingNode] = 0;\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n    priorityQueue.emplace(0, startingNode);\n\n    while (!priorityQueue.empty())\n    {\n        int currentTime = priorityQueue.top().first, currentNode = priorityQueue.top().second;\n        priorityQueue.pop();\n\n        if (currentTime > shortestDistances[currentNode])\n            continue;\n        for (int j = 0; j < adjacencyList[currentNode].size(); ++j)\n        {\n            const auto &neighbour = adjacencyList[currentNode][j];\n            int nextNode = neighbour.first, travelTime = neighbour.second;\n            if (currentTime + travelTime < shortestDistances[nextNode])\n            {\n                shortestDistances[nextNode] = currentTime + travelTime;\n                priorityQueue.push({shortestDistances[nextNode], nextNode});\n            }\n        }\n    }\n\n    int maxTravelTime = *max_element(shortestDistances.begin() + 1, shortestDistances.end());\n    return maxTravelTime == numeric_limits<int>::max() ? -1 : maxTravelTime;\n}",
    "output": "#include <bits/stdc++.h>\nint networkDelayTime(std::vector<std::vector<int>> &travelTimes, int numberOfNodes, int startingNode)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(numberOfNodes + 1);\n    for(const auto &edge : travelTimes)\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n\n    std::vector<int> shortestDistances(numberOfNodes + 1, std::numeric_limits<int>::max());\n    shortestDistances[startingNode]= 0;\n\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n    priorityQueue.emplace(0, startingNode);\n\n    while(!priorityQueue.empty())\n    {\n        int currentTime= priorityQueue.top().first, currentNode= priorityQueue.top().second;\n        priorityQueue.pop();\n\n        if(currentTime > shortestDistances[currentNode])\n            continue;\n        for(const auto &neighbour : adjacencyList[currentNode])\n        {\n            int nextNode= neighbour.first, travelTime= neighbour.second;\n            if(currentTime + travelTime < shortestDistances[nextNode])\n            {\n                shortestDistances[nextNode]= currentTime + travelTime;\n                priorityQueue.push({shortestDistances[nextNode], nextNode});\n            }\n        }\n    }\n\n    int maxTravelTime= *std::max_element(shortestDistances.begin() + 1, shortestDistances.end());\n    return maxTravelTime == std::numeric_limits<int>::max() ? -1 : maxTravelTime;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar getNextGreatestLetter(vector<char> &letterList, char targetLetter)\n{\n    for (int i = 0; i < letterList.size(); ++i)\n    {\n        char currentLetter = letterList[i];\n        if (currentLetter > targetLetter)\n        {\n            return currentLetter;\n        }\n    }\n    return letterList[0];\n}",
    "output": "#include <bits/stdc++.h>\nchar getNextGreatestLetter(std::vector<char> &letterList, char targetLetter)\n{\n    for(char currentLetter : letterList)\n    {\n        if(currentLetter > targetLetter)\n        {\n            return currentLetter;\n        }\n    }\n    return letterList[0];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass WordFilter\n{\n    unordered_map<string, int> wordIndexMap;\n\n  public:\n    WordFilter(vector<string> &words)\n    {\n        for(int wordIndex= 0; wordIndex < words.size(); ++wordIndex)\n        {\n            for(int prefixLength= 0; prefixLength <= words[wordIndex].size(); ++prefixLength)\n            {\n                wordIndexMap[words[wordIndex].substr(0, prefixLength) + \"#\" + words[wordIndex].substr(prefixLength)]= wordIndex;\n            }\n        }\n    }\n\n    int f(string prefix, string suffix)\n    {\n        auto it= wordIndexMap.find(prefix + \"#\" + suffix);\n        if(it == wordIndexMap.end())\n        {\n            return -1;\n        }\n        return it->second;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass WordFilter\n{\n    std::unordered_map<std::string, int> wordIndexMap;\n\n  public:\n    WordFilter(std::vector<std::string> &words)\n    {\n        for(int wordIndex= 0; wordIndex < words.size(); ++wordIndex)\n        {\n            for(int prefixLength= 0; prefixLength <= words[wordIndex].size(); ++prefixLength)\n            {\n                wordIndexMap[words[wordIndex].substr(0, prefixLength) + \"#\" + words[wordIndex].substr(prefixLength)]= wordIndex;\n            }\n        }\n    }\n\n    int f(std::string prefix, std::string suffix)\n    {\n        auto it= wordIndexMap.find(prefix + \"#\" + suffix);\n        if(it == wordIndexMap.end())\n        {\n            return -1;\n        }\n        return it->second;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minCostClimbingStairs(vector<int> &climbingCosts)\n{\n    int numberOfSteps = climbingCosts.size();\n    for (int stepIndex = 2; stepIndex < numberOfSteps; stepIndex++)\n        climbingCosts[stepIndex] += min(climbingCosts[stepIndex - 1], climbingCosts[stepIndex - 2]);\n    return min(climbingCosts[numberOfSteps - 1], climbingCosts[numberOfSteps - 2]);\n}",
    "output": "#include <bits/stdc++.h>\nint minCostClimbingStairs(std::vector<int> &climbingCosts)\n{\n    int numberOfSteps= climbingCosts.size();\n    for(int stepIndex= 2; stepIndex < numberOfSteps; stepIndex++)\n        climbingCosts[stepIndex]+= std::min(climbingCosts[stepIndex - 1], climbingCosts[stepIndex - 2]);\n    return std::min(climbingCosts[numberOfSteps - 1], climbingCosts[numberOfSteps - 2]);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring findShortestCompletingWord(string licensePlate, vector<string> &wordList)\n{\n    unordered_map<char, int> licensePlateCount;\n    for (char character : licensePlate)\n        if (isalpha(character))\n            licensePlateCount[tolower(character)]++;\n\n    string shortestCompletingWord = \"\";\n    for (int i = 0; i < wordList.size(); ++i)\n    {\n        const string &currentWord = wordList[i];\n        unordered_map<char, int> currentWordCount;\n        for (char character : currentWord)\n            currentWordCount[character]++;\n\n        bool isValid = true;\n        for (const auto &[letter, count] : licensePlateCount)\n            if (currentWordCount[letter] < count)\n            {\n                isValid = false;\n                break;\n            }\n\n        if (isValid && (shortestCompletingWord.empty() || currentWord.length() < shortestCompletingWord.length()))\n            shortestCompletingWord = currentWord;\n    }\n    return shortestCompletingWord;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string findShortestCompletingWord(std::string licensePlate, std::vector<std::string> &wordList)\n{\n    std::unordered_map<char, int> licensePlateCount;\n    for(char character : licensePlate)\n        if(isalpha(character))\n            licensePlateCount[tolower(character)]++;\n\n    std::string shortestCompletingWord= \"\";\n    for(const std::string &currentWord : wordList)\n    {\n        std::unordered_map<char, int> currentWordCount;\n        for(char character : currentWord)\n            currentWordCount[character]++;\n\n        bool isValid= true;\n        for(const auto &[letter, count] : licensePlateCount)\n            if(currentWordCount[letter] < count)\n            {\n                isValid= false;\n                break;\n            }\n\n        if(isValid && (shortestCompletingWord.empty() || currentWord.length() < shortestCompletingWord.length()))\n            shortestCompletingWord= currentWord;\n    }\n    return shortestCompletingWord;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring findShortestCompletingWord(string licensePlate, vector<string> wordList)\n{\n    vector<int> letterCount(26, 0);\n    for(char character : licensePlate)\n        if(isalpha(character))\n            letterCount[tolower(character) - 'a']++;\n\n    string shortestWord;\n    for(int i = 0; i < wordList.size(); ++i)\n    {\n        const string &candidateWord = wordList[i];\n        vector<int> currentCount(26, 0);\n        for(char character : candidateWord)\n            if(isalpha(character))\n                currentCount[tolower(character) - 'a']++;\n\n        if(equal(letterCount.begin(), letterCount.end(), currentCount.begin(), [](int a, int b)\n                 { return a <= b; }))\n            if(shortestWord.empty() || candidateWord.size() < shortestWord.size())\n                shortestWord = candidateWord;\n    }\n\n    return shortestWord;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string findShortestCompletingWord(std::string licensePlate, std::vector<std::string> wordList)\n{\n    std::vector<int> letterCount(26, 0);\n    for(char character : licensePlate)\n        if(isalpha(character))\n            letterCount[tolower(character) - 'a']++;\n\n    std::string shortestWord;\n    for(const std::string &candidateWord : wordList)\n    {\n        std::vector<int> currentCount(26, 0);\n        for(char character : candidateWord)\n            if(isalpha(character))\n                currentCount[tolower(character) - 'a']++;\n\n        if(std::equal(letterCount.begin(), letterCount.end(), currentCount.begin(), [](int a, int b)\n                      { return a <= b; }))\n            if(shortestWord.empty() || candidateWord.size() < shortestWord.size())\n                shortestWord= candidateWord;\n    }\n\n    return shortestWord;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countCornerRectangles(vector<vector<int>> &grid)\n{\n    int rectangleCount= 0;\n    int rowCount= grid.size();\n    int columnCount= grid[0].size();\n\n    for(int rowIndex= 0; rowIndex < rowCount - 1; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < columnCount - 1; colIndex++)\n        {\n            if(grid[rowIndex][colIndex] == 1)\n            {\n                for(int bottomRowIndex= rowIndex + 1; bottomRowIndex < rowCount; bottomRowIndex++)\n                {\n                    for(int rightColIndex= colIndex + 1; rightColIndex < columnCount; rightColIndex++)\n                    {\n                        if(grid[bottomRowIndex][rightColIndex] == 1 && grid[rowIndex][rightColIndex] == 1 && grid[bottomRowIndex][colIndex] == 1)\n                        {\n                            rectangleCount++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return rectangleCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countCornerRectangles(std::vector<std::vector<int>> &grid)\n{\n    int rectangleCount= 0;\n    int rowCount= grid.size();\n    int columnCount= grid[0].size();\n\n    for(int rowIndex= 0; rowIndex < rowCount - 1; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < columnCount - 1; colIndex++)\n        {\n            if(grid[rowIndex][colIndex] == 1)\n            {\n                for(int bottomRowIndex= rowIndex + 1; bottomRowIndex < rowCount; bottomRowIndex++)\n                {\n                    for(int rightColIndex= colIndex + 1; rightColIndex < columnCount; rightColIndex++)\n                    {\n                        if(grid[bottomRowIndex][rightColIndex] == 1 && grid[rowIndex][rightColIndex] == 1 && grid[bottomRowIndex][colIndex] == 1)\n                        {\n                            rectangleCount++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return rectangleCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> convertIpToCidR(string ipAddress, int numberOfAddresses)\n{\n    stringstream ipStream(ipAddress);\n    int octet1, octet2, octet3, octet4;\n    char separator;\n    ipStream >> octet1 >> separator >> octet2 >> separator >> octet3 >> separator >> octet4;\n    unsigned mask= 0xFFFFFFFF;\n    unsigned startAddress= (octet1 << 24) + (octet2 << 16) + (octet3 << 8) + octet4;\n    unsigned endAddress= startAddress + numberOfAddresses - 1;\n\n    vector<string> cidrBlocks;\n    while(startAddress <= endAddress)\n    {\n        int samePrefixBits= __builtin_ctz(~(startAddress & -startAddress));\n        while((mask >> samePrefixBits) & 1)\n            ++samePrefixBits;\n        while(((endAddress - startAddress) >> samePrefixBits) < 1)\n            --samePrefixBits;\n        unsigned addressRange= 1 << samePrefixBits;\n        stringstream cidrResult;\n        cidrResult << (startAddress >> 24) << \".\" << ((startAddress >> 16) & 255) << \".\" << ((startAddress >> 8) & 255) << \".\" << (startAddress & 255) << \"/\" << (32 - samePrefixBits);\n        cidrBlocks.push_back(cidrResult.str());\n        startAddress+= addressRange;\n    }\n\n    return cidrBlocks;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> convertIpToCidR(std::string ipAddress, int numberOfAddresses)\n{\n    std::stringstream ipStream(ipAddress);\n    int octet1, octet2, octet3, octet4;\n    char separator;\n    ipStream >> octet1 >> separator >> octet2 >> separator >> octet3 >> separator >> octet4;\n    unsigned mask = 0xFFFFFFFF;\n    unsigned startAddress = (octet1 << 24) + (octet2 << 16) + (octet3 << 8) + octet4;\n    unsigned endAddress = startAddress + numberOfAddresses - 1;\n\n    std::vector<std::string> cidrBlocks;\n    while(startAddress <= endAddress)\n    {\n        int samePrefixBits = __builtin_ctz(~(startAddress & -startAddress));\n        while((mask >> samePrefixBits) & 1)\n            ++samePrefixBits;\n        while(((endAddress - startAddress) >> samePrefixBits) < 1)\n            --samePrefixBits;\n        unsigned addressRange = 1 << samePrefixBits;\n        std::stringstream cidrResult;\n        cidrResult << (startAddress >> 24) << \".\" << ((startAddress >> 16) & 255) << \".\" << ((startAddress >> 8) & 255) << \".\" << (startAddress & 255) << \"/\" << (32 - samePrefixBits);\n        cidrBlocks.push_back(cidrResult.str());\n        startAddress += addressRange;\n    }\n\n    return cidrBlocks;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint openLock(vector<string> &deadEnds, string target)\n{\n    set<string> deadSet(deadEnds.begin(), deadEnds.end());\n    set<string> visitedLocks;\n    queue<string> lockQueue;\n    string startLock= \"0000\";\n\n    if(deadSet.find(startLock) != deadSet.end())\n        return -1;\n    lockQueue.push(startLock);\n    visitedLocks.insert(startLock);\n\n    int moveCount= 0;\n    while(!lockQueue.empty())\n    {\n        int levelSize= lockQueue.size();\n        for(int i= 0; i < levelSize; ++i)\n        {\n            string currentLock= lockQueue.front();\n            lockQueue.pop();\n\n            if(currentLock == target)\n                return moveCount;\n\n            for(int j= 0; j < 4; ++j)\n            {\n                for(int k= -1; k <= 1; k+= 2)\n                {\n                    string nextLock= currentLock;\n                    nextLock[j]= (nextLock[j] - '0' + k + 10) % 10 + '0';\n\n                    if(visitedLocks.find(nextLock) == visitedLocks.end() && deadSet.find(nextLock) == deadSet.end())\n                    {\n                        visitedLocks.insert(nextLock);\n                        lockQueue.push(nextLock);\n                    }\n                }\n            }\n        }\n        moveCount++;\n    }\n\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint openLock(std::vector<std::string> &deadEnds, std::string target)\n{\n    std::set<std::string> deadSet(deadEnds.begin(), deadEnds.end());\n    std::set<std::string> visitedLocks;\n    std::queue<std::string> lockQueue;\n    std::string startLock= \"0000\";\n\n    if(deadSet.find(startLock) != deadSet.end())\n        return -1;\n    lockQueue.push(startLock);\n    visitedLocks.insert(startLock);\n\n    int moveCount= 0;\n    while(!lockQueue.empty())\n    {\n        int levelSize= lockQueue.size();\n        for(int i= 0; i < levelSize; ++i)\n        {\n            std::string currentLock= lockQueue.front();\n            lockQueue.pop();\n\n            if(currentLock == target)\n                return moveCount;\n\n            for(int j= 0; j < 4; ++j)\n            {\n                for(int k= -1; k <= 1; k+= 2)\n                {\n                    std::string nextLock= currentLock;\n                    nextLock[j]= (nextLock[j] - '0' + k + 10) % 10 + '0';\n\n                    if(visitedLocks.find(nextLock) == visitedLocks.end() && deadSet.find(nextLock) == deadSet.end())\n                    {\n                        visitedLocks.insert(nextLock);\n                        lockQueue.push(nextLock);\n                    }\n                }\n            }\n        }\n        moveCount++;\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint openLock(vector<string> &deadEnds, string target)\n{\n    unordered_set<string> deadSet(deadEnds.begin(), deadEnds.end());\n    unordered_set<string> visitedStates;\n    queue<pair<string, int>> wheelStatesQueue;\n\n    if(deadSet.find(\"0000\") != deadSet.end())\n        return -1;\n    wheelStatesQueue.push({\"0000\", 0});\n    visitedStates.insert(\"0000\");\n\n    while(!wheelStatesQueue.empty())\n    {\n        auto [currentState, turns] = wheelStatesQueue.front();\n        wheelStatesQueue.pop();\n\n        if(currentState == target)\n            return turns;\n\n        for(int i = 0; i < 4; ++i)\n        {\n            string upState = currentState;\n            string downState = currentState;\n            upState[i] = (upState[i] - '0' + 1) % 10 + '0';\n            downState[i] = (downState[i] - '0' + 9) % 10 + '0';\n\n            if(!visitedStates.count(upState) && !deadSet.count(upState))\n            {\n                wheelStatesQueue.push({upState, turns + 1});\n                visitedStates.insert(upState);\n            }\n\n            if(!visitedStates.count(downState) && !deadSet.count(downState))\n            {\n                wheelStatesQueue.push({downState, turns + 1});\n                visitedStates.insert(downState);\n            }\n        }\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint openLock(std::vector<std::string> &deadEnds, std::string target)\n{\n    std::unordered_set<std::string> deadSet(deadEnds.begin(), deadEnds.end());\n    std::unordered_set<std::string> visitedStates;\n    std::queue<std::pair<std::string, int>> wheelStatesQueue;\n\n    if(deadSet.find(\"0000\") != deadSet.end())\n        return -1;\n    wheelStatesQueue.push({\"0000\", 0});\n    visitedStates.insert(\"0000\");\n\n    while(!wheelStatesQueue.empty())\n    {\n        auto [currentState, turns]= wheelStatesQueue.front();\n        wheelStatesQueue.pop();\n\n        if(currentState == target)\n            return turns;\n\n        for(int i= 0; i < 4; ++i)\n        {\n            std::string upState= currentState;\n            std::string downState= currentState;\n            upState[i]= (upState[i] - '0' + 1) % 10 + '0';\n            downState[i]= (downState[i] - '0' + 9) % 10 + '0';\n\n            if(!visitedStates.count(upState) && !deadSet.count(upState))\n            {\n                wheelStatesQueue.push({upState, turns + 1});\n                visitedStates.insert(upState);\n            }\n\n            if(!visitedStates.count(downState) && !deadSet.count(downState))\n            {\n                wheelStatesQueue.push({downState, turns + 1});\n                visitedStates.insert(downState);\n            }\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int reachNumber(int targetPosition)\n{\n    targetPosition= abs(targetPosition);\n    int currentStep= 0, currentSum= 0;\n    while(currentSum < targetPosition)\n    {\n        currentStep++;\n        currentSum+= currentStep;\n    }\n    while((currentSum - targetPosition) % 2 != 0)\n    {\n        currentStep++;\n        currentSum+= currentStep;\n    }\n    return currentStep;\n}",
    "output": "int reachNumber(int targetPosition)\n{\n    targetPosition= abs(targetPosition);\n    int currentStep= 0, currentSum= 0;\n    while(currentSum < targetPosition)\n    {\n        currentStep++;\n        currentSum+= currentStep;\n    }\n    while((currentSum - targetPosition) % 2 != 0)\n    {\n        currentStep++;\n        currentSum+= currentStep;\n    }\n    return currentStep;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int minMoves(int target)\n{\n    target= abs(target);\n    int stepCount= 0;\n    int totalSum= 0;\n    while(totalSum < target || (totalSum - target) % 2 == 1)\n    {\n        stepCount++;\n        totalSum+= stepCount;\n    }\n    return stepCount;\n}",
    "output": "int minMoves(int target)\n{\n    target= abs(target);\n    int stepCount= 0;\n    int totalSum= 0;\n    while(totalSum < target || (totalSum - target) % 2 == 1)\n    {\n        stepCount++;\n        totalSum+= stepCount;\n    }\n    return stepCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool pyramidTransitionHelper(string &bottom, string &top, int index, unordered_map<string, vector<char>> &mapping)\n{\n    if(bottom.length() == 1)\n        return true;\n    if(index == bottom.length() - 1)\n        return pyramidTransitionHelper(top, \"\", 0, mapping);\n    string key = bottom.substr(index, 2);\n    if(mapping.find(key) == mapping.end())\n        return false;\n    for (int i = 0; i < mapping[key].size(); ++i)\n    {\n        char character = mapping[key][i];\n        top.push_back(character);\n        if(pyramidTransitionHelper(bottom, top, index + 1, mapping))\n            return true;\n        top.pop_back();\n    }\n    return false;\n}\n\nbool pyramidTransition(string bottom, vector<string> &allowed)\n{\n    unordered_map<string, vector<char>> mapping;\n    for(int i = 0; i < allowed.size(); ++i)\n    {\n        const auto &allowedString = allowed[i];\n        mapping[allowedString.substr(0, 2)].push_back(allowedString[2]);\n    }\n    return pyramidTransitionHelper(bottom, \"\", 0, mapping);\n}",
    "output": "#include <bits/stdc++.h>\nbool pyramidTransitionHelper(std::string &bottom, std::string &top, int index, std::unordered_map<std::string, std::vector<char>> &mapping)\n{\n    if(bottom.length() == 1)\n        return true;\n    if(index == bottom.length() - 1)\n        return pyramidTransitionHelper(top, \"\", 0, mapping);\n    std::string key= bottom.substr(index, 2);\n    if(mapping.find(key) == mapping.end())\n        return false;\n    for(char character : mapping[key])\n    {\n        top.push_back(character);\n        if(pyramidTransitionHelper(bottom, top, index + 1, mapping))\n            return true;\n        top.pop_back();\n    }\n    return false;\n}\n\nbool pyramidTransition(std::string bottom, std::vector<std::string> &allowed)\n{\n    std::unordered_map<std::string, std::vector<char>> mapping;\n    for(const auto &allowedString : allowed)\n        mapping[allowedString.substr(0, 2)].push_back(allowedString[2]);\n    return pyramidTransitionHelper(bottom, \"\", 0, mapping);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool depthFirstSearch(string currentRow, string bottomRow, unordered_map<string, vector<char>> &transitionMapping)\n{\n    if(bottomRow.size() == 1)\n        return true;\n\n    for(int i = 0; i < bottomRow.size() - 1; ++i)\n    {\n        string pair = bottomRow.substr(i, 2);\n        if(transitionMapping.count(pair) == 0)\n            return false;\n    }\n\n    currentRow = \"\";\n    for(int i = 0; i < bottomRow.size() - 1; ++i)\n    {\n        currentRow += transitionMapping[bottomRow.substr(i, 2)][0];\n    }\n\n    return depthFirstSearch(currentRow, currentRow, transitionMapping);\n}\n\nbool pyramidTransition(string bottomRow, vector<string> &allowedTransitions)\n{\n    unordered_map<string, vector<char>> transitionMapping;\n    for(int i = 0; i < allowedTransitions.size(); ++i)\n    {\n        string &transition = allowedTransitions[i];\n        transitionMapping[transition.substr(0, 2)].emplace_back(transition[2]);\n    }\n    return depthFirstSearch(\"\", bottomRow, transitionMapping);\n}",
    "output": "#include <bits/stdc++.h>\nbool depthFirstSearch(std::string currentRow, std::string bottomRow, std::unordered_map<std::string, std::vector<char>> &transitionMapping)\n{\n    if(bottomRow.size() == 1)\n        return true;\n\n    for(int i= 0; i < bottomRow.size() - 1; ++i)\n    {\n        std::string pair= bottomRow.substr(i, 2);\n        if(transitionMapping.count(pair) == 0)\n            return false;\n    }\n\n    currentRow= \"\";\n    for(int i= 0; i < bottomRow.size() - 1; ++i)\n    {\n        currentRow+= transitionMapping[bottomRow.substr(i, 2)][0];\n    }\n\n    return depthFirstSearch(currentRow, currentRow, transitionMapping);\n}\n\nbool pyramidTransition(std::string bottomRow, std::vector<std::string> &allowedTransitions)\n{\n    std::unordered_map<std::string, std::vector<char>> transitionMapping;\n    for(std::string &transition : allowedTransitions)\n    {\n        transitionMapping[transition.substr(0, 2)].emplace_back(transition[2]);\n    }\n    return depthFirstSearch(\"\", bottomRow, transitionMapping);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring addBoldTag(vector<string> &keywords, string inputString)\n{\n    vector<bool> isBold(inputString.size(), false);\n    for (int i = 0; i < keywords.size(); ++i)\n    {\n        string keyword = keywords[i];\n        int position = inputString.find(keyword);\n        while (position != string::npos)\n        {\n            for (int index = position; index < position + keyword.size(); index++)\n            {\n                isBold[index] = true;\n            }\n            position = inputString.find(keyword, position + 1);\n        }\n    }\n\n    string result = \"\";\n    for (int index = 0; index < inputString.size(); index++)\n    {\n        if (isBold[index] && (index == 0 || !isBold[index - 1]))\n            result += \"<b>\";\n        result += inputString[index];\n        if (isBold[index] && (index == inputString.size() - 1 || !isBold[index + 1]))\n            result += \"</b>\";\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string addBoldTag(std::vector<std::string> &keywords, std::string inputString)\n{\n    std::vector<bool> isBold(inputString.size(), false);\n    for(std::string keyword : keywords)\n    {\n        int position= inputString.find(keyword);\n        while(position != std::string::npos)\n        {\n            for(int index= position; index < position + keyword.size(); index++)\n            {\n                isBold[index]= true;\n            }\n            position= inputString.find(keyword, position + 1);\n        }\n    }\n\n    std::string result= \"\";\n    for(int index= 0; index < inputString.size(); index++)\n    {\n        if(isBold[index] && (index == 0 || !isBold[index - 1]))\n            result+= \"<b>\";\n        result+= inputString[index];\n        if(isBold[index] && (index == inputString.size() - 1 || !isBold[index + 1]))\n            result+= \"</b>\";\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minSetSize(vector<pair<int, int>> intervalPairs)\n{\n    sort(intervalPairs.begin(), intervalPairs.end());\n    int totalIntervals = intervalPairs.size();\n    int currentEnd = intervalPairs[0].second;\n    int nonOverlappingCount = 1;\n\n    for (int i = 1; i < totalIntervals; i++)\n    {\n        if (currentEnd < intervalPairs[i].first)\n        {\n            currentEnd = intervalPairs[i].second;\n            nonOverlappingCount++;\n        }\n        else\n        {\n            currentEnd = min(currentEnd, intervalPairs[i].second);\n        }\n    }\n    return nonOverlappingCount * 2;\n}",
    "output": "#include <bits/stdc++.h>\nint minSetSize(std::vector<std::pair<int, int>> intervalPairs)\n{\n    std::sort(intervalPairs.begin(), intervalPairs.end());\n    int totalIntervals= intervalPairs.size();\n    int currentEnd= intervalPairs[0].second;\n    int nonOverlappingCount= 1;\n\n    for(int i= 1; i < totalIntervals; i++)\n    {\n        if(currentEnd < intervalPairs[i].first)\n        {\n            currentEnd= intervalPairs[i].second;\n            nonOverlappingCount++;\n        }\n        else\n        {\n            currentEnd= std::min(currentEnd, intervalPairs[i].second);\n        }\n    }\n    return nonOverlappingCount * 2;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> anagramMappings(vector<int> &sourceArray, vector<int> &targetArray)\n{\n    unordered_map<int, int> indexMap;\n    for(int index= 0; index < targetArray.size(); index++)\n    {\n        indexMap[targetArray[index]]= index;\n    }\n    vector<int> mappedIndices(sourceArray.size());\n    for(int index= 0; index < sourceArray.size(); index++)\n    {\n        mappedIndices[index]= indexMap[sourceArray[index]];\n    }\n    return mappedIndices;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> anagramMappings(std::vector<int> &sourceArray, std::vector<int> &targetArray)\n{\n    std::unordered_map<int, int> indexMap;\n    for(int index= 0; index < targetArray.size(); index++)\n    {\n        indexMap[targetArray[index]]= index;\n    }\n    std::vector<int> mappedIndices(sourceArray.size());\n    for(int index= 0; index < sourceArray.size(); index++)\n    {\n        mappedIndices[index]= indexMap[sourceArray[index]];\n    }\n    return mappedIndices;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring makeLargestSpecial(string specialString)\n{\n    int balanceCount = 0, startIndex = 0;\n    vector<string> specialSubstrings;\n\n    for (int currentIndex = 0; currentIndex < specialString.size(); currentIndex++)\n    {\n        if (specialString[currentIndex] == '1')\n            balanceCount++;\n        else\n            balanceCount--;\n\n        if (balanceCount == 0)\n        {\n            specialSubstrings.push_back('1' + makeLargestSpecial(specialString.substr(startIndex + 1, currentIndex - startIndex - 1)) + '0');\n            startIndex = currentIndex + 1;\n        }\n    }\n\n    sort(specialSubstrings.rbegin(), specialSubstrings.rend());\n    string result;\n    for (int i = 0; i < specialSubstrings.size(); ++i)\n    {\n        result += specialSubstrings[i];\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string makeLargestSpecial(std::string specialString)\n{\n    int balanceCount= 0, startIndex= 0;\n    std::vector<std::string> specialSubstrings;\n\n    for(int currentIndex= 0; currentIndex < specialString.size(); currentIndex++)\n    {\n        if(specialString[currentIndex] == '1')\n            balanceCount++;\n        else\n            balanceCount--;\n\n        if(balanceCount == 0)\n        {\n            specialSubstrings.push_back('1' + makeLargestSpecial(specialString.substr(startIndex + 1, currentIndex - startIndex - 1)) + '0');\n            startIndex= currentIndex + 1;\n        }\n    }\n\n    std::sort(specialSubstrings.rbegin(), specialSubstrings.rend());\n    std::string result;\n    for(const auto &substring : specialSubstrings)\n    {\n        result+= substring;\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPrime(int number)\n{\n    if(number <= 1)\n        return false;\n    if(number <= 3)\n        return true;\n    if(number % 2 == 0 || number % 3 == 0)\n        return false;\n    for(int divisor= 5; divisor * divisor <= number; divisor+= 6)\n        if(number % divisor == 0 || number % (divisor + 2) == 0)\n            return false;\n    return true;\n}\n\nint countPrimeSetBits(int rangeStart, int rangeEnd)\n{\n    int primeCount= 0;\n    for(int currentNumber= rangeStart; currentNumber <= rangeEnd; ++currentNumber)\n        primeCount+= isPrime(bitset<32>(currentNumber).count());\n    return primeCount;\n}",
    "output": "#include <bits/stdc++.h>\nbool isPrime(int number)\n{\n    if(number <= 1)\n        return false;\n    if(number <= 3)\n        return true;\n    if(number % 2 == 0 || number % 3 == 0)\n        return false;\n    for(int divisor= 5; divisor * divisor <= number; divisor+= 6)\n        if(number % divisor == 0 || number % (divisor + 2) == 0)\n            return false;\n    return true;\n}\n\nint countPrimeSetBits(int rangeStart, int rangeEnd)\n{\n    int primeCount= 0;\n    for(int currentNumber= rangeStart; currentNumber <= rangeEnd; ++currentNumber)\n        primeCount+= isPrime(std::bitset<32>(currentNumber).count());\n    return primeCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> partitionLabels(string inputString)\n{\n    unordered_map<char, int> lastOccurrence;\n    for(int currentIndex= 0; currentIndex < inputString.size(); currentIndex++)\n    {\n        lastOccurrence[inputString[currentIndex]= currentIndex;\n    }\n    vector<int> partitionLengths;\n    int lastPosition= 0, anchor= 0;\n    for(int currentIndex= 0; currentIndex < inputString.size(); currentIndex++)\n    {\n        lastPosition= max(lastPosition, lastOccurrence[inputString[currentIndex]]);\n        if(currentIndex == lastPosition)\n        {\n            partitionLengths.push_back(currentIndex - anchor + 1);\n            anchor= currentIndex + 1;\n        }\n    }\n    return partitionLengths;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> partitionLabels(std::string inputString)\n{\n    std::unordered_map<char, int> lastOccurrence;\n    for(int currentIndex= 0; currentIndex < inputString.size(); currentIndex++)\n    {\n        lastOccurrence[inputString[currentIndex]]= currentIndex;\n    }\n    std::vector<int> partitionLengths;\n    int lastPosition= 0, anchor= 0;\n    for(int currentIndex= 0; currentIndex < inputString.size(); currentIndex++)\n    {\n        lastPosition= std::max(lastPosition, lastOccurrence[inputString[currentIndex]]);\n        if(currentIndex == lastPosition)\n        {\n            partitionLengths.push_back(currentIndex - anchor + 1);\n            anchor= currentIndex + 1;\n        }\n    }\n    return partitionLengths;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Node\n{\n  public:\n    int value;\n    vector<Node *> children;\n\n    Node() {}\n\n    Node(int valueIn)\n    {\n        value = valueIn;\n    }\n\n    Node(int valueIn, vector<Node *> childrenIn)\n    {\n        value = valueIn;\n        children = childrenIn;\n    }\n};\n\nvector<vector<int>> levelOrder(Node *root)\n{\n    vector<vector<int>> result;\n    if(root == NULL)\n        return result;\n\n    queue<Node *> nodesToVisit;\n    nodesToVisit.push(root);\n\n    while(!nodesToVisit.empty())\n    {\n        int currentLevelSize = nodesToVisit.size();\n        vector<int> currentLevel;\n\n        for(int i = 0; i < currentLevelSize; i++)\n        {\n            Node *currentNode = nodesToVisit.front();\n            nodesToVisit.pop();\n            currentLevel.push_back(currentNode->value);\n\n            for(int j = 0; j < currentNode->children.size(); j++)\n            {\n                Node *child = currentNode->children[j];\n                nodesToVisit.push(child);\n            }\n        }\n        result.push_back(currentLevel);\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nclass Node\n{\n  public:\n    int value;\n    std::vector<Node *> children;\n\n    Node() {}\n\n    Node(int valueIn)\n    {\n        value= valueIn;\n    }\n\n    Node(int valueIn, std::vector<Node *> childrenIn)\n    {\n        value= valueIn;\n        children= childrenIn;\n    }\n};\n\nvector<std::vector<int>> levelOrder(Node *root)\n{\n    std::vector<std::vector<int>> result;\n    if(root == NULL)\n        return result;\n\n    std::queue<Node *> nodesToVisit;\n    nodesToVisit.push(root);\n\n    while(!nodesToVisit.empty())\n    {\n        int currentLevelSize= nodesToVisit.size();\n        std::vector<int> currentLevel;\n\n        for(int i= 0; i < currentLevelSize; i++)\n        {\n            Node *currentNode= nodesToVisit.front();\n            nodesToVisit.pop();\n            currentLevel.push_back(currentNode->value);\n\n            for(Node *child : currentNode->children)\n            {\n                nodesToVisit.push(child);\n            }\n        }\n        result.push_back(currentLevel);\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minSwapsForCouples(vector<int> &row)\n{\n    int size= row.size();\n    vector<int> position(size);\n    for(int index= 0; index < size; ++index)\n        position[row[index]]= index;\n\n    int swapCount= 0;\n    for(int index= 0; index < size; index+= 2)\n    {\n        int partner= row[index] % 2 == 0 ? row[index] + 1 : row[index] - 1;\n        if(row[index + 1] != partner)\n        {\n            swap(row[position[partner]], row[index + 1]);\n            swap(position[row[index + 1]], position[partner]);\n            swapCount++;\n        }\n    }\n    return swapCount;\n}",
    "output": "#include <bits/stdc++.h>\nint minSwapsForCouples(std::vector<int> &row)\n{\n    int size= row.size();\n    std::vector<int> position(size);\n    for(int index= 0; index < size; ++index)\n        position[row[index]]= index;\n\n    int swapCount= 0;\n    for(int index= 0; index < size; index+= 2)\n    {\n        int partner= row[index] % 2 == 0 ? row[index] + 1 : row[index] - 1;\n        if(row[index + 1] != partner)\n        {\n            std::swap(row[position[partner]], row[index + 1]);\n            std::swap(position[row[index + 1]], position[partner]);\n            swapCount++;\n        }\n    }\n    return swapCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class Node\n{\n  public:\n    int value;\n    Node *previous;\n    Node *next;\n    Node *child;\n};\n\nNode *flatten(Node *head)\n{\n    if(!head)\n        return NULL;\n\n    Node *current= head;\n    while(current)\n    {\n        if(current->child)\n        {\n            Node *insert= current->child;\n            Node *next= current->next;\n\n            insert->previous= current;\n            current->next= insert;\n            current->child= NULL;\n\n            while(insert->next)\n                insert= insert->next;\n\n            if(next)\n            {\n                next->previous= insert;\n                insert->next= next;\n            }\n        }\n        current= current->next;\n    }\n\n    return head;\n}",
    "output": "class Node\n{\n  public:\n    int value;\n    Node *previous;\n    Node *next;\n    Node *child;\n};\n\nNode *flatten(Node *head)\n{\n    if(!head)\n        return NULL;\n\n    Node *current= head;\n    while(current)\n    {\n        if(current->child)\n        {\n            Node *insert= current->child;\n            Node *next= current->next;\n\n            insert->previous= current;\n            current->next= insert;\n            current->child= NULL;\n\n            while(insert->next)\n                insert= insert->next;\n\n            if(next)\n            {\n                next->previous= insert;\n                insert->next= next;\n            }\n        }\n        current= current->next;\n    }\n\n    return head;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPrime(int number)\n{\n    if(number <= 1)\n        return false;\n    for(int factor= 2; factor * factor <= number; factor++)\n    {\n        if(number % factor == 0)\n            return false;\n    }\n    return true;\n}\n\nint countPrimeSetBits(int rangeStart, int rangeEnd)\n{\n    int primeCount= 0;\n    for(int currentNumber= rangeStart; currentNumber <= rangeEnd; currentNumber++)\n    {\n        if(isPrime(bitset<32>(currentNumber).count()))\n            primeCount++;\n    }\n    return primeCount;\n}",
    "output": "#include <bits/stdc++.h>\nbool isPrime(int number)\n{\n    if(number <= 1)\n        return false;\n    for(int factor= 2; factor * factor <= number; factor++)\n    {\n        if(number % factor == 0)\n            return false;\n    }\n    return true;\n}\n\nint countPrimeSetBits(int rangeStart, int rangeEnd)\n{\n    int primeCount= 0;\n    for(int currentNumber= rangeStart; currentNumber <= rangeEnd; currentNumber++)\n    {\n        if(isPrime(std::bitset<32>(currentNumber).count()))\n            primeCount++;\n    }\n    return primeCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> partitionLabels(const string &inputString)\n{\n    unordered_map<char, int> lastPositionMap;\n    for(int currentIndex= 0; currentIndex < inputString.size(); currentIndex++)\n    {\n        lastPositionMap[inputString[currentIndex]]= currentIndex;\n    }\n\n    vector<int> partitionSizes;\n    int partitionStart= 0, partitionEnd= 0;\n    for(int currentIndex= 0; currentIndex < inputString.size(); currentIndex++)\n    {\n        partitionEnd= max(partitionEnd, lastPositionMap[inputString[currentIndex]]);\n        if(currentIndex == partitionEnd)\n        {\n            partitionSizes.push_back(partitionEnd - partitionStart + 1);\n            partitionStart= currentIndex + 1;\n        }\n    }\n    return partitionSizes;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> partitionLabels(const std::string &inputString)\n{\n    std::unordered_map<char, int> lastPositionMap;\n    for(int currentIndex= 0; currentIndex < inputString.size(); currentIndex++)\n    {\n        lastPositionMap[inputString[currentIndex]]= currentIndex;\n    }\n\n    std::vector<int> partitionSizes;\n    int partitionStart= 0, partitionEnd= 0;\n    for(int currentIndex= 0; currentIndex < inputString.size(); currentIndex++)\n    {\n        partitionEnd= std::max(partitionEnd, lastPositionMap[inputString[currentIndex]]);\n        if(currentIndex == partitionEnd)\n        {\n            partitionSizes.push_back(partitionEnd - partitionStart + 1);\n            partitionStart= currentIndex + 1;\n        }\n    }\n    return partitionSizes;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint orderOfLargestPlusSign(int gridSize, vector<vector<int>> &mines)\n{\n    vector<vector<int>> grid(gridSize, vector<int>(gridSize, 1));\n    for (const auto &mine : mines)\n        grid[mine[0]][mine[1]] = 0;\n\n    vector<vector<int>> leftCount(grid), rightCount(grid), upCount(grid), downCount(grid);\n    for (int row = 0; row < gridSize; ++row)\n    {\n        for (int col = 0; col < gridSize; ++col)\n        {\n            if (grid[row][col])\n            {\n                leftCount[row][col] = col > 0 ? leftCount[row][col - 1] + 1 : 1;\n                upCount[row][col] = row > 0 ? upCount[row - 1][col] + 1 : 1;\n            }\n            if (grid[gridSize - row - 1][gridSize - col - 1])\n            {\n                rightCount[gridSize - row - 1][gridSize - col - 1] = col > 0 ? rightCount[gridSize - row - 1][gridSize - col] + 1 : 1;\n                downCount[gridSize - row - 1][gridSize - col - 1] = row > 0 ? downCount[gridSize - row][gridSize - col - 1] + 1 : 1;\n            }\n        }\n    }\n\n    int largestPlusSignOrder = 0;\n    for (int row = 0; row < gridSize; ++row)\n        for (int col = 0; col < gridSize; ++col)\n            largestPlusSignOrder = max(largestPlusSignOrder, min({leftCount[row][col], rightCount[row][col], upCount[row][col], downCount[row][col]}));\n    return largestPlusSignOrder;\n}",
    "output": "#include <bits/stdc++.h>\nint orderOfLargestPlusSign(int gridSize, std::vector<std::vector<int>> &mines)\n{\n    std::vector<std::vector<int>> grid(gridSize, std::vector<int>(gridSize, 1));\n    for(const auto &mine : mines)\n        grid[mine[0]][mine[1]]= 0;\n\n    std::vector<std::vector<int>> leftCount(grid), rightCount(grid), upCount(grid), downCount(grid);\n    for(int row= 0; row < gridSize; ++row)\n    {\n        for(int col= 0; col < gridSize; ++col)\n        {\n            if(grid[row][col])\n            {\n                leftCount[row][col]= col > 0 ? leftCount[row][col - 1] + 1 : 1;\n                upCount[row][col]= row > 0 ? upCount[row - 1][col] + 1 : 1;\n            }\n            if(grid[gridSize - row - 1][gridSize - col - 1])\n            {\n                rightCount[gridSize - row - 1][gridSize - col - 1]= col > 0 ? rightCount[gridSize - row - 1][gridSize - col] + 1 : 1;\n                downCount[gridSize - row - 1][gridSize - col - 1]= row > 0 ? downCount[gridSize - row][gridSize - col - 1] + 1 : 1;\n            }\n        }\n    }\n\n    int largestPlusSignOrder= 0;\n    for(int row= 0; row < gridSize; ++row)\n        for(int col= 0; col < gridSize; ++col)\n            largestPlusSignOrder= std::max(largestPlusSignOrder, std::min({leftCount[row][col], rightCount[row][col], upCount[row][col], downCount[row][col]}));\n    return largestPlusSignOrder;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minSwapsCouples(vector<int> &seatingArrangement)\n{\n    int numberOfCouples= seatingArrangement.size() / 2;\n    int swapCount= 0;\n    unordered_map<int, int> positionMap;\n\n    for(int index= 0; index < seatingArrangement.size(); index++)\n    {\n        positionMap[seatingArrangement[index]]= index;\n    }\n\n    for(int index= 0; index < seatingArrangement.size(); index+= 2)\n    {\n        int expectedCouple= (seatingArrangement[index] % 2 == 0) ? seatingArrangement[index] + 1 : seatingArrangement[index] - 1;\n        if(seatingArrangement[index + 1] != expectedCouple)\n        {\n            swap(seatingArrangement[index + 1], seatingArrangement[positionMap[expectedCouple]]);\n            swap(positionMap[seatingArrangement[index + 1]], positionMap[expectedCouple]);\n            swapCount++;\n        }\n    }\n    return swapCount;\n}",
    "output": "#include <bits/stdc++.h>\nint minSwapsCouples(std::vector<int> &seatingArrangement)\n{\n    int numberOfCouples = seatingArrangement.size() / 2;\n    int swapCount = 0;\n    std::unordered_map<int, int> positionMap;\n\n    for(int index = 0; index < seatingArrangement.size(); index++)\n    {\n        positionMap[seatingArrangement[index]] = index;\n    }\n\n    for(int index = 0; index < seatingArrangement.size(); index += 2)\n    {\n        int expectedCouple = (seatingArrangement[index] % 2 == 0) ? seatingArrangement[index] + 1 : seatingArrangement[index] - 1;\n        if(seatingArrangement[index + 1] != expectedCouple)\n        {\n            std::swap(seatingArrangement[index + 1], seatingArrangement[positionMap[expectedCouple]]);\n            std::swap(positionMap[seatingArrangement[index + 1]], positionMap[expectedCouple]);\n            swapCount++;\n        }\n    }\n    return swapCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countJewelsInStones(string jewels, string stones)\n{\n    int jewelCount = 0;\n    for (int i = 0; i < stones.size(); ++i)\n    {\n        char stone = stones[i];\n        if (jewels.find(stone) != string::npos)\n        {\n            jewelCount++;\n        }\n    }\n    return jewelCount;\n}",
    "output": "int countJewelsInStones(string jewels, string stones)\n{\n    int jewelCount= 0;\n    for(char stone : stones)\n    {\n        if(jewels.find(stone) != std::string::npos)\n        {\n            jewelCount++;\n        }\n    }\n    return jewelCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct QuadTreeNode\n{\n    bool value;\n    bool isLeaf;\n    QuadTreeNode *topLeft;\n    QuadTreeNode *topRight;\n    QuadTreeNode *bottomLeft;\n    QuadTreeNode *bottomRight;\n};\n\nQuadTreeNode *construct(vector<vector<int>> &grid);\n\nQuadTreeNode *helper(vector<vector<int>> &grid, int startX, int startY, int length)\n{\n    if(length == 1)\n    {\n        return new QuadTreeNode{grid[startX][startY] == 1, true, NULL, NULL, NULL, NULL};\n    }\n\n    QuadTreeNode *topLeftNode= helper(grid, startX, startY, length / 2);\n    QuadTreeNode *topRightNode= helper(grid, startX, startY + length / 2, length / 2);\n    QuadTreeNode *bottomLeftNode= helper(grid, startX + length / 2, startY, length / 2);\n    QuadTreeNode *bottomRightNode= helper(grid, startX + length / 2, startY + length / 2, length / 2);\n\n    if(topLeftNode->isLeaf && topRightNode->isLeaf && bottomLeftNode->isLeaf && bottomRightNode->isLeaf &&\n       topLeftNode->value == topRightNode->value && topRightNode->value == bottomLeftNode->value && bottomLeftNode->value == bottomRightNode->value)\n    {\n        bool combinedValue= topLeftNode->value;\n        delete topLeftNode;\n        delete topRightNode;\n        delete bottomLeftNode;\n        delete bottomRightNode;\n        return new QuadTreeNode{combinedValue, true, NULL, NULL, NULL, NULL};\n    }\n    else\n    {\n        return new QuadTreeNode{false, false, topLeftNode, topRightNode, bottomLeftNode, bottomRightNode};\n    }\n}\n\nQuadTreeNode *construct(vector<vector<int>> &grid)\n{\n    return helper(grid, 0, 0, grid.size());\n}",
    "output": "#include <bits/stdc++.h>\nstruct QuadTreeNode\n{\n    bool value;\n    bool isLeaf;\n    QuadTreeNode *topLeft;\n    QuadTreeNode *topRight;\n    QuadTreeNode *bottomLeft;\n    QuadTreeNode *bottomRight;\n};\n\nQuadTreeNode *construct(std::vector<std::vector<int>> &grid)\n{\n    return helper(grid, 0, 0, grid.size());\n}\n\nQuadTreeNode *helper(std::vector<std::vector<int>> &grid, int startX, int startY, int length)\n{\n    if(length == 1)\n    {\n        return new QuadTreeNode{grid[startX][startY] == 1, true, NULL, NULL, NULL, NULL};\n    }\n\n    QuadTreeNode *topLeftNode= helper(grid, startX, startY, length / 2);\n    QuadTreeNode *topRightNode= helper(grid, startX, startY + length / 2, length / 2);\n    QuadTreeNode *bottomLeftNode= helper(grid, startX + length / 2, startY, length / 2);\n    QuadTreeNode *bottomRightNode= helper(grid, startX + length / 2, startY + length / 2, length / 2);\n\n    if(topLeftNode->isLeaf && topRightNode->isLeaf && bottomLeftNode->isLeaf && bottomRightNode->isLeaf &&\n       topLeftNode->value == topRightNode->value && topRightNode->value == bottomLeftNode->value && bottomLeftNode->value == bottomRightNode->value)\n    {\n        bool combinedValue= topLeftNode->value;\n        delete topLeftNode;\n        delete topRightNode;\n        delete bottomLeftNode;\n        delete bottomRightNode;\n        return new QuadTreeNode{combinedValue, true, NULL, NULL, NULL, NULL};\n    }\n    else\n    {\n        return new QuadTreeNode{false, false, topLeftNode, topRightNode, bottomLeftNode, bottomRightNode};\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct QuadTreeNode\n{\n    bool isLeaf;\n    bool value;\n    QuadTreeNode *topLeft;\n    QuadTreeNode *topRight;\n    QuadTreeNode *bottomLeft;\n    QuadTreeNode *bottomRight;\n};\n\nQuadTreeNode *intersect(QuadTreeNode *quadTree1, QuadTreeNode *quadTree2)\n{\n    if(quadTree1->isLeaf)\n    {\n        return quadTree1->value ? quadTree1 : quadTree2;\n    }\n    if(quadTree2->isLeaf)\n    {\n        return quadTree2->value ? quadTree2 : quadTree1;\n    }\n\n    quadTree1->topLeft= intersect(quadTree1->topLeft, quadTree2->topLeft);\n    quadTree1->topRight= intersect(quadTree1->topRight, quadTree2->topRight);\n    quadTree1->bottomLeft= intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\n    quadTree1->bottomRight= intersect(quadTree1->bottomRight, quadTree2->bottomRight);\n\n    if(quadTree1->topLeft->isLeaf && quadTree1->topRight->isLeaf && quadTree1->bottomLeft->isLeaf && quadTree1->bottomRight->isLeaf &&\n       quadTree1->topLeft->value == quadTree1->topRight->value &&\n       quadTree1->topRight->value == quadTree1->bottomLeft->value &&\n       quadTree1->bottomLeft->value == quadTree1->bottomRight->value)\n    {\n\n        quadTree1->isLeaf= true;\n        quadTree1->value= quadTree1->topLeft->value;\n        delete quadTree1->topLeft;\n        delete quadTree1->topRight;\n        delete quadTree1->bottomLeft;\n        delete quadTree1->bottomRight;\n    }\n\n    return quadTree1;\n}",
    "output": "struct QuadTreeNode\n{\n    bool isLeaf;\n    bool value;\n    QuadTreeNode *topLeft;\n    QuadTreeNode *topRight;\n    QuadTreeNode *bottomLeft;\n    QuadTreeNode *bottomRight;\n};\n\nQuadTreeNode *intersect(QuadTreeNode *quadTree1, QuadTreeNode *quadTree2)\n{\n    if(quadTree1->isLeaf)\n    {\n        return quadTree1->value ? quadTree1 : quadTree2;\n    }\n    if(quadTree2->isLeaf)\n    {\n        return quadTree2->value ? quadTree2 : quadTree1;\n    }\n\n    quadTree1->topLeft= intersect(quadTree1->topLeft, quadTree2->topLeft);\n    quadTree1->topRight= intersect(quadTree1->topRight, quadTree2->topRight);\n    quadTree1->bottomLeft= intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\n    quadTree1->bottomRight= intersect(quadTree1->bottomRight, quadTree2->bottomRight);\n\n    if(quadTree1->topLeft->isLeaf && quadTree1->topRight->isLeaf && quadTree1->bottomLeft->isLeaf && quadTree1->bottomRight->isLeaf &&\n       quadTree1->topLeft->value == quadTree1->topRight->value &&\n       quadTree1->topRight->value == quadTree1->bottomLeft->value &&\n       quadTree1->bottomLeft->value == quadTree1->bottomRight->value)\n    {\n\n        quadTree1->isLeaf= true;\n        quadTree1->value= quadTree1->topLeft->value;\n        delete quadTree1->topLeft;\n        delete quadTree1->topRight;\n        delete quadTree1->bottomLeft;\n        delete quadTree1->bottomRight;\n    }\n\n    return quadTree1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Node\n{\n  public:\n    int value;\n    vector<Node *> children;\n\n    Node() {}\n\n    Node(int valueIn)\n    {\n        value = valueIn;\n    }\n};\n\nint maxDepth(Node *root)\n{\n    if(root == NULL)\n    {\n        return 0;\n    }\n    int currentDepth = 0;\n    for(int i = 0; i < root->children.size(); ++i)\n    {\n        Node *child = root->children[i];\n        currentDepth = max(currentDepth, maxDepth(child));\n    }\n    return 1 + currentDepth;\n}",
    "output": "#include <bits/stdc++.h>\nclass Node\n{\n  public:\n    int value;\n    std::vector<Node *> children;\n\n    Node() {}\n\n    Node(int valueIn)\n    {\n        value= valueIn;\n    }\n};\n\nint maxDepth(Node *root)\n{\n    if(root == NULL)\n    {\n        return 0;\n    }\n    int currentDepth= 0;\n    for(Node *child : root->children)\n    {\n        currentDepth= std::max(currentDepth, maxDepth(child));\n    }\n    return 1 + currentDepth;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Node\n{\n  public:\n    int value;\n    vector<Node *> childNodes;\n\n    Node() {}\n    Node(int valueIn) { value= valueIn; }\n    Node(int valueIn, vector<Node *> childNodesIn)\n    {\n        value= valueIn;\n        childNodes= childNodesIn;\n    }\n};\n\nvoid traversePreorder(Node *currentNode, vector<int> &traversalResult)\n{\n    if(!currentNode)\n        return;\n    traversalResult.push_back(currentNode->value);\n    for(size_t i = 0; i < currentNode->childNodes.size(); ++i)\n    {\n        Node *childNode = currentNode->childNodes[i];\n        traversePreorder(childNode, traversalResult);\n    }\n}\n\nvector<int> preorderTraversal(Node *rootNode)\n{\n    vector<int> traversalResult;\n    traversePreorder(rootNode, traversalResult);\n    return traversalResult;\n}",
    "output": "#include <bits/stdc++.h>\nclass Node\n{\n  public:\n    int value;\n    std::vector<Node *> childNodes;\n\n    Node() {}\n    Node(int valueIn) { value= valueIn; }\n    Node(int valueIn, std::vector<Node *> childNodesIn)\n    {\n        value= valueIn;\n        childNodes= childNodesIn;\n    }\n};\n\nvoid traversePreorder(Node *currentNode, std::vector<int> &traversalResult)\n{\n    if(!currentNode)\n        return;\n    traversalResult.push_back(currentNode->value);\n    for(Node *childNode : currentNode->childNodes)\n    {\n        traversePreorder(childNode, traversalResult);\n    }\n}\n\nstd::vector<int> preorderTraversal(Node *rootNode)\n{\n    std::vector<int> traversalResult;\n    traversePreorder(rootNode, traversalResult);\n    return traversalResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Node\n{\n  public:\n    int value;\n    vector<Node *> children;\n\n    Node() {}\n    Node(int valueIn) { value= valueIn; }\n    Node(int valueIn, vector<Node *> childrenIn)\n    {\n        value= valueIn;\n        children= childrenIn;\n    }\n};\n\nvector<int> postorder(Node *root)\n{\n    vector<int> result;\n    if(root == NULL)\n        return result;\n\n    stack<Node *> stack;\n    stack.push(root);\n    while(!stack.empty())\n    {\n        Node *currentNode = stack.top();\n        stack.pop();\n\n        result.push_back(currentNode->value);\n        for (int i = 0; i < currentNode->children.size(); ++i)\n        {\n            Node *childNode = currentNode->children[i];\n            stack.push(childNode);\n        }\n    }\n    reverse(result.begin(), result.end());\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nclass Node\n{\n  public:\n    int value;\n    std::vector<Node *> children;\n\n    Node() {}\n    Node(int valueIn) { value= valueIn; }\n    Node(int valueIn, std::vector<Node *> childrenIn)\n    {\n        value= valueIn;\n        children= childrenIn;\n    }\n};\n\nstd::vector<int> postorder(Node *root)\n{\n    std::vector<int> result;\n    if(root == NULL)\n        return result;\n\n    std::stack<Node *> stack;\n    stack.push(root);\n    while(!stack.empty())\n    {\n        Node *currentNode= stack.top();\n        stack.pop();\n\n        result.push_back(currentNode->value);\n        for(Node *childNode : currentNode->children)\n        {\n            stack.push(childNode);\n        }\n    }\n    std::reverse(result.begin(), result.end());\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isToeplitzMatrix(vector<vector<int>> &matrix)\n{\n    int rowCount= matrix.size();\n    int colCount= matrix[0].size();\n    for(int currentRow= 0; currentRow < rowCount - 1; ++currentRow)\n    {\n        for(int currentCol= 0; currentCol < colCount - 1; ++currentCol)\n        {\n            if(matrix[currentRow][currentCol] != matrix[currentRow + 1][currentCol + 1])\n                return false;\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isToeplitzMatrix(std::vector<std::vector<int>> &matrix)\n{\n    int rowCount = matrix.size();\n    int colCount = matrix[0].size();\n    for(int currentRow = 0; currentRow < rowCount - 1; ++currentRow)\n    {\n        for(int currentCol = 0; currentCol < colCount - 1; ++currentCol)\n        {\n            if(matrix[currentRow][currentCol] != matrix[currentRow + 1][currentCol + 1])\n                return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring rearrangeString(string inputString)\n{\n    unordered_map<char, int> characterCounts;\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char character = inputString[i];\n        characterCounts[character]++;\n    }\n\n    auto compare = [](const auto &a, const auto &b)\n    {\n        return a.second < b.second;\n    };\n\n    priority_queue<pair<char, int>, vector<pair<char, int>>, decltype(compare)> priorityQueue(compare);\n\n    for (auto &count : characterCounts)\n    {\n        priorityQueue.push(count);\n    }\n\n    string rearrangedString;\n    pair<char, int> previousCharacter = {'#', 0};\n\n    while (!priorityQueue.empty())\n    {\n        auto currentCharacter = priorityQueue.top();\n        priorityQueue.pop();\n        rearrangedString += currentCharacter.first;\n\n        if (previousCharacter.second > 0)\n        {\n            priorityQueue.push(previousCharacter);\n        }\n\n        currentCharacter.second--;\n        previousCharacter = currentCharacter;\n    }\n\n    return rearrangedString.size() == inputString.size() ? rearrangedString : \"\";\n}",
    "output": "#include <bits/stdc++.h>\nstd::string rearrangeString(std::string inputString)\n{\n    std::unordered_map<char, int> characterCounts;\n    for(char character : inputString)\n    {\n        characterCounts[character]++;\n    }\n\n    auto compare= [](const auto &a, const auto &b)\n    {\n        return a.second < b.second;\n    };\n\n    std::priority_queue<std::pair<char, int>, std::vector<std::pair<char, int>>, decltype(compare)> priorityQueue(compare);\n\n    for(auto &count : characterCounts)\n    {\n        priorityQueue.push(count);\n    }\n\n    std::string rearrangedString;\n    std::pair<char, int> previousCharacter= {'#', 0};\n\n    while(!priorityQueue.empty())\n    {\n        auto currentCharacter= priorityQueue.top();\n        priorityQueue.pop();\n        rearrangedString+= currentCharacter.first;\n\n        if(previousCharacter.second > 0)\n        {\n            priorityQueue.push(previousCharacter);\n        }\n\n        currentCharacter.second--;\n        previousCharacter= currentCharacter;\n    }\n\n    return rearrangedString.size() == inputString.size() ? rearrangedString : \"\";\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxChunksToSorted(vector<int> &array)\n{\n    int maxValue= 0, chunkCount= 0;\n    for(int index= 0; index < array.size(); ++index)\n    {\n        maxValue= max(maxValue, array[index]);\n        if(maxValue == index)\n        {\n            chunkCount++;\n        }\n    }\n    return chunkCount;\n}",
    "output": "#include <bits/stdc++.h>\nint maxChunksToSorted(std::vector<int> &array)\n{\n    int maxValue= 0, chunkCount= 0;\n    for(int index= 0; index < array.size(); ++index)\n    {\n        maxValue= std::max(maxValue, array[index]);\n        if(maxValue == index)\n        {\n            chunkCount++;\n        }\n    }\n    return chunkCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxChunksToSorted(vector<int> &inputArray)\n{\n    int maxSoFar= 0, chunkCount= 0;\n    for(int index= 0; index < inputArray.size(); index++)\n    {\n        maxSoFar= max(maxSoFar, inputArray[index]);\n        if(maxSoFar == index)\n        {\n            chunkCount++;\n        }\n    }\n    return chunkCount;\n}",
    "output": "#include <bits/stdc++.h>\nint maxChunksToSorted(std::vector<int> &inputArray)\n{\n    int maxSoFar= 0, chunkCount= 0;\n    for(int index= 0; index < inputArray.size(); index++)\n    {\n        maxSoFar= std::max(maxSoFar, inputArray[index]);\n        if(maxSoFar == index)\n        {\n            chunkCount++;\n        }\n    }\n    return chunkCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numRabbits(vector<int> &rabbitAnswers)\n{\n    unordered_map<int, int> answerCount;\n    int totalRabbits = 0;\n    for (int answer : rabbitAnswers)\n    {\n        answerCount[answer]++;\n    }\n    for (auto it = answerCount.begin(); it != answerCount.end(); ++it)\n    {\n        int answer = it->first;\n        int count = it->second;\n        totalRabbits += (answer + count) / (answer + 1) * (answer + 1);\n    }\n    return totalRabbits;\n}",
    "output": "#include <bits/stdc++.h>\nint numRabbits(std::vector<int> &rabbitAnswers)\n{\n    std::unordered_map<int, int> answerCount;\n    int totalRabbits = 0;\n    for(int answer : rabbitAnswers)\n    {\n        answerCount[answer]++;\n    }\n    for(auto &[answer, count] : answerCount)\n    {\n        totalRabbits += (answer + count) / (answer + 1) * (answer + 1);\n    }\n    return totalRabbits;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countJewelsInStones(string jewels, string stones)\n{\n    int jewelCount = 0;\n    for (int i = 0; i < stones.size(); ++i)\n    {\n        char stone = stones[i];\n        if (jewels.find(stone) != string::npos)\n        {\n            jewelCount++;\n        }\n    }\n    return jewelCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countJewelsInStones(std::string jewels, std::string stones)\n{\n    int jewelCount= 0;\n    for(char stone : stones)\n    {\n        if(jewels.find(stone) != std::string::npos)\n        {\n            jewelCount++;\n        }\n    }\n    return jewelCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nTreeNode *searchBinarySearchTree(TreeNode *root, int value)\n{\n    if(!root || root->value == value)\n    {\n        return root;\n    }\n    return (root->value > value) ? searchBinarySearchTree(root->leftChild, value) : searchBinarySearchTree(root->rightChild, value);\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nTreeNode *searchBinarySearchTree(TreeNode *root, int value)\n{\n    if(!root || root->value == value)\n    {\n        return root;\n    }\n    return (root->value > value) ? searchBinarySearchTree(root->leftChild, value) : searchBinarySearchTree(root->rightChild, value);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nTreeNode *insertIntoBST(TreeNode *root, int value)\n{\n    if(root == NULL)\n    {\n        return new TreeNode(value);\n    }\n\n    if(value < root->value)\n    {\n        root->leftChild= insertIntoBST(root->leftChild, value);\n    }\n    else\n    {\n        root->rightChild= insertIntoBST(root->rightChild, value);\n    }\n\n    return root;\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nTreeNode *insertIntoBST(TreeNode *root, int value)\n{\n    if(root == NULL)\n    {\n        return new TreeNode(value);\n    }\n\n    if(value < root->value)\n    {\n        root->leftChild= insertIntoBST(root->leftChild, value);\n    }\n    else\n    {\n        root->rightChild= insertIntoBST(root->rightChild, value);\n    }\n\n    return root;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool depthFirstSearch(int currentNode, int currentColor, vector<int> &nodeColors, vector<vector<int>> &adjacencyList)\n{\n    if(nodeColors[currentNode] != 0)\n    {\n        return nodeColors[currentNode] == currentColor;\n    }\n\n    nodeColors[currentNode] = currentColor;\n    for(int i = 0; i < adjacencyList[currentNode].size(); ++i)\n    {\n        int neighbor = adjacencyList[currentNode][i];\n        if(!depthFirstSearch(neighbor, 3 - currentColor, nodeColors, adjacencyList))\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nbool isBipartite(vector<vector<int>> &adjacencyList)\n{\n    int graphSize = adjacencyList.size();\n    vector<int> nodeColors(graphSize, 0);\n\n    for(int i = 0; i < graphSize; ++i)\n    {\n        if(nodeColors[i] == 0 && !depthFirstSearch(i, 1, nodeColors, adjacencyList))\n        {\n            return false;\n        }\n    }\n\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool depthFirstSearch(int currentNode, int currentColor, std::vector<int> &nodeColors, std::vector<std::vector<int>> &adjacencyList)\n{\n    if(nodeColors[currentNode] != 0)\n    {\n        return nodeColors[currentNode] == currentColor;\n    }\n\n    nodeColors[currentNode] = currentColor;\n    for(int neighbor : adjacencyList[currentNode])\n    {\n        if(!depthFirstSearch(neighbor, 3 - currentColor, nodeColors, adjacencyList))\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nbool isBipartite(std::vector<std::vector<int>> &adjacencyList)\n{\n    int graphSize = adjacencyList.size();\n    std::vector<int> nodeColors(graphSize, 0);\n\n    for(int i = 0; i < graphSize; ++i)\n    {\n        if(nodeColors[i] == 0 && !depthFirstSearch(i, 1, nodeColors, adjacencyList))\n        {\n            return false;\n        }\n    }\n\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findKthSmallestPrimeFraction(vector<int> &primeNumbers, int k)\n{\n    auto compareFractions= [&](pair<int, int> &a, pair<int, int> &b)\n    {\n        return primeNumbers[a.first] * primeNumbers[b.second] > primeNumbers[a.second] * primeNumbers[b.first];\n    };\n    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(compareFractions)> fractionQueue(compareFractions);\n    for(int index= 0; index < primeNumbers.size() - 1; ++index)\n    {\n        fractionQueue.push({index, primeNumbers.size() - 1});\n    }\n    for(int iteration= 0; iteration < k - 1; ++iteration)\n    {\n        auto [rowIndex, colIndex]= fractionQueue.top();\n        fractionQueue.pop();\n        if(--colIndex > rowIndex)\n        {\n            fractionQueue.push({rowIndex, colIndex});\n        }\n    }\n    return {primeNumbers[fractionQueue.top().first], primeNumbers[fractionQueue.top().second]};\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findKthSmallestPrimeFraction(std::vector<int> &primeNumbers, int k)\n{\n    auto compareFractions = [&](std::pair<int, int> &a, std::pair<int, int> &b)\n    {\n        return primeNumbers[a.first] * primeNumbers[b.second] > primeNumbers[a.second] * primeNumbers[b.first];\n    };\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, decltype(compareFractions)> fractionQueue(compareFractions);\n    for(int index = 0; index < primeNumbers.size() - 1; ++index)\n    {\n        fractionQueue.push({index, primeNumbers.size() - 1});\n    }\n    for(int iteration = 0; iteration < k - 1; ++iteration)\n    {\n        auto [rowIndex, colIndex] = fractionQueue.top();\n        fractionQueue.pop();\n        if(--colIndex > rowIndex)\n        {\n            fractionQueue.push({rowIndex, colIndex});\n        }\n    }\n    return {primeNumbers[fractionQueue.top().first], primeNumbers[fractionQueue.top().second]};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint slidingPuzzle(vector<vector<int>> &puzzleBoard)\n{\n    int numberOfRows = 2, numberOfColumns = 3;\n    string targetState = \"123450\";\n    string startState = \"\";\n    for (int rowIndex = 0; rowIndex < numberOfRows; ++rowIndex)\n        for (int columnIndex = 0; columnIndex < numberOfColumns; ++columnIndex)\n            startState += to_string(puzzleBoard[rowIndex][columnIndex]);\n    vector<vector<int>> possibleMoves{{1, 3}, {0, 2, 4}, {1, 5}, {0, 4}, {1, 3, 5}, {2, 4}};\n    queue<string> stateQueue{{startState}};\n    int moveCount = 0;\n    unordered_set<string> visitedStates{startState};\n    while (!stateQueue.empty())\n    {\n        for (int k = stateQueue.size(); k > 0; --k)\n        {\n            string currentState = stateQueue.front();\n            stateQueue.pop();\n            if (currentState == targetState)\n                return moveCount;\n            int zeroIndex = currentState.find(\"0\");\n            for (int j = 0; j < possibleMoves[zeroIndex].size(); ++j)\n            {\n                int move = possibleMoves[zeroIndex][j];\n                string neighborState = currentState;\n                swap(neighborState[zeroIndex], neighborState[move]);\n                if (!visitedStates.count(neighborState))\n                {\n                    visitedStates.insert(neighborState);\n                    stateQueue.push(neighborState);\n                }\n            }\n        }\n        ++moveCount;\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint slidingPuzzle(std::vector<std::vector<int>> &puzzleBoard)\n{\n    int numberOfRows= 2, numberOfColumns= 3;\n    std::string targetState= \"123450\";\n    std::string startState= \"\";\n    for(int rowIndex= 0; rowIndex < numberOfRows; ++rowIndex)\n        for(int columnIndex= 0; columnIndex < numberOfColumns; ++columnIndex)\n            startState+= std::to_string(puzzleBoard[rowIndex][columnIndex]);\n    std::vector<std::vector<int>> possibleMoves{{1, 3}, {0, 2, 4}, {1, 5}, {0, 4}, {1, 3, 5}, {2, 4}};\n    std::queue<std::string> stateQueue{{startState}};\n    int moveCount= 0;\n    std::unordered_set<std::string> visitedStates{startState};\n    while(!stateQueue.empty())\n    {\n        for(int k= stateQueue.size(); k > 0; --k)\n        {\n            std::string currentState= stateQueue.front();\n            stateQueue.pop();\n            if(currentState == targetState)\n                return moveCount;\n            int zeroIndex= currentState.find(\"0\");\n            for(int move : possibleMoves[zeroIndex])\n            {\n                std::string neighborState= currentState;\n                std::swap(neighborState[zeroIndex], neighborState[move]);\n                if(!visitedStates.count(neighborState))\n                {\n                    visitedStates.insert(neighborState);\n                    stateQueue.push(neighborState);\n                }\n            }\n        }\n        ++moveCount;\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int countRotatedDigits(int upperLimit)\n{\n    int validCount= 0;\n    for(int currentNumber= 1; currentNumber <= upperLimit; currentNumber++)\n    {\n        if(isGood(currentNumber))\n            validCount++;\n    }\n    return validCount;\n}\n\nbool isGood(int number)\n{\n    bool hasChanged= false;\n    while(number)\n    {\n        int currentDigit= number % 10;\n        if(currentDigit == 3 || currentDigit == 4 || currentDigit == 7)\n            return false;\n        if(currentDigit == 2 || currentDigit == 5 || currentDigit == 6 || currentDigit == 9)\n            hasChanged= true;\n        number/= 10;\n    }\n    return hasChanged;\n}",
    "output": "int countRotatedDigits(int upperLimit)\n{\n    int validCount= 0;\n    for(int currentNumber= 1; currentNumber <= upperLimit; currentNumber++)\n    {\n        if(isGood(currentNumber))\n            validCount++;\n    }\n    return validCount;\n}\n\nbool isGood(int number)\n{\n    bool hasChanged= false;\n    while(number)\n    {\n        int currentDigit= number % 10;\n        if(currentDigit == 3 || currentDigit == 4 || currentDigit == 7)\n            return false;\n        if(currentDigit == 2 || currentDigit == 5 || currentDigit == 6 || currentDigit == 9)\n            hasChanged= true;\n        number/= 10;\n    }\n    return hasChanged;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass KthLargest\n{\n  public:\n    priority_queue<int, vector<int>, greater<int>> minHeap;\n    int k;\n\n    KthLargest(int k, vector<int> &numbers)\n    {\n        this->k = k;\n        for (int i = 0; i < numbers.size(); ++i)\n        {\n            add(numbers[i]);\n        }\n    }\n\n    int add(int value)\n    {\n        minHeap.push(value);\n        if (minHeap.size() > k)\n        {\n            minHeap.pop();\n        }\n        return minHeap.top();\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass KthLargest\n{\n  public:\n    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;\n    int k;\n\n    KthLargest(int k, std::vector<int> &numbers)\n    {\n        this->k= k;\n        for(int number : numbers)\n        {\n            add(number);\n        }\n    }\n\n    int add(int value)\n    {\n        minHeap.push(value);\n        if(minHeap.size() > k)\n        {\n            minHeap.pop();\n        }\n        return minHeap.top();\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// for abs function\nusing namespace std;\n\nbool isIdealPermutation(vector<int> &numberList)\n{\n    for(int index= 0; index < numberList.size(); ++index)\n    {\n        if(abs(numberList[index] - index) > 1)\n        {\n            return false;\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isIdealPermutation(std::vector<int> &numberList)\n{\n    for(int index= 0; index < numberList.size(); ++index)\n    {\n        if(std::abs(numberList[index] - index) > 1)\n        {\n            return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring customSortString(const string &sortOrder, string &inputString)\n{\n    unordered_map<char, int> characterPriority;\n    for(int index= 0; index < sortOrder.size(); index++)\n    {\n        characterPriority[sortOrder[index]]= index;\n    }\n\n    sort(inputString.begin(), inputString.end(), [&](char firstChar, char secondChar)\n              { return characterPriority[firstChar] < characterPriority[secondChar]; });\n\n    return inputString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string customSortString(const std::string &sortOrder, std::string &inputString)\n{\n    std::unordered_map<char, int> characterPriority;\n    for(int index= 0; index < sortOrder.size(); index++)\n    {\n        characterPriority[sortOrder[index]]= index;\n    }\n\n    std::sort(inputString.begin(), inputString.end(), [&](char firstChar, char secondChar)\n              { return characterPriority[firstChar] < characterPriority[secondChar]; });\n\n    return inputString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint search(vector<int> &numberList, int target)\n{\n    int leftIndex= 0;\n    int rightIndex= numberList.size() - 1;\n\n    while(leftIndex <= rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n\n        if(numberList[midIndex] == target)\n        {\n            return midIndex;\n        }\n        else if(numberList[midIndex] < target)\n        {\n            leftIndex= midIndex + 1;\n        }\n        else\n        {\n            rightIndex= midIndex - 1;\n        }\n    }\n\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint search(std::vector<int> &numberList, int target)\n{\n    int leftIndex= 0;\n    int rightIndex= numberList.size() - 1;\n\n    while(leftIndex <= rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n\n        if(numberList[midIndex] == target)\n        {\n            return midIndex;\n        }\n        else if(numberList[midIndex] < target)\n        {\n            leftIndex= midIndex + 1;\n        }\n        else\n        {\n            rightIndex= midIndex - 1;\n        }\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canTransform(string startString, string endString)\n{\n    if(startString.size() != endString.size())\n        return false;\n\n    int startIndex= 0, endIndex= 0;\n    int length= startString.size();\n    while(startIndex < length && endIndex < length)\n    {\n        while(startIndex < length && startString[startIndex] == 'X')\n            startIndex++;\n        while(endIndex < length && endString[endIndex] == 'X')\n            endIndex++;\n\n        if(startIndex < length && endIndex < length && startString[startIndex] != endString[endIndex])\n            return false;\n\n        if((startIndex < length && endIndex < length) && \n           ((startString[startIndex] == 'R' && startIndex > endIndex) || \n            (startString[startIndex] == 'L' && startIndex < endIndex)))\n            return false;\n\n        startIndex++;\n        endIndex++;\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool canTransform(std::string startString, std::string endString)\n{\n    if(startString.size() != endString.size())\n        return false;\n\n    int startIndex= 0, endIndex= 0;\n    int length= startString.size();\n    while(startIndex < length && endIndex < length)\n    {\n        while(startIndex < length && startString[startIndex] == 'X')\n            startIndex++;\n        while(endIndex < length && endString[endIndex] == 'X')\n            endIndex++;\n\n        if(startString[startIndex] != endString[endIndex])\n            return false;\n\n        if((startString[startIndex] == 'R' && startIndex > endIndex) || (startString[startIndex] == 'L' && startIndex < endIndex))\n            return false;\n\n        startIndex++;\n        endIndex++;\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint swim(int gridSize, vector<vector<int>> &elevationGrid)\n{\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n    vector<vector<bool>> visitedCells(gridSize, vector<bool>(gridSize, false));\n\n    priorityQueue.push({elevationGrid[0][0], 0});\n\n    int rowDirections[]= {-1, 0, 1, 0};\n    int colDirections[]= {0, 1, 0, -1};\n\n    while(!priorityQueue.empty())\n    {\n        int currentRow= priorityQueue.top().second / gridSize;\n        int currentCol= priorityQueue.top().second % gridSize;\n        int currentTime= priorityQueue.top().first;\n        priorityQueue.pop();\n\n        if(currentRow == gridSize - 1 && currentCol == gridSize - 1)\n            return currentTime;\n\n        for(int direction= 0; direction < 4; direction++)\n        {\n            int newRow= currentRow + rowDirections[direction];\n            int newCol= currentCol + colDirections[direction];\n            if(0 <= newRow && newRow < gridSize && 0 <= newCol && newCol < gridSize && !visitedCells[newRow][newCol])\n            {\n                visitedCells[newRow][newCol]= true;\n                priorityQueue.push({max(currentTime, elevationGrid[newRow][newCol]), newRow * gridSize + newCol});\n            }\n        }\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> &elevationGrid)\n{\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n    std::vector<std::vector<bool>> visitedCells(gridSize, std::vector<bool>(gridSize, false));\n\n    priorityQueue.push({elevationGrid[0][0], 0});\n\n    int rowDirections[]= {-1, 0, 1, 0};\n    int colDirections[]= {0, 1, 0, -1};\n\n    while(!priorityQueue.empty())\n    {\n        int currentRow= priorityQueue.top().second / gridSize;\n        int currentCol= priorityQueue.top().second % gridSize;\n        int currentTime= priorityQueue.top().first;\n        priorityQueue.pop();\n\n        if(currentRow == gridSize - 1 && currentCol == gridSize - 1)\n            return currentTime;\n\n        for(int direction= 0; direction < 4; direction++)\n        {\n            int newRow= currentRow + rowDirections[direction];\n            int newCol= currentCol + colDirections[direction];\n            if(0 <= newRow && newRow < gridSize && 0 <= newCol && newCol < gridSize && !visitedCells[newRow][newCol])\n            {\n                visitedCells[newRow][newCol]= true;\n                priorityQueue.push({std::max(currentTime, elevationGrid[newRow][newCol]), newRow * gridSize + newCol});\n            }\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int findKthSymbolInGrammar(int row, int position)\n{\n    if(row == 1)\n        return 0;\n    if(position % 2 == 0)\n        return 1 - findKthSymbolInGrammar(row - 1, position / 2);\n    else\n        return findKthSymbolInGrammar(row - 1, (position + 1) / 2);\n}",
    "output": "int findKthSymbolInGrammar(int row, int position)\n{\n    if(row == 1)\n        return 0;\n    if(position % 2 == 0)\n        return 1 - findKthSymbolInGrammar(row - 1, position / 2);\n    else\n        return findKthSymbolInGrammar(row - 1, (position + 1) / 2);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "bool canTransform(int startX, int startY, int targetX, int targetY)\n{\n    while(startX != targetX || startY != targetY)\n    {\n        if(startX > targetX || startY > targetY)\n            return false;\n        if(startX < targetX)\n        {\n            targetX-= targetY;\n        }\n        else\n        {\n            targetY-= startX;\n        }\n    }\n    return true;\n}",
    "output": "bool canTransform(int startX, int startY, int targetX, int targetY)\n{\n    while(startX != targetX || startY != targetY)\n    {\n        if(startX > targetX || startY > targetY)\n            return false;\n        if(startX < targetX)\n        {\n            targetX-= targetY;\n        }\n        else\n        {\n            targetY-= startX;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numRabbits(vector<int> &rabbitAnswers)\n{\n    unordered_map<int, int> rabbitCount;\n    int totalRabbits = 0;\n    for (int i = 0; i < rabbitAnswers.size(); ++i)\n    {\n        int answer = rabbitAnswers[i];\n        ++rabbitCount[answer];\n        if (rabbitCount[answer] == 1)\n        {\n            totalRabbits += (answer + 1);\n        }\n        else if (rabbitCount[answer] > answer + 1)\n        {\n            rabbitCount[answer] = 1;\n            totalRabbits += (answer + 1);\n        }\n    }\n    return totalRabbits;\n}",
    "output": "#include <bits/stdc++.h>\nint numRabbits(std::vector<int> &rabbitAnswers)\n{\n    std::unordered_map<int, int> rabbitCount;\n    int totalRabbits = 0;\n    for(int answer : rabbitAnswers)\n    {\n        ++rabbitCount[answer];\n        if(rabbitCount[answer] == 1)\n        {\n            totalRabbits += (answer + 1);\n        }\n        else if(rabbitCount[answer] > answer + 1)\n        {\n            rabbitCount[answer] = 1;\n            totalRabbits += (answer + 1);\n        }\n    }\n    return totalRabbits;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint movesToChessboard(vector<vector<int>> &chessboard)\n{\n    int boardSize = chessboard.size();\n    bitset<30> rowBitset, colBitset;\n\n    for(int rowIndex = 0; rowIndex < boardSize; ++rowIndex)\n        for(int colIndex = 0; colIndex < boardSize; ++colIndex)\n            if(chessboard[0][0] ^ chessboard[rowIndex][0] ^ chessboard[0][colIndex] ^ chessboard[rowIndex][colIndex])\n                return -1;\n\n    for(int index = 0; index < boardSize; ++index)\n    {\n        rowBitset.flip(index);\n        colBitset.flip(index);\n    }\n\n    int countRow = (chessboard[0] & colBitset).count();\n    int countCol = rowBitset.count() - (rowBitset & colBitset).count();\n    int maxCount = max(countRow, countCol);\n\n    if(maxCount == boardSize)\n        return 0;\n\n    if(boardSize & 1)\n        return maxCount & 1 ? maxCount / 2 : maxCount / 2 + 1;\n    else\n        return maxCount / 2;\n}",
    "output": "#include <bits/stdc++.h>\nint movesToChessboard(std::vector<std::vector<int>> &chessboard)\n{\n    int boardSize= chessboard.size();\n    std::bitset<30> rowBitset, colBitset;\n\n    for(int rowIndex= 0; rowIndex < boardSize; ++rowIndex)\n        for(int colIndex= 0; colIndex < boardSize; ++colIndex)\n            if(chessboard[0][0] ^ chessboard[rowIndex][0] ^ chessboard[0][colIndex] ^ chessboard[rowIndex][colIndex])\n                return -1;\n\n    for(int index= 0; index < boardSize; ++index)\n    {\n        rowBitset.flip(index);\n        colBitset.flip(index);\n    }\n\n    int countRow= (chessboard[0] & colBitset).count();\n    int countCol= rowBitset.count() - (rowBitset & colBitset).count();\n    int maxCount= max(countRow, countCol);\n\n    if(maxCount == boardSize)\n        return 0;\n\n    if(boardSize & 1)\n        return maxCount & 1 ? maxCount / 2 : maxCount / 2 + 1;\n    else\n        return maxCount / 2;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nclass Solution\n{\n    int minimumDifference = numeric_limits<int>::max();\n    TreeNode *previousNode = NULL;\n\n  public:\n    int minDiffInBST(TreeNode *rootNode)\n    {\n        inOrderTraversal(rootNode);\n        return minimumDifference;\n    }\n\n    void inOrderTraversal(TreeNode *currentNode)\n    {\n        if (!currentNode)\n            return;\n        inOrderTraversal(currentNode->leftChild);\n        if (previousNode)\n        {\n            minimumDifference = min(minimumDifference, currentNode->value - previousNode->value);\n        }\n        previousNode = currentNode;\n        inOrderTraversal(currentNode->rightChild);\n    }\n};",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nclass Solution\n{\n    int minimumDifference= std::numeric_limits<int>::max();\n    TreeNode *previousNode= NULL;\n\n  public:\n    int minDiffInBST(TreeNode *rootNode)\n    {\n        inOrderTraversal(rootNode);\n        return minimumDifference;\n    }\n\n    void inOrderTraversal(TreeNode *currentNode)\n    {\n        if(!currentNode)\n            return;\n        inOrderTraversal(currentNode->leftChild);\n        if(previousNode)\n        {\n            minimumDifference= std::min(minimumDifference, currentNode->value - previousNode->value);\n        }\n        previousNode= currentNode;\n        inOrderTraversal(currentNode->rightChild);\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid backtrack(string inputString, int currentIndex, vector<string> &permutations)\n{\n    if(currentIndex == inputString.length())\n    {\n        permutations.push_back(inputString);\n        return;\n    }\n    backtrack(inputString, currentIndex + 1, permutations);\n    if(isalpha(inputString[currentIndex]))\n    {\n        inputString[currentIndex]^= (1 << 5);\n        backtrack(inputString, currentIndex + 1, permutations);\n    }\n}\n\nvector<string> letterCasePermutation(string inputString)\n{\n    vector<string> permutations;\n    backtrack(inputString, 0, permutations);\n    return permutations;\n}",
    "output": "#include <bits/stdc++.h>\nvoid backtrack(std::string inputString, int currentIndex, std::vector<std::string> &permutations)\n{\n    if(currentIndex == inputString.length())\n    {\n        permutations.push_back(inputString);\n        return;\n    }\n    backtrack(inputString, currentIndex + 1, permutations);\n    if(isalpha(inputString[currentIndex]))\n    {\n        inputString[currentIndex]^= (1 << 5);\n        backtrack(inputString, currentIndex + 1, permutations);\n    }\n}\n\nstd::vector<std::string> letterCasePermutation(std::string inputString)\n{\n    std::vector<std::string> permutations;\n    backtrack(inputString, 0, permutations);\n    return permutations;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isBipartite(vector<vector<int>> &graph)\n{\n    vector<int> colorAssignments(graph.size(), 0);\n    for(int vertex = 0; vertex < graph.size(); vertex++)\n    {\n        if(colorAssignments[vertex] != 0)\n            continue;\n        colorAssignments[vertex] = 1;\n        queue<int> vertexQueue;\n        vertexQueue.push(vertex);\n        while(!vertexQueue.empty())\n        {\n            int currentNode = vertexQueue.front();\n            vertexQueue.pop();\n            for(int j = 0; j < graph[currentNode].size(); ++j)\n            {\n                int neighbor = graph[currentNode][j];\n                if(colorAssignments[neighbor] == 0)\n                {\n                    colorAssignments[neighbor] = -colorAssignments[currentNode];\n                    vertexQueue.push(neighbor);\n                }\n                else if(colorAssignments[neighbor] == colorAssignments[currentNode])\n                {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isBipartite(std::vector<std::vector<int>> &graph)\n{\n    std::vector<int> colorAssignments(graph.size(), 0);\n    for(int vertex= 0; vertex < graph.size(); vertex++)\n    {\n        if(colorAssignments[vertex] != 0)\n            continue;\n        colorAssignments[vertex]= 1;\n        std::queue<int> vertexQueue;\n        vertexQueue.push(vertex);\n        while(!vertexQueue.empty())\n        {\n            int currentNode= vertexQueue.front();\n            vertexQueue.pop();\n            for(int neighbor : graph[currentNode])\n            {\n                if(colorAssignments[neighbor] == 0)\n                {\n                    colorAssignments[neighbor]= -colorAssignments[currentNode];\n                    vertexQueue.push(neighbor);\n                }\n                else if(colorAssignments[neighbor] == colorAssignments[currentNode])\n                {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> kthSmallestPrimeFraction(vector<int> &primeNumbers, int k)\n{\n    auto compareFractions= [&](const pair<int, int> &a, const pair<int, int> &b)\n    {\n        return (long long)primeNumbers[a.first] * primeNumbers[b.second] > (long long)primeNumbers[a.second] * primeNumbers[b.first];\n    };\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(compareFractions)> fractionQueue(compareFractions);\n\n    for(int index= 0; index < primeNumbers.size() - 1; ++index)\n    {\n        fractionQueue.push({index, primeNumbers.size() - 1});\n    }\n\n    for(int iteration= 1; iteration < k; ++iteration)\n    {\n        auto currentFraction= fractionQueue.top();\n        fractionQueue.pop();\n        currentFraction.second--;\n        if(currentFraction.first < currentFraction.second)\n        {\n            fractionQueue.push(currentFraction);\n        }\n    }\n\n    return {primeNumbers[fractionQueue.top().first], primeNumbers[fractionQueue.top().second]};\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> kthSmallestPrimeFraction(std::vector<int> &primeNumbers, int k)\n{\n    auto compareFractions= [&](const std::pair<int, int> &a, const std::pair<int, int> &b)\n    {\n        return (long long)primeNumbers[a.first] * primeNumbers[b.second] > (long long)primeNumbers[a.second] * primeNumbers[b.first];\n    };\n\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, decltype(compareFractions)> fractionQueue(compareFractions);\n\n    for(int index= 0; index < primeNumbers.size() - 1; ++index)\n    {\n        fractionQueue.push({index, primeNumbers.size() - 1});\n    }\n\n    for(int iteration= 1; iteration < k; ++iteration)\n    {\n        auto currentFraction= fractionQueue.top();\n        fractionQueue.pop();\n        currentFraction.second--;\n        if(currentFraction.first < currentFraction.second)\n        {\n            fractionQueue.push(currentFraction);\n        }\n    }\n\n    return {primeNumbers[fractionQueue.top().first], primeNumbers[fractionQueue.top().second]};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findCheapestPrice(int numberOfCities, vector<vector<int>> &flights, int sourceCity, int destinationCity, int maxStops)\n{\n    vector<vector<pair<int, int>>> flightGraph(numberOfCities);\n    for (const auto &flight : flights)\n        flightGraph[flight[0]].push_back({flight[1], flight[2]});\n\n    priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> priorityQueue;\n    priorityQueue.push({0, sourceCity, maxStops + 1});\n\n    while (!priorityQueue.empty())\n    {\n        auto flightInfo = priorityQueue.top();\n        priorityQueue.pop();\n        int currentPrice = flightInfo[0], currentCity = flightInfo[1], remainingStops = flightInfo[2];\n\n        if (currentCity == destinationCity)\n            return currentPrice;\n\n        if (remainingStops > 0)\n        {\n            for (int i = 0; i < flightGraph[currentCity].size(); ++i)\n            {\n                auto &nextFlight = flightGraph[currentCity][i];\n                priorityQueue.push({currentPrice + nextFlight.second, nextFlight.first, remainingStops - 1});\n            }\n        }\n    }\n\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint findCheapestPrice(int numberOfCities, std::vector<std::vector<int>> &flights, int sourceCity, int destinationCity, int maxStops)\n{\n    std::vector<std::vector<std::pair<int, int>>> flightGraph(numberOfCities);\n    for(auto &flight : flights)\n        flightGraph[flight[0]].push_back({flight[1], flight[2]});\n\n    std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, std::greater<std::vector<int>>> priorityQueue;\n    priorityQueue.push({0, sourceCity, maxStops + 1});\n\n    while(!priorityQueue.empty())\n    {\n        auto flightInfo= priorityQueue.top();\n        priorityQueue.pop();\n        int currentPrice= flightInfo[0], currentCity= flightInfo[1], remainingStops= flightInfo[2];\n\n        if(currentCity == destinationCity)\n            return currentPrice;\n\n        if(remainingStops > 0)\n        {\n            for(auto &nextFlight : flightGraph[currentCity])\n                priorityQueue.push({currentPrice + nextFlight.second, nextFlight.first, remainingStops - 1});\n        }\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int countRotatedDigits(int maxNumber)\n{\n    int validRotatedCount= 0;\n    for(int currentNumber= 1; currentNumber <= maxNumber; ++currentNumber)\n    {\n        bool isValidAfterRotation= true;\n        bool isDifferentAfterRotation= false;\n        int number= currentNumber;\n        while(number != 0)\n        {\n            int digit= number % 10;\n            if(digit == 3 || digit == 4 || digit == 7)\n            {\n                isValidAfterRotation= false;\n                break;\n            }\n            if(digit == 2 || digit == 5 || digit == 6 || digit == 9)\n            {\n                isDifferentAfterRotation= true;\n            }\n            number/= 10;\n        }\n        if(isValidAfterRotation && isDifferentAfterRotation)\n        {\n            validRotatedCount++;\n        }\n    }\n    return validRotatedCount;\n}",
    "output": "int countRotatedDigits(int maxNumber)\n{\n    int validRotatedCount= 0;\n    for(int currentNumber= 1; currentNumber <= maxNumber; ++currentNumber)\n    {\n        bool isValidAfterRotation= true;\n        bool isDifferentAfterRotation= false;\n        int number= currentNumber;\n        while(number != 0)\n        {\n            int digit= number % 10;\n            if(digit == 3 || digit == 4 || digit == 7)\n            {\n                isValidAfterRotation= false;\n                break;\n            }\n            if(digit == 2 || digit == 5 || digit == 6 || digit == 9)\n            {\n                isDifferentAfterRotation= true;\n            }\n            number/= 10;\n        }\n        if(isValidAfterRotation && isDifferentAfterRotation)\n        {\n            validRotatedCount++;\n        }\n    }\n    return validRotatedCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool escapeGhosts(vector<vector<int>> &ghostPositions, vector<int> &targetPosition)\n{\n    int maxDistance = abs(targetPosition[0]) + abs(targetPosition[1]);\n    for (int i = 0; i < ghostPositions.size(); ++i)\n    {\n        const auto &ghost = ghostPositions[i];\n        int ghostDistance = abs(ghost[0] - targetPosition[0]) + abs(ghost[1] - targetPosition[1]);\n        if (ghostDistance <= maxDistance)\n        {\n            return false;\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool escapeGhosts(std::vector<std::vector<int>> &ghostPositions, std::vector<int> &targetPosition)\n{\n    int maxDistance= std::abs(targetPosition[0]) + std::abs(targetPosition[1]);\n    for(const auto &ghost : ghostPositions)\n    {\n        int ghostDistance= std::abs(ghost[0] - targetPosition[0]) + std::abs(ghost[1] - targetPosition[1]);\n        if(ghostDistance <= maxDistance)\n        {\n            return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numberOfWays(int totalSteps)\n{\n    int modulus= 1000000007;\n    vector<int> ways(totalSteps + 1, 0);\n    ways[0]= 1;\n    ways[1]= 1;\n\n    for(int step= 2; step <= totalSteps; ++step)\n        ways[step]= (ways[step - 1] + ways[step - 2]) % modulus;\n\n    return ways[totalSteps];\n}",
    "output": "#include <bits/stdc++.h>\nint numberOfWays(int totalSteps)\n{\n    int modulus= 1000000007;\n    std::vector<int> ways(totalSteps + 1, 0);\n    ways[0]= 1;\n    ways[1]= 1;\n\n    for(int step= 2; step <= totalSteps; ++step)\n        ways[step]= (ways[step - 1] + ways[step - 2]) % modulus;\n\n    return ways[totalSteps];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring customSortString(string order, string inputString)\n{\n    sort(inputString.begin(), inputString.end(), [&](char firstChar, char secondChar)\n         { return order.find(firstChar) < order.find(secondChar); });\n    return inputString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string customSortString(std::string order, std::string inputString)\n{\n    std::sort(inputString.begin(), inputString.end(), [&](char firstChar, char secondChar)\n         { return order.find(firstChar) < order.find(secondChar); });\n    return inputString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countMatchingSubsequences(const string &sourceString, const vector<string> &targetWords)\n{\n    vector<vector<int>> characterPositions(26);\n\n    for(int charIndex = 0; charIndex < sourceString.size(); ++charIndex)\n    {\n        characterPositions[sourceString[charIndex] - 'a'].push_back(charIndex);\n    }\n\n    int matchingCount = 0;\n\n    for(int i = 0; i < targetWords.size(); ++i)\n    {\n        const auto &targetWord = targetWords[i];\n        int lastIndex = -1;\n        bool isSubsequence = true;\n\n        for(int j = 0; j < targetWord.size(); ++j)\n        {\n            const char &currentChar = targetWord[j];\n            auto it = upper_bound(characterPositions[currentChar - 'a'].begin(), characterPositions[currentChar - 'a'].end(), lastIndex);\n            if(it == characterPositions[currentChar - 'a'].end())\n            {\n                isSubsequence = false;\n                break;\n            }\n            lastIndex = *it;\n        }\n\n        if(isSubsequence)\n        {\n            ++matchingCount;\n        }\n    }\n\n    return matchingCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countMatchingSubsequences(const std::string &sourceString, const std::vector<std::string> &targetWords)\n{\n    std::vector<std::vector<int>> characterPositions(26);\n\n    for(int charIndex= 0; charIndex < sourceString.size(); ++charIndex)\n    {\n        characterPositions[sourceString[charIndex] - 'a'].push_back(charIndex);\n    }\n\n    int matchingCount= 0;\n\n    for(const auto &targetWord : targetWords)\n    {\n        int lastIndex= -1;\n        bool isSubsequence= true;\n\n        for(const char &currentChar : targetWord)\n        {\n            auto it= std::upper_bound(characterPositions[currentChar - 'a'].begin(), characterPositions[currentChar - 'a'].end(), lastIndex);\n            if(it == characterPositions[currentChar - 'a'].end())\n            {\n                isSubsequence= false;\n                break;\n            }\n            lastIndex= *it;\n        }\n\n        if(isSubsequence)\n        {\n            ++matchingCount;\n        }\n    }\n\n    return matchingCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int countTrailingZeros(int number)\n{\n    int zeroCount= 0;\n    for(int divisor= 5; number / divisor >= 1; divisor*= 5)\n    {\n        zeroCount+= number / divisor;\n    }\n    return zeroCount;\n}",
    "output": "int countTrailingZeros(int number)\n{\n    int zeroCount= 0;\n    for(int divisor= 5; number / divisor >= 1; divisor*= 5)\n    {\n        zeroCount+= number / divisor;\n    }\n    return zeroCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidTicTacToe(vector<string> &gameBoard)\n{\n    int xCount = 0, oCount = 0;\n    for (int i = 0; i < gameBoard.size(); ++i) // Modified to traditional for loop\n    {\n        const string &row = gameBoard[i];\n        for (int j = 0; j < row.size(); ++j) // Modified to traditional for loop\n        {\n            char cell = row[j];\n            if (cell == 'X')\n                xCount++;\n            else if (cell == 'O')\n                oCount++;\n        }\n    }\n    if (xCount != oCount && xCount != oCount + 1)\n        return false;\n\n    bool isXWin = false, isOWin = false;\n    for (int i = 0; i < 3; ++i)\n    {\n        if (gameBoard[i][0] == gameBoard[i][1] && gameBoard[i][1] == gameBoard[i][2])\n            gameBoard[i][0] == 'X' ? isXWin = true : (gameBoard[i][0] == 'O' ? isOWin = true : 0);\n        if (gameBoard[0][i] == gameBoard[1][i] && gameBoard[1][i] == gameBoard[2][i])\n            gameBoard[0][i] == 'X' ? isXWin = true : (gameBoard[0][i] == 'O' ? isOWin = true : 0);\n    }\n    if (gameBoard[0][0] == gameBoard[1][1] && gameBoard[1][1] == gameBoard[2][2])\n        gameBoard[0][0] == 'X' ? isXWin = true : (gameBoard[0][0] == 'O' ? isOWin = true : 0);\n    if (gameBoard[0][2] == gameBoard[1][1] && gameBoard[1][1] == gameBoard[2][0])\n        gameBoard[0][2] == 'X' ? isXWin = true : (gameBoard[0][2] == 'O' ? isOWin = true : 0);\n\n    if (isXWin && isOWin)\n        return false;\n    if (isXWin && xCount == oCount)\n        return false;\n    if (isOWin && xCount > oCount)\n        return false;\n\n    return true;\n}",
    "output": "bool isValidTicTacToe(std::vector<std::string> &gameBoard)\n{\n    int xCount= 0, oCount= 0;\n    for(const std::string &row : gameBoard)\n    {\n        for(char cell : row)\n        {\n            if(cell == 'X')\n                xCount++;\n            else if(cell == 'O')\n                oCount++;\n        }\n    }\n    if(xCount != oCount && xCount != oCount + 1)\n        return false;\n\n    bool isXWin= false, isOWin= false;\n    for(int i= 0; i < 3; ++i)\n    {\n        if(gameBoard[i][0] == gameBoard[i][1] && gameBoard[i][1] == gameBoard[i][2])\n            gameBoard[i][0] == 'X' ? isXWin= true : (gameBoard[i][0] == 'O' ? isOWin= true : 0);\n        if(gameBoard[0][i] == gameBoard[1][i] && gameBoard[1][i] == gameBoard[2][i])\n            gameBoard[0][i] == 'X' ? isXWin= true : (gameBoard[0][i] == 'O' ? isOWin= true : 0);\n    }\n    if(gameBoard[0][0] == gameBoard[1][1] && gameBoard[1][1] == gameBoard[2][2])\n        gameBoard[0][0] == 'X' ? isXWin= true : (gameBoard[0][0] == 'O' ? isOWin= true : 0);\n    if(gameBoard[0][2] == gameBoard[1][1] && gameBoard[1][1] == gameBoard[2][0])\n        gameBoard[0][2] == 'X' ? isXWin= true : (gameBoard[0][2] == 'O' ? isOWin= true : 0);\n\n    if(isXWin && isOWin)\n        return false;\n    if(isXWin && xCount == oCount)\n        return false;\n    if(isOWin && xCount > oCount)\n        return false;\n\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countSubarraysWithBoundedMax(vector<int> &array, int lowerBound, int upperBound)\n{\n    int totalCount= 0, previousCount= 0, lastInvalidIndex= -1;\n    for(int currentIndex= 0; currentIndex < array.size(); ++currentIndex)\n    {\n        if(array[currentIndex] >= lowerBound && array[currentIndex] <= upperBound)\n        {\n            previousCount= currentIndex - lastInvalidIndex;\n            totalCount+= previousCount;\n        }\n        else if(array[currentIndex] < lowerBound)\n        {\n            totalCount+= previousCount;\n        }\n        else\n        {\n            lastInvalidIndex= currentIndex;\n            previousCount= 0;\n        }\n    }\n    return totalCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countSubarraysWithBoundedMax(std::vector<int> &array, int lowerBound, int upperBound)\n{\n    int totalCount= 0, previousCount= 0, lastInvalidIndex= -1;\n    for(int currentIndex= 0; currentIndex < array.size(); ++currentIndex)\n    {\n        if(array[currentIndex] >= lowerBound && array[currentIndex] <= upperBound)\n        {\n            previousCount= currentIndex - lastInvalidIndex;\n            totalCount+= previousCount;\n        }\n        else if(array[currentIndex] < lowerBound)\n        {\n            totalCount+= previousCount;\n        }\n        else\n        {\n            lastInvalidIndex= currentIndex;\n            previousCount= 0;\n        }\n    }\n    return totalCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isShifted(string sourceString, string goalString)\n{\n    if(sourceString.length() != goalString.length())\n        return false;\n\n    sourceString= sourceString + sourceString;\n    return sourceString.find(goalString) != string::npos;\n}",
    "output": "#include <bits/stdc++.h>\nbool isShifted(std::string sourceString, std::string goalString)\n{\n    if(sourceString.length() != goalString.length())\n        return false;\n\n    sourceString= sourceString + sourceString;\n    return sourceString.find(goalString) != std::string::npos;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(vector<vector<int>> &graph, vector<vector<int>> &allPaths, vector<int> &currentPath, int currentNode)\n{\n    currentPath.push_back(currentNode);\n    if(currentNode == graph.size() - 1)\n    {\n        allPaths.push_back(currentPath);\n    }\n    else\n    {\n        for(int i = 0; i < graph[currentNode].size(); ++i)\n        {\n            int neighbor = graph[currentNode][i];\n            depthFirstSearch(graph, allPaths, currentPath, neighbor);\n        }\n    }\n    currentPath.pop_back();\n}\n\nvector<vector<int>> allPathsFromSourceToTarget(vector<vector<int>> &graph)\n{\n    vector<vector<int>> allPaths;\n    vector<int> currentPath;\n    depthFirstSearch(graph, allPaths, currentPath, 0);\n    return allPaths;\n}",
    "output": "#include <bits/stdc++.h>\nvoid depthFirstSearch(std::vector<std::vector<int>> &graph, std::vector<std::vector<int>> &allPaths, std::vector<int> &currentPath, int currentNode)\n{\n    currentPath.push_back(currentNode);\n    if(currentNode == graph.size() - 1)\n    {\n        allPaths.push_back(currentPath);\n    }\n    else\n    {\n        for(int neighbor : graph[currentNode])\n        {\n            depthFirstSearch(graph, allPaths, currentPath, neighbor);\n        }\n    }\n    currentPath.pop_back();\n}\n\nstd::vector<std::vector<int>> allPathsFromSourceToTarget(std::vector<std::vector<int>> &graph)\n{\n    std::vector<std::vector<int>> allPaths;\n    std::vector<int> currentPath;\n    depthFirstSearch(graph, allPaths, currentPath, 0);\n    return allPaths;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint bestRotation(vector<int> &rotations)\n{\n    int size = rotations.size();\n    vector<int> scoreChange(size, 0);\n\n    for(int index = 0; index < size; ++index)\n    {\n        scoreChange[(index - rotations[index] + 1 + size) % size] -= 1;\n        scoreChange[(index + 1) % size] += 1;\n    }\n\n    int maxScore = 0;\n    for(int index = 1, currentScore = scoreChange[0]; index < size; ++index)\n    {\n        currentScore += scoreChange[index];\n        if(currentScore > maxScore)\n        {\n            maxScore = currentScore;\n        }\n    }\n    return maxScore;\n}",
    "output": "#include <bits/stdc++.h>\nint bestRotation(std::vector<int> &rotations)\n{\n    int size= rotations.size();\n    std::vector<int> scoreChange(size, 0);\n\n    for(int index= 0; index < size; ++index)\n    {\n        scoreChange[(index - rotations[index] + 1 + size) % size]-= 1;\n        scoreChange[(index + 1) % size]+= 1;\n    }\n\n    int maxScore= 0;\n    for(int index= 1, currentScore= scoreChange[0]; index < size; ++index)\n    {\n        currentScore+= scoreChange[index];\n        if(currentScore > maxScore)\n        {\n            maxScore= currentScore;\n        }\n    }\n    return maxScore;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numBusesToDestination(vector<vector<int>> &busRoutes, int source, int target)\n{\n    if(source == target)\n        return 0;\n\n    unordered_map<int, unordered_set<int>> stopRouteMap;\n    for(int routeIndex = 0; routeIndex < busRoutes.size(); ++routeIndex)\n    {\n        for(int j = 0; j < busRoutes[routeIndex].size(); ++j)\n        {\n            int stop = busRoutes[routeIndex][j];\n            stopRouteMap[stop].insert(routeIndex);\n        }\n    }\n\n    queue<int> stopQueue;\n    unordered_set<int> visitedStops;\n\n    stopQueue.push(source);\n    visitedStops.insert(source);\n    int transfers = 0;\n\n    while(!stopQueue.empty())\n    {\n        int size = stopQueue.size();\n        while(size--)\n        {\n            int currentStop = stopQueue.front();\n            stopQueue.pop();\n            if(currentStop == target)\n                return transfers;\n\n            for(int route : stopRouteMap[currentStop])\n            {\n                for(int j = 0; j < busRoutes[route].size(); ++j)\n                {\n                    int stop = busRoutes[route][j];\n                    if(visitedStops.count(stop) == 0)\n                    {\n                        stopQueue.push(stop);\n                        visitedStops.insert(stop);\n                    }\n                }\n                stopRouteMap[currentStop].erase(route);\n            }\n        }\n        transfers++;\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint numBusesToDestination(std::vector<std::vector<int>> &busRoutes, int source, int target)\n{\n    if(source == target)\n        return 0;\n\n    std::unordered_map<int, std::unordered_set<int>> stopRouteMap;\n    for(int routeIndex= 0; routeIndex < busRoutes.size(); ++routeIndex)\n    {\n        for(int stop : busRoutes[routeIndex])\n        {\n            stopRouteMap[stop].insert(routeIndex);\n        }\n    }\n\n    std::queue<int> stopQueue;\n    std::unordered_set<int> visitedStops;\n\n    stopQueue.push(source);\n    visitedStops.insert(source);\n    int transfers= 0;\n\n    while(!stopQueue.empty())\n    {\n        int size= stopQueue.size();\n        while(size--)\n        {\n            int currentStop= stopQueue.front();\n            stopQueue.pop();\n            if(currentStop == target)\n                return transfers;\n\n            for(int route : stopRouteMap[currentStop])\n            {\n                for(int stop : busRoutes[route])\n                {\n                    if(visitedStops.count(stop) == 0)\n                    {\n                        stopQueue.push(stop);\n                        visitedStops.insert(stop);\n                    }\n                }\n                stopRouteMap[currentStop].erase(route);\n            }\n        }\n        transfers++;\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass MyHashSet\n{\n  public:\n    vector<bool> storage;\n\n    MyHashSet()\n    {\n        storage.resize(1000001, false);\n    }\n\n    void add(int key)\n    {\n        storage[key]= true;\n    }\n\n    void remove(int key)\n    {\n        storage[key]= false;\n    }\n\n    bool contains(int key)\n    {\n        return storage[key];\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass MyHashSet\n{\n  public:\n    std::vector<bool> storage;\n\n    MyHashSet()\n    {\n        storage.resize(1000001, false);\n    }\n\n    void add(int key)\n    {\n        storage[key]= true;\n    }\n\n    void remove(int key)\n    {\n        storage[key]= false;\n    }\n\n    bool contains(int key)\n    {\n        return storage[key];\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass MyHashMap\n{\n  public:\n    vector<int> keyValuePairs;\n    MyHashMap()\n    {\n        keyValuePairs = vector<int>(1000001, -1);\n    }\n\n    void put(int key, int value)\n    {\n        keyValuePairs[key] = value;\n    }\n\n    int get(int key)\n    {\n        return keyValuePairs[key];\n    }\n\n    void remove(int key)\n    {\n        keyValuePairs[key] = -1;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass MyHashMap\n{\n  public:\n    std::vector<int> keyValuePairs;\n    MyHashMap()\n    {\n        keyValuePairs= std::vector<int>(1000001, -1);\n    }\n\n    void put(int key, int value)\n    {\n        keyValuePairs[key]= value;\n    }\n\n    int get(int key)\n    {\n        return keyValuePairs[key];\n    }\n\n    void remove(int key)\n    {\n        keyValuePairs[key]= -1;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint racecar(int target)\n{\n    unordered_map<int, unordered_map<int, int>> memoization;\n    function<int(int, int)> dynamicProgramming= [&](int position, int speed)\n    {\n        if(abs(position) > 2 * target)\n            return target + 1;\n        if(position == target)\n            return speed == 1 ? 0 : 1;\n        if(memoization[position][speed])\n            return memoization[position][speed];\n        int result= (speed > 0 ? dynamicProgramming(position + speed / 2, -speed / 2) : dynamicProgramming(position - speed / 2, -speed / 2)) + 1;\n        result= min(result, dynamicProgramming(position + speed, speed * 2) + 1);\n        return memoization[position][speed]= result;\n    };\n    return dynamicProgramming(0, 1);\n}",
    "output": "#include <bits/stdc++.h>\nint racecar(int target)\n{\n    std::unordered_map<int, std::unordered_map<int, int>> memoization;\n    std::function<int(int, int)> dynamicProgramming= [&](int position, int speed)\n    {\n        if(std::abs(position) > 2 * target)\n            return target + 1;\n        if(position == target)\n            return speed == 1 ? 0 : 1;\n        if(memoization[position][speed])\n            return memoization[position][speed];\n        int result= (speed > 0 ? dynamicProgramming(position + speed / 2, -speed / 2) : dynamicProgramming(position - speed / 2, -speed / 2)) + 1;\n        result= std::min(result, dynamicProgramming(position + speed, speed * 2) + 1);\n        return memoization[position][speed]= result;\n    };\n    return dynamicProgramming(0, 1);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minSwaps(vector<int> &firstArray, vector<int> &secondArray)\n{\n    int arraySize= firstArray.size();\n    vector<int> noSwap(arraySize, INT_MAX);\n    vector<int> doSwap(arraySize, INT_MAX);\n    noSwap[0]= 0;\n    doSwap[0]= 1;\n\n    for(int index= 1; index < arraySize; index++)\n    {\n        if(firstArray[index] > firstArray[index - 1] && secondArray[index] > secondArray[index - 1])\n        {\n            noSwap[index]= noSwap[index - 1];\n            doSwap[index]= doSwap[index - 1] + 1;\n        }\n        if(firstArray[index] > secondArray[index - 1] && secondArray[index] > firstArray[index - 1])\n        {\n            noSwap[index]= min(noSwap[index], doSwap[index - 1]);\n            doSwap[index]= min(doSwap[index], noSwap[index - 1] + 1);\n        }\n    }\n\n    return min(noSwap[arraySize - 1], doSwap[arraySize - 1]);\n}",
    "output": "#include <bits/stdc++.h>\nint minSwaps(std::vector<int> &firstArray, std::vector<int> &secondArray)\n{\n    int arraySize = firstArray.size();\n    std::vector<int> noSwap(arraySize, INT_MAX);\n    std::vector<int> doSwap(arraySize, INT_MAX);\n    noSwap[0] = 0;\n    doSwap[0] = 1;\n\n    for(int index = 1; index < arraySize; index++)\n    {\n        if(firstArray[index] > firstArray[index - 1] && secondArray[index] > secondArray[index - 1])\n        {\n            noSwap[index] = noSwap[index - 1];\n            doSwap[index] = doSwap[index - 1] + 1;\n        }\n        if(firstArray[index] > secondArray[index - 1] && secondArray[index] > firstArray[index - 1])\n        {\n            noSwap[index] = std::min(noSwap[index], doSwap[index - 1]);\n            doSwap[index] = std::min(doSwap[index], noSwap[index - 1] + 1);\n        }\n    }\n\n    return std::min(noSwap[arraySize - 1], doSwap[arraySize - 1]);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findEventualSafeNodes(vector<vector<int>> &graph)\n{\n    int nodeCount = graph.size();\n    vector<int> nodeColor(nodeCount, 0);\n    vector<int> safeNodes;\n\n    bool hasCycle(int currentNode, vector<int> &nodeColor, vector<vector<int>> &graph)\n    {\n        if(nodeColor[currentNode] > 0)\n            return nodeColor[currentNode] == 1;\n        nodeColor[currentNode] = 1;\n        for(int j = 0; j < graph[currentNode].size(); ++j)\n        {\n            int neighbor = graph[currentNode][j];\n            if(hasCycle(neighbor, nodeColor, graph))\n                return true;\n        }\n        nodeColor[currentNode] = 2;\n        return false;\n    }\n\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        if(!hasCycle(i, nodeColor, graph))\n            safeNodes.push_back(i);\n    }\n    return safeNodes;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findEventualSafeNodes(std::vector<std::vector<int>> &graph)\n{\n    int nodeCount= graph.size();\n    std::vector<int> nodeColor(nodeCount, 0);\n    std::vector<int> safeNodes;\n\n    bool hasCycle(int currentNode, std::vector<int> &nodeColor, std::vector<std::vector<int>> &graph)\n    {\n        if(nodeColor[currentNode] > 0)\n            return nodeColor[currentNode] == 1;\n        nodeColor[currentNode]= 1;\n        for(int neighbor : graph[currentNode])\n        {\n            if(hasCycle(neighbor, nodeColor, graph))\n                return true;\n        }\n        nodeColor[currentNode]= 2;\n        return false;\n    }\n\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        if(!hasCycle(i, nodeColor, graph))\n            safeNodes.push_back(i);\n    }\n    return safeNodes;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> hitBricks(vector<vector<int>> &grid, vector<vector<int>> &hits)\n{\n    const int rows = grid.size(), columns = grid[0].size();\n    vector<int> result;\n    vector<vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    for (int i = 0; i < hits.size(); ++i)\n    {\n        const auto &hit = hits[i];\n        grid[hit[0]][hit[1]]--;\n    }\n\n    function<int(int, int)> depthFirstSearch = [&](int x, int y)\n    {\n        if (x < 0 || x >= rows || y < 0 || y >= columns || grid[x][y] <= 0)\n        {\n            return 0;\n        }\n        grid[x][y] = -1;\n        int sum = 1;\n        for (const auto &direction : directions)\n        {\n            sum += depthFirstSearch(x + direction[0], y + direction[1]);\n        }\n        return sum;\n    };\n\n    for (int column = 0; column < columns; ++column)\n    {\n        if (grid[0][column] == 1)\n        {\n            depthFirstSearch(0, column);\n        }\n    }\n\n    for (int i = 0; i < hits.size(); ++i)\n    {\n        const auto &hit = hits[i];\n        grid[hit[0]][hit[1]]++;\n        if (grid[hit[0]][hit[1]] != 1)\n        {\n            result.push_back(0);\n            continue;\n        }\n        for (int j = 0; j < directions.size(); ++j)\n        {\n            const auto &direction = directions[j];\n            if (depthFirstSearch(hit[0] + direction[0], hit[1] + direction[1]))\n            {\n                result.push_back(depthFirstSearch(hit[0], hit[1]) - 1);\n                break;\n            }\n        }\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> hitBricks(std::vector<std::vector<int>> &grid, std::vector<std::vector<int>> &hits)\n{\n    const int rows= grid.size(), columns= grid[0].size();\n    std::vector<int> result;\n    std::vector<std::vector<int>> directions= {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    for(const auto &hit : hits)\n    {\n        grid[hit[0]][hit[1]]--;\n    }\n\n    function<int(int, int)> depthFirstSearch= [&](int x, int y)\n    {\n        if(x < 0 || x >= rows || y < 0 || y >= columns || grid[x][y] <= 0)\n        {\n            return 0;\n        }\n        grid[x][y]= -1;\n        int sum= 1;\n        for(const auto &direction : directions)\n        {\n            sum+= depthFirstSearch(x + direction[0], y + direction[1]);\n        }\n        return sum;\n    };\n\n    for(int column= 0; column < columns; ++column)\n    {\n        if(grid[0][column] == 1)\n        {\n            depthFirstSearch(0, column);\n        }\n    }\n\n    for(const auto &hit : hits)\n    {\n        grid[hit[0]][hit[1]]++;\n        if(grid[hit[0]][hit[1]] != 1)\n        {\n            result.push_back(0);\n            continue;\n        }\n        for(const auto &direction : directions)\n        {\n            if(depthFirstSearch(hit[0] + direction[0], hit[1] + direction[1]))\n            {\n                result.push_back(depthFirstSearch(hit[0], hit[1]) - 1);\n                break;\n            }\n        }\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint uniqueMorseRepresentations(vector<string> &words)\n{\n    vector<string> morseCodes = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\n    unordered_set<string> uniqueTransformations;\n\n    for (int i = 0; i < words.size(); ++i)\n    {\n        const auto &word = words[i];\n        string morseCode;\n        for (int j = 0; j < word.size(); ++j)\n        {\n            char character = word[j];\n            morseCode += morseCodes[character - 'a'];\n        }\n        uniqueTransformations.insert(morseCode);\n    }\n\n    return uniqueTransformations.size();\n}",
    "output": "#include <bits/stdc++.h>\nint uniqueMorseRepresentations(std::vector<std::string> &words)\n{\n    std::vector<std::string> morseCodes= {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\n    std::unordered_set<std::string> uniqueTransformations;\n\n    for(const auto &word : words)\n    {\n        std::string morseCode;\n        for(char character : word)\n        {\n            morseCode+= morseCodes[character - 'a'];\n        }\n        uniqueTransformations.insert(morseCode);\n    }\n\n    return uniqueTransformations.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPossibleToSplit(const vector<int> &numbers)\n{\n    int numberCount = numbers.size();\n    int totalSum = accumulate(numbers.begin(), numbers.end(), 0);\n\n    if (totalSum % numberCount != 0)\n        return false;\n\n    int targetSum = totalSum * (numberCount / 2) / numberCount;\n    vector<vector<bool>> dynamicProgramming(numberCount / 2 + 1, vector<bool>(targetSum + 1, false));\n    dynamicProgramming[0][0] = true;\n\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        for (int count = numberCount / 2; count >= 1; --count)\n        {\n            for (int sum = targetSum; sum >= currentNumber; --sum)\n            {\n                dynamicProgramming[count][sum] = dynamicProgramming[count][sum] || dynamicProgramming[count - 1][sum - currentNumber];\n            }\n        }\n        if (dynamicProgramming[numberCount / 2][targetSum])\n            return true;\n    }\n\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool isPossibleToSplit(const std::vector<int> &numbers)\n{\n    int numberCount= numbers.size();\n    int totalSum= std::accumulate(numbers.begin(), numbers.end(), 0);\n\n    if(totalSum % numberCount != 0)\n        return false;\n\n    int targetSum= totalSum * (numberCount / 2) / numberCount;\n    std::vector<std::vector<bool>> dynamicProgramming(numberCount / 2 + 1, std::vector<bool>(targetSum + 1, false));\n    dynamicProgramming[0][0]= true;\n\n    for(int currentNumber : numbers)\n    {\n        for(int count= numberCount / 2; count >= 1; --count)\n        {\n            for(int sum= targetSum; sum >= currentNumber; --sum)\n            {\n                dynamicProgramming[count][sum]= dynamicProgramming[count][sum] || dynamicProgramming[count - 1][sum - currentNumber];\n            }\n        }\n        if(dynamicProgramming[numberCount / 2][targetSum])\n            return true;\n    }\n\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> numberOfLines(vector<int> &characterWidths, string inputString)\n{\n    int totalLines = 1;\n    int currentPixelCount = 0;\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char character = inputString[i];\n        int letterPixelWidth = characterWidths[character - 'a'];\n        if (currentPixelCount + letterPixelWidth > 100)\n        {\n            totalLines++;\n            currentPixelCount = 0;\n        }\n        currentPixelCount += letterPixelWidth;\n    }\n    return {totalLines, currentPixelCount};\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> numberOfLines(std::vector<int> &characterWidths, std::string inputString)\n{\n    int totalLines= 1;\n    int currentPixelCount= 0;\n    for(char character : inputString)\n    {\n        int letterPixelWidth= characterWidths[character - 'a'];\n        if(currentPixelCount + letterPixelWidth > 100)\n        {\n            totalLines++;\n            currentPixelCount= 0;\n        }\n        currentPixelCount+= letterPixelWidth;\n    }\n    return {totalLines, currentPixelCount};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxIncreaseKeepingSkyline(vector<vector<int>> &grid)\n{\n    int size= grid.size();\n    vector<int> rowMax(size, 0);\n    vector<int> colMax(size, 0);\n\n    for(int rowIndex= 0; rowIndex < size; ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex < size; ++colIndex)\n        {\n            rowMax[rowIndex]= max(rowMax[rowIndex], grid[rowIndex][colIndex]);\n            colMax[colIndex]= max(colMax[colIndex], grid[rowIndex][colIndex]);\n        }\n    }\n\n    int totalSum= 0;\n    for(int rowIndex= 0; rowIndex < size; ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex < size; ++colIndex)\n        {\n            totalSum+= min(rowMax[rowIndex], colMax[colIndex]) - grid[rowIndex][colIndex];\n        }\n    }\n\n    return totalSum;\n}",
    "output": "#include <bits/stdc++.h>\nint maxIncreaseKeepingSkyline(std::vector<std::vector<int>> &grid)\n{\n    int size = grid.size();\n    std::vector<int> rowMax(size, 0);\n    std::vector<int> colMax(size, 0);\n\n    for(int rowIndex = 0; rowIndex < size; ++rowIndex)\n    {\n        for(int colIndex = 0; colIndex < size; ++colIndex)\n        {\n            rowMax[rowIndex] = std::max(rowMax[rowIndex], grid[rowIndex][colIndex]);\n            colMax[colIndex] = std::max(colMax[colIndex], grid[rowIndex][colIndex]);\n        }\n    }\n\n    int totalSum = 0;\n    for(int rowIndex = 0; rowIndex < size; ++rowIndex)\n    {\n        for(int colIndex = 0; colIndex < size; ++colIndex)\n        {\n            totalSum += std::min(rowMax[rowIndex], colMax[colIndex]) - grid[rowIndex][colIndex];\n        }\n    }\n\n    return totalSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxProfitAssignment(vector<int> &jobDifficulty, vector<int> &jobProfit, vector<int> &workerSkill)\n{\n    int jobCount = jobDifficulty.size();\n    vector<pair<int, int>> jobPairs(jobCount);\n\n    for(int jobIndex = 0; jobIndex < jobCount; ++jobIndex)\n    {\n        jobPairs[jobIndex] = {jobDifficulty[jobIndex], jobProfit[jobIndex]};\n    }\n\n    sort(jobPairs.begin(), jobPairs.end());\n    sort(workerSkill.begin(), workerSkill.end());\n\n    int maxProfit = 0;\n    int totalProfit = 0;\n    int jobIndex = 0;\n\n    for(int i = 0; i < workerSkill.size(); ++i)\n    {\n        int worker = workerSkill[i];\n        while(jobIndex < jobCount && worker >= jobPairs[jobIndex].first)\n        {\n            maxProfit = max(maxProfit, jobPairs[jobIndex].second);\n            jobIndex++;\n        }\n        totalProfit += maxProfit;\n    }\n\n    return totalProfit;\n}",
    "output": "#include <bits/stdc++.h>\nint maxProfitAssignment(std::vector<int> &jobDifficulty, std::vector<int> &jobProfit, std::vector<int> &workerSkill)\n{\n    int jobCount= jobDifficulty.size();\n    std::vector<std::pair<int, int>> jobPairs(jobCount);\n\n    for(int jobIndex= 0; jobIndex < jobCount; ++jobIndex)\n    {\n        jobPairs[jobIndex]= {jobDifficulty[jobIndex], jobProfit[jobIndex]};\n    }\n\n    std::sort(jobPairs.begin(), jobPairs.end());\n    std::sort(workerSkill.begin(), workerSkill.end());\n\n    int maxProfit= 0;\n    int totalProfit= 0;\n    int jobIndex= 0;\n\n    for(int worker : workerSkill)\n    {\n        while(jobIndex < jobCount && worker >= jobPairs[jobIndex].first)\n        {\n            maxProfit= std::max(maxProfit, jobPairs[jobIndex].second);\n            jobIndex++;\n        }\n        totalProfit+= maxProfit;\n    }\n\n    return totalProfit;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAreaOfIsland(vector<vector<int>> &grid)\n{\n    function<int(int, int)> dfs= [&](int x, int y)\n    {\n        if(x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] == 0)\n        {\n            return 0;\n        }\n        grid[x][y]= 0;\n        return dfs(x - 1, y) + dfs(x + 1, y) + dfs(x, y - 1) + dfs(x, y + 1) + 1;\n    };\n\n    int maxArea= 0;\n    for(int row= 0; row < grid.size(); ++row)\n        for(int col= 0; col < grid[row].size(); ++col)\n            if(grid[row][col] == 1)  // Fixing the condition to check for land (1) instead of water (0)\n            {\n                maxArea= max(maxArea, dfs(row, col));\n            }\n    return maxArea;\n}",
    "output": "#include <bits/stdc++.h>\nint maxAreaOfIsland(std::vector<std::vector<int>> &grid)\n{\n    std::function<int(int, int)> dfs= [&](int x, int y)\n    {\n        if(x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] == 0)\n        {\n            return 0;\n        }\n        grid[x][y]= 0;\n        return dfs(x - 1, y) + dfs(x + 1, y) + dfs(x, y - 1) + dfs(x, y + 1) + 1;\n    };\n\n    int maxArea= 0;\n    for(int row= 0; row < grid.size(); ++row)\n        for(int col= 0; col < grid[row].size(); ++col)\n            if(grid[row][col] == 1)  // Should check for land (1) instead of water (0)\n            {\n                grid[row][col]= 0;  // Mark as visited\n                maxArea= std::max(maxArea, dfs(row, col));\n                grid[row][col]= 1;  // Restore the grid (optional, depending on the logic)\n            }\n    return maxArea;\n}\n"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool xorGame(const vector<int> &numbers)\n{\n    int xorSum = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        xorSum ^= currentNumber;\n    }\n    return xorSum == 0 || numbers.size() % 2 == 0;\n}",
    "output": "bool xorGame(const std::vector<int> &numbers)\n{\n    int xorSum= 0;\n    for(int currentNumber : numbers)\n    {\n        xorSum^= currentNumber;\n    }\n    return xorSum == 0 || numbers.size() % 2 == 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> subdomainVisits(vector<string> &cpDomains)\n{\n    unordered_map<string, int> domainCounts;\n    vector<string> result;\n\n    for (const string &cpDomain : cpDomains)\n    {\n        int spaceIndex = cpDomain.find(' ');\n        int visitCount = stoi(cpDomain.substr(0, spaceIndex));\n        string domain = cpDomain.substr(spaceIndex + 1);\n\n        for (int i = 0; i < domain.size(); ++i)\n        {\n            if (domain[i] == '.')\n            {\n                domainCounts[domain.substr(i + 1)] += visitCount;\n            }\n        }\n        domainCounts[domain] += visitCount;\n    }\n\n    for (auto it = domainCounts.begin(); it != domainCounts.end(); ++it)\n    {\n        result.push_back(to_string(it->second) + ' ' + it->first);\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> subdomainVisits(std::vector<std::string> &cpDomains)\n{\n    std::unordered_map<std::string, int> domainCounts;\n    std::vector<std::string> result;\n\n    for(const std::string &cpDomain : cpDomains)\n    {\n        int spaceIndex= cpDomain.find(' ');\n        int visitCount= std::stoi(cpDomain.substr(0, spaceIndex));\n        std::string domain= cpDomain.substr(spaceIndex + 1);\n\n        for(int i= 0; i < domain.size(); ++i)\n        {\n            if(domain[i] == '.')\n            {\n                domainCounts[domain.substr(i + 1)]+= visitCount;\n            }\n        }\n        domainCounts[domain]+= visitCount;\n    }\n\n    for(const auto &pair : domainCounts)\n    {\n        result.push_back(std::to_string(pair.second) + ' ' + pair.first);\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble largestTriangleArea(vector<vector<int>> &points)\n{\n    double maxArea= 0.0;\n    for(int firstPointIndex= 0; firstPointIndex < points.size(); ++firstPointIndex)\n    {\n        for(int secondPointIndex= firstPointIndex + 1; secondPointIndex < points.size(); ++secondPointIndex)\n        {\n            for(int thirdPointIndex= secondPointIndex + 1; thirdPointIndex < points.size(); ++thirdPointIndex)\n            {\n                maxArea= max(maxArea, 0.5 * abs(points[firstPointIndex][0] * (points[secondPointIndex][1] - points[thirdPointIndex][1]) + points[secondPointIndex][0] * (points[thirdPointIndex][1] - points[firstPointIndex][1]) + points[thirdPointIndex][0] * (points[firstPointIndex][1] - points[secondPointIndex][1])));\n            }\n        }\n    }\n    return maxArea;\n}",
    "output": "#include <bits/stdc++.h>\ndouble largestTriangleArea(std::vector<std::vector<int>> &points)\n{\n    double maxArea= 0.0;\n    for(int firstPointIndex= 0; firstPointIndex < points.size(); ++firstPointIndex)\n    {\n        for(int secondPointIndex= firstPointIndex + 1; secondPointIndex < points.size(); ++secondPointIndex)\n        {\n            for(int thirdPointIndex= secondPointIndex + 1; thirdPointIndex < points.size(); ++thirdPointIndex)\n            {\n                maxArea= std::max(maxArea, 0.5 * std::abs(points[firstPointIndex][0] * (points[secondPointIndex][1] - points[thirdPointIndex][1]) + points[secondPointIndex][0] * (points[thirdPointIndex][1] - points[firstPointIndex][1]) + points[thirdPointIndex][0] * (points[firstPointIndex][1] - points[secondPointIndex][1])));\n            }\n        }\n    }\n    return maxArea;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble maxPartitionSum(int startIndex, int partitionCount, const vector<int> &numbers, vector<vector<double>> &memoization)\n{\n    if(partitionCount == 1)\n    {\n        return (accumulate(numbers.begin() + startIndex, numbers.end(), 0.0)) / (numbers.size() - startIndex);\n    }\n    if(memoization[startIndex][partitionCount] != -1.0)\n    {\n        return memoization[startIndex][partitionCount];\n    }\n    double currentSum= 0, maxAverage= 0;\n    for(int i= startIndex; i < numbers.size() - partitionCount + 1; ++i)\n    {\n        currentSum+= numbers[i];\n        maxAverage= max(maxAverage, currentSum / (i - startIndex + 1) + maxPartitionSum(i + 1, partitionCount - 1, numbers, memoization));\n    }\n    memoization[startIndex][partitionCount]= maxAverage;\n    return maxAverage;\n}\n\ndouble largestSumOfAverages(vector<int> &numbers, int partitionCount)\n{\n    int totalNumbers= numbers.size();\n    vector<vector<double>> memoization(totalNumbers, vector<double>(partitionCount + 1, -1.0));\n    return maxPartitionSum(0, partitionCount, numbers, memoization);\n}",
    "output": "#include <bits/stdc++.h>\ndouble maxPartitionSum(int startIndex, int partitionCount, const std::vector<int> &numbers, std::vector<std::vector<double>> &memoization)\n{\n    if(partitionCount == 1)\n    {\n        return (std::accumulate(numbers.begin() + startIndex, numbers.end(), 0.0)) / (numbers.size() - startIndex);\n    }\n    if(memoization[startIndex][partitionCount] != -1.0)\n    {\n        return memoization[startIndex][partitionCount];\n    }\n    double currentSum= 0, maxAverage= 0;\n    for(int i= startIndex; i < numbers.size() - partitionCount + 1; ++i)\n    {\n        currentSum+= numbers[i];\n        maxAverage= std::max(maxAverage, currentSum / (i - startIndex + 1) + maxPartitionSum(i + 1, partitionCount - 1, numbers, memoization));\n    }\n    memoization[startIndex][partitionCount]= maxAverage;\n    return maxAverage;\n}\n\ndouble largestSumOfAverages(std::vector<int> &numbers, int partitionCount)\n{\n    int totalNumbers= numbers.size();\n    std::vector<std::vector<double>> memoization(totalNumbers, std::vector<double>(partitionCount + 1, -1.0));\n    return maxPartitionSum(0, partitionCount, numbers, memoization);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "TreeNode *pruneTree(TreeNode *rootNode)\n{\n    if(!rootNode)\n        return NULL;\n    rootNode->left= pruneTree(rootNode->left);\n    rootNode->right= pruneTree(rootNode->right);\n    if(rootNode->val == 0 && !rootNode->left && !rootNode->right)\n        return NULL;\n    return rootNode;\n}",
    "output": "TreeNode *pruneTree(TreeNode *rootNode)\n{\n    if(!rootNode)\n        return NULL;\n    rootNode->left= pruneTree(rootNode->left);\n    rootNode->right= pruneTree(rootNode->right);\n    if(rootNode->val == 0 && !rootNode->left && !rootNode->right)\n        return NULL;\n    return rootNode;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numBusesToDestination(vector<vector<int>> &busRoutes, int sourceStop, int targetStop)\n{\n    if(sourceStop == targetStop)\n        return 0;\n\n    unordered_map<int, unordered_set<int>> stopToBusesMap;\n    for(int busIndex = 0; busIndex < busRoutes.size(); ++busIndex)\n    {\n        for(int j = 0; j < busRoutes[busIndex].size(); ++j)\n        {\n            int stop = busRoutes[busIndex][j];\n            stopToBusesMap[stop].insert(busIndex);\n        }\n    }\n\n    queue<int> stopQueue;\n    unordered_set<int> visitedBusesSet;\n    int numberOfBuses = 0;\n    stopQueue.push(sourceStop);\n\n    while(!stopQueue.empty())\n    {\n        int queueSize = stopQueue.size();\n        while(queueSize--)\n        {\n            int currentStop = stopQueue.front();\n            stopQueue.pop();\n            for(int bus : stopToBusesMap[currentStop])\n            {\n                if(visitedBusesSet.count(bus))\n                    continue;\n                visitedBusesSet.insert(bus);\n                for(int k = 0; k < busRoutes[bus].size(); ++k)\n                {\n                    int nextStop = busRoutes[bus][k];\n                    if(nextStop == targetStop)\n                        return numberOfBuses + 1;\n                    stopQueue.push(nextStop);\n                }\n            }\n        }\n        numberOfBuses++;\n    }\n\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint numBusesToDestination(std::vector<std::vector<int>> &busRoutes, int sourceStop, int targetStop)\n{\n    if(sourceStop == targetStop)\n        return 0;\n\n    std::unordered_map<int, std::unordered_set<int>> stopToBusesMap;\n    for(int busIndex= 0; busIndex < busRoutes.size(); ++busIndex)\n    {\n        for(int stop : busRoutes[busIndex])\n        {\n            stopToBusesMap[stop].insert(busIndex);\n        }\n    }\n\n    std::queue<int> stopQueue;\n    std::unordered_set<int> visitedBusesSet;\n    int numberOfBuses= 0;\n    stopQueue.push(sourceStop);\n\n    while(!stopQueue.empty())\n    {\n        int queueSize= stopQueue.size();\n        while(queueSize--)\n        {\n            int currentStop= stopQueue.front();\n            stopQueue.pop();\n            for(int bus : stopToBusesMap[currentStop])\n            {\n                if(visitedBusesSet.count(bus))\n                    continue;\n                visitedBusesSet.insert(bus);\n                for(int nextStop : busRoutes[bus])\n                {\n                    if(nextStop == targetStop)\n                        return numberOfBuses + 1;\n                    stopQueue.push(nextStop);\n                }\n            }\n        }\n        numberOfBuses++;\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> generateAmbiguousCoordinates(string inputString)\n{\n    int inputLength = inputString.size();\n    vector<string> coordinatesList;\n\n    for (int splitIndex = 2; splitIndex < inputLength - 1; ++splitIndex)\n    {\n        auto firstNumbers = generateNumber(inputString.substr(1, splitIndex - 1));\n        auto secondNumbers = generateNumber(inputString.substr(splitIndex, inputLength - 1 - splitIndex));\n\n        for (int i = 0; i < firstNumbers.size(); ++i)\n        {\n            const auto &first = firstNumbers[i];\n            for (int j = 0; j < secondNumbers.size(); ++j)\n            {\n                const auto &second = secondNumbers[j];\n                coordinatesList.push_back(\"(\" + first + \", \" + second + \")\");\n            }\n        }\n    }\n    return coordinatesList;\n}\n\nvector<string> generateNumber(const string &numberString)\n{\n    int numberLength = numberString.size();\n    vector<string> validNumbers;\n\n    if (numberLength == 0 || (numberLength > 1 && numberString[0] == '0' && numberString[numberLength - 1] == '0'))\n        return validNumbers;\n    if (numberLength > 1 && numberString[0] == '0')\n    {\n        validNumbers.push_back(\"0.\" + numberString.substr(1));\n        return validNumbers;\n    }\n    validNumbers.push_back(numberString);\n    if (numberLength == 1 || numberString[numberLength - 1] == '0')\n        return validNumbers;\n\n    for (int decimalIndex = 1; decimalIndex < numberLength; ++decimalIndex)\n    {\n        validNumbers.push_back(numberString.substr(0, decimalIndex) + \".\" + numberString.substr(decimalIndex));\n    }\n    return validNumbers;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> generateAmbiguousCoordinates(std::string inputString)\n{\n    int inputLength= inputString.size();\n    std::vector<std::string> coordinatesList;\n\n    for(int splitIndex= 2; splitIndex < inputLength - 1; ++splitIndex)\n    {\n        auto firstNumbers= generateNumber(inputString.substr(1, splitIndex - 1));\n        auto secondNumbers= generateNumber(inputString.substr(splitIndex, inputLength - 1 - splitIndex));\n\n        for(const auto &first : firstNumbers)\n        {\n            for(const auto &second : secondNumbers)\n            {\n                coordinatesList.push_back(\"(\" + first + \", \" + second + \")\");\n            }\n        }\n    }\n    return coordinatesList;\n}\n\nstd::vector<std::string> generateNumber(const std::string &numberString)\n{\n    int numberLength= numberString.size();\n    std::vector<std::string> validNumbers;\n\n    if(numberLength == 0 || (numberLength > 1 && numberString[0] == '0' && numberString[numberLength - 1] == '0'))\n        return validNumbers;\n    if(numberLength > 1 && numberString[0] == '0')\n    {\n        validNumbers.push_back(\"0.\" + numberString.substr(1));\n        return validNumbers;\n    }\n    validNumbers.push_back(numberString);\n    if(numberLength == 1 || numberString[numberLength - 1] == '0')\n        return validNumbers;\n\n    for(int decimalIndex= 1; decimalIndex < numberLength; ++decimalIndex)\n    {\n        validNumbers.push_back(numberString.substr(0, decimalIndex) + \".\" + numberString.substr(decimalIndex));\n    }\n    return validNumbers;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nint countComponents(ListNode *head, vector<int> &numList)\n{\n    unordered_set<int> numSet(numList.begin(), numList.end());\n    int componentCount= 0;\n    bool isConnected= false;\n\n    while(head)\n    {\n        if(numSet.find(head->value) != numSet.end())\n        {\n            if(!isConnected)\n            {\n                isConnected= true;\n                componentCount++;\n            }\n        }\n        else\n        {\n            isConnected= false;\n        }\n        head= head->next;\n    }\n\n    return componentCount;\n}",
    "output": "#include <bits/stdc++.h>\nstruct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nint countComponents(ListNode *head, std::vector<int> &numList)\n{\n    std::unordered_set<int> numSet(numList.begin(), numList.end());\n    int componentCount= 0;\n    bool isConnected= false;\n\n    while(head)\n    {\n        if(numSet.find(head->value) != numSet.end())\n        {\n            if(!isConnected)\n            {\n                isConnected= true;\n                componentCount++;\n            }\n        }\n        else\n        {\n            isConnected= false;\n        }\n        head= head->next;\n    }\n\n    return componentCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint racecar(int target)\n{\n    unordered_map<int, unordered_map<int, int>> memo;\n    function<int(int, int)> dynamicProgramming= [&](int position, int speed)\n    {\n        if(position == target)\n            return 0;\n        if(abs(position) > 2 * target)\n            return INT_MAX;\n\n        int &answer= memo[position][speed];\n        if(answer)\n            return answer;\n\n        if(speed == -1)\n        {\n            int option1= dynamicProgramming(position + speed, 2 * speed) + 1;\n            int option2= dynamicProgramming(position, -speed) + 2;\n\n            answer= min(option1, option2);\n        }\n        else\n        {\n            int option1= dynamicProgramming(position - speed, -2 * speed) + 1;\n            int option2= dynamicProgramming(position, -speed) + 2;\n\n            answer= min(option1, option2);\n        }\n\n        return answer;\n    };\n\n    return dynamicProgramming(0, target) + 1;\n}",
    "output": "#include <bits/stdc++.h>\nint racecar(int target)\n{\n    std::unordered_map<int, std::unordered_map<int, int>> memo;\n    std::function<int(int, int)> dynamicProgramming= [&](int position, int speed)\n    {\n        if(position == target)\n            return 0;\n        if(std::abs(position) > 2 * target)\n            return INT_MAX;\n\n        int &answer= memo[position][speed];\n        if(answer)\n            return answer;\n\n        if(speed == -1)\n        {\n            int option1= dynamicProgramming(position + speed, 2 * speed) + 1;\n            int option2= dynamicProgramming(position, -speed) + 2;\n\n            answer= std::min(option1, option2);\n        }\n        else\n        {\n            int option1= dynamicProgramming(position - speed, -2 * speed) + 1;\n            int option2= dynamicProgramming(position, -speed) + 2;\n\n            answer= std::min(option1, option2);\n        }\n\n        return answer;\n    };\n\n    return dynamicProgramming(0, target) + 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring mostCommonWord(string paragraph, vector<string> &bannedWords)\n{\n    unordered_map<string, int> wordFrequency;\n    string currentWord;\n    for(char character : paragraph)\n    {\n        if(isalpha(character))\n        {\n            currentWord.push_back(tolower(character));\n        }\n        else if(!currentWord.empty())\n        {\n            wordFrequency[currentWord]++;\n            currentWord.clear();\n        }\n    }\n\n    if(!currentWord.empty())\n    {\n        wordFrequency[currentWord]++;\n    }\n\n    for(int i = 0; i < bannedWords.size(); ++i)\n    {\n        string &bannedWord = bannedWords[i];\n        transform(bannedWord.begin(), bannedWord.end(), bannedWord.begin(), ::tolower);\n        wordFrequency[bannedWord] = 0;\n    }\n\n    return max_element(wordFrequency.begin(), wordFrequency.end(), [](const auto &a, const auto &b)\n                            { return a.second < b.second; })\n        ->first;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string mostCommonWord(std::string paragraph, std::vector<std::string> &bannedWords)\n{\n    std::unordered_map<std::string, int> wordFrequency;\n    std::string currentWord;\n    for(char character : paragraph)\n    {\n        if(isalpha(character))\n        {\n            currentWord.push_back(tolower(character));\n        }\n        else if(!currentWord.empty())\n        {\n            wordFrequency[currentWord]++;\n            currentWord.clear();\n        }\n    }\n\n    if(!currentWord.empty())\n    {\n        wordFrequency[currentWord]++;\n    }\n\n    for(std::string &bannedWord : bannedWords)\n    {\n        transform(bannedWord.begin(), bannedWord.end(), bannedWord.begin(), ::tolower);\n        wordFrequency[bannedWord]= 0;\n    }\n\n    return std::max_element(wordFrequency.begin(), wordFrequency.end(), [](const auto &a, const auto &b)\n                            { return a.second < b.second; })\n        ->first;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring pushDominoes(string dominoes)\n{\n    int dominoesCount = dominoes.size();\n    vector<int> forces(dominoesCount, 0);\n\n    int currentForce = 0;\n    for (int i = 0; i < dominoesCount; ++i)\n    {\n        if (dominoes[i] == 'R')\n            currentForce = dominoesCount;\n        else if (dominoes[i] == 'L')\n            currentForce = 0;\n        else\n            currentForce = max(currentForce - 1, 0);\n        forces[i] += currentForce;\n    }\n\n    currentForce = 0;\n    for (int i = dominoesCount - 1; i >= 0; --i)\n    {\n        if (dominoes[i] == 'L')\n            currentForce = dominoesCount;\n        else if (dominoes[i] == 'R')\n            currentForce = 0;\n        else\n            currentForce = max(currentForce - 1, 0);\n        forces[i] -= currentForce;\n    }\n\n    string result = \"\";\n    for (int i = 0; i < forces.size(); ++i)\n    {\n        int force = forces[i];\n        if (force > 0)\n            result += 'R';\n        else if (force < 0)\n            result += 'L';\n        else\n            result += '.';\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string pushDominoes(std::string dominoes)\n{\n    int dominoesCount= dominoes.size();\n    std::vector<int> forces(dominoesCount, 0);\n\n    int currentForce= 0;\n    for(int i= 0; i < dominoesCount; ++i)\n    {\n        if(dominoes[i] == 'R')\n            currentForce= dominoesCount;\n        else if(dominoes[i] == 'L')\n            currentForce= 0;\n        else\n            currentForce= std::max(currentForce - 1, 0);\n        forces[i]+= currentForce;\n    }\n\n    currentForce= 0;\n    for(int i= dominoesCount - 1; i >= 0; --i)\n    {\n        if(dominoes[i] == 'L')\n            currentForce= dominoesCount;\n        else if(dominoes[i] == 'R')\n            currentForce= 0;\n        else\n            currentForce= std::max(currentForce - 1, 0);\n        forces[i]-= currentForce;\n    }\n\n    std::string result= \"\";\n    for(int force : forces)\n    {\n        if(force > 0)\n            result+= 'R';\n        else if(force < 0)\n            result+= 'L';\n        else\n            result+= '.';\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimalLengthEncoding(const vector<string> &wordList)\n{\n    unordered_set<string> uniqueWords(wordList.begin(), wordList.end());\n\n    for (int i = 0; i < wordList.size(); ++i)\n    {\n        const string &currentWord = wordList[i];\n        for (int index = 1; index < currentWord.size(); ++index)\n        {\n            uniqueWords.erase(currentWord.substr(index));\n        }\n    }\n\n    int totalLength = 0;\n    for (int i = 0; i < uniqueWords.size(); ++i)\n    {\n        // Since we cannot directly index into an unordered_set, we need to iterate using an iterator.\n        auto it = uniqueWords.begin();\n        advance(it, i);\n        totalLength += it->size() + 1;\n    }\n    return totalLength;\n}",
    "output": "#include <bits/stdc++.h>\nint minimalLengthEncoding(const std::vector<std::string> &wordList)\n{\n    std::unordered_set<std::string> uniqueWords(wordList.begin(), wordList.end());\n\n    for(const std::string &currentWord : wordList)\n    {\n        for(int index= 1; index < currentWord.size(); ++index)\n        {\n            uniqueWords.erase(currentWord.substr(index));\n        }\n    }\n\n    int totalLength= 0;\n    for(const std::string &remainingWord : uniqueWords)\n    {\n        totalLength+= remainingWord.size() + 1;\n    }\n    return totalLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isMagic(vector<vector<int>> &grid, int startX, int startY);\n\nint countMagicSquaresInside(vector<vector<int>> &grid)\n{\n    int magicSquareCount= 0;\n    for(int rowIndex= 0; rowIndex < grid.size() - 2; ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex < grid[0].size() - 2; ++colIndex)\n        {\n            if(grid[rowIndex][colIndex] <= 9 && grid[rowIndex + 1][colIndex + 1] == 5 && isMagic(grid, rowIndex, colIndex))\n            {\n                magicSquareCount++;\n            }\n        }\n    }\n    return magicSquareCount;\n}\n\nbool isMagic(vector<vector<int>> &grid, int startX, int startY)\n{\n    vector<int> numberCount(16, 0);\n    for(int i= 0; i < 3; ++i)\n    {\n        for(int j= 0; j < 3; ++j)\n        {\n            int currentNumber= grid[startX + i][startY + j];\n            numberCount[currentNumber]++;\n            if(currentNumber > 9 || numberCount[currentNumber] > 1)\n            {\n                return false;\n            }\n        }\n    }\n    int targetSum= grid[startX][startY] + grid[startX][startY + 1] + grid[startX][startY + 2];\n    for(int i= 0; i < 3; ++i)\n    {\n        int rowSum= 0, colSum= 0;\n        for(int j= 0; j < 3; ++j)\n        {\n            rowSum+= grid[startX + i][startY + j];\n            colSum+= grid[startX + j][startY + i];\n        }\n        if(rowSum != targetSum || colSum != targetSum)\n            return false;\n    }\n    if(grid[startX][startY] + grid[startX + 1][startY + 1] + grid[startX + 2][startY + 2] != targetSum)\n        return false;\n    if(grid[startX][startY + 2] + grid[startX + 1][startY + 1] + grid[startX + 2][startY] != targetSum)\n        return false;\n\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isMagic(std::vector<std::vector<int>> &grid, int startX, int startY);\n\nint countMagicSquaresInside(std::vector<std::vector<int>> &grid)\n{\n    int magicSquareCount= 0;\n    for(int rowIndex= 0; rowIndex < grid.size() - 2; ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex < grid[0].size() - 2; ++colIndex)\n        {\n            if(grid[rowIndex][colIndex] <= 9 && grid[rowIndex + 1][colIndex + 1] == 5 && isMagic(grid, rowIndex, colIndex))\n            {\n                magicSquareCount++;\n            }\n        }\n    }\n    return magicSquareCount;\n}\n\nbool isMagic(std::vector<std::vector<int>> &grid, int startX, int startY)\n{\n    std::vector<int> numberCount(16, 0);\n    for(int i= 0; i < 3; ++i)\n    {\n        for(int j= 0; j < 3; ++j)\n        {\n            int currentNumber= grid[startX + i][startY + j];\n            numberCount[currentNumber]++;\n            if(currentNumber > 9 || numberCount[currentNumber] > 1)\n            {\n                return false;\n            }\n        }\n    }\n    int targetSum= grid[startX][startY] + grid[startX][startY + 1] + grid[startX][startY + 2];\n    for(int i= 0; i < 3; ++i)\n    {\n        int rowSum= 0, colSum= 0;\n        for(int j= 0; j < 3; ++j)\n        {\n            rowSum+= grid[startX + i][startY + j];\n            colSum+= grid[startX + j][startY + i];\n        }\n        if(rowSum != targetSum || colSum != targetSum)\n            return false;\n    }\n    if(grid[startX][startY] + grid[startX + 1][startY + 1] + grid[startX + 2][startY + 2] != targetSum)\n        return false;\n    if(grid[startX][startY + 2] + grid[startX + 1][startY + 1] + grid[startX + 2][startY] != targetSum)\n        return false;\n\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> shortestToChar(const string &inputString, char targetChar)\n{\n    int stringLength = inputString.size();\n    vector<int> distanceToChar(stringLength, stringLength);\n\n    int lastPosition = -stringLength;\n    for(int currentIndex = 0; currentIndex < stringLength; ++currentIndex)\n    {\n        if(inputString[currentIndex] == targetChar)\n            lastPosition = currentIndex;\n        distanceToChar[currentIndex] = currentIndex - lastPosition;\n    }\n\n    for(int currentIndex = lastPosition - 1; currentIndex >= 0; --currentIndex)\n    {\n        if(inputString[currentIndex] == targetChar)\n            lastPosition = currentIndex;\n        distanceToChar[currentIndex] = min(distanceToChar[currentIndex], lastPosition - currentIndex);\n    }\n\n    return distanceToChar;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> shortestToChar(const std::string &inputString, char targetChar)\n{\n    int stringLength= inputString.size();\n    std::vector<int> distanceToChar(stringLength, stringLength);\n\n    int lastPosition= -stringLength;\n    for(int currentIndex= 0; currentIndex < stringLength; ++currentIndex)\n    {\n        if(inputString[currentIndex] == targetChar)\n            lastPosition= currentIndex;\n        distanceToChar[currentIndex]= currentIndex - lastPosition;\n    }\n\n    for(int currentIndex= lastPosition - 1; currentIndex >= 0; --currentIndex)\n    {\n        if(inputString[currentIndex] == targetChar)\n            lastPosition= currentIndex;\n        distanceToChar[currentIndex]= std::min(distanceToChar[currentIndex], lastPosition - currentIndex);\n    }\n\n    return distanceToChar;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint smallestGoodInteger(vector<int> &fronts, vector<int> &backs)\n{\n    set<int> notGoodIntegers;\n    int numberOfCards = fronts.size();\n    for (int i = 0; i < numberOfCards; ++i)\n        if (fronts[i] == backs[i])\n            notGoodIntegers.insert(fronts[i]);\n\n    int smallestGoodInteger = INT_MAX;\n    for (int i = 0; i < numberOfCards; ++i)\n    {\n        if (!notGoodIntegers.count(fronts[i]))\n            smallestGoodInteger = min(smallestGoodInteger, fronts[i]);\n        if (!notGoodIntegers.count(backs[i]))\n            smallestGoodInteger = min(smallestGoodInteger, backs[i]);\n    }\n    return smallestGoodInteger == INT_MAX ? 0 : smallestGoodInteger;\n}",
    "output": "#include <bits/stdc++.h>\nint smallestGoodInteger(std::vector<int> &fronts, std::vector<int> &backs)\n{\n    std::set<int> notGoodIntegers;\n    int numberOfCards= fronts.size();\n    for(int i= 0; i < numberOfCards; ++i)\n        if(fronts[i] == backs[i])\n            notGoodIntegers.insert(fronts[i]);\n\n    int smallestGoodInteger= INT_MAX;\n    for(int i= 0; i < numberOfCards; ++i)\n    {\n        if(!notGoodIntegers.count(fronts[i]))\n            smallestGoodInteger= std::min(smallestGoodInteger, fronts[i]);\n        if(!notGoodIntegers.count(backs[i]))\n            smallestGoodInteger= std::min(smallestGoodInteger, backs[i]);\n    }\n    return smallestGoodInteger == INT_MAX ? 0 : smallestGoodInteger;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countFactoredBinaryTrees(vector<int> &inputArray)\n{\n    long long modulus = 1e9 + 7;\n    int arraySize = inputArray.size();\n    sort(inputArray.begin(), inputArray.end());\n    unordered_map<int, long long> dynamicProgramming;\n\n    for (int i = 0; i < arraySize; ++i)\n    {\n        dynamicProgramming[inputArray[i]] = 1;\n        for (int j = 0; j < i; ++j)\n        {\n            if (inputArray[i] % inputArray[j] == 0 && dynamicProgramming.count(inputArray[i] / inputArray[j]))\n                dynamicProgramming[inputArray[i]] = (dynamicProgramming[inputArray[i]] + dynamicProgramming[inputArray[j]] * dynamicProgramming[inputArray[i] / inputArray[j]]) % modulus;\n        }\n    }\n\n    long long totalCount = 0;\n    for (auto it = dynamicProgramming.begin(); it != dynamicProgramming.end(); ++it)\n        totalCount = (totalCount + it->second) % modulus;\n\n    return totalCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countFactoredBinaryTrees(std::vector<int> &inputArray)\n{\n    long long modulus= 1e9 + 7;\n    int arraySize= inputArray.size();\n    std::sort(inputArray.begin(), inputArray.end());\n    std::unordered_map<int, long long> dynamicProgramming;\n\n    for(int i= 0; i < arraySize; ++i)\n    {\n        dynamicProgramming[inputArray[i]]= 1;\n        for(int j= 0; j < i; ++j)\n        {\n            if(inputArray[i] % inputArray[j] == 0 && dynamicProgramming.count(inputArray[i] / inputArray[j]))\n                dynamicProgramming[inputArray[i]]= (dynamicProgramming[inputArray[i]] + dynamicProgramming[inputArray[j]] * dynamicProgramming[inputArray[i] / inputArray[j]]) % modulus;\n        }\n    }\n\n    long long totalCount= 0;\n    for(const auto &element : dynamicProgramming)\n        totalCount= (totalCount + element.second) % modulus;\n\n    return totalCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool backspaceCompare(string sourceString, string targetString)\n{\n    int sourceIndex= sourceString.length() - 1, targetIndex= targetString.length() - 1;\n    while(true)\n    {\n        int backspaceCount;\n        for(backspaceCount= 0; sourceIndex >= 0 && (backspaceCount > 0 || sourceString[sourceIndex] == '#'); --sourceIndex)\n            backspaceCount+= sourceString[sourceIndex] == '#' ? 1 : -1;\n        for(backspaceCount= 0; targetIndex >= 0 && (backspaceCount > 0 || targetString[targetIndex] == '#'); --targetIndex)\n            backspaceCount+= targetString[targetIndex] == '#' ? 1 : -1;\n        if(sourceIndex >= 0 && targetIndex >= 0 && sourceString[sourceIndex] == targetString[targetIndex])\n            sourceIndex--, targetIndex--;\n        else\n            return sourceIndex == -1 && targetIndex == -1;\n    }\n}",
    "output": "#include <bits/stdc++.h>\nbool backspaceCompare(std::string sourceString, std::string targetString)\n{\n    int sourceIndex= sourceString.length() - 1, targetIndex= targetString.length() - 1;\n    while(true)\n    {\n        int backspaceCount;\n        for(backspaceCount= 0; sourceIndex >= 0 && (backspaceCount > 0 || sourceString[sourceIndex] == '#'); --sourceIndex)\n            backspaceCount+= sourceString[sourceIndex] == '#' ? 1 : -1;\n        for(backspaceCount= 0; targetIndex >= 0 && (backspaceCount > 0 || targetString[targetIndex] == '#'); --targetIndex)\n            backspaceCount+= targetString[targetIndex] == '#' ? 1 : -1;\n        if(sourceIndex >= 0 && targetIndex >= 0 && sourceString[sourceIndex] == targetString[targetIndex])\n            sourceIndex--, targetIndex--;\n        else\n            return sourceIndex == -1 && targetIndex == -1;\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findLongestMountain(vector<int> &elevationArray)\n{\n    int arraySize= elevationArray.size(), longestMountainLength= 0, ascendingCount= 0, descendingCount= 0;\n\n    for(int index= 1; index < arraySize; ++index)\n    {\n        if(descendingCount && elevationArray[index - 1] < elevationArray[index] || elevationArray[index - 1] == elevationArray[index])\n        {\n            ascendingCount= descendingCount= 0;\n        }\n\n        ascendingCount+= elevationArray[index - 1] < elevationArray[index];\n        descendingCount+= elevationArray[index - 1] > elevationArray[index];\n\n        if(ascendingCount && descendingCount)\n        {\n            longestMountainLength= max(longestMountainLength, ascendingCount + descendingCount + 1);\n        }\n    }\n    return longestMountainLength;\n}",
    "output": "#include <bits/stdc++.h>\nint findLongestMountain(std::vector<int> &elevationArray)\n{\n    int arraySize= elevationArray.size(), longestMountainLength= 0, ascendingCount= 0, descendingCount= 0;\n\n    for(int index= 1; index < arraySize; ++index)\n    {\n        if(descendingCount && (elevationArray[index - 1] < elevationArray[index] || elevationArray[index - 1] == elevationArray[index]))\n        {\n            ascendingCount= descendingCount= 0;\n        }\n\n        ascendingCount+= elevationArray[index - 1] < elevationArray[index];\n        descendingCount+= elevationArray[index - 1] > elevationArray[index];\n\n        if(ascendingCount && descendingCount)\n        {\n            longestMountainLength= std::max(longestMountainLength, ascendingCount + descendingCount + 1);\n        }\n    }\n    return longestMountainLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPossibleDivide(vector<int> &hand, int groupSize)\n{\n    map<int, int> cardCount;\n    for(int card : hand)\n    {\n        cardCount[card]++;\n    }\n\n    for(auto it = cardCount.begin(); it != cardCount.end(); ++it)\n    {\n        if(it->second > 0)\n        {\n            int count = it->second;\n            for(int i = 1; i < groupSize; ++i)\n            {\n                cardCount[it->first + i] -= count;\n                if(cardCount[it->first + i] < 0)\n                {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isPossibleDivide(std::vector<int> &hand, int groupSize)\n{\n    std::map<int, int> cardCount;\n    for(int card : hand)\n    {\n        cardCount[card]++;\n    }\n\n    for(auto it= cardCount.begin(); it != cardCount.end(); ++it)\n    {\n        if(it->second > 0)\n        {\n            int count= it->second;\n            for(int i= 1; i < groupSize; ++i)\n            {\n                cardCount[it->first + i]-= count;\n                if(cardCount[it->first + i] < 0)\n                {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPathLength(const vector<vector<int>> &graph)\n{\n    int numberOfNodes = graph.size();\n    queue<tuple<int, int, int>> queue;\n    vector<vector<bool>> visited(numberOfNodes, vector<bool>(1 << numberOfNodes, false));\n\n    for(int nodeIndex = 0; nodeIndex < numberOfNodes; ++nodeIndex)\n    {\n        queue.push({nodeIndex, 1 << nodeIndex, 0});\n        visited[nodeIndex][1 << nodeIndex] = true;\n    }\n\n    while(!queue.empty())\n    {\n        auto [currentNode, currentBitmask, pathLength] = queue.front();\n        queue.pop();\n\n        if(currentBitmask == (1 << numberOfNodes) - 1)\n            return pathLength;\n\n        for(int i = 0; i < graph[currentNode].size(); ++i) // Modified to traditional for loop\n        {\n            int neighbor = graph[currentNode][i];\n            int nextBitmask = currentBitmask | (1 << neighbor);\n            if(!visited[neighbor][nextBitmask])\n            {\n                visited[neighbor][nextBitmask] = true;\n                queue.push({neighbor, nextBitmask, pathLength + 1});\n            }\n        }\n    }\n\n    return 0;\n}",
    "output": "#include <bits/stdc++.h>\nint shortestPathLength(const std::vector<std::vector<int>> &graph)\n{\n    int numberOfNodes= graph.size();\n    std::queue<std::tuple<int, int, int>> queue;\n    std::vector<std::vector<bool>> visited(numberOfNodes, std::vector<bool>(1 << numberOfNodes, false));\n\n    for(int nodeIndex= 0; nodeIndex < numberOfNodes; ++nodeIndex)\n    {\n        queue.push({nodeIndex, 1 << nodeIndex, 0});\n        visited[nodeIndex][1 << nodeIndex]= true;\n    }\n\n    while(!queue.empty())\n    {\n        auto [currentNode, currentBitmask, pathLength]= queue.front();\n        queue.pop();\n\n        if(currentBitmask == (1 << numberOfNodes) - 1)\n            return pathLength;\n\n        for(int neighbor : graph[currentNode])\n        {\n            int nextBitmask= currentBitmask | (1 << neighbor);\n            if(!visited[neighbor][nextBitmask])\n            {\n                visited[neighbor][nextBitmask]= true;\n                queue.push({neighbor, nextBitmask, pathLength + 1});\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring shiftingLetters(string inputString, vector<int> &shiftValues)\n{\n    for(int index= shiftValues.size() - 2; index >= 0; index--)\n    {\n        shiftValues[index]+= shiftValues[index + 1] % 26;\n    }\n\n    for(int charIndex= 0; charIndex < inputString.size(); charIndex++)\n    {\n        inputString[charIndex]= (inputString[charIndex] - 'a' + shiftValues[charIndex] % 26) % 26 + 'a';\n    }\n\n    return inputString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string shiftingLetters(std::string inputString, std::vector<int> &shiftValues)\n{\n    for(int index= shiftValues.size() - 2; index >= 0; index--)\n    {\n        shiftValues[index]+= shiftValues[index + 1] % 26;\n    }\n\n    for(int charIndex= 0; charIndex < inputString.size(); charIndex++)\n    {\n        inputString[charIndex]= (inputString[charIndex] - 'a' + shiftValues[charIndex] % 26) % 26 + 'a';\n    }\n\n    return inputString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxDistanceToClosest(vector<int> &seats)\n{\n    int totalSeats= seats.size();\n    int maximumDistance= 0, lastOccupiedSeat= -1;\n\n    for(int i= 0; i < totalSeats; ++i)\n    {\n        if(seats[i] == 1)\n        {\n            if(lastOccupiedSeat == -1)\n                maximumDistance= i;\n            else\n                maximumDistance= max(maximumDistance, (i - lastOccupiedSeat) / 2);\n            lastOccupiedSeat= i;\n        }\n    }\n    maximumDistance= max(maximumDistance, totalSeats - 1 - lastOccupiedSeat);\n    return maximumDistance;\n}",
    "output": "#include <bits/stdc++.h>\nint maxDistanceToClosest(std::vector<int> &seats)\n{\n    int totalSeats= seats.size();\n    int maximumDistance= 0, lastOccupiedSeat= -1;\n\n    for(int i= 0; i < totalSeats; ++i)\n    {\n        if(seats[i] == 1)\n        {\n            if(lastOccupiedSeat == -1)\n                maximumDistance= i;\n            else\n                maximumDistance= std::max(maximumDistance, (i - lastOccupiedSeat) / 2);\n            lastOccupiedSeat= i;\n        }\n    }\n    maximumDistance= std::max(maximumDistance, totalSeats - 1 - lastOccupiedSeat);\n    return maximumDistance;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint rectangleArea(vector<vector<int>> &rectangles)\n{\n    const int64_t modulus = 1e9 + 7;\n    int rectangleCount = rectangles.size();\n    vector<int> xCoordinates, yCoordinates;\n\n    for (int i = 0; i < rectangleCount; ++i) {\n        xCoordinates.push_back(rectangles[i][0]);\n        xCoordinates.push_back(rectangles[i][2]);\n        yCoordinates.push_back(rectangles[i][1]);\n        yCoordinates.push_back(rectangles[i][3]);\n    }\n    \n    sort(xCoordinates.begin(), xCoordinates.end());\n    sort(yCoordinates.begin(), yCoordinates.end());\n\n    xCoordinates.erase(unique(xCoordinates.begin(), xCoordinates.end()), xCoordinates.end());\n    yCoordinates.erase(unique(yCoordinates.begin(), yCoordinates.end()), yCoordinates.end());\n\n    vector<vector<int>> coverage(xCoordinates.size() - 1, vector<int>(yCoordinates.size() - 1));\n\n    for (int i = 0; i < rectangleCount; ++i) {\n        const auto &rectangle = rectangles[i];\n        int x1Index = lower_bound(xCoordinates.begin(), xCoordinates.end(), rectangle[0]) - xCoordinates.begin();\n        int x2Index = lower_bound(xCoordinates.begin(), xCoordinates.end(), rectangle[2]) - xCoordinates.begin() - 1;\n        int y1Index = lower_bound(yCoordinates.begin(), yCoordinates.end(), rectangle[1]) - yCoordinates.begin();\n        int y2Index = lower_bound(yCoordinates.begin(), yCoordinates.end(), rectangle[3]) - yCoordinates.begin() - 1;\n        \n        for (int j = x1Index; j <= x2Index; ++j) {\n            for (int k = y1Index; k <= y2Index; ++k) {\n                coverage[j][k] = 1;\n            }\n        }\n    }\n\n    int64_t totalArea = 0;\n    for (int i = 0; i < xCoordinates.size() - 1; ++i) {\n        for (int j = 0; j < yCoordinates.size() - 1; ++j) {\n            if (coverage[i][j]) {\n                totalArea += (int64_t)(xCoordinates[i + 1] - xCoordinates[i]) * (yCoordinates[j + 1] - yCoordinates[j]);\n                totalArea %= modulus;\n            }\n        }\n    }\n    return totalArea;\n}",
    "output": "#include <bits/stdc++.h>\nint rectangleArea(std::vector<std::vector<int>> &rectangles)\n{\n    const int64_t modulus = 1e9 + 7;\n    int rectangleCount = rectangles.size();\n    std::vector<int> xCoordinates, yCoordinates;\n    \n    for(const auto &rectangle : rectangles)\n    {\n        xCoordinates.push_back(rectangle[0]);\n        xCoordinates.push_back(rectangle[2]);\n        yCoordinates.push_back(rectangle[1]);\n        yCoordinates.push_back(rectangle[3]);\n    }\n    \n    std::sort(xCoordinates.begin(), xCoordinates.end());\n    std::sort(yCoordinates.begin(), yCoordinates.end());\n\n    xCoordinates.erase(std::unique(xCoordinates.begin(), xCoordinates.end()), xCoordinates.end());\n    yCoordinates.erase(std::unique(yCoordinates.begin(), yCoordinates.end()), yCoordinates.end());\n\n    std::vector<std::vector<int>> coverage(xCoordinates.size() - 1, std::vector<int>(yCoordinates.size() - 1));\n\n    for(const auto &rectangle : rectangles)\n    {\n        int x1Index = std::lower_bound(xCoordinates.begin(), xCoordinates.end(), rectangle[0]) - xCoordinates.begin();\n        int x2Index = std::lower_bound(xCoordinates.begin(), xCoordinates.end(), rectangle[2]) - xCoordinates.begin() - 1;\n        int y1Index = std::lower_bound(yCoordinates.begin(), yCoordinates.end(), rectangle[1]) - yCoordinates.begin();\n        int y2Index = std::lower_bound(yCoordinates.begin(), yCoordinates.end(), rectangle[3]) - yCoordinates.begin() - 1;\n        \n        for(int i = x1Index; i <= x2Index; ++i)\n        {\n            for(int j = y1Index; j <= y2Index; ++j)\n            {\n                coverage[i][j] = 1;\n            }\n        }\n    }\n    \n    int64_t totalArea = 0;\n    for(int i = 0; i < xCoordinates.size() - 1; ++i)\n    {\n        for(int j = 0; j < yCoordinates.size() - 1; ++j)\n        {\n            if(coverage[i][j])\n            {\n                totalArea += (int64_t)(xCoordinates[i + 1] - xCoordinates[i]) * (yCoordinates[j + 1] - yCoordinates[j]);\n                totalArea %= modulus;\n            }\n        }\n    }\n    \n    return totalArea;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring convertToGoatLatin(string sentence)\n{\n    istringstream stringStream(sentence);\n    string word, goatLatinResult, suffix= \"a\";\n    const string vowels= \"AEIOUaeiou\";\n\n    while(stringStream >> word)\n    {\n        if(vowels.find(word[0]) == string::npos)\n        {\n            word= word.substr(1) + word[0];\n        }\n        goatLatinResult+= word + \"ma\" + suffix + \" \";\n        suffix+= \"a\";\n    }\n\n    goatLatinResult.pop_back();\n    return goatLatinResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string convertToGoatLatin(std::string sentence)\n{\n    std::istringstream stringStream(sentence);\n    std::string word, goatLatinResult, suffix= \"a\";\n    const std::string vowels= \"AEIOUaeiou\";\n\n    while(stringStream >> word)\n    {\n        if(vowels.find(word[0]) == std::string::npos)\n        {\n            word= word.substr(1) + word[0];\n        }\n        goatLatinResult+= word + \"ma\" + suffix + \" \";\n        suffix+= \"a\";\n    }\n\n    goatLatinResult.pop_back();\n    return goatLatinResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateFriendRequests(vector<int> &ageList)\n{\n    vector<int> ageCount(121, 0);\n    int totalRequests = 0;\n\n    for (int age : ageList)\n        ageCount[age]++;\n\n    for (int ageA = 1; ageA <= 120; ageA++)\n    {\n        for (int ageB = 1; ageB <= 120; ageB++)\n        {\n            if (ageA * 0.5 + 7 >= ageB)\n                continue;\n            if (ageA < ageB)\n                continue;\n            if (ageA < ageB * 2)\n            {\n                totalRequests += ageCount[ageA] * ageCount[ageB];\n                if (ageA == ageB)\n                    totalRequests -= ageCount[ageA];\n            }\n        }\n    }\n\n    return totalRequests;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateFriendRequests(std::vector<int> &ageList)\n{\n    std::vector<int> ageCount(121, 0);\n    int totalRequests= 0;\n\n    for(int age : ageList)\n        ageCount[age]++;\n\n    for(int ageA= 1; ageA <= 120; ageA++)\n    {\n        for(int ageB= 1; ageB <= 120; ageB++)\n        {\n            if(ageA * 0.5 + 7 >= ageB)\n                continue;\n            if(ageA < ageB)\n                continue;\n            if(ageA < ageB * 2)\n            {\n                totalRequests+= ageCount[ageA] * ageCount[ageB];\n                if(ageA == ageB)\n                    totalRequests-= ageCount[ageA];\n            }\n        }\n    }\n\n    return totalRequests;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxProfitAssignment(vector<int> &jobDifficulty, vector<int> &jobProfit, vector<int> &workerAbility)\n{\n    vector<pair<int, int>> jobs;\n    for(int jobIndex = 0; jobIndex < jobDifficulty.size(); ++jobIndex)\n        jobs.push_back({jobDifficulty[jobIndex], jobProfit[jobIndex]});\n    sort(jobs.begin(), jobs.end());\n    sort(workerAbility.begin(), workerAbility.end());\n\n    int jobIndex = 0, maxProfit = 0, totalProfit = 0;\n    for(int i = 0; i < workerAbility.size(); ++i)\n    {\n        int ability = workerAbility[i];\n        while(jobIndex < jobDifficulty.size() && ability >= jobs[jobIndex].first)\n        {\n            maxProfit = max(maxProfit, jobs[jobIndex].second);\n            ++jobIndex;\n        }\n        totalProfit += maxProfit;\n    }\n    return totalProfit;\n}",
    "output": "#include <bits/stdc++.h>\nint maxProfitAssignment(std::vector<int> &jobDifficulty, std::vector<int> &jobProfit, std::vector<int> &workerAbility)\n{\n    std::vector<std::pair<int, int>> jobs;\n    for(int jobIndex= 0; jobIndex < jobDifficulty.size(); ++jobIndex)\n        jobs.push_back({jobDifficulty[jobIndex], jobProfit[jobIndex]});\n    std::sort(jobs.begin(), jobs.end());\n    std::sort(workerAbility.begin(), workerAbility.end());\n\n    int jobIndex= 0, maxProfit= 0, totalProfit= 0;\n    for(int &ability : workerAbility)\n    {\n        while(jobIndex < jobDifficulty.size() && ability >= jobs[jobIndex].first)\n        {\n            maxProfit= std::max(maxProfit, jobs[jobIndex].second);\n            ++jobIndex;\n        }\n        totalProfit+= maxProfit;\n    }\n    return totalProfit;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateKSimilarity(const string &sourceString, const string &targetString)\n{\n    int swapCount= 0;\n    string modifiedString= sourceString;\n\n    for(int currentIndex= 0; currentIndex < modifiedString.length(); ++currentIndex)\n    {\n        if(modifiedString[currentIndex] != targetString[currentIndex])\n        {\n            int nextIndex= currentIndex + 1;\n            while(modifiedString[nextIndex] != targetString[currentIndex] || targetString[nextIndex] == modifiedString[nextIndex])\n            {\n                ++nextIndex;\n            }\n            swap(modifiedString[currentIndex], modifiedString[nextIndex]);\n            swapCount++;\n        }\n    }\n    return swapCount;\n}",
    "output": "int calculateKSimilarity(const std::string &sourceString, const std::string &targetString)\n{\n    int swapCount= 0;\n    std::string modifiedString= sourceString;\n\n    for(int currentIndex= 0; currentIndex < modifiedString.length(); ++currentIndex)\n    {\n        if(modifiedString[currentIndex] != targetString[currentIndex])\n        {\n            int nextIndex= currentIndex + 1;\n            while(modifiedString[nextIndex] != targetString[currentIndex] || targetString[nextIndex] == modifiedString[nextIndex])\n            {\n                ++nextIndex;\n            }\n            std::swap(modifiedString[currentIndex], modifiedString[nextIndex]);\n            swapCount++;\n        }\n    }\n    return swapCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countUniqueCharacters(const string &inputString)\n{\n    unordered_set<char> uniqueCharacters(inputString.begin(), inputString.end());\n    return uniqueCharacters.size();\n}\n\nint sumCountUniqueCharacters(const string &inputString)\n{\n    int totalSum= 0;\n    for(int startIndex= 0; startIndex < inputString.size(); ++startIndex)\n    {\n        for(int endIndex= startIndex + 1; endIndex <= inputString.size(); ++endIndex)\n        {\n            totalSum+= countUniqueCharacters(inputString.substr(startIndex, endIndex - startIndex));\n        }\n    }\n    return totalSum;\n}",
    "output": "#include <bits/stdc++.h>\nint countUniqueCharacters(const std::string &inputString)\n{\n    std::unordered_set<char> uniqueCharacters(inputString.begin(), inputString.end());\n    return uniqueCharacters.size();\n}\n\nint sumCountUniqueCharacters(const std::string &inputString)\n{\n    int totalSum= 0;\n    for(int startIndex= 0; startIndex < inputString.size(); ++startIndex)\n    {\n        for(int endIndex= startIndex + 1; endIndex <= inputString.size(); ++endIndex)\n        {\n            totalSum+= countUniqueCharacters(inputString.substr(startIndex, endIndex - startIndex));\n        }\n    }\n    return totalSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int consecutiveNumbersSum(int targetSum)\n{\n    int waysToExpress= 0;\n    for(int consecutiveCount= 1; consecutiveCount * (consecutiveCount - 1) / 2 < targetSum; consecutiveCount++)\n    {\n        if((targetSum - consecutiveCount * (consecutiveCount - 1) / 2) % consecutiveCount == 0)\n        {\n            waysToExpress++;\n        }\n    }\n    return waysToExpress;\n}",
    "output": "int consecutiveNumbersSum(int targetSum)\n{\n    int waysToExpress= 0;\n    for(int consecutiveCount= 1; consecutiveCount * (consecutiveCount - 1) / 2 < targetSum; consecutiveCount++)\n    {\n        if((targetSum - consecutiveCount * (consecutiveCount - 1) / 2) % consecutiveCount == 0)\n        {\n            waysToExpress++;\n        }\n    }\n    return waysToExpress;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> findLargeGroupPositions(string inputString)\n{\n    vector<vector<int>> largeGroupIndices;\n    int groupStartIndex= 0;\n    for(int currentIndex= 1; currentIndex < inputString.size(); ++currentIndex)\n    {\n        if(inputString[currentIndex] != inputString[groupStartIndex])\n        {\n            if(currentIndex - groupStartIndex >= 3)\n            {\n                largeGroupIndices.push_back({groupStartIndex, currentIndex - 1});\n            }\n            groupStartIndex= currentIndex;\n        }\n    }\n    if(inputString.size() - groupStartIndex >= 3)\n    {\n        largeGroupIndices.push_back({groupStartIndex, static_cast<int>(inputString.size()) - 1});\n    }\n    return largeGroupIndices;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> findLargeGroupPositions(std::string inputString)\n{\n    std::vector<std::vector<int>> largeGroupIndices;\n    int groupStartIndex= 0;\n    for(int currentIndex= 1; currentIndex < inputString.size(); ++currentIndex)\n    {\n        if(inputString[currentIndex] != inputString[groupStartIndex])\n        {\n            if(currentIndex - groupStartIndex >= 3)\n            {\n                largeGroupIndices.push_back({groupStartIndex, currentIndex - 1});\n            }\n            groupStartIndex= currentIndex;\n        }\n    }\n    if(inputString.size() - groupStartIndex >= 3)\n    {\n        largeGroupIndices.push_back({groupStartIndex, static_cast<int>(inputString.size()) - 1});\n    }\n    return largeGroupIndices;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring maskInformation(string inputString)\n{\n    if(inputString.find('@') != string::npos)\n    {\n        for(char &character : inputString)\n            character = tolower(character);\n        return inputString[0] + string(5, '*') + inputString.substr(inputString.find('@') - 1);\n    }\n    else\n    {\n        string digits = \"\";\n        for(int i = 0; i < inputString.length(); ++i)\n        {\n            char character = inputString[i];\n            if(isdigit(character))\n                digits += character;\n        }\n        if(digits.length() == 10)\n            return \"***-***-\" + digits.substr(6);\n        string prefix = string(digits.length() - 10, '*') + '-';\n        return '+' + prefix + \"***-***-\" + digits.substr(digits.length() - 4);\n    }\n}",
    "output": "#include <bits/stdc++.h>\nstd::string maskInformation(std::string inputString)\n{\n    if(inputString.find('@') != std::string::npos)\n    {\n        for(char &character : inputString)\n            character = std::tolower(character);\n        return inputString[0] + std::string(5, '*') + inputString.substr(inputString.find('@') - 1);\n    }\n    else\n    {\n        std::string digits = \"\";\n        for(char character : inputString)\n            if(std::isdigit(character))\n                digits += character;\n        if(digits.length() == 10)\n            return \"***-***-\" + digits.substr(6);\n        std::string prefix = std::string(digits.length() - 10, '*') + '-';\n        return '+' + prefix + \"***-***-\" + digits.substr(digits.length() - 4);\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass MyCircularDeque\n{\n  public:\n    vector<int> buffer;\n    int frontIndex, rearIndex, currentSize;\n\n    MyCircularDeque(int capacity)\n    {\n        buffer.resize(capacity);\n        frontIndex= 0;\n        rearIndex= 0;\n        currentSize= 0;\n    }\n\n    bool insertFront(int value)\n    {\n        if(currentSize == buffer.size())\n            return false;\n        frontIndex= (frontIndex - 1 + buffer.size()) % buffer.size();\n        buffer[frontIndex]= value;\n        currentSize++;\n        return true;\n    }\n\n    bool insertLast(int value)\n    {\n        if(currentSize == buffer.size())\n            return false;\n        buffer[rearIndex]= value;\n        rearIndex= (rearIndex + 1) % buffer.size();\n        currentSize++;\n        return true;\n    }\n\n    bool deleteFront()\n    {\n        if(currentSize == 0)\n            return false;\n        frontIndex= (frontIndex + 1) % buffer.size();\n        currentSize--;\n        return true;\n    }\n\n    bool deleteLast()\n    {\n        if(currentSize == 0)\n            return false;\n        rearIndex= (rearIndex - 1 + buffer.size()) % buffer.size();\n        currentSize--;\n        return true;\n    }\n\n    int getFront()\n    {\n        if(currentSize == 0)\n            return -1;\n        return buffer[frontIndex];\n    }\n\n    int getRear()\n    {\n        if(currentSize == 0)\n            return -1;\n        return buffer[(rearIndex - 1 + buffer.size()) % buffer.size()];\n    }\n\n    bool isEmpty()\n    {\n        return currentSize == 0;\n    }\n\n    bool isFull()\n    {\n        return currentSize == buffer.size();\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass MyCircularDeque\n{\n  public:\n    std::vector<int> buffer;\n    int frontIndex, rearIndex, currentSize;\n\n    MyCircularDeque(int capacity)\n    {\n        buffer.resize(capacity);\n        frontIndex= 0;\n        rearIndex= 0;\n        currentSize= 0;\n    }\n\n    bool insertFront(int value)\n    {\n        if(currentSize == buffer.size())\n            return false;\n        frontIndex= (frontIndex - 1 + buffer.size()) % buffer.size();\n        buffer[frontIndex]= value;\n        currentSize++;\n        return true;\n    }\n\n    bool insertLast(int value)\n    {\n        if(currentSize == buffer.size())\n            return false;\n        buffer[rearIndex]= value;\n        rearIndex= (rearIndex + 1) % buffer.size();\n        currentSize++;\n        return true;\n    }\n\n    bool deleteFront()\n    {\n        if(currentSize == 0)\n            return false;\n        frontIndex= (frontIndex + 1) % buffer.size();\n        currentSize--;\n        return true;\n    }\n\n    bool deleteLast()\n    {\n        if(currentSize == 0)\n            return false;\n        rearIndex= (rearIndex - 1 + buffer.size()) % buffer.size();\n        currentSize--;\n        return true;\n    }\n\n    int getFront()\n    {\n        if(currentSize == 0)\n            return -1;\n        return buffer[frontIndex];\n    }\n\n    int getRear()\n    {\n        if(currentSize == 0)\n            return -1;\n        return buffer[(rearIndex - 1 + buffer.size()) % buffer.size()];\n    }\n\n    bool isEmpty()\n    {\n        return currentSize == 0;\n    }\n\n    bool isFull()\n    {\n        return currentSize == buffer.size();\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass MyCircularQueue\n{\n  public:\n    MyCircularQueue(int queueCapacity)\n    {\n        queueData.resize(queueCapacity);\n        queueHead= 0;\n        queueTail= -1;\n        currentSize= 0;\n        capacity= queueCapacity;\n    }\n\n    bool enqueue(int value)\n    {\n        if(isFull())\n        {\n            return false;\n        }\n        queueTail= (queueTail + 1) % capacity;\n        queueData[queueTail]= value;\n        currentSize++;\n        return true;\n    }\n\n    bool dequeue()\n    {\n        if(isEmpty())\n        {\n            return false;\n        }\n        queueHead= (queueHead + 1) % capacity;\n        currentSize--;\n        return true;\n    }\n\n    int front()\n    {\n        if(isEmpty())\n        {\n            return -1;\n        }\n        return queueData[queueHead];\n    }\n\n    int rear()\n    {\n        if(isEmpty())\n        {\n            return -1;\n        }\n        return queueData[queueTail];\n    }\n\n    bool isEmpty()\n    {\n        return currentSize == 0;\n    }\n\n    bool isFull()\n    {\n        return currentSize == capacity;\n    }\n\n  private:\n    vector<int> queueData;\n    int queueHead, queueTail, currentSize, capacity;\n};",
    "output": "#include <bits/stdc++.h>\nclass MyCircularQueue\n{\n  public:\n    MyCircularQueue(int queueCapacity)\n    {\n        queueData.resize(queueCapacity);\n        queueHead = 0;\n        queueTail = -1;\n        currentSize = 0;\n        capacity = queueCapacity;\n    }\n\n    bool enqueue(int value)\n    {\n        if(isFull())\n        {\n            return false;\n        }\n        queueTail = (queueTail + 1) % capacity;\n        queueData[queueTail] = value;\n        currentSize++;\n        return true;\n    }\n\n    bool dequeue()\n    {\n        if(isEmpty())\n        {\n            return false;\n        }\n        queueHead = (queueHead + 1) % capacity;\n        currentSize--;\n        return true;\n    }\n\n    int front()\n    {\n        if(isEmpty())\n        {\n            return -1;\n        }\n        return queueData[queueHead];\n    }\n\n    int rear()\n    {\n        if(isEmpty())\n        {\n            return -1;\n        }\n        return queueData[queueTail];\n    }\n\n    bool isEmpty()\n    {\n        return currentSize == 0;\n    }\n\n    bool isFull()\n    {\n        return currentSize == capacity;\n    }\n\n  private:\n    std::vector<int> queueData;\n    int queueHead, queueTail, currentSize, capacity;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> flipAndInvertImage(vector<vector<int>> &image)\n{\n    for (int i = 0; i < image.size(); ++i)\n    {\n        reverse(image[i].begin(), image[i].end());\n        for (int j = 0; j < image[i].size(); ++j)\n        {\n            int &pixel = image[i][j];\n            pixel = 1 - pixel;\n        }\n    }\n    return image;\n}",
    "output": "#include <bits/stdc++.h>\n// Include this for std::reverse\n\nstd::vector<std::vector<int>> flipAndInvertImage(std::vector<std::vector<int>> &image)\n{\n    for(auto &row : image)\n    {\n        std::reverse(row.begin(), row.end());\n        for(int &pixel : row)\n        {\n            pixel= 1 - pixel;\n        }\n    }\n    return image;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring findReplaceString(string originalString, vector<int> &indices, vector<string> &sources, vector<string> &targets)\n{\n    vector<pair<int, int>> indexMapping(indices.size());\n\n    for(int index = 0; index < indices.size(); ++index)\n    {\n        if(originalString.substr(indices[index], sources[index].size()) == sources[index])\n        {\n            indexMapping[index] = {indices[index], index};\n        }\n        else\n        {\n            indexMapping[index] = {-1, index};\n        }\n    }\n\n    sort(indexMapping.begin(), indexMapping.end());\n    string modifiedString = \"\";\n    int lastIndex = 0;\n\n    for (int i = 0; i < indexMapping.size(); ++i)\n    {\n        const auto &pair = indexMapping[i];\n        if(pair.first >= 0)\n        {\n            modifiedString += originalString.substr(lastIndex, pair.first - lastIndex) + targets[pair.second];\n            lastIndex = pair.first + sources[pair.second].size();\n        }\n    }\n\n    modifiedString += originalString.substr(lastIndex);\n    return modifiedString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string findReplaceString(std::string originalString, std::vector<int> &indices, std::vector<std::string> &sources, std::vector<std::string> &targets)\n{\n    std::vector<std::pair<int, int>> indexMapping(indices.size());\n\n    for(int index= 0; index < indices.size(); ++index)\n    {\n        if(originalString.substr(indices[index], sources[index].size()) == sources[index])\n        {\n            indexMapping[index]= {indices[index], index};\n        }\n        else\n        {\n            indexMapping[index]= {-1, index};\n        }\n    }\n\n    sort(indexMapping.begin(), indexMapping.end());\n    std::string modifiedString= \"\";\n    int lastIndex= 0;\n\n    for(const auto &pair : indexMapping)\n    {\n        if(pair.first >= 0)\n        {\n            modifiedString+= originalString.substr(lastIndex, pair.first - lastIndex) + targets[pair.second];\n            lastIndex= pair.first + sources[pair.second].size();\n        }\n    }\n\n    modifiedString+= originalString.substr(lastIndex);\n    return modifiedString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> sumOfDistancesInTree(int numberOfNodes, vector<vector<int>> &edges)\n{\n    vector<vector<int>> adjacencyList(numberOfNodes);\n    vector<int> subtreeNodeCount(numberOfNodes);\n    vector<int> distanceSumResult(numberOfNodes);\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        const auto &edge = edges[i];\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    function<void(int, int)> dfs = [&](int currentNode, int parentNode)\n    {\n        for (int childNode : adjacencyList[currentNode])\n        {\n            if (childNode != parentNode)\n            {\n                dfs(childNode, currentNode);\n                subtreeNodeCount[currentNode] += subtreeNodeCount[childNode];\n                distanceSumResult[currentNode] += distanceSumResult[childNode] + subtreeNodeCount[childNode];\n            }\n        }\n        subtreeNodeCount[currentNode]++;\n    };\n\n    function<void(int, int)> dfs2 = [&](int currentNode, int parentNode)\n    {\n        for (int childNode : adjacencyList[currentNode])\n        {\n            if (childNode != parentNode)\n            {\n                distanceSumResult[childNode] = distanceSumResult[currentNode] - subtreeNodeCount[childNode] + numberOfNodes - subtreeNodeCount[childNode];\n                dfs2(childNode, currentNode);\n            }\n        }\n    };\n\n    dfs(0, -1);\n    dfs2(0, -1);\n\n    return distanceSumResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> sumOfDistancesInTree(int numberOfNodes, std::vector<std::vector<int>> &edges)\n{\n    std::vector<std::vector<int>> adjacencyList(numberOfNodes);\n    std::vector<int> subtreeNodeCount(numberOfNodes);\n    std::vector<int> distanceSumResult(numberOfNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    std::function<void(int, int)> dfs= [&](int currentNode, int parentNode)\n    {\n        for(int childNode : adjacencyList[currentNode])\n        {\n            if(childNode != parentNode)\n            {\n                dfs(childNode, currentNode);\n                subtreeNodeCount[currentNode]+= subtreeNodeCount[childNode];\n                distanceSumResult[currentNode]+= distanceSumResult[childNode] + subtreeNodeCount[childNode];\n            }\n        }\n        subtreeNodeCount[currentNode]++;\n    };\n\n    std::function<void(int, int)> dfs2= [&](int currentNode, int parentNode)\n    {\n        for(int childNode : adjacencyList[currentNode])\n        {\n            if(childNode != parentNode)\n            {\n                distanceSumResult[childNode]= distanceSumResult[currentNode] - subtreeNodeCount[childNode] + numberOfNodes - subtreeNodeCount[childNode];\n                dfs2(childNode, currentNode);\n            }\n        }\n    };\n\n    dfs(0, -1);\n    dfs2(0, -1);\n\n    return distanceSumResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint largestOverlap(vector<vector<int>> &firstImage, vector<vector<int>> &secondImage)\n{\n    int imageSize = firstImage.size();\n    vector<pair<int, int>> onesInFirstImage, onesInSecondImage;\n    for(int row = 0; row < imageSize; ++row)\n    {\n        for(int col = 0; col < imageSize; ++col)\n        {\n            if(firstImage[row][col])\n                onesInFirstImage.emplace_back(row, col);\n            if(secondImage[row][col])\n                onesInSecondImage.emplace_back(row, col);\n        }\n    }\n\n    unordered_map<int, int> overlapCount;\n    for(int i = 0; i < onesInFirstImage.size(); ++i)\n    {\n        const auto &pointInFirst = onesInFirstImage[i];\n        for(int j = 0; j < onesInSecondImage.size(); ++j)\n        {\n            const auto &pointInSecond = onesInSecondImage[j];\n            int deltaX = pointInSecond.first - pointInFirst.first;\n            int deltaY = pointInSecond.second - pointInFirst.second;\n            int key = (deltaX << 16) + deltaY;\n            ++overlapCount[key];\n        }\n    }\n\n    int maximumOverlap = 0;\n    for(const auto &overlapPair : overlapCount)\n    {\n        maximumOverlap = max(maximumOverlap, overlapPair.second);\n    }\n    return maximumOverlap;\n}",
    "output": "#include <bits/stdc++.h>\nint largestOverlap(std::vector<std::vector<int>> &firstImage, std::vector<std::vector<int>> &secondImage)\n{\n    int imageSize= firstImage.size();\n    std::vector<std::pair<int, int>> onesInFirstImage, onesInSecondImage;\n    for(int row= 0; row < imageSize; ++row)\n    {\n        for(int col= 0; col < imageSize; ++col)\n        {\n            if(firstImage[row][col])\n                onesInFirstImage.emplace_back(row, col);\n            if(secondImage[row][col])\n                onesInSecondImage.emplace_back(row, col);\n        }\n    }\n\n    std::unordered_map<int, int> overlapCount;\n    for(const auto &pointInFirst : onesInFirstImage)\n    {\n        for(const auto &pointInSecond : onesInSecondImage)\n        {\n            int deltaX= pointInSecond.first - pointInFirst.first;\n            int deltaY= pointInSecond.second - pointInFirst.second;\n            int key= (deltaX << 16) + deltaY;\n            ++overlapCount[key];\n        }\n    }\n\n    int maximumOverlap= 0;\n    for(const auto &overlapPair : overlapCount)\n    {\n        maximumOverlap= std::max(maximumOverlap, overlapPair.second);\n    }\n    return maximumOverlap;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : value(x), left(NULL), right(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    TreeNode *subtreeWithAllDeepest(TreeNode *root)\n    {\n        return findDeepest(root).first;\n    }\n\n  private:\n    pair<TreeNode *, int> findDeepest(TreeNode *currentNode)\n    {\n        if(currentNode == NULL)\n            return {NULL, 0};\n        auto leftDeepest = findDeepest(currentNode->left);\n        auto rightDeepest = findDeepest(currentNode->right);\n        if(leftDeepest.second == rightDeepest.second)\n        {\n            return {currentNode, leftDeepest.second + 1};\n        }\n        return leftDeepest.second > rightDeepest.second ? make_pair(leftDeepest.first, leftDeepest.second + 1) : make_pair(rightDeepest.first, rightDeepest.second + 1);\n    }\n};",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : value(x), left(NULL), right(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    TreeNode *subtreeWithAllDeepest(TreeNode *root)\n    {\n        return findDeepest(root).first;\n    }\n\n  private:\n    std::pair<TreeNode *, int> findDeepest(TreeNode *currentNode)\n    {\n        if(currentNode == NULL)\n            return {NULL, 0};\n        auto leftDeepest= findDeepest(currentNode->left);\n        auto rightDeepest= findDeepest(currentNode->right);\n        if(leftDeepest.second == rightDeepest.second)\n        {\n            return {currentNode, leftDeepest.second + 1};\n        }\n        return leftDeepest.second > rightDeepest.second ? std::make_pair(leftDeepest.first, leftDeepest.second + 1) : std::make_pair(rightDeepest.first, rightDeepest.second + 1);\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isRectangleOverlap(vector<int> &rectangle1, vector<int> &rectangle2)\n{\n    return rectangle1[2] > rectangle2[0] && rectangle1[3] > rectangle2[1] && rectangle1[0] < rectangle2[2] && rectangle1[1] < rectangle2[3];\n}",
    "output": "#include <bits/stdc++.h>\nbool isRectangleOverlap(std::vector<int> &rectangle1, std::vector<int> &rectangle2)\n{\n    return rectangle1[2] > rectangle2[0] && rectangle1[3] > rectangle2[1] && rectangle1[0] < rectangle2[2] && rectangle1[1] < rectangle2[3];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble new21Game(int totalPoints, int targetPoints, int maxPoints)\n{\n    if(targetPoints == 0 || totalPoints >= targetPoints + maxPoints)\n    {\n        return 1;\n    }\n\n    vector<double> probabilityDistribution(totalPoints + 1, 0);\n    probabilityDistribution[0]= 1;\n    double currentSum= 1, result= 0;\n\n    for(int currentScore= 1; currentScore <= totalPoints; ++currentScore)\n    {\n        probabilityDistribution[currentScore]= currentSum / maxPoints;\n        if(currentScore < targetPoints)\n        {\n            currentSum+= probabilityDistribution[currentScore];\n        }\n        else\n        {\n            result+= probabilityDistribution[currentScore];\n        }\n        if(currentScore >= maxPoints)\n        {\n            currentSum-= probabilityDistribution[currentScore - maxPoints];\n        }\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\ndouble new21Game(int totalPoints, int targetPoints, int maxPoints)\n{\n    if(targetPoints == 0 || totalPoints >= targetPoints + maxPoints)\n    {\n        return 1;\n    }\n\n    std::vector<double> probabilityDistribution(totalPoints + 1, 0);\n    probabilityDistribution[0] = 1;\n    double currentSum = 1, result = 0;\n\n    for(int currentScore = 1; currentScore <= totalPoints; ++currentScore)\n    {\n        probabilityDistribution[currentScore] = currentSum / maxPoints;\n        if(currentScore < targetPoints)\n        {\n            currentSum += probabilityDistribution[currentScore];\n        }\n        else\n        {\n            result += probabilityDistribution[currentScore];\n        }\n        if(currentScore >= maxPoints)\n        {\n            currentSum -= probabilityDistribution[currentScore - maxPoints];\n        }\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring pushDominoes(string dominoes)\n{\n    int dominoesCount= dominoes.size();\n    string previousState, currentState= dominoes;\n    do\n    {\n        previousState= currentState;\n        for(int index= 0; index < dominoesCount; ++index)\n        {\n            if(previousState[index] == 'L' && index > 0 && previousState[index - 1] == '.')\n                currentState[index - 1]= 'L';\n            else if(previousState[index] == 'R' && index < dominoesCount - 1 && previousState[index + 1] == '.')\n                currentState[index + 1]= 'R';\n        }\n    } while(previousState != currentState);\n    return currentState;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string pushDominoes(std::string dominoes)\n{\n    int dominoesCount = dominoes.size();\n    std::string previousState, currentState = dominoes;\n    do\n    {\n        previousState = currentState;\n        for(int index = 0; index < dominoesCount; ++index)\n        {\n            if(previousState[index] == 'L' && index > 0 && previousState[index - 1] == '.')\n                currentState[index - 1] = 'L';\n            else if(previousState[index] == 'R' && index < dominoesCount - 1 && previousState[index + 1] == '.')\n                currentState[index + 1] = 'R';\n        }\n    } while(previousState != currentState);\n    return currentState;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isSimilar(const string &firstString, const string &secondString)\n{\n    int differenceCount= 0;\n    for(int index= 0; index < firstString.size(); ++index)\n    {\n        if(firstString[index] != secondString[index])\n        {\n            ++differenceCount;\n            if(differenceCount > 2)\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint countGroups(vector<string> &stringList)\n{\n    int groupCount= 0;\n    vector<bool> visited(stringList.size(), false);\n    for(int outerIndex= 0; outerIndex < stringList.size(); ++outerIndex)\n    {\n        if(!visited[outerIndex])\n        {\n            ++groupCount;\n            visited[outerIndex]= true;\n            for(int innerIndex= outerIndex + 1; innerIndex < stringList.size(); ++innerIndex)\n            {\n                if(isSimilar(stringList[outerIndex], stringList[innerIndex]))\n                {\n                    visited[innerIndex]= true;\n                }\n            }\n        }\n    }\n    return groupCount;\n}",
    "output": "#include <bits/stdc++.h>\nbool isSimilar(const std::string &firstString, const std::string &secondString)\n{\n    int differenceCount= 0;\n    for(int index= 0; index < firstString.size(); ++index)\n    {\n        if(firstString[index] != secondString[index])\n        {\n            ++differenceCount;\n            if(differenceCount > 2)\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint countGroups(std::vector<std::string> &stringList)\n{\n    int groupCount= 0;\n    std::vector<bool> visited(stringList.size(), false);\n    for(int outerIndex= 0; outerIndex < stringList.size(); ++outerIndex)\n    {\n        if(!visited[outerIndex])\n        {\n            ++groupCount;\n            visited[outerIndex]= true;\n            for(int innerIndex= outerIndex + 1; innerIndex < stringList.size(); ++innerIndex)\n            {\n                if(isSimilar(stringList[outerIndex], stringList[innerIndex]))\n                {\n                    visited[innerIndex]= true;\n                }\n            }\n        }\n    }\n    return groupCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> advantageCount(vector<int> &firstArray, vector<int> &secondArray)\n{\n    multiset<int> sortedElements(firstArray.begin(), firstArray.end());\n    vector<int> result;\n    for (int i = 0; i < secondArray.size(); ++i)\n    {\n        int element = secondArray[i];\n        auto iterator = sortedElements.upper_bound(element);\n        if (iterator == sortedElements.end())\n            iterator = sortedElements.begin();\n        result.push_back(*iterator);\n        sortedElements.erase(iterator);\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> advantageCount(std::vector<int> &firstArray, std::vector<int> &secondArray)\n{\n    std::multiset<int> sortedElements(firstArray.begin(), firstArray.end());\n    std::vector<int> result;\n    for(int element : secondArray)\n    {\n        auto iterator= sortedElements.upper_bound(element);\n        if(iterator == sortedElements.end())\n            iterator= sortedElements.begin();\n        result.push_back(*iterator);\n        sortedElements.erase(iterator);\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canVisitAllRooms(const vector<vector<int>> &rooms)\n{\n    unordered_set<int> visitedRooms;\n    vector<int> roomStack = {0};\n\n    while (!roomStack.empty())\n    {\n        int currentRoom = roomStack.back();\n        roomStack.pop_back();\n\n        visitedRooms.insert(currentRoom);\n\n        for (int i = 0; i < rooms[currentRoom].size(); ++i)\n        {\n            int key = rooms[currentRoom][i];\n            if (!visitedRooms.count(key))\n            {\n                roomStack.push_back(key);\n            }\n        }\n    }\n\n    return visitedRooms.size() == rooms.size();\n}",
    "output": "#include <bits/stdc++.h>\nbool canVisitAllRooms(const std::vector<std::vector<int>> &rooms)\n{\n    std::unordered_set<int> visitedRooms;\n    std::vector<int> roomStack= {0};\n\n    while(!roomStack.empty())\n    {\n        int currentRoom= roomStack.back();\n        roomStack.pop_back();\n\n        visitedRooms.insert(currentRoom);\n\n        for(int key : rooms[currentRoom])\n        {\n            if(!visitedRooms.count(key))\n            {\n                roomStack.push_back(key);\n            }\n        }\n    }\n\n    return visitedRooms.size() == rooms.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> splitIntoFibonacci(string number)\n{\n    vector<int> fibonacciSequence;\n    backtrack(number, fibonacciSequence, 0, 0, 0);\n    return fibonacciSequence;\n}\n\nbool backtrack(string &number, vector<int> &fibonacciSequence, int currentIndex, int previousValue1, int previousValue2)\n{\n    if(currentIndex == number.size())\n    {\n        return fibonacciSequence.size() >= 3;\n    }\n    long currentValue = 0;\n    for(int index = currentIndex; index < number.size(); ++index)\n    {\n        if(index > currentIndex && number[currentIndex] == '0')\n        {\n            break;\n        }\n        currentValue = currentValue * 10 + number[index] - '0';\n        if(currentValue > INT32_MAX)\n        {\n            break;\n        }\n\n        if(fibonacciSequence.size() >= 2)\n        {\n            long sum = (long)previousValue1 + previousValue2;\n            if(currentValue < sum)\n            {\n                continue;\n            }\n            else if(currentValue > sum)\n            {\n                break;\n            }\n        }\n\n        fibonacciSequence.push_back(currentValue);\n        if(backtrack(number, fibonacciSequence, index + 1, previousValue2, currentValue))\n        {\n            return true;\n        }\n        fibonacciSequence.pop_back();\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> splitIntoFibonacci(std::string number)\n{\n    std::vector<int> fibonacciSequence;\n    backtrack(number, fibonacciSequence, 0, 0, 0);\n    return fibonacciSequence;\n}\n\nbool backtrack(std::string &number, std::vector<int> &fibonacciSequence, int currentIndex, int previousValue1, int previousValue2)\n{\n    if(currentIndex == number.size())\n    {\n        return fibonacciSequence.size() >= 3;\n    }\n    long currentValue= 0;\n    for(int index= currentIndex; index < number.size(); ++index)\n    {\n        if(index > currentIndex && number[currentIndex] == '0')\n        {\n            break;\n        }\n        currentValue= currentValue * 10 + number[index] - '0';\n        if(currentValue > INT32_MAX)\n        {\n            break;\n        }\n\n        if(fibonacciSequence.size() >= 2)\n        {\n            long sum= (long)previousValue1 + previousValue2;\n            if(currentValue < sum)\n            {\n                continue;\n            }\n            else if(currentValue > sum)\n            {\n                break;\n            }\n        }\n\n        fibonacciSequence.push_back(currentValue);\n        if(backtrack(number, fibonacciSequence, index + 1, previousValue2, currentValue))\n        {\n            return true;\n        }\n        fibonacciSequence.pop_back();\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint match(const string &secretWord, const string &guessedWord)\n{\n    int matchCount = 0;\n    for(int index = 0; index < 6; ++index)\n        if(secretWord[index] == guessedWord[index])\n            matchCount++;\n    return matchCount;\n}\n\nvoid findSecretWord(vector<string> &wordList, Master &master)\n{\n    int wordCount = wordList.size();\n    for(int attempt = 0, matchCount = 0; attempt < 10 && matchCount < 6; ++attempt)\n    {\n        string guessedWord = wordList[rand() % wordCount];\n        matchCount = master.guess(guessedWord);\n        vector<string> candidates;\n        for(int i = 0; i < wordList.size(); ++i)\n        {\n            const string &candidateWord = wordList[i];\n            if(match(candidateWord, guessedWord) == matchCount)\n                candidates.push_back(candidateWord);\n        }\n        wordList = candidates;\n        wordCount = wordList.size();\n    }\n}",
    "output": "#include <bits/stdc++.h>\nint match(const std::string &secretWord, const std::string &guessedWord)\n{\n    int matchCount= 0;\n    for(int index= 0; index < 6; ++index)\n        if(secretWord[index] == guessedWord[index])\n            matchCount++;\n    return matchCount;\n}\n\nvoid findSecretWord(std::vector<std::string> &wordList, Master &master)\n{\n    int wordCount= wordList.size();\n    for(int attempt= 0, matchCount= 0; attempt < 10 && matchCount < 6; ++attempt)\n    {\n        std::string guessedWord= wordList[rand() % wordCount];\n        matchCount= master.guess(guessedWord);\n        std::vector<std::string> candidates;\n        for(const std::string &candidateWord : wordList)\n            if(match(candidateWord, guessedWord) == matchCount)\n                candidates.push_back(candidateWord);\n        wordList= candidates;\n        wordCount= wordList.size();\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool backspaceCompare(string firstString, string secondString)\n{\n    stack<char> firstStack, secondStack;\n\n    for (int i = 0; i < firstString.size(); ++i)\n    {\n        char currentChar = firstString[i];\n        if (currentChar != '#')\n        {\n            firstStack.push(currentChar);\n        }\n        else if (!firstStack.empty())\n        {\n            firstStack.pop();\n        }\n    }\n\n    for (int i = 0; i < secondString.size(); ++i)\n    {\n        char currentChar = secondString[i];\n        if (currentChar != '#')\n        {\n            secondStack.push(currentChar);\n        }\n        else if (!secondStack.empty())\n        {\n            secondStack.pop();\n        }\n    }\n\n    return firstStack == secondStack;\n}",
    "output": "#include <bits/stdc++.h>\nbool backspaceCompare(std::string firstString, std::string secondString)\n{\n    std::stack<char> firstStack, secondStack;\n\n    for(char currentChar : firstString)\n    {\n        if(currentChar != '#')\n        {\n            firstStack.push(currentChar);\n        }\n        else if(!firstStack.empty())\n        {\n            firstStack.pop();\n        }\n    }\n\n    for(char currentChar : secondString)\n    {\n        if(currentChar != '#')\n        {\n            secondStack.push(currentChar);\n        }\n        else if(!secondStack.empty())\n        {\n            secondStack.pop();\n        }\n    }\n\n    return firstStack == secondStack;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint longestMountain(vector<int> &elevations)\n{\n    int size = elevations.size();\n    int longestLength = 0;\n    int currentIndex = 1;\n    while(currentIndex < size - 1)\n    {\n        if(elevations[currentIndex - 1] < elevations[currentIndex] && elevations[currentIndex] > elevations[currentIndex + 1])\n        {\n            int leftBoundary = currentIndex - 1;\n            int rightBoundary = currentIndex + 1;\n            while(leftBoundary > 0 && elevations[leftBoundary - 1] < elevations[leftBoundary])\n            {\n                leftBoundary--;\n            }\n            while(rightBoundary < size - 1 && elevations[rightBoundary] > elevations[rightBoundary + 1])\n            {\n                rightBoundary++;\n            }\n            longestLength = max(longestLength, rightBoundary - leftBoundary + 1);\n            currentIndex = rightBoundary;\n        }\n        else\n        {\n            currentIndex++;\n        }\n    }\n    return longestLength;\n}",
    "output": "#include <bits/stdc++.h>\nint longestMountain(std::vector<int> &elevations)\n{\n    int size= elevations.size();\n    int longestLength= 0;\n    int currentIndex= 1;\n    while(currentIndex < size - 1)\n    {\n        if(elevations[currentIndex - 1] < elevations[currentIndex] && elevations[currentIndex] > elevations[currentIndex + 1])\n        {\n            int leftBoundary= currentIndex - 1;\n            int rightBoundary= currentIndex + 1;\n            while(leftBoundary > 0 && elevations[leftBoundary - 1] < elevations[leftBoundary])\n            {\n                leftBoundary--;\n            }\n            while(rightBoundary < size - 1 && elevations[rightBoundary] > elevations[rightBoundary + 1])\n            {\n                rightBoundary++;\n            }\n            longestLength= std::max(longestLength, rightBoundary - leftBoundary + 1);\n            currentIndex= rightBoundary;\n        }\n        else\n        {\n            currentIndex++;\n        }\n    }\n    return longestLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isNStraightHand(vector<int> &cardHand, int groupSize)\n{\n    map<int, int> cardCounts;\n\n    for (int card : cardHand)\n    {\n        cardCounts[card]++;\n    }\n\n    for (auto iterator = cardCounts.begin(); iterator != cardCounts.end(); ++iterator)\n    {\n        if (iterator->second > 0)\n        {\n            for (int index = groupSize - 1; index >= 0; --index)\n            {\n                if (cardCounts[iterator->first + index] < iterator->second)\n                {\n                    return false;\n                }\n                cardCounts[iterator->first + index] -= iterator->second;\n            }\n        }\n    }\n\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isNStraightHand(std::vector<int> &cardHand, int groupSize)\n{\n    std::map<int, int> cardCounts;\n\n    for(int card : cardHand)\n    {\n        cardCounts[card]++;\n    }\n\n    for(auto iterator= cardCounts.begin(); iterator != cardCounts.end(); ++iterator)\n    {\n        if(iterator->second > 0)\n        {\n            for(int index= groupSize - 1; index >= 0; --index)\n            {\n                if(cardCounts[iterator->first + index] < iterator->second)\n                {\n                    return false;\n                }\n                cardCounts[iterator->first + index]-= iterator->second;\n            }\n        }\n    }\n\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPathLength(vector<vector<int>> &graph)\n{\n    int numberOfNodes = graph.size();\n    queue<pair<int, bitset<12>>> nodeQueue;\n\n    for (int nodeIndex = 0; nodeIndex < numberOfNodes; nodeIndex++)\n    {\n        nodeQueue.push({nodeIndex, 1 << nodeIndex});\n    }\n    int steps = -1;\n    vector<vector<bool>> visited(numberOfNodes, vector<bool>(1 << numberOfNodes));\n\n    while (!nodeQueue.empty())\n    {\n        steps++;\n        int queueSize = nodeQueue.size();\n\n        for (int k = 0; k < queueSize; k++)\n        {\n            int currentNode = nodeQueue.front().first;\n            bitset<12> currentVisits = nodeQueue.front().second;\n            nodeQueue.pop();\n\n            if (currentVisits.count() == numberOfNodes)\n                return steps;\n\n            for (int j = 0; j < graph[currentNode].size(); j++)\n            {\n                int nextNode = graph[currentNode][j];\n                bitset<12> nextVisits = currentVisits;\n                nextVisits.set(nextNode);\n\n                if (!visited[nextNode][nextVisits.to_ulong()])\n                {\n                    visited[nextNode][nextVisits.to_ulong()] = true;\n                    nodeQueue.push({nextNode, nextVisits});\n                }\n            }\n        }\n    }\n\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint shortestPathLength(std::vector<std::vector<int>> &graph)\n{\n    int numberOfNodes = graph.size();\n    std::queue<std::pair<int, std::bitset<12>>> nodeQueue;\n\n    for(int nodeIndex = 0; nodeIndex < numberOfNodes; nodeIndex++)\n    {\n        nodeQueue.push({nodeIndex, 1 << nodeIndex});\n    }\n    int steps = -1;\n    std::vector<std::vector<bool>> visited(numberOfNodes, std::vector<bool>(1 << numberOfNodes));\n\n    while(!nodeQueue.empty())\n    {\n        steps++;\n        int queueSize = nodeQueue.size();\n\n        for(int k = 0; k < queueSize; k++)\n        {\n            int currentNode = nodeQueue.front().first;\n            std::bitset<12> currentVisits = nodeQueue.front().second;\n            nodeQueue.pop();\n\n            if(currentVisits.count() == numberOfNodes)\n                return steps;\n\n            for(int nextNode : graph[currentNode])\n            {\n                std::bitset<12> nextVisits = currentVisits;\n                nextVisits.set(nextNode);\n\n                if(!visited[nextNode][nextVisits.to_ulong()])\n                {\n                    visited[nextNode][nextVisits.to_ulong()] = true;\n                    nodeQueue.push({nextNode, nextVisits});\n                }\n            }\n        }\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring shiftingLetters(string inputString, vector<int> &shiftValues)\n{\n    int stringLength = inputString.size();\n    for(int index = stringLength - 2; index >= 0; index--)\n    {\n        shiftValues[index] = (shiftValues[index] + shiftValues[index + 1]) % 26;\n    }\n\n    for(int index = 0; index < stringLength; index++)\n    {\n        inputString[index] = (inputString[index] - 'a' + shiftValues[index]) % 26 + 'a';\n    }\n\n    return inputString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string shiftingLetters(std::string inputString, std::vector<int> &shiftValues)\n{\n    int stringLength= inputString.size();\n    for(int index= stringLength - 2; index >= 0; index--)\n    {\n        shiftValues[index]= (shiftValues[index] + shiftValues[index + 1]) % 26;\n    }\n\n    for(int index= 0; index < stringLength; index++)\n    {\n        inputString[index]= (inputString[index] - 'a' + shiftValues[index]) % 26 + 'a';\n    }\n\n    return inputString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxDistanceToClosest(vector<int> &seats)\n{\n    int maxDistance= 0, lastPersonIndex= -1;\n    for(int currentIndex= 0; currentIndex < seats.size(); ++currentIndex)\n    {\n        if(seats[currentIndex] == 1)\n        {\n            maxDistance= lastPersonIndex < 0 ? currentIndex : max(maxDistance, (currentIndex - lastPersonIndex) / 2);\n            lastPersonIndex= currentIndex;\n        }\n    }\n    return max(maxDistance, (int)(seats.size() - 1 - lastPersonIndex));\n}",
    "output": "#include <bits/stdc++.h>\nint maxDistanceToClosest(std::vector<int> &seats)\n{\n    int maxDistance= 0, lastPersonIndex= -1;\n    for(int currentIndex= 0; currentIndex < seats.size(); ++currentIndex)\n    {\n        if(seats[currentIndex] == 1)\n        {\n            maxDistance= lastPersonIndex < 0 ? currentIndex : std::max(maxDistance, (currentIndex - lastPersonIndex) / 2);\n            lastPersonIndex= currentIndex;\n        }\n    }\n    return std::max(maxDistance, (int)(seats.size() - 1 - lastPersonIndex));\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint rectangleArea(vector<vector<int>> &rectangles)\n{\n    int modulus = 1e9 + 7;\n    vector<int> xCoordinates;\n    map<int, int> xCoordinateCompression;\n    \n    for (int i = 0; i < rectangles.size(); ++i)\n    {\n        xCoordinates.push_back(rectangles[i][0]);\n        xCoordinates.push_back(rectangles[i][2]);\n    }\n    \n    sort(xCoordinates.begin(), xCoordinates.end());\n    int index = 0;\n    for (auto x : xCoordinates)\n    {\n        if (!xCoordinateCompression.count(x))\n            xCoordinateCompression[x] = index++;\n    }\n\n    vector<vector<int>> events;\n    for (int i = 0; i < rectangles.size(); ++i)\n    {\n        events.push_back({xCoordinateCompression[rectangles[i][0]], 1, rectangles[i][1], rectangles[i][3]});\n        events.push_back({xCoordinateCompression[rectangles[i][2]], -1, rectangles[i][1], rectangles[i][3]});\n    }\n    sort(events.begin(), events.end());\n\n    int area = 0;\n    vector<int> count(index, 0);\n    int activeCount = 0;\n    for (int i = 0; i < events.size(); ++i)\n    {\n        auto event = events[i];\n        int xIndex = event[0], eventType = event[1], y1 = event[2], y2 = event[3];\n        area = (area + (long long)(xCoordinates[xIndex + 1] - xCoordinates[xIndex]) * activeCount % modulus) % modulus;\n        count[y1] += eventType;\n        count[y2] -= eventType;\n        activeCount = 0;\n        for (int j = 0; j < index; ++j)\n        {\n            if (count[j])\n                activeCount += xCoordinates[j + 1] - xCoordinates[j];\n        }\n    }\n    return area;\n}",
    "output": "#include <bits/stdc++.h>\nint rectangleArea(std::vector<std::vector<int>> &rectangles)\n{\n    int modulus= 1e9 + 7;\n    std::vector<int> xCoordinates;\n    std::map<int, int> xCoordinateCompression;\n    for(auto rectangle : rectangles)\n    {\n        xCoordinates.push_back(rectangle[0]);\n        xCoordinates.push_back(rectangle[2]);\n    }\n    std::sort(xCoordinates.begin(), xCoordinates.end());\n    int index= 0;\n    for(auto x : xCoordinates)\n    {\n        if(!xCoordinateCompression.count(x))\n            xCoordinateCompression[x]= index++;\n    }\n\n    std::vector<std::vector<int>> events;\n    for(auto rectangle : rectangles)\n    {\n        events.push_back({xCoordinateCompression[rectangle[0]], 1, rectangle[1], rectangle[3]});\n        events.push_back({xCoordinateCompression[rectangle[2]], -1, rectangle[1], rectangle[3]});\n    }\n    std::sort(events.begin(), events.end());\n\n    int area= 0;\n    std::vector<int> count(index, 0);\n    int activeCount= 0;\n    for(auto event : events)\n    {\n        int xIndex= event[0], eventType= event[1], y1= event[2], y2= event[3];\n        area= (area + (long long)(xCoordinates[xIndex + 1] - xCoordinates[xIndex]) * activeCount % modulus) % modulus;\n        count[y1]+= eventType;\n        count[y2]-= eventType;\n        activeCount= 0;\n        for(int i= 0; i < xIndex; ++i)\n        {\n            if(count[i])\n                activeCount+= xCoordinates[i + 1] - xCoordinates[i];\n        }\n    }\n    return area;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(int currentPerson, vector<vector<int>> &wealthGraph, vector<int> &quietness, vector<int> &result)\n{\n    if(result[currentPerson] != -1)\n        return;\n    result[currentPerson] = currentPerson;\n\n    for(int i = 0; i < wealthGraph[currentPerson].size(); ++i)\n    {\n        int richerPerson = wealthGraph[currentPerson][i];\n        depthFirstSearch(richerPerson, wealthGraph, quietness, result);\n        if(quietness[result[richerPerson]] < quietness[result[currentPerson]])\n            result[currentPerson] = result[richerPerson];\n    }\n}\n\nvector<int> loudAndRich(vector<vector<int>> &richer, vector<int> &quiet)\n{\n    int numberOfPeople = quiet.size();\n    vector<vector<int>> wealthGraph(numberOfPeople);\n    for(auto &relationship : richer)\n        wealthGraph[relationship[1]].push_back(relationship[0]);\n\n    vector<int> result(numberOfPeople, -1);\n    for(int i = 0; i < numberOfPeople; ++i)\n        depthFirstSearch(i, wealthGraph, quiet, result);\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nvoid depthFirstSearch(int currentPerson, std::vector<std::vector<int>> &wealthGraph, std::vector<int> &quietness, std::vector<int> &result)\n{\n    if(result[currentPerson] != -1)\n        return;\n    result[currentPerson]= currentPerson;\n\n    for(int richerPerson : wealthGraph[currentPerson])\n    {\n        depthFirstSearch(richerPerson, wealthGraph, quietness, result);\n        if(quietness[result[richerPerson]] < quietness[result[currentPerson]])\n            result[currentPerson]= result[richerPerson];\n    }\n}\n\nstd::vector<int> loudAndRich(std::vector<std::vector<int>> &richer, std::vector<int> &quiet)\n{\n    int numberOfPeople= quiet.size();\n    std::vector<std::vector<int>> wealthGraph(numberOfPeople);\n    for(auto &relationship : richer)\n        wealthGraph[relationship[1]].push_back(relationship[0]);\n\n    std::vector<int> result(numberOfPeople, -1);\n    for(int i= 0; i < numberOfPeople; ++i)\n        depthFirstSearch(i, wealthGraph, quiet, result);\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint peakIndexInMountainArray(vector<int> &mountainArray)\n{\n    int lowIndex= 0, highIndex= mountainArray.size() - 1;\n    while(lowIndex < highIndex)\n    {\n        int midIndex= lowIndex + (highIndex - lowIndex) / 2;\n        if(mountainArray[midIndex] < mountainArray[midIndex + 1])\n            lowIndex= midIndex + 1;\n        else\n            highIndex= midIndex;\n    }\n    return lowIndex;\n}",
    "output": "#include <bits/stdc++.h>\nint peakIndexInMountainArray(std::vector<int> &mountainArray)\n{\n    int lowIndex= 0, highIndex= mountainArray.size() - 1;\n    while(lowIndex < highIndex)\n    {\n        int midIndex= lowIndex + (highIndex - lowIndex) / 2;\n        if(mountainArray[midIndex] < mountainArray[midIndex + 1])\n            lowIndex= midIndex + 1;\n        else\n            highIndex= midIndex;\n    }\n    return lowIndex;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint carFleet(int target, vector<int> &carPosition, vector<int> &carSpeed)\n{\n    int numberOfCars= carPosition.size();\n    vector<pair<int, int>> cars;\n    for(int i= 0; i < numberOfCars; ++i)\n    {\n        cars.emplace_back(carPosition[i], carSpeed[i]);\n    }\n    sort(cars.begin(), cars.end(), [](const pair<int, int> &a, const pair<int, int> &b)\n         { return a.first > b.first; });\n\n    int numberOfFleets= 0;\n    double lastArrivalTime= -1;\n    for(int i= 0; i < numberOfCars; ++i)\n    {\n        double arrivalTime= static_cast<double>(target - cars[i].first) / cars[i].second;\n        if(arrivalTime > lastArrivalTime)\n        {\n            ++numberOfFleets;\n            lastArrivalTime= arrivalTime;\n        }\n    }\n\n    return numberOfFleets;\n}",
    "output": "#include <bits/stdc++.h>\nint carFleet(int target, std::vector<int> &carPosition, std::vector<int> &carSpeed)\n{\n    int numberOfCars= carPosition.size();\n    std::vector<std::pair<int, int>> cars;\n    for(int i= 0; i < numberOfCars; ++i)\n    {\n        cars.emplace_back(carPosition[i], carSpeed[i]);\n    }\n    std::sort(cars.begin(), cars.end(), [](const std::pair<int, int> &a, const std::pair<int, int> &b)\n         { return a.first > b.first; });\n\n    int numberOfFleets= 0;\n    double lastArrivalTime= -1;\n    for(int i= 0; i < numberOfCars; ++i)\n    {\n        double arrivalTime= static_cast<double>(target - cars[i].first) / cars[i].second;\n        if(arrivalTime > lastArrivalTime)\n        {\n            ++numberOfFleets;\n            lastArrivalTime= arrivalTime;\n        }\n    }\n\n    return numberOfFleets;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "using namespace std;\n\nint calculateKSimilarity(const string &sourceString, const string &targetString)\n{\n    int swapCount = 0;\n    string modifiedSource = sourceString, modifiedTarget = targetString;\n    for(int i = 0; i < modifiedSource.size(); ++i)\n    {\n        if(modifiedSource[i] != modifiedTarget[i])\n        {\n            for(int j = i + 1; j < modifiedTarget.size(); ++j)\n            {\n                if(modifiedSource[i] == modifiedTarget[j] && modifiedSource[j] != modifiedTarget[j])\n                {\n                    swap(modifiedSource[i], modifiedSource[j]);\n                    swapCount++;\n                    break;\n                }\n            }\n        }\n    }\n    return swapCount;\n}",
    "output": "int calculateKSimilarity(const std::string &sourceString, const std::string &targetString)\n{\n    int swapCount= 0;\n    std::string modifiedSource= sourceString, modifiedTarget= targetString;\n    for(int i= 0; i < modifiedSource.size(); ++i)\n    {\n        if(modifiedSource[i] != modifiedTarget[i])\n        {\n            for(int j= i + 1; j < modifiedTarget.size(); ++j)\n            {\n                if(modifiedSource[i] == modifiedTarget[j] && modifiedSource[j] != modifiedTarget[j])\n                {\n                    std::swap(modifiedSource[i], modifiedSource[j]);\n                    swapCount++;\n                    break;\n                }\n            }\n        }\n    }\n    return swapCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass ExamRoom\n{\n  public:\n    set<int> occupiedSeats;\n    int roomCapacity;\n\n    ExamRoom(int capacity)\n    {\n        this->roomCapacity = capacity;\n    }\n\n    int seat()\n    {\n        if (occupiedSeats.empty())\n        {\n            occupiedSeats.insert(0);\n            return 0;\n        }\n\n        int maxDistance = *occupiedSeats.begin(), seatIndex = 0;\n\n        for (auto itr = next(occupiedSeats.begin()); itr != occupiedSeats.end(); ++itr)\n        {\n            auto prev = prev(itr);\n            int distance = (*itr - *prev) / 2;\n\n            if (distance > maxDistance)\n            {\n                maxDistance = distance;\n                seatIndex = *prev + distance;\n            }\n        }\n\n        if (roomCapacity - 1 - *occupiedSeats.rbegin() > maxDistance)\n            seatIndex = roomCapacity - 1;\n\n        occupiedSeats.insert(seatIndex);\n        return seatIndex;\n    }\n\n    void leave(int seatPosition)\n    {\n        occupiedSeats.erase(seatPosition);\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass ExamRoom\n{\n  public:\n    std::set<int> occupiedSeats;\n    int roomCapacity;\n\n    ExamRoom(int capacity)\n    {\n        this->roomCapacity= capacity;\n    }\n\n    int seat()\n    {\n        if(occupiedSeats.empty())\n        {\n            occupiedSeats.insert(0);\n            return 0;\n        }\n\n        int maxDistance= *occupiedSeats.begin(), seatIndex= 0;\n\n        for(auto itr= std::next(occupiedSeats.begin()); itr != occupiedSeats.end(); ++itr)\n        {\n            auto prev= std::prev(itr);\n            int distance= (*itr - *prev) / 2;\n\n            if(distance > maxDistance)\n            {\n                maxDistance= distance;\n                seatIndex= *prev + distance;\n            }\n        }\n\n        if(roomCapacity - 1 - *occupiedSeats.rbegin() > maxDistance)\n            seatIndex= roomCapacity - 1;\n\n        occupiedSeats.insert(seatIndex);\n        return seatIndex;\n    }\n\n    void leave(int seatPosition)\n    {\n        occupiedSeats.erase(seatPosition);\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint scoreOfParentheses(string parenthesesString)\n{\n    int totalScore= 0, currentDepth= 0;\n    for(int index= 0; index < parenthesesString.size(); index++)\n    {\n        if(parenthesesString[index] == '(')\n            currentDepth++;\n        else\n        {\n            currentDepth--;\n            if(parenthesesString[index - 1] == '(')\n                totalScore+= 1 << currentDepth;\n        }\n    }\n    return totalScore;\n}",
    "output": "#include <bits/stdc++.h>\nint scoreOfParentheses(std::string parenthesesString)\n{\n    int totalScore= 0, currentDepth= 0;\n    for(int index= 0; index < parenthesesString.size(); index++)\n    {\n        if(parenthesesString[index] == '(')\n            currentDepth++;\n        else\n        {\n            currentDepth--;\n            if(parenthesesString[index - 1] == '(')\n                totalScore+= 1 << currentDepth;\n        }\n    }\n    return totalScore;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble minCostToHireWorkers(vector<int> &workerQuality, vector<int> &workerWage, int requiredWorkers)\n{\n    vector<pair<double, int>> workers;\n    for(int index = 0; index < workerQuality.size(); index++)\n    {\n        workers.emplace_back((double)workerWage[index] / workerQuality[index], workerQuality[index]);\n    }\n    sort(workers.begin(), workers.end());\n\n    int totalQuality = 0;\n    double minimumCost = 1e60;\n    priority_queue<int> qualityQueue;\n\n    for (int i = 0; i < workers.size(); ++i)\n    {\n        double wageToQualityRatio = workers[i].first;\n        int quality = workers[i].second;\n\n        totalQuality += quality;\n        qualityQueue.push(quality);\n\n        if (qualityQueue.size() > requiredWorkers)\n        {\n            totalQuality -= qualityQueue.top();\n            qualityQueue.pop();\n        }\n\n        if (qualityQueue.size() == requiredWorkers)\n        {\n            minimumCost = min(minimumCost, wageToQualityRatio * totalQuality);\n        }\n    }\n\n    return minimumCost;\n}",
    "output": "#include <bits/stdc++.h>\ndouble minCostToHireWorkers(std::vector<int> &workerQuality, std::vector<int> &workerWage, int requiredWorkers)\n{\n    std::vector<std::pair<double, int>> workers;\n    for(int index= 0; index < workerQuality.size(); index++)\n    {\n        workers.emplace_back((double)workerWage[index] / workerQuality[index], workerQuality[index]);\n    }\n    std::sort(workers.begin(), workers.end());\n\n    int totalQuality= 0;\n    double minimumCost= 1e60;\n    std::priority_queue<int> qualityQueue;\n\n    for(auto [wageToQualityRatio, quality] : workers)\n    {\n        totalQuality+= quality;\n        qualityQueue.push(quality);\n\n        if(qualityQueue.size() > requiredWorkers)\n        {\n            totalQuality-= qualityQueue.top();\n            qualityQueue.pop();\n        }\n\n        if(qualityQueue.size() == requiredWorkers)\n        {\n            minimumCost= std::min(minimumCost, wageToQualityRatio * totalQuality);\n        }\n    }\n\n    return minimumCost;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int mirrorReflection(int panelLength, int beamHeight)\n{\n    int currentLength= panelLength, currentHeight= beamHeight;\n    int greatestCommonDivisor;\n    while(currentHeight)\n    {\n        greatestCommonDivisor= currentLength % currentHeight;\n        currentLength= currentHeight;\n        currentHeight= greatestCommonDivisor;\n    }\n\n    if((panelLength / currentLength) % 2 == 0)\n        return 2;\n    if((beamHeight / currentLength) % 2 == 0)\n        return 0;\n    return 1;\n}",
    "output": "int mirrorReflection(int panelLength, int beamHeight)\n{\n    int currentLength= panelLength, currentHeight= beamHeight;\n    int greatestCommonDivisor;\n    while(currentHeight)\n    {\n        greatestCommonDivisor= currentLength % currentHeight;\n        currentLength= currentHeight;\n        currentHeight= greatestCommonDivisor;\n    }\n\n    if((panelLength / currentLength) % 2 == 0)\n        return 2;\n    if((beamHeight / currentLength) % 2 == 0)\n        return 0;\n    return 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool areAlmostEqual(string sourceString, string targetString)\n{\n    if(sourceString == targetString)\n        return true;\n    int mismatchCount= 0;\n    int firstMismatchIndex= -1, secondMismatchIndex= -1;\n    for(int index= 0; index < sourceString.size(); index++)\n    {\n        if(sourceString[index] != targetString[index])\n        {\n            mismatchCount++;\n            if(firstMismatchIndex == -1)\n                firstMismatchIndex= index;\n            else\n                secondMismatchIndex= index;\n            if(mismatchCount > 2)\n                return false;\n        }\n    }\n    return (mismatchCount == 2 && sourceString[firstMismatchIndex] == targetString[secondMismatchIndex] && sourceString[secondMismatchIndex] == targetString[firstMismatchIndex]);\n}",
    "output": "bool areAlmostEqual(std::string sourceString, std::string targetString)\n{\n    if(sourceString == targetString)\n        return true;\n    int mismatchCount= 0;\n    int firstMismatchIndex= -1, secondMismatchIndex= -1;\n    for(int index= 0; index < sourceString.size(); index++)\n    {\n        if(sourceString[index] != targetString[index])\n        {\n            mismatchCount++;\n            if(firstMismatchIndex == -1)\n                firstMismatchIndex= index;\n            else\n                secondMismatchIndex= index;\n            if(mismatchCount > 2)\n                return false;\n        }\n    }\n    return (mismatchCount == 2 && sourceString[firstMismatchIndex] == targetString[secondMismatchIndex] && sourceString[secondMismatchIndex] == targetString[firstMismatchIndex]);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool lemonadeChange(vector<int> &customerBills)\n{\n    int fiveDollarBills = 0, tenDollarBills = 0;\n    for (int i = 0; i < customerBills.size(); ++i)\n    {\n        int bill = customerBills[i];\n        if (bill == 5)\n            fiveDollarBills++;\n        else if (bill == 10)\n        {\n            if (!fiveDollarBills)\n                return false;\n            fiveDollarBills--;\n            tenDollarBills++;\n        }\n        else\n        {\n            if (tenDollarBills && fiveDollarBills)\n            {\n                tenDollarBills--;\n                fiveDollarBills--;\n            }\n            else if (fiveDollarBills >= 3)\n                fiveDollarBills -= 3;\n            else\n                return false;\n        }\n    }\n    return true;\n}",
    "output": "bool lemonadeChange(std::vector<int> &customerBills)\n{\n    int fiveDollarBills= 0, tenDollarBills= 0;\n    for(int bill : customerBills)\n    {\n        if(bill == 5)\n            fiveDollarBills++;\n        else if(bill == 10)\n        {\n            if(!fiveDollarBills)\n                return false;\n            fiveDollarBills--;\n            tenDollarBills++;\n        }\n        else\n        {\n            if(tenDollarBills && fiveDollarBills)\n            {\n                tenDollarBills--;\n                fiveDollarBills--;\n            }\n            else if(fiveDollarBills >= 3)\n                fiveDollarBills-= 3;\n            else\n                return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMatrixScore(vector<vector<int>> &binaryGrid)\n{\n    int rowCount = binaryGrid.size(), columnCount = binaryGrid[0].size();\n    for(int rowIndex = 0; rowIndex < rowCount; rowIndex++)\n    {\n        if(binaryGrid[rowIndex][0] == 0)\n        {\n            for(int columnIndex = 0; columnIndex < columnCount; columnIndex++)\n            {\n                binaryGrid[rowIndex][columnIndex] = 1 - binaryGrid[rowIndex][columnIndex];\n            }\n        }\n    }\n    for(int columnIndex = 1; columnIndex < columnCount; columnIndex++)\n    {\n        int oneCount = 0;\n        for(int rowIndex = 0; rowIndex < rowCount; rowIndex++)\n        {\n            oneCount += binaryGrid[rowIndex][columnIndex];\n        }\n        if(oneCount <= rowCount / 2)\n        {\n            for(int rowIndex = 0; rowIndex < rowCount; rowIndex++)\n            {\n                binaryGrid[rowIndex][columnIndex] = 1 - binaryGrid[rowIndex][columnIndex];\n            }\n        }\n    }\n    int totalSum = 0;\n    for(int rowIndex = 0; rowIndex < rowCount; rowIndex++)\n    {\n        int binaryNumber = 0;\n        for(int columnIndex = 0; columnIndex < columnCount; columnIndex++)\n        {\n            binaryNumber = binaryNumber * 2 + binaryGrid[rowIndex][columnIndex];\n        }\n        totalSum += binaryNumber;\n    }\n    return totalSum;\n}",
    "output": "int calculateMatrixScore(std::vector<std::vector<int>> &binaryGrid)\n{\n    int rowCount= binaryGrid.size(), columnCount= binaryGrid[0].size();\n    for(int rowIndex= 0; rowIndex < rowCount; rowIndex++)\n    {\n        if(binaryGrid[rowIndex][0] == 0)\n        {\n            for(int columnIndex= 0; columnIndex < columnCount; columnIndex++)\n            {\n                binaryGrid[rowIndex][columnIndex]= 1 - binaryGrid[rowIndex][columnIndex];\n            }\n        }\n    }\n    for(int columnIndex= 1; columnIndex < columnCount; columnIndex++)\n    {\n        int oneCount= 0;\n        for(int rowIndex= 0; rowIndex < rowCount; rowIndex++)\n        {\n            oneCount+= binaryGrid[rowIndex][columnIndex];\n        }\n        if(oneCount <= rowCount / 2)\n        {\n            for(int rowIndex= 0; rowIndex < rowCount; rowIndex++)\n            {\n                binaryGrid[rowIndex][columnIndex]= 1 - binaryGrid[rowIndex][columnIndex];\n            }\n        }\n    }\n    int totalSum= 0;\n    for(int rowIndex= 0; rowIndex < rowCount; rowIndex++)\n    {\n        int binaryNumber= 0;\n        for(int columnIndex= 0; columnIndex < columnCount; columnIndex++)\n        {\n            binaryNumber= binaryNumber * 2 + binaryGrid[rowIndex][columnIndex];\n        }\n        totalSum+= binaryNumber;\n    }\n    return totalSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestSubarray(vector<int> &numbers, int targetSum)\n{\n    int arraySize= numbers.size();\n    vector<int> prefixSum(arraySize + 1, 0);\n    for(int index= 0; index < arraySize; index++)\n        prefixSum[index + 1]= prefixSum[index] + numbers[index];\n\n    int result= arraySize + 1;\n    deque<int> dequeIndices;\n    for(int index= 0; index < arraySize + 1; index++)\n    {\n        while(!dequeIndices.empty() && prefixSum[index] - prefixSum[dequeIndices.front()] >= targetSum)\n        {\n            result= min(result, index - dequeIndices.front());\n            dequeIndices.pop_front();\n        }\n        while(!dequeIndices.empty() && prefixSum[index] <= prefixSum[dequeIndices.back()])\n        {\n            dequeIndices.pop_back();\n        }\n        dequeIndices.push_back(index);\n    }\n    return result <= arraySize ? result : -1;\n}",
    "output": "#include <bits/stdc++.h>\nint shortestSubarray(std::vector<int> &numbers, int targetSum)\n{\n    int arraySize= numbers.size();\n    std::vector<int> prefixSum(arraySize + 1, 0);\n    for(int index= 0; index < arraySize; index++)\n        prefixSum[index + 1]= prefixSum[index] + numbers[index];\n\n    int result= arraySize + 1;\n    std::deque<int> dequeIndices;\n    for(int index= 0; index < arraySize + 1; index++)\n    {\n        while(!dequeIndices.empty() && prefixSum[index] - prefixSum[dequeIndices.front()] >= targetSum)\n        {\n            result= std::min(result, index - dequeIndices.front());\n            dequeIndices.pop_front();\n        }\n        while(!dequeIndices.empty() && prefixSum[index] <= prefixSum[dequeIndices.back()])\n        {\n            dequeIndices.pop_back();\n        }\n        dequeIndices.push_back(index);\n    }\n    return result <= arraySize ? result : -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nvector<int> findNodesAtDistanceK(TreeNode *rootNode, int targetValue, int distanceK)\n{\n    if(distanceK < 0)\n        return {};\n    unordered_map<TreeNode *, TreeNode *> parentMap;\n    unordered_set<TreeNode *> visitedNodes;\n    TreeNode *targetNode= NULL;\n    initializeParentMap(rootNode, NULL, targetValue, parentMap, targetNode);\n\n    vector<int> result;\n    findNodesAtDistanceKHelper(targetNode, distanceK, visitedNodes, parentMap, result);\n    return result;\n}\n\nvoid initializeParentMap(TreeNode *currentNode, TreeNode *parentNode, int targetValue, unordered_map<TreeNode *, TreeNode *> &parentMap, TreeNode *&targetNode)\n{\n    if(!currentNode || targetNode)\n        return;\n    if(currentNode->value == targetValue)\n        targetNode= currentNode;\n    parentMap[currentNode]= parentNode;\n    initializeParentMap(currentNode->leftChild, currentNode, targetValue, parentMap, targetNode);\n    initializeParentMap(currentNode->rightChild, currentNode, targetValue, parentMap, targetNode);\n}\n\nvoid findNodesAtDistanceKHelper(TreeNode *currentNode, int distanceK, unordered_set<TreeNode *> &visitedNodes, unordered_map<TreeNode *, TreeNode *> &parentMap, vector<int> &result)\n{\n    if(!currentNode || visitedNodes.count(currentNode))\n        return;\n    visitedNodes.insert(currentNode);\n    if(distanceK == 0)\n    {\n        result.push_back(currentNode->value);\n        return;\n    }\n\n    findNodesAtDistanceKHelper(currentNode->leftChild, distanceK - 1, visitedNodes, parentMap, result);\n    findNodesAtDistanceKHelper(currentNode->rightChild, distanceK - 1, visitedNodes, parentMap, result);\n    findNodesAtDistanceKHelper(parentMap[currentNode], distanceK - 1, visitedNodes, parentMap, result);\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nstd::vector<int> findNodesAtDistanceK(TreeNode *rootNode, int targetValue, int distanceK)\n{\n    if(distanceK < 0)\n        return {};\n    std::unordered_map<TreeNode *, TreeNode *> parentMap;\n    std::unordered_set<TreeNode *> visitedNodes;\n    TreeNode *targetNode= NULL;\n    initializeParentMap(rootNode, NULL, targetValue, parentMap, targetNode);\n\n    std::vector<int> result;\n    findNodesAtDistanceKHelper(targetNode, distanceK, visitedNodes, parentMap, result);\n    return result;\n}\n\nvoid initializeParentMap(TreeNode *currentNode, TreeNode *parentNode, int targetValue, std::unordered_map<TreeNode *, TreeNode *> &parentMap, TreeNode *&targetNode)\n{\n    if(!currentNode || targetNode)\n        return;\n    if(currentNode->value == targetValue)\n        targetNode= currentNode;\n    parentMap[currentNode]= parentNode;\n    initializeParentMap(currentNode->leftChild, currentNode, targetValue, parentMap, targetNode);\n    initializeParentMap(currentNode->rightChild, currentNode, targetValue, parentMap, targetNode);\n}\n\nvoid findNodesAtDistanceKHelper(TreeNode *currentNode, int distanceK, std::unordered_set<TreeNode *> &visitedNodes, std::unordered_map<TreeNode *, TreeNode *> &parentMap, std::vector<int> &result)\n{\n    if(!currentNode || visitedNodes.count(currentNode))\n        return;\n    visitedNodes.insert(currentNode);\n    if(distanceK == 0)\n    {\n        result.push_back(currentNode->value);\n        return;\n    }\n\n    findNodesAtDistanceKHelper(currentNode->leftChild, distanceK - 1, visitedNodes, parentMap, result);\n    findNodesAtDistanceKHelper(currentNode->rightChild, distanceK - 1, visitedNodes, parentMap, result);\n    findNodesAtDistanceKHelper(parentMap[currentNode], distanceK - 1, visitedNodes, parentMap, result);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution\n{\n  public:\n    unordered_map<int, int> blacklistMap;\n    int reducedN;\n\n    Solution(int totalCount, vector<int> &blacklist)\n    {\n        for (int i = 0; i < blacklist.size(); ++i)\n        {\n            int blacklistedValue = blacklist[i];\n            if (blacklistedValue < totalCount)\n            {\n                blacklistMap[blacklistedValue] = -1;\n            }\n        }\n        reducedN = totalCount - blacklistMap.size();\n\n        for (int i = 0; i < blacklist.size(); ++i)\n        {\n            int blacklistedValue = blacklist[i];\n            if (blacklistedValue >= reducedN)\n                continue;\n            while (blacklistMap.count(--totalCount))\n            {\n            }\n            blacklistMap[blacklistedValue] = totalCount;\n        }\n    }\n\n    int pick()\n    {\n        int randomIndex = rand() % reducedN;\n        if (blacklistMap.count(randomIndex))\n        {\n            return blacklistMap[randomIndex];\n        }\n        return randomIndex;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Solution\n{\n  public:\n    std::unordered_map<int, int> blacklistMap;\n    int reducedN;\n\n    Solution(int totalCount, std::vector<int> &blacklist)\n    {\n        for(int blacklistedValue : blacklist)\n        {\n            if(blacklistedValue < totalCount)\n            {\n                blacklistMap[blacklistedValue]= -1;\n            }\n        }\n        reducedN= totalCount - blacklistMap.size();\n\n        for(int blacklistedValue : blacklist)\n        {\n            if(blacklistedValue >= reducedN)\n                continue;\n            while(blacklistMap.count(--totalCount))\n            {\n            }\n            blacklistMap[blacklistedValue]= totalCount;\n        }\n    }\n\n    int pick()\n    {\n        int randomIndex= rand() % reducedN;\n        if(blacklistMap.count(randomIndex))\n        {\n            return blacklistMap[randomIndex];\n        }\n        return randomIndex;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPathAllKeys(vector<string> &grid)\n{\n    int rowCount = grid.size(), colCount = grid[0].size(), stepsCount = 0, keyCount = 0, startX = -1, startY = -1, keyMask = 0;\n    queue<vector<int>> positionQueue;\n\n    for (int row = 0; row < rowCount; row++)\n    {\n        for (int col = 0; col < colCount; col++)\n        {\n            if (grid[row][col] == '@')\n            {\n                startX = row;\n                startY = col;\n            }\n            else if (grid[row][col] >= 'a' && grid[row][col] <= 'f')\n            {\n                keyCount = max(keyCount, grid[row][col] - 'a' + 1);\n            }\n        }\n    }\n\n    positionQueue.push({startX, startY, 0});\n    unordered_set<string> visitedPositions;\n    visitedPositions.insert(to_string(startX) + \",\" + to_string(startY) + \",\" + to_string(keyMask));\n\n    vector<vector<int>> directions = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\n\n    while (!positionQueue.empty())\n    {\n        int queueSize = positionQueue.size();\n\n        for (int size = 0; size < queueSize; size++)\n        {\n            vector<int> currentPosition = positionQueue.front();\n            positionQueue.pop();\n            int currentX = currentPosition[0], currentY = currentPosition[1], currentMask = currentPosition[2];\n\n            if (currentMask == (1 << keyCount) - 1)\n                return stepsCount;\n\n            for (int d = 0; d < directions.size(); d++)\n            {\n                vector<int> &direction = directions[d];\n                int nextX = currentX + direction[0], nextY = currentY + direction[1], newMask = currentMask;\n\n                if (nextX >= 0 && nextX < rowCount && nextY >= 0 && nextY < colCount)\n                {\n                    if (grid[nextX][nextY] >= 'A' && grid[nextX][nextY] <= 'F' && !(newMask & (1 << (grid[nextX][nextY] - 'A'))))\n                        continue;\n                    if (grid[nextX][nextY] >= 'a' && grid[nextX][nextY] <= 'f')\n                        newMask |= (1 << (grid[nextX][nextY] - 'a'));\n\n                    string positionKey = to_string(nextX) + \",\" + to_string(nextY) + \",\" + to_string(newMask);\n\n                    if (visitedPositions.count(positionKey))\n                        continue;\n\n                    visitedPositions.insert(positionKey);\n                    positionQueue.push({nextX, nextY, newMask});\n                }\n            }\n        }\n\n        stepsCount++;\n    }\n\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint shortestPathAllKeys(std::vector<std::string> &grid)\n{\n    int rowCount= grid.size(), colCount= grid[0].size(), stepsCount= 0, keyCount= 0, startX= -1, startY= -1, keyMask= 0;\n    std::queue<std::vector<int>> positionQueue;\n\n    for(int row= 0; row < rowCount; row++)\n    {\n        for(int col= 0; col < colCount; col++)\n        {\n            if(grid[row][col] == '@')\n            {\n                startX= row;\n                startY= col;\n            }\n            else if(grid[row][col] >= 'a' && grid[row][col] <= 'f')\n            {\n                keyCount= std::max(keyCount, grid[row][col] - 'a' + 1);\n            }\n        }\n    }\n\n    positionQueue.push({startX, startY, 0});\n    std::unordered_set<std::string> visitedPositions;\n    visitedPositions.insert(std::to_string(startX) + \",\" + std::to_string(startY) + \",\" + std::to_string(keyMask));\n\n    std::vector<std::vector<int>> directions= {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\n\n    while(!positionQueue.empty())\n    {\n        int queueSize= positionQueue.size();\n\n        for(int size= 0; size < queueSize; size++)\n        {\n            std::vector<int> currentPosition= positionQueue.front();\n            positionQueue.pop();\n            int currentX= currentPosition[0], currentY= currentPosition[1], currentMask= currentPosition[2];\n\n            if(currentMask == (1 << keyCount) - 1)\n                return stepsCount;\n\n            for(std::vector<int> &direction : directions)\n            {\n                int nextX= currentX + direction[0], nextY= currentY + direction[1], newMask= currentMask;\n\n                if(nextX >= 0 && nextX < rowCount && nextY >= 0 && nextY < colCount)\n                {\n                    if(grid[nextX][nextY] >= 'A' && grid[nextX][nextY] <= 'F' && !(newMask & (1 << (grid[nextX][nextY] - 'A'))))\n                        continue;\n                    if(grid[nextX][nextY] >= 'a' && grid[nextX][nextY] <= 'f')\n                        newMask|= (1 << (grid[nextX][nextY] - 'a'));\n\n                    std::string positionKey= std::to_string(nextX) + \",\" + std::to_string(nextY) + \",\" + std::to_string(newMask);\n\n                    if(visitedPositions.count(positionKey))\n                        continue;\n\n                    visitedPositions.insert(positionKey);\n                    positionQueue.push({nextX, nextY, newMask});\n                }\n            }\n        }\n\n        stepsCount++;\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int v) : value(v), leftChild(NULL), rightChild(NULL) {}\n};\n\nint maxDepth(TreeNode *currentNode)\n{\n    if(currentNode == NULL)\n        return 0;\n    else\n        return max(maxDepth(currentNode->leftChild), maxDepth(currentNode->rightChild)) + 1;\n}\n\nTreeNode *subtreeWithAllDeepest(TreeNode *rootNode)\n{\n    if(rootNode == NULL)\n        return NULL;\n\n    int leftDepth= maxDepth(rootNode->leftChild);\n    int rightDepth= maxDepth(rootNode->rightChild);\n\n    if(leftDepth == rightDepth)\n        return rootNode;\n\n    if(leftDepth > rightDepth)\n        return subtreeWithAllDeepest(rootNode->leftChild);\n    else\n        return subtreeWithAllDeepest(rootNode->rightChild);\n}",
    "output": "class TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int v) : value(v), leftChild(NULL), rightChild(NULL) {}\n};\n\nint maxDepth(TreeNode *currentNode)\n{\n    if(currentNode == NULL)\n        return 0;\n    else\n        return max(maxDepth(currentNode->leftChild), maxDepth(currentNode->rightChild)) + 1;\n}\n\nTreeNode *subtreeWithAllDeepest(TreeNode *rootNode)\n{\n    if(rootNode == NULL)\n        return NULL;\n\n    int leftDepth= maxDepth(rootNode->leftChild);\n    int rightDepth= maxDepth(rootNode->rightChild);\n\n    if(leftDepth == rightDepth)\n        return rootNode;\n\n    if(leftDepth > rightDepth)\n        return subtreeWithAllDeepest(rootNode->leftChild);\n    else\n        return subtreeWithAllDeepest(rootNode->rightChild);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "bool isPrime(int number)\n{\n    if(number <= 1)\n        return false;\n    for(int divisor= 2; divisor * divisor <= number; divisor++)\n    {\n        if(number % divisor == 0)\n            return false;\n    }\n    return true;\n}\n\nbool isPalindrome(int number)\n{\n    int reversedNumber= 0, originalNumber= number;\n    while(number > 0)\n    {\n        reversedNumber= reversedNumber * 10 + number % 10;\n        number/= 10;\n    }\n    return originalNumber == reversedNumber;\n}\n\nint primePalindrome(int number)\n{\n    while(true)\n    {\n        if(isPrime(number) && isPalindrome(number))\n            return number;\n        number++;\n    }\n}",
    "output": "bool isPrime(int number)\n{\n    if(number <= 1)\n        return false;\n    for(int divisor= 2; divisor * divisor <= number; divisor++)\n    {\n        if(number % divisor == 0)\n            return false;\n    }\n    return true;\n}\n\nbool isPalindrome(int number)\n{\n    int reversedNumber= 0, originalNumber= number;\n    while(number > 0)\n    {\n        reversedNumber= reversedNumber * 10 + number % 10;\n        number/= 10;\n    }\n    return originalNumber == reversedNumber;\n}\n\nint primePalindrome(int number)\n{\n    while(true)\n    {\n        if(isPrime(number) && isPalindrome(number))\n            return number;\n        number++;\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> transpose(vector<vector<int>> &inputMatrix)\n{\n    int rowCount= inputMatrix.size();\n    int colCount= inputMatrix[0].size();\n    vector<vector<int>> transposedMatrix(colCount, vector<int>(rowCount));\n    for(int rowIndex= 0; rowIndex < rowCount; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < colCount; colIndex++)\n        {\n            transposedMatrix[colIndex][rowIndex]= inputMatrix[rowIndex][colIndex];\n        }\n    }\n    return transposedMatrix;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> transpose(std::vector<std::vector<int>> &inputMatrix)\n{\n    int rowCount= inputMatrix.size();\n    int colCount= inputMatrix[0].size();\n    std::vector<std::vector<int>> transposedMatrix(colCount, std::vector<int>(rowCount));\n    for(int rowIndex= 0; rowIndex < rowCount; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < colCount; colIndex++)\n        {\n            transposedMatrix[colIndex][rowIndex]= inputMatrix[rowIndex][colIndex];\n        }\n    }\n    return transposedMatrix;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "using namespace std;\n\nint longestDistance(int number)\n{\n    int lastIndex= -1, longestGap= 0;\n    for(int currentIndex= 0; number > 0; number>>= 1, currentIndex++)\n    {\n        if(number & 1)\n        {\n            if(lastIndex >= 0)\n                longestGap= max(longestGap, currentIndex - lastIndex);\n            lastIndex= currentIndex;\n        }\n    }\n    return longestGap;\n}",
    "output": "int longestDistance(int number)\n{\n    int lastIndex= -1, longestGap= 0;\n    for(int currentIndex= 0; number > 0; number>>= 1, currentIndex++)\n    {\n        if(number & 1)\n        {\n            if(lastIndex >= 0)\n                longestGap= std::max(longestGap, currentIndex - lastIndex);\n            lastIndex= currentIndex;\n        }\n    }\n    return longestGap;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool reorderedPowerOf2(int number)\n{\n    string numberString = to_string(number);\n    sort(numberString.begin(), numberString.end());\n    do\n    {\n        if(numberString[0] != '0' && (bitset<32>(stoi(numberString)).count() == 1))\n        {\n            return true;\n        }\n    } while(next_permutation(numberString.begin(), numberString.end()));\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool reorderedPowerOf2(int number)\n{\n    std::string numberString= std::to_string(number);\n    std::sort(numberString.begin(), numberString.end());\n    do\n    {\n        if(numberString[0] != '0' && (std::bitset<32>(std::stoi(numberString)).count() == 1))\n        {\n            return true;\n        }\n    } while(std::next_permutation(numberString.begin(), numberString.end()));\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> advantageCount(vector<int> &firstArray, vector<int> &secondArray)\n{\n    multiset<int> sortedElements(firstArray.begin(), firstArray.end());\n    vector<int> result;\n    for (int i = 0; i < secondArray.size(); ++i)\n    {\n        int target = secondArray[i];\n        auto iterator = sortedElements.upper_bound(target);\n        if (iterator == sortedElements.end())\n            iterator = sortedElements.begin();\n        result.push_back(*iterator);\n        sortedElements.erase(iterator);\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> advantageCount(std::vector<int> &firstArray, std::vector<int> &secondArray)\n{\n    std::multiset<int> sortedElements(firstArray.begin(), firstArray.end());\n    std::vector<int> result;\n    for(int target : secondArray)\n    {\n        auto iterator = sortedElements.upper_bound(target);\n        if(iterator == sortedElements.end())\n            iterator = sortedElements.begin();\n        result.push_back(*iterator);\n        sortedElements.erase(iterator);\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minRefuelStops(int targetDistance, int startingFuel, vector<vector<int>> &fuelStations)\n{\n    int stationIndex= 0, refuelStops= 0, currentFuel= startingFuel;\n    priority_queue<int> maxHeap;\n    while(currentFuel < targetDistance)\n    {\n        while(stationIndex < fuelStations.size() && fuelStations[stationIndex][0] <= currentFuel)\n        {\n            maxHeap.push(fuelStations[stationIndex][1]);\n            stationIndex++;\n        }\n        if(maxHeap.empty())\n            return -1;\n        currentFuel+= maxHeap.top();\n        maxHeap.pop();\n        refuelStops++;\n    }\n    return refuelStops;\n}",
    "output": "#include <bits/stdc++.h>\nint minRefuelStops(int targetDistance, int startingFuel, std::vector<std::vector<int>> &fuelStations)\n{\n    int stationIndex = 0, refuelStops = 0, currentFuel = startingFuel;\n    std::priority_queue<int> maxHeap;\n    while(currentFuel < targetDistance)\n    {\n        while(stationIndex < fuelStations.size() && fuelStations[stationIndex][0] <= currentFuel)\n        {\n            maxHeap.push(fuelStations[stationIndex][1]);\n            stationIndex++;\n        }\n        if(maxHeap.empty())\n            return -1;\n        currentFuel += maxHeap.top();\n        maxHeap.pop();\n        refuelStops++;\n    }\n    return refuelStops;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For rand()\nusing namespace std;\n\nint rand10()\n{\n    int randomResult;\n    do\n    {\n        randomResult= (rand7() - 1) * 7 + rand7();\n    } while(randomResult > 40);\n    return randomResult % 10 + 1;\n}",
    "output": "#include <bits/stdc++.h>\nint rand10()\n{\n    int randomResult;\n    do\n    {\n        randomResult= (std::rand() % 7 + 1 - 1) * 7 + (std::rand() % 7 + 1);\n    } while(randomResult > 40);\n    return randomResult % 10 + 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool areLeafNodesSimilar(TreeNode *firstTreeRoot, TreeNode *secondTreeRoot)\n{\n    vector<int> firstTreeLeaves;\n    vector<int> secondTreeLeaves;\n    collectLeaves(firstTreeRoot, firstTreeLeaves);\n    collectLeaves(secondTreeRoot, secondTreeLeaves);\n    return firstTreeLeaves == secondTreeLeaves;\n}\n\nvoid collectLeaves(TreeNode *currentNode, vector<int> &leafValues)\n{\n    if(!currentNode)\n        return;\n    if(!currentNode->left && !currentNode->right)\n        leafValues.push_back(currentNode->val);\n    collectLeaves(currentNode->left, leafValues);\n    collectLeaves(currentNode->right, leafValues);\n}",
    "output": "bool areLeafNodesSimilar(TreeNode *firstTreeRoot, TreeNode *secondTreeRoot)\n{\n    std::vector<int> firstTreeLeaves;\n    std::vector<int> secondTreeLeaves;\n    collectLeaves(firstTreeRoot, firstTreeLeaves);\n    collectLeaves(secondTreeRoot, secondTreeLeaves);\n    return firstTreeLeaves == secondTreeLeaves;\n}\n\nvoid collectLeaves(TreeNode *currentNode, std::vector<int> &leafValues)\n{\n    if(!currentNode)\n        return;\n    if(!currentNode->left && !currentNode->right)\n        leafValues.push_back(currentNode->val);\n    collectLeaves(currentNode->left, leafValues);\n    collectLeaves(currentNode->right, leafValues);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint lenLongestFibSubseq(vector<int> &fibonacciNumbers)\n{\n    int arraySize= fibonacciNumbers.size();\n    unordered_map<int, int> indexMap;\n    for(int currentIndex= 0; currentIndex < arraySize; ++currentIndex)\n        indexMap[fibonacciNumbers[currentIndex]]= currentIndex;\n\n    unordered_map<int, int> longestFibSubseq;\n    int maxLength= 0;\n\n    for(int currentK= 0; currentK < arraySize; ++currentK)\n        for(int currentJ= 0; currentJ < currentK; ++currentJ)\n        {\n            int currentI= indexMap.find(fibonacciNumbers[currentK] - fibonacciNumbers[currentJ]) == indexMap.end() ? -1 : indexMap[fibonacciNumbers[currentK] - fibonacciNumbers[currentJ]];\n            if(currentI >= 0 && currentI < currentJ)\n            {\n                longestFibSubseq[currentJ * arraySize + currentK]= longestFibSubseq.find(currentI * arraySize + currentJ) == longestFibSubseq.end() ? 2 : longestFibSubseq[currentI * arraySize + currentJ] + 1;\n                maxLength= max(maxLength, longestFibSubseq[currentJ * arraySize + currentK] + 1);\n            }\n        }\n\n    return maxLength >= 3 ? maxLength : 0;\n}",
    "output": "#include <bits/stdc++.h>\nint lenLongestFibSubseq(std::vector<int> &fibonacciNumbers)\n{\n    int arraySize= fibonacciNumbers.size();\n    std::unordered_map<int, int> indexMap;\n    for(int currentIndex= 0; currentIndex < arraySize; ++currentIndex)\n        indexMap[fibonacciNumbers[currentIndex]]= currentIndex;\n\n    std::unordered_map<int, int> longestFibSubseq;\n    int maxLength= 0;\n\n    for(int currentK= 0; currentK < arraySize; ++currentK)\n        for(int currentJ= 0; currentJ < currentK; ++currentJ)\n        {\n            int currentI= indexMap.find(fibonacciNumbers[currentK] - fibonacciNumbers[currentJ]) == indexMap.end() ? -1 : indexMap[fibonacciNumbers[currentK] - fibonacciNumbers[currentJ]];\n            if(currentI >= 0 && currentI < currentJ)\n            {\n                longestFibSubseq[currentJ * arraySize + currentK]= longestFibSubseq.find(currentI * arraySize + currentJ) == longestFibSubseq.end() ? 2 : longestFibSubseq[currentI * arraySize + currentJ] + 1;\n                maxLength= std::max(maxLength, longestFibSubseq[currentJ * arraySize + currentK] + 1);\n            }\n        }\n\n    return maxLength >= 3 ? maxLength : 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint robotSim(vector<int> &commandList, vector<vector<int>> &obstacleList)\n{\n    int directionX[] = {0, 1, 0, -1};\n    int directionY[] = {1, 0, -1, 0};\n    int currentX = 0, currentY = 0, currentDirection = 0;\n\n    set<pair<int, int>> obstacleSet;\n    for (int i = 0; i < obstacleList.size(); ++i)\n        obstacleSet.insert(make_pair(obstacleList[i][0], obstacleList[i][1]));\n\n    int maximumDistanceSquared = 0;\n    for (int i = 0; i < commandList.size(); ++i)\n    {\n        int command = commandList[i];\n        if (command == -2)\n        {\n            currentDirection = (currentDirection + 3) % 4;\n        }\n        else if (command == -1)\n        {\n            currentDirection = (currentDirection + 1) % 4;\n        }\n        else\n        {\n            for (int step = 0; step < command; ++step)\n            {\n                int nextX = currentX + directionX[currentDirection];\n                int nextY = currentY + directionY[currentDirection];\n                if (!obstacleSet.count(make_pair(nextX, nextY)))\n                {\n                    currentX = nextX;\n                    currentY = nextY;\n                    maximumDistanceSquared = max(maximumDistanceSquared, currentX * currentX + currentY * currentY);\n                }\n            }\n        }\n    }\n\n    return maximumDistanceSquared;\n}",
    "output": "#include <bits/stdc++.h>\nint robotSim(std::vector<int> &commandList, std::vector<std::vector<int>> &obstacleList)\n{\n    int directionX[]= {0, 1, 0, -1};\n    int directionY[]= {1, 0, -1, 0};\n    int currentX= 0, currentY= 0, currentDirection= 0;\n\n    std::set<std::pair<int, int>> obstacleSet;\n    for(std::vector<int> obstacle : obstacleList)\n        obstacleSet.insert(std::make_pair(obstacle[0], obstacle[1]));\n\n    int maximumDistanceSquared= 0;\n    for(int command : commandList)\n    {\n        if(command == -2)\n        {\n            currentDirection= (currentDirection + 3) % 4;\n        }\n        else if(command == -1)\n        {\n            currentDirection= (currentDirection + 1) % 4;\n        }\n        else\n        {\n            for(int step= 0; step < command; ++step)\n            {\n                int nextX= currentX + directionX[currentDirection];\n                int nextY= currentY + directionY[currentDirection];\n                if(!obstacleSet.count(std::make_pair(nextX, nextY)))\n                {\n                    currentX= nextX;\n                    currentY= nextY;\n                    maximumDistanceSquared= std::max(maximumDistanceSquared, currentX * currentX + currentY * currentY);\n                }\n            }\n        }\n    }\n\n    return maximumDistanceSquared;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinEatingSpeed(vector<int> &bananaPiles, int totalHours)\n{\n    int left = 1, right = *max_element(bananaPiles.begin(), bananaPiles.end());\n    while(left < right)\n    {\n        int mid = left + (right - left) / 2;\n        int totalHoursNeeded = 0;\n        for(int i = 0; i < bananaPiles.size(); ++i)\n            totalHoursNeeded += (bananaPiles[i] + mid - 1) / mid;\n        if(totalHoursNeeded > totalHours)\n            left = mid + 1;\n        else\n            right = mid;\n    }\n    return left;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMinEatingSpeed(std::vector<int> &bananaPiles, int totalHours)\n{\n    int left= 1, right= *std::max_element(bananaPiles.begin(), bananaPiles.end());\n    while(left < right)\n    {\n        int mid= left + (right - left) / 2;\n        int totalHoursNeeded= 0;\n        for(int pile : bananaPiles)\n            totalHoursNeeded+= (pile + mid - 1) / mid;\n        if(totalHoursNeeded > totalHours)\n            left= mid + 1;\n        else\n            right= mid;\n    }\n    return left;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *middleNode(ListNode *head)\n{\n    ListNode *slowPointer= head;\n    ListNode *fastPointer= head;\n\n    while(fastPointer != NULL && fastPointer->next != NULL)\n    {\n        slowPointer= slowPointer->next;\n        fastPointer= fastPointer->next->next;\n    }\n\n    return slowPointer;\n}",
    "output": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *middleNode(ListNode *head)\n{\n    ListNode *slowPointer= head;\n    ListNode *fastPointer= head;\n\n    while(fastPointer != NULL && fastPointer->next != NULL)\n    {\n        slowPointer= slowPointer->next;\n        fastPointer= fastPointer->next->next;\n    }\n\n    return slowPointer;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool aliceWins(vector<int> &piles)\n{\n    int numberOfPiles= piles.size();\n    int dynamicProgrammingTable[numberOfPiles][numberOfPiles];\n    for(int gap= 0; gap < numberOfPiles; ++gap)\n    {\n        for(int startIndex= 0, endIndex= gap; endIndex < numberOfPiles; ++startIndex, ++endIndex)\n        {\n            int optionX= ((startIndex + 2) <= endIndex) ? dynamicProgrammingTable[startIndex + 2][endIndex] : 0;\n            int optionY= ((startIndex + 1) <= (endIndex - 1)) ? dynamicProgrammingTable[startIndex + 1][endIndex - 1] : 0;\n            int optionZ= (startIndex <= (endIndex - 2)) ? dynamicProgrammingTable[startIndex][endIndex - 2] : 0;\n            dynamicProgrammingTable[startIndex][endIndex]= max(piles[startIndex] + min(optionX, optionY), piles[endIndex] + min(optionY, optionZ));\n        }\n    }\n    int totalSum= accumulate(piles.begin(), piles.end(), 0);\n    return dynamicProgrammingTable[0][numberOfPiles - 1] > (totalSum - dynamicProgrammingTable[0][numberOfPiles - 1]);\n}",
    "output": "#include <bits/stdc++.h>\nbool aliceWins(std::vector<int> &piles)\n{\n    int numberOfPiles= piles.size();\n    int dynamicProgrammingTable[numberOfPiles][numberOfPiles];\n    for(int gap= 0; gap < numberOfPiles; ++gap)\n    {\n        for(int startIndex= 0, endIndex= gap; endIndex < numberOfPiles; ++startIndex, ++endIndex)\n        {\n            int optionX= ((startIndex + 2) <= endIndex) ? dynamicProgrammingTable[startIndex + 2][endIndex] : 0;\n            int optionY= ((startIndex + 1) <= (endIndex - 1)) ? dynamicProgrammingTable[startIndex + 1][endIndex - 1] : 0;\n            int optionZ= (startIndex <= (endIndex - 2)) ? dynamicProgrammingTable[startIndex][endIndex - 2] : 0;\n            dynamicProgrammingTable[startIndex][endIndex]= std::max(piles[startIndex] + std::min(optionX, optionY), piles[endIndex] + std::min(optionY, optionZ));\n        }\n    }\n    int totalSum= std::accumulate(piles.begin(), piles.end(), 0);\n    return dynamicProgrammingTable[0][numberOfPiles - 1] > (totalSum - dynamicProgrammingTable[0][numberOfPiles - 1]);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int findNthMagicalNumber(int n, int a, int b)\n{\n    long long modulus= 1000000007, leastCommonMultiple= a * b / __gcd(a, b);\n    long long leftBound= 1, rightBound= 1e14, midPoint;\n    while(leftBound < rightBound)\n    {\n        midPoint= leftBound + (rightBound - leftBound) / 2;\n        if((midPoint / a + midPoint / b - midPoint / leastCommonMultiple) < n)\n        {\n            leftBound= midPoint + 1;\n        }\n        else\n        {\n            rightBound= midPoint;\n        }\n    }\n    return leftBound % modulus;\n}",
    "output": "int findNthMagicalNumber(int n, int a, int b)\n{\n    long long modulus= 1000000007, leastCommonMultiple= a * b / __gcd(a, b);\n    long long leftBound= 1, rightBound= 1e14, midPoint;\n    while(leftBound < rightBound)\n    {\n        midPoint= leftBound + (rightBound - leftBound) / 2;\n        if((midPoint / a + midPoint / b - midPoint / leastCommonMultiple) < n)\n        {\n            leftBound= midPoint + 1;\n        }\n        else\n        {\n            rightBound= midPoint;\n        }\n    }\n    return leftBound % modulus;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint profitableSchemes(int totalMembers, int minimumProfit, vector<int> &groupSizes, vector<int> &profits)\n{\n    int dynamicProgramming[totalMembers + 1][minimumProfit + 1], mod= 1e9 + 7;\n    dynamicProgramming[0][0]= 1;\n    for(int i= 0; i < groupSizes.size(); ++i)\n    {\n        for(int j= totalMembers; j >= groupSizes[i]; --j)\n        {\n            for(int k= minimumProfit; k >= 0; --k)\n            {\n                dynamicProgramming[j][k]= (dynamicProgramming[j][k] + dynamicProgramming[j - groupSizes[i]][max(0, k - profits[i])]) % mod;\n            }\n        }\n    }\n    int result= 0;\n    for(int i= 1; i <= totalMembers; ++i)\n    {\n        result= (result + dynamicProgramming[i][minimumProfit]) % mod;\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nint profitableSchemes(int totalMembers, int minimumProfit, std::vector<int> &groupSizes, std::vector<int> &profits)\n{\n    int dynamicProgramming[totalMembers + 1][minimumProfit + 1], mod= 1e9 + 7;\n    dynamicProgramming[0][0]= 1;\n    for(int i= 0; i < groupSizes.size(); ++i)\n    {\n        for(int j= totalMembers; j >= groupSizes[i]; --j)\n        {\n            for(int k= minimumProfit; k >= 0; --k)\n            {\n                dynamicProgramming[j][k]= (dynamicProgramming[j][k] + dynamicProgramming[j - groupSizes[i]][std::max(0, k - profits[i])]) % mod;\n            }\n        }\n    }\n    int result= 0;\n    for(int i= 1; i <= totalMembers; ++i)\n    {\n        result= (result + dynamicProgramming[i][minimumProfit]) % mod;\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution\n{\n  public:\n    vector<int> cumulativeWeights;\n    default_random_engine randomGenerator;\n    uniform_real_distribution<double> randomDistribution;\n\n    Solution(vector<int> &weights)\n    {\n        cumulativeWeights.push_back(weights[0]);\n        for(size_t weightIndex= 1; weightIndex < weights.size(); ++weightIndex)\n        {\n            cumulativeWeights.push_back(cumulativeWeights.back() + weights[weightIndex]);\n        }\n        randomDistribution= uniform_real_distribution<double>(0, cumulativeWeights.back());\n    }\n\n    int pickIndex()\n    {\n        double randomValue= randomDistribution(randomGenerator);\n        return lower_bound(cumulativeWeights.begin(), cumulativeWeights.end(), randomValue) - cumulativeWeights.begin();\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Solution\n{\n  public:\n    std::vector<int> cumulativeWeights;\n    std::default_random_engine randomGenerator;\n    std::uniform_real_distribution<double> randomDistribution;\n\n    Solution(std::vector<int> &weights)\n    {\n        cumulativeWeights.push_back(weights[0]);\n        for(size_t weightIndex= 1; weightIndex < weights.size(); ++weightIndex)\n        {\n            cumulativeWeights.push_back(cumulativeWeights.back() + weights[weightIndex]);\n        }\n        randomDistribution= std::uniform_real_distribution<double>(0, cumulativeWeights.back());\n    }\n\n    int pickIndex()\n    {\n        double randomValue= randomDistribution(randomGenerator);\n        return std::lower_bound(cumulativeWeights.begin(), cumulativeWeights.end(), randomValue) - cumulativeWeights.begin();\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution\n{\n  public:\n    Solution(int numRows, int numColumns) : grid(numRows, vector<int>(numColumns, 0)), zeroCount(numRows * numColumns), rng(random_device{}()) {}\n\n    pair<int, int> pick()\n    {\n        uniform_int_distribution<int> distribution(0, zeroCount - 1);\n        int index= distribution(rng);\n\n        for(int row= 0; row < grid.size(); ++row)\n        {\n            for(int column= 0; column < grid[0].size(); ++column)\n            {\n                if(grid[row][column] == 0)\n                {\n                    if(index == 0)\n                    {\n                        grid[row][column]= 1;\n                        --zeroCount;\n                        return {row, column};\n                    }\n                    --index;\n                }\n            }\n        }\n        return {-1, -1}; // Should not happen\n    }\n\n  private:\n    vector<vector<int>> grid;\n    int zeroCount;\n    mt19937 rng;\n};",
    "output": "#include <bits/stdc++.h>\nclass Solution\n{\n  public:\n    Solution(int numRows, int numColumns) : grid(numRows, std::vector<int>(numColumns, 0)), zeroCount(numRows * numColumns), rng(std::random_device{}()) {}\n\n    std::pair<int, int> pick()\n    {\n        std::uniform_int_distribution<int> distribution(0, zeroCount - 1);\n        int index= distribution(rng);\n\n        for(int row= 0; row < grid.size(); ++row)\n        {\n            for(int column= 0; column < grid[0].size(); ++column)\n            {\n                if(grid[row][column] == 0)\n                {\n                    if(index == 0)\n                    {\n                        grid[row][column]= 1;\n                        --zeroCount;\n                        return {row, column};\n                    }\n                    --index;\n                }\n            }\n        }\n        return {-1, -1}; // Should not happen\n    }\n\n  private:\n    std::vector<std::vector<int>> grid;\n    int zeroCount;\n    std::mt19937 rng;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution\n{\n  public:\n    vector<vector<int>> rectangles;\n    vector<int> cumulativeAreas;\n    int totalArea;\n    default_random_engine randomGenerator;\n\n    Solution(vector<vector<int>> &inputRectangles)\n    {\n        rectangles = inputRectangles;\n        totalArea = 0;\n        for (int i = 0; i < rectangles.size(); ++i)\n        {\n            const auto &rectangle = rectangles[i];\n            int area = (rectangle[2] - rectangle[0] + 1) * (rectangle[3] - rectangle[1] + 1);\n            totalArea += area;\n            cumulativeAreas.push_back(totalArea);\n        }\n    }\n\n    vector<int> pick()\n    {\n        uniform_int_distribution<int> areaDistribution(0, totalArea - 1);\n        int randomArea = areaDistribution(randomGenerator);\n        int rectangleIndex = lower_bound(cumulativeAreas.begin(), cumulativeAreas.end(), randomArea + 1) - cumulativeAreas.begin();\n\n        uniform_int_distribution<int> xDistribution(rectangles[rectangleIndex][0], rectangles[rectangleIndex][2]);\n        uniform_int_distribution<int> yDistribution(rectangles[rectangleIndex][1], rectangles[rectangleIndex][3]);\n\n        int xCoordinate = xDistribution(randomGenerator);\n        int yCoordinate = yDistribution(randomGenerator);\n\n        return {xCoordinate, yCoordinate};\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Solution\n{\n  public:\n    std::vector<std::vector<int>> rectangles;\n    std::vector<int> cumulativeAreas;\n    int totalArea;\n    std::default_random_engine randomGenerator;\n\n    Solution(std::vector<std::vector<int>> &inputRectangles)\n    {\n        rectangles= inputRectangles;\n        totalArea= 0;\n        for(const auto &rectangle : rectangles)\n        {\n            int area= (rectangle[2] - rectangle[0] + 1) * (rectangle[3] - rectangle[1] + 1);\n            totalArea+= area;\n            cumulativeAreas.push_back(totalArea);\n        }\n    }\n\n    std::vector<int> pick()\n    {\n        std::uniform_int_distribution<int> areaDistribution(0, totalArea - 1);\n        int randomArea= areaDistribution(randomGenerator);\n        int rectangleIndex= std::lower_bound(cumulativeAreas.begin(), cumulativeAreas.end(), randomArea + 1) - cumulativeAreas.begin();\n\n        std::uniform_int_distribution<int> xDistribution(rectangles[rectangleIndex][0], rectangles[rectangleIndex][2]);\n        std::uniform_int_distribution<int> yDistribution(rectangles[rectangleIndex][1], rectangles[rectangleIndex][3]);\n\n        int xCoordinate= xDistribution(randomGenerator);\n        int yCoordinate= yDistribution(randomGenerator);\n\n        return {xCoordinate, yCoordinate};\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution\n{\n  public:\n    double radius, xCenter, yCenter;\n\n    Solution(double radius, double xCenter, double yCenter)\n    {\n        this->radius= radius;\n        this->xCenter= xCenter;\n        this->yCenter= yCenter;\n    }\n\n    vector<double> randPoint()\n    {\n        double angle= (double)rand() / RAND_MAX * 2 * M_PI;\n        double randomRadius= sqrt((double)rand() / RAND_MAX) * radius;\n        return {xCenter + randomRadius * cos(angle), yCenter + randomRadius * sin(angle)};\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Solution\n{\n  public:\n    double radius, xCenter, yCenter;\n\n    Solution(double radius, double xCenter, double yCenter)\n    {\n        this->radius = radius;\n        this->xCenter = xCenter;\n        this->yCenter = yCenter;\n    }\n\n    std::vector<double> randPoint()\n    {\n        double angle = (double)std::rand() / RAND_MAX * 2 * M_PI;\n        double randomRadius = sqrt((double)std::rand() / RAND_MAX) * radius;\n        return {xCenter + randomRadius * std::cos(angle), yCenter + randomRadius * std::sin(angle)};\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar findKthCharacter(const string &inputString, int position)\n{\n    int stringLength = inputString.length();\n    long long totalSize = 0;\n\n    for (int i = 0; i < stringLength; ++i)\n    {\n        char character = inputString[i];\n        if (isdigit(character))\n        {\n            totalSize *= character - '0';\n        }\n        else\n        {\n            totalSize++;\n        }\n    }\n\n    for (int index = stringLength - 1; index >= 0; --index)\n    {\n        char currentCharacter = inputString[index];\n        position %= totalSize;\n        if (position == 0 && !isdigit(currentCharacter))\n        {\n            return currentCharacter;\n        }\n\n        if (isdigit(currentCharacter))\n        {\n            totalSize /= currentCharacter - '0';\n        }\n        else\n        {\n            totalSize--;\n        }\n    }\n\n    return '-';\n}",
    "output": "#include <bits/stdc++.h>\nchar findKthCharacter(const std::string &inputString, int position)\n{\n    int stringLength= inputString.length();\n    long long totalSize= 0;\n\n    for(auto character : inputString)\n    {\n        if(isdigit(character))\n        {\n            totalSize*= character - '0';\n        }\n        else\n        {\n            totalSize++;\n        }\n    }\n\n    for(int index= stringLength - 1; index >= 0; --index)\n    {\n        char currentCharacter= inputString[index];\n        position%= totalSize;\n        if(position == 0 && !isdigit(currentCharacter))\n        {\n            return currentCharacter;\n        }\n\n        if(isdigit(currentCharacter))\n        {\n            totalSize/= currentCharacter - '0';\n        }\n        else\n        {\n            totalSize--;\n        }\n    }\n\n    return '-';\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numRescueBoats(vector<int> &people, int weightLimit)\n{\n    sort(people.begin(), people.end());\n    int leftIndex= 0, rightIndex= people.size() - 1;\n    int boatCount= 0;\n    while(leftIndex <= rightIndex)\n    {\n        if(people[leftIndex] + people[rightIndex] <= weightLimit)\n        {\n            leftIndex++;\n        }\n        rightIndex--;\n        boatCount++;\n    }\n    return boatCount;\n}",
    "output": "#include <bits/stdc++.h>\nint numRescueBoats(std::vector<int> &people, int weightLimit)\n{\n    std::sort(people.begin(), people.end());\n    int leftIndex= 0, rightIndex= people.size() - 1;\n    int boatCount= 0;\n    while(leftIndex <= rightIndex)\n    {\n        if(people[leftIndex] + people[rightIndex] <= weightLimit)\n        {\n            leftIndex++;\n        }\n        rightIndex--;\n        boatCount++;\n    }\n    return boatCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint reachableNodes(vector<vector<int>> &edges, int maxMoves, int nodeCount)\n{\n    vector<vector<pair<int, int>>> graph(nodeCount);\n    for (const auto &edge : edges)\n    {\n        int fromNode = edge[0], toNode = edge[1], edgeCost = edge[2];\n        graph[fromNode].emplace_back(toNode, edgeCost + 1);\n        graph[toNode].emplace_back(fromNode, edgeCost + 1);\n    }\n\n    unordered_set<int> visitedNodes;\n    priority_queue<pair<int, int>> priorityQueue;\n    priorityQueue.emplace(maxMoves, 0);\n\n    while (!priorityQueue.empty())\n    {\n        int movesLeft = priorityQueue.top().first;\n        int currentNode = priorityQueue.top().second;\n        priorityQueue.pop();\n\n        if (visitedNodes.count(currentNode))\n            continue;\n        visitedNodes.insert(currentNode);\n\n        for (int i = 0; i < graph[currentNode].size(); ++i)\n        {\n            const auto &neighbor = graph[currentNode][i];\n            int nextNode = neighbor.first;\n            int movesNeeded = neighbor.second;\n            int movesLeftAfter = movesLeft - movesNeeded;\n\n            if (!visitedNodes.count(nextNode) && movesLeftAfter > 0)\n            {\n                priorityQueue.emplace(movesLeftAfter, nextNode);\n            }\n        }\n    }\n\n    return visitedNodes.size();\n}",
    "output": "#include <bits/stdc++.h>\nint reachableNodes(std::vector<std::vector<int>> &edges, int maxMoves, int nodeCount)\n{\n    std::vector<std::vector<std::pair<int, int>>> graph(nodeCount);\n    for(const auto &edge : edges)\n    {\n        int fromNode= edge[0], toNode= edge[1], edgeCost= edge[2];\n        graph[fromNode].emplace_back(toNode, edgeCost + 1);\n        graph[toNode].emplace_back(fromNode, edgeCost + 1);\n    }\n\n    std::unordered_set<int> visitedNodes;\n    std::priority_queue<std::pair<int, int>> priorityQueue;\n    priorityQueue.emplace(maxMoves, 0);\n\n    while(!priorityQueue.empty())\n    {\n        int movesLeft= priorityQueue.top().first;\n        int currentNode= priorityQueue.top().second;\n        priorityQueue.pop();\n\n        if(visitedNodes.count(currentNode))\n            continue;\n        visitedNodes.insert(currentNode);\n\n        for(const auto &neighbor : graph[currentNode])\n        {\n            int nextNode= neighbor.first;\n            int movesNeeded= neighbor.second;\n            int movesLeftAfter= movesLeft - movesNeeded;\n\n            if(!visitedNodes.count(nextNode) && movesLeftAfter > 0)\n            {\n                priorityQueue.emplace(movesLeftAfter, nextNode);\n            }\n        }\n    }\n\n    return visitedNodes.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint projectionArea(vector<vector<int>> &grid)\n{\n    int gridSize= grid.size();\n    int topArea= 0, frontArea= 0, sideArea= 0;\n    for(int rowIndex= 0; rowIndex < gridSize; ++rowIndex)\n    {\n        int maxFrontHeight= 0, maxSideHeight= 0;\n        for(int columnIndex= 0; columnIndex < gridSize; ++columnIndex)\n        {\n            if(grid[rowIndex][columnIndex] > 0)\n            {\n                ++topArea;\n            }\n            maxFrontHeight= max(maxFrontHeight, grid[rowIndex][columnIndex]);\n            maxSideHeight= max(maxSideHeight, grid[columnIndex][rowIndex]);\n        }\n        frontArea+= maxFrontHeight;\n        sideArea+= maxSideHeight;\n    }\n    return topArea + frontArea + sideArea;\n}",
    "output": "#include <bits/stdc++.h>\nint projectionArea(std::vector<std::vector<int>> &grid)\n{\n    int gridSize= grid.size();\n    int topArea= 0, frontArea= 0, sideArea= 0;\n    for(int rowIndex= 0; rowIndex < gridSize; ++rowIndex)\n    {\n        int maxFrontHeight= 0, maxSideHeight= 0;\n        for(int columnIndex= 0; columnIndex < gridSize; ++columnIndex)\n        {\n            if(grid[rowIndex][columnIndex] > 0)\n            {\n                ++topArea;\n            }\n            maxFrontHeight= std::max(maxFrontHeight, grid[rowIndex][columnIndex]);\n            maxSideHeight= std::max(maxSideHeight, grid[columnIndex][rowIndex]);\n        }\n        frontArea+= maxFrontHeight;\n        sideArea+= maxSideHeight;\n    }\n    return topArea + frontArea + sideArea;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> findUncommonWordsFromSentences(string firstSentence, string secondSentence)\n{\n    unordered_map<string, int> wordCountMap;\n    istringstream sentenceStream(firstSentence + ' ' + secondSentence);\n    string currentWord;\n\n    while (sentenceStream >> currentWord)\n    {\n        wordCountMap[currentWord]++;\n    }\n\n    vector<string> uncommonWords;\n    for (auto it = wordCountMap.begin(); it != wordCountMap.end(); ++it)\n    {\n        if (it->second == 1)\n        {\n            uncommonWords.push_back(it->first);\n        }\n    }\n\n    return uncommonWords;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> findUncommonWordsFromSentences(std::string firstSentence, std::string secondSentence)\n{\n    std::unordered_map<std::string, int> wordCountMap;\n    std::istringstream sentenceStream(firstSentence + ' ' + secondSentence);\n    std::string currentWord;\n\n    while(sentenceStream >> currentWord)\n    {\n        wordCountMap[currentWord]++;\n    }\n\n    std::vector<std::string> uncommonWords;\n    for(const auto &wordPair : wordCountMap)\n    {\n        if(wordPair.second == 1)\n        {\n            uncommonWords.push_back(wordPair.first);\n        }\n    }\n\n    return uncommonWords;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> spiralWalk(int totalRows, int totalCols, int startRow, int startCol)\n{\n    vector<vector<int>> result;\n    int directionRows[]= {0, 1, 0, -1};\n    int directionCols[]= {1, 0, -1, 0};\n    int totalMoves= totalRows * totalCols;\n    int currentRow= startRow, currentCol= startCol, currentDirection= 0;\n\n    while(result.size() < totalMoves)\n    {\n        result.push_back({currentRow, currentCol});\n        currentRow+= directionRows[currentDirection];\n        currentCol+= directionCols[currentDirection];\n\n        if(currentRow < 0 || currentRow >= totalRows || currentCol < 0 || currentCol >= totalCols)\n        {\n            currentRow-= directionRows[currentDirection];\n            currentCol-= directionCols[currentDirection];\n            currentDirection= (currentDirection + 1) % 4;\n            currentRow+= directionRows[currentDirection];\n            currentCol+= directionCols[currentDirection];\n        }\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> spiralWalk(int totalRows, int totalCols, int startRow, int startCol)\n{\n    std::vector<std::vector<int>> result;\n    int directionRows[]= {0, 1, 0, -1};\n    int directionCols[]= {1, 0, -1, 0};\n    int totalMoves= totalRows * totalCols;\n    int currentRow= startRow, currentCol= startCol, currentDirection= 0;\n\n    while(result.size() < totalMoves)\n    {\n        result.push_back({currentRow, currentCol});\n        currentRow+= directionRows[currentDirection];\n        currentCol+= directionCols[currentDirection];\n\n        if(currentRow < 0 || currentRow >= totalRows || currentCol < 0 || currentCol >= totalCols)\n        {\n            currentRow-= directionRows[currentDirection];\n            currentCol-= directionCols[currentDirection];\n            currentDirection= (currentDirection + 1) % 4;\n            currentRow+= directionRows[currentDirection];\n            currentCol+= directionCols[currentDirection];\n        }\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool depthFirstSearch(int currentPerson, int currentGroup, vector<int> &groupAssignments, vector<vector<int>> &dislikesList)\n{\n    if(groupAssignments[currentPerson] != 0)\n    {\n        return groupAssignments[currentPerson] == currentGroup;\n    }\n    groupAssignments[currentPerson] = currentGroup;\n    for(int i = 0; i < dislikesList[currentPerson].size(); ++i)\n    {\n        int dislikedPerson = dislikesList[currentPerson][i];\n        if(!depthFirstSearch(dislikedPerson, -currentGroup, groupAssignments, dislikesList))\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool isPossibleBipartition(int totalPersons, vector<vector<int>> &dislikePairs)\n{\n    vector<int> groupAssignments(totalPersons + 1, 0);\n    vector<vector<int>> dislikesList(totalPersons + 1);\n\n    for(int i = 0; i < dislikePairs.size(); ++i)\n    {\n        dislikesList[dislikePairs[i][0]].push_back(dislikePairs[i][1]);\n        dislikesList[dislikePairs[i][1]].push_back(dislikePairs[i][0]);\n    }\n\n    for(int person = 1; person <= totalPersons; person++)\n    {\n        if(groupAssignments[person] == 0 && !depthFirstSearch(person, 1, groupAssignments, dislikesList))\n        {\n            return false;\n        }\n    }\n\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool depthFirstSearch(int currentPerson, int currentGroup, std::vector<int> &groupAssignments, std::vector<std::vector<int>> &dislikesList)\n{\n    if(groupAssignments[currentPerson] != 0)\n    {\n        return groupAssignments[currentPerson] == currentGroup;\n    }\n    groupAssignments[currentPerson]= currentGroup;\n    for(int dislikedPerson : dislikesList[currentPerson])\n    {\n        if(!depthFirstSearch(dislikedPerson, -currentGroup, groupAssignments, dislikesList))\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool isPossibleBipartition(int totalPersons, std::vector<std::vector<int>> &dislikePairs)\n{\n    std::vector<int> groupAssignments(totalPersons + 1, 0);\n    std::vector<std::vector<int>> dislikesList(totalPersons + 1);\n\n    for(auto &dislikePair : dislikePairs)\n    {\n        dislikesList[dislikePair[0]].push_back(dislikePair[1]);\n        dislikesList[dislikePair[1]].push_back(dislikePair[0]);\n    }\n\n    for(int person= 1; person <= totalPersons; person++)\n    {\n        if(groupAssignments[person] == 0 && !depthFirstSearch(person, 1, groupAssignments, dislikesList))\n        {\n            return false;\n        }\n    }\n\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int minMoves(int numberOfEggs, int numberOfFloors)\n{\n    if(numberOfEggs == 1 || numberOfFloors == 0 || numberOfFloors == 1)\n    {\n        return numberOfFloors;\n    }\n    int minimumAttempts= INT_MAX;\n    for(int floor= 1; floor <= numberOfFloors; floor++)\n    {\n        int tempResult= max(minMoves(numberOfEggs - 1, floor - 1), minMoves(numberOfEggs, numberOfFloors - floor));\n        minimumAttempts= min(minimumAttempts, tempResult);\n    }\n    return minimumAttempts + 1;\n}",
    "output": "int minMoves(int numberOfEggs, int numberOfFloors)\n{\n    if(numberOfEggs == 1 || numberOfFloors == 0 || numberOfFloors == 1)\n    {\n        return numberOfFloors;\n    }\n    int minimumAttempts= INT_MAX;\n    for(int floor= 1; floor <= numberOfFloors; floor++)\n    {\n        int tempResult= max(minMoves(numberOfEggs - 1, floor - 1), minMoves(numberOfEggs, numberOfFloors - floor));\n        minimumAttempts= min(minimumAttempts, tempResult);\n    }\n    return minimumAttempts + 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> fairCandySwap(vector<int> &aliceSizes, vector<int> &bobSizes)\n{\n    int aliceTotal = 0, bobTotal = 0;\n    for (int i = 0; i < aliceSizes.size(); ++i)\n        aliceTotal += aliceSizes[i];\n    for (int i = 0; i < bobSizes.size(); ++i)\n        bobTotal += bobSizes[i];\n\n    int delta = (bobTotal - aliceTotal) / 2;\n    for (int i = 0; i < aliceSizes.size(); ++i)\n    {\n        int aliceCandy = aliceSizes[i];\n        for (int j = 0; j < bobSizes.size(); ++j)\n        {\n            int bobCandy = bobSizes[j];\n            if (aliceCandy + delta == bobCandy)\n            {\n                return {aliceCandy, bobCandy};\n            }\n        }\n    }\n    return {};\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> fairCandySwap(std::vector<int> &aliceSizes, std::vector<int> &bobSizes)\n{\n    int aliceTotal= 0, bobTotal= 0;\n    for(int candy : aliceSizes)\n        aliceTotal+= candy;\n    for(int candy : bobSizes)\n        bobTotal+= candy;\n\n    int delta= (bobTotal - aliceTotal) / 2;\n    for(int aliceCandy : aliceSizes)\n    {\n        for(int bobCandy : bobSizes)\n        {\n            if(aliceCandy + delta == bobCandy)\n            {\n                return {aliceCandy, bobCandy};\n            }\n        }\n    }\n    return {};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    TreeNode *constructFromPrePost(vector<int> &preorderTraversal, vector<int> &postorderTraversal)\n    {\n        return buildTree(preorderTraversal, 0, preorderTraversal.size(), postorderTraversal, 0, postorderTraversal.size());\n    }\n\n    TreeNode *buildTree(vector<int> &preorder, int preStartIndex, int preEndIndex, vector<int> &postorder, int postStartIndex, int postEndIndex)\n    {\n        if(preStartIndex == preEndIndex)\n            return NULL;\n\n        TreeNode *rootNode= new TreeNode(preorder[preStartIndex]);\n\n        if(preStartIndex + 1 == preEndIndex)\n            return rootNode;\n\n        int leftRootValue= preorder[preStartIndex + 1];\n\n        int leftSubtreeSize= 0;\n        for(int i= postStartIndex; i < postEndIndex; ++i)\n        {\n            if(postorder[i] == leftRootValue)\n            {\n                leftSubtreeSize= i - postStartIndex + 1;\n                break;\n            }\n        }\n\n        rootNode->leftChild= buildTree(preorder, preStartIndex + 1, preStartIndex + 1 + leftSubtreeSize, postorder, postStartIndex, postStartIndex + leftSubtreeSize);\n        rootNode->rightChild= buildTree(preorder, preStartIndex + 1 + leftSubtreeSize, preEndIndex, postorder, postStartIndex + leftSubtreeSize, postEndIndex - 1);\n\n        return rootNode;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    TreeNode *constructFromPrePost(std::vector<int> &preorderTraversal, std::vector<int> &postorderTraversal)\n    {\n        return buildTree(preorderTraversal, 0, preorderTraversal.size(), postorderTraversal, 0, postorderTraversal.size());\n    }\n\n    TreeNode *buildTree(std::vector<int> &preorder, int preStartIndex, int preEndIndex, std::vector<int> &postorder, int postStartIndex, int postEndIndex)\n    {\n        if(preStartIndex == preEndIndex)\n            return NULL;\n\n        TreeNode *rootNode= new TreeNode(preorder[preStartIndex]);\n\n        if(preStartIndex + 1 == preEndIndex)\n            return rootNode;\n\n        int leftRootValue= preorder[preStartIndex + 1];\n\n        int leftSubtreeSize= 0;\n        for(int i= postStartIndex; i < postEndIndex; ++i)\n        {\n            if(postorder[i] == leftRootValue)\n            {\n                leftSubtreeSize= i - postStartIndex + 1;\n                break;\n            }\n        }\n\n        rootNode->leftChild= buildTree(preorder, preStartIndex + 1, preStartIndex + 1 + leftSubtreeSize, postorder, postStartIndex, postStartIndex + leftSubtreeSize);\n        rootNode->rightChild= buildTree(preorder, preStartIndex + 1 + leftSubtreeSize, preEndIndex, postorder, postStartIndex + leftSubtreeSize, postEndIndex - 1);\n\n        return rootNode;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> findAndReplacePatterns(vector<string> &inputWords, string pattern)\n{\n    vector<string> matchingWords;\n    for (size_t i = 0; i < inputWords.size(); ++i)\n    {\n        const string &currentWord = inputWords[i];\n        if (currentWord.size() != pattern.size())\n            continue;\n\n        unordered_map<char, char> wordToPatternMap;\n        unordered_map<char, char> patternToWordMap;\n        bool isMatch = true;\n        for (size_t index = 0; index < currentWord.size(); ++index)\n        {\n            char currentChar = currentWord[index];\n            char patternChar = pattern[index];\n\n            if (!wordToPatternMap.count(currentChar))\n                wordToPatternMap[currentChar] = patternChar;\n            if (!patternToWordMap.count(patternChar))\n                patternToWordMap[patternChar] = currentChar;\n\n            if (wordToPatternMap[currentChar] != patternChar || patternToWordMap[patternChar] != currentChar)\n            {\n                isMatch = false;\n                break;\n            }\n        }\n        if (isMatch)\n            matchingWords.push_back(currentWord);\n    }\n    return matchingWords;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> findAndReplacePatterns(std::vector<std::string> &inputWords, std::string pattern)\n{\n    std::vector<std::string> matchingWords;\n    for(const std::string &currentWord : inputWords)\n    {\n        if(currentWord.size() != pattern.size())\n            continue;\n\n        std::unordered_map<char, char> wordToPatternMap;\n        std::unordered_map<char, char> patternToWordMap;\n        bool isMatch= true;\n        for(size_t index= 0; index < currentWord.size(); ++index)\n        {\n            char currentChar= currentWord[index];\n            char patternChar= pattern[index];\n\n            if(!wordToPatternMap.count(currentChar))\n                wordToPatternMap[currentChar]= patternChar;\n            if(!patternToWordMap.count(patternChar))\n                patternToWordMap[patternChar]= currentChar;\n\n            if(wordToPatternMap[currentChar] != patternChar || patternToWordMap[patternChar] != currentChar)\n            {\n                isMatch= false;\n                break;\n            }\n        }\n        if(isMatch)\n            matchingWords.push_back(currentWord);\n    }\n    return matchingWords;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo= 1e9 + 7;\n\nint sumOfWidths(vector<int> &sortedNumbers)\n{\n    int size= sortedNumbers.size();\n    sort(sortedNumbers.begin(), sortedNumbers.end());\n    long long result= 0, coefficient= 1;\n\n    for(int index= 0; index < size; index++, coefficient= coefficient * 2 % modulo)\n        result= (result + (sortedNumbers[index] - sortedNumbers[size - index - 1]) * coefficient) % modulo;\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nconst int modulo= 1e9 + 7;\n\nint sumOfWidths(std::vector<int> &sortedNumbers)\n{\n    int size= sortedNumbers.size();\n    std::sort(sortedNumbers.begin(), sortedNumbers.end());\n    long long result= 0, coefficient= 1;\n\n    for(int index= 0; index < size; index++, coefficient= coefficient * 2 % modulo)\n        result= (result + (sortedNumbers[index] - sortedNumbers[size - index - 1]) * coefficient) % modulo;\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateSurfaceArea(vector<vector<int>> &heightGrid)\n{\n    int gridSize= heightGrid.size();\n    int totalArea= 0;\n\n    for(int row= 0; row < gridSize; ++row)\n    {\n        for(int column= 0; column < gridSize; ++column)\n        {\n            if(heightGrid[row][column])\n            {\n                totalArea+= 4 * heightGrid[row][column] + 2;\n                if(row > 0)\n                    totalArea-= 2 * min(heightGrid[row][column], heightGrid[row - 1][column]);\n                if(column > 0)\n                    totalArea-= 2 * min(heightGrid[row][column], heightGrid[row][column - 1]);\n            }\n        }\n    }\n\n    return totalArea;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateSurfaceArea(std::vector<std::vector<int>> &heightGrid)\n{\n    int gridSize= heightGrid.size();\n    int totalArea= 0;\n\n    for(int row= 0; row < gridSize; ++row)\n    {\n        for(int column= 0; column < gridSize; ++column)\n        {\n            if(heightGrid[row][column])\n            {\n                totalArea+= 4 * heightGrid[row][column] + 2;\n                if(row > 0)\n                    totalArea-= 2 * std::min(heightGrid[row][column], heightGrid[row - 1][column]);\n                if(column > 0)\n                    totalArea-= 2 * std::min(heightGrid[row][column], heightGrid[row][column - 1]);\n            }\n        }\n    }\n\n    return totalArea;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numSpecialEquivalentGroups(vector<string> &words)\n{\n    unordered_set<string> uniqueGroups;\n\n    for (size_t i = 0; i < words.size(); ++i)\n    {\n        string currentWord = words[i];\n        string evenIndexedChars, oddIndexedChars;\n\n        for (size_t index = 0; index < currentWord.size(); ++index)\n        {\n            if (index % 2 == 0)\n                evenIndexedChars += currentWord[index];\n            else\n                oddIndexedChars += currentWord[index];\n        }\n\n        sort(evenIndexedChars.begin(), evenIndexedChars.end());\n        sort(oddIndexedChars.begin(), oddIndexedChars.end());\n\n        uniqueGroups.insert(evenIndexedChars + oddIndexedChars);\n    }\n\n    return uniqueGroups.size();\n}",
    "output": "#include <bits/stdc++.h>\nint numSpecialEquivalentGroups(std::vector<std::string> &words)\n{\n    std::unordered_set<std::string> uniqueGroups;\n\n    for(std::string currentWord : words)\n    {\n        std::string evenIndexedChars, oddIndexedChars;\n\n        for(size_t index= 0; index < currentWord.size(); ++index)\n        {\n            if(index % 2 == 0)\n                evenIndexedChars+= currentWord[index];\n            else\n                oddIndexedChars+= currentWord[index];\n        }\n\n        std::sort(evenIndexedChars.begin(), evenIndexedChars.end());\n        std::sort(oddIndexedChars.begin(), oddIndexedChars.end());\n\n        uniqueGroups.insert(evenIndexedChars + oddIndexedChars);\n    }\n\n    return uniqueGroups.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int valueIn) : value(valueIn), leftChild(NULL), rightChild(NULL) {}\n};\n\nvector<TreeNode *> generateAllPossibleFBT(int nodeCount)\n{\n    if(nodeCount % 2 == 0)\n        return {};\n    if(nodeCount == 1)\n        return {new TreeNode(0)};\n\n    vector<TreeNode *> resultTrees;\n    for(int i = 1; i < nodeCount; i += 2)\n    {\n        vector<TreeNode *> leftSubtrees = generateAllPossibleFBT(i);\n        vector<TreeNode *> rightSubtrees = generateAllPossibleFBT(nodeCount - i - 1);\n        for(int j = 0; j < leftSubtrees.size(); ++j)\n        {\n            TreeNode *leftTree = leftSubtrees[j];\n            for(int k = 0; k < rightSubtrees.size(); ++k)\n            {\n                TreeNode *rightTree = rightSubtrees[k];\n                TreeNode *rootNode = new TreeNode(0);\n                rootNode->leftChild = leftTree;\n                rootNode->rightChild = rightTree;\n                resultTrees.push_back(rootNode);\n            }\n        }\n    }\n    return resultTrees;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int valueIn) : value(valueIn), leftChild(NULL), rightChild(NULL) {}\n};\n\nstd::vector<TreeNode *> generateAllPossibleFBT(int nodeCount)\n{\n    if(nodeCount % 2 == 0)\n        return {};\n    if(nodeCount == 1)\n        return {new TreeNode(0)};\n\n    std::vector<TreeNode *> resultTrees;\n    for(int i= 1; i < nodeCount; i+= 2)\n    {\n        std::vector<TreeNode *> leftSubtrees= generateAllPossibleFBT(i);\n        std::vector<TreeNode *> rightSubtrees= generateAllPossibleFBT(nodeCount - i - 1);\n        for(TreeNode *leftTree : leftSubtrees)\n        {\n            for(TreeNode *rightTree : rightSubtrees)\n            {\n                TreeNode *rootNode= new TreeNode(0);\n                rootNode->leftChild= leftTree;\n                rootNode->rightChild= rightTree;\n                resultTrees.push_back(rootNode);\n            }\n        }\n    }\n    return resultTrees;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass FreqStack\n{\n    unordered_map<int, int> frequencyMap;\n    map<int, stack<int>> groupedElements;\n\n  public:\n    FreqStack() {}\n\n    void push(int element)\n    {\n        int frequency = ++frequencyMap[element];\n        groupedElements[frequency].push(element);\n    }\n\n    int pop()\n    {\n        auto &stack = groupedElements.rbegin()->second;\n        int element = stack.top();\n        stack.pop();\n        if (stack.empty())\n        {\n            groupedElements.erase(groupedElements.rbegin()->first);\n        }\n        --frequencyMap[element];\n        return element;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass FreqStack\n{\n    std::unordered_map<int, int> frequencyMap;\n    std::map<int, std::stack<int>> groupedElements;\n\n  public:\n    FreqStack() {}\n\n    void push(int element)\n    {\n        int frequency= ++frequencyMap[element];\n        groupedElements[frequency].push(element);\n    }\n\n    int pop()\n    {\n        auto &stack= groupedElements.rbegin()->second;\n        int element= stack.top();\n        stack.pop();\n        if(stack.empty())\n        {\n            groupedElements.erase(groupedElements.rbegin()->first);\n        }\n        --frequencyMap[element];\n        return element;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isMonotonic(vector<int> &numberList)\n{\n    bool isIncreasing= true, isDecreasing= true;\n    for(int index= 1; index < numberList.size(); index++)\n    {\n        if(numberList[index] > numberList[index - 1])\n            isDecreasing= false;\n        if(numberList[index] < numberList[index - 1])\n            isIncreasing= false;\n    }\n    return isIncreasing || isDecreasing;\n}",
    "output": "#include <bits/stdc++.h>\nbool isMonotonic(std::vector<int> &numberList)\n{\n    bool isIncreasing= true, isDecreasing= true;\n    for(int index= 1; index < numberList.size(); index++)\n    {\n        if(numberList[index] > numberList[index - 1])\n            isDecreasing= false;\n        if(numberList[index] < numberList[index - 1])\n            isIncreasing= false;\n    }\n    return isIncreasing || isDecreasing;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nvoid inorderTraversal(TreeNode *currentNode, TreeNode *&previousNode)\n{\n    if(currentNode == NULL)\n        return;\n\n    inorderTraversal(currentNode->leftChild, previousNode);\n    previousNode->rightChild= currentNode;\n    previousNode= currentNode;\n    currentNode->leftChild= NULL;\n    inorderTraversal(currentNode->rightChild, previousNode);\n}\n\nTreeNode *increasingBST(TreeNode *rootNode)\n{\n    TreeNode dummyNode(0);\n    TreeNode *previousNode= &dummyNode;\n    inorderTraversal(rootNode, previousNode);\n    return dummyNode.rightChild;\n}",
    "output": "class TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nvoid inorderTraversal(TreeNode *currentNode, TreeNode *&previousNode)\n{\n    if(currentNode == NULL)\n        return;\n\n    inorderTraversal(currentNode->leftChild, previousNode);\n    previousNode->rightChild= currentNode;\n    previousNode= currentNode;\n    currentNode->leftChild= NULL;\n    inorderTraversal(currentNode->rightChild, previousNode);\n}\n\nTreeNode *increasingBST(TreeNode *rootNode)\n{\n    TreeNode dummyNode(0);\n    TreeNode *previousNode= &dummyNode;\n    inorderTraversal(rootNode, previousNode);\n    return dummyNode.rightChild;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint subarrayBitwiseOrs(vector<int> &inputArray)\n{\n    set<int> uniqueResults, currentBitwiseOrs, tempBitwiseOrs;\n    for(int i = 0; i < inputArray.size(); ++i)\n    {\n        int currentNumber = inputArray[i];\n        tempBitwiseOrs = {currentNumber};\n        for(int j = 0; j < currentBitwiseOrs.size(); ++j)\n        {\n            int previousBitwiseOr = *next(currentBitwiseOrs.begin(), j);\n            tempBitwiseOrs.insert(currentNumber | previousBitwiseOr);\n        }\n        currentBitwiseOrs = move(tempBitwiseOrs);\n        uniqueResults.insert(currentBitwiseOrs.begin(), currentBitwiseOrs.end());\n    }\n    return uniqueResults.size();\n}",
    "output": "#include <bits/stdc++.h>\nint subarrayBitwiseOrs(std::vector<int> &inputArray)\n{\n    std::set<int> uniqueResults, currentBitwiseOrs, tempBitwiseOrs;\n    for(int currentNumber : inputArray)\n    {\n        tempBitwiseOrs= {currentNumber};\n        for(int previousBitwiseOr : currentBitwiseOrs)\n        {\n            tempBitwiseOrs.insert(currentNumber | previousBitwiseOr);\n        }\n        currentBitwiseOrs= std::move(tempBitwiseOrs);\n        uniqueResults.insert(currentBitwiseOrs.begin(), currentBitwiseOrs.end());\n    }\n    return uniqueResults.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring getLexicographicallySmallestString(string inputString, int rotations)\n{\n    string smallestString= inputString;\n    for(int index= 0; index < rotations; ++index)\n    {\n        string rotatedString= inputString.substr(index) + inputString.substr(0, index);\n        if(rotatedString < smallestString)\n            smallestString= rotatedString;\n    }\n    return smallestString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string getLexicographicallySmallestString(std::string inputString, int rotations)\n{\n    std::string smallestString = inputString;\n    for(int index = 0; index < rotations; ++index)\n    {\n        std::string rotatedString = inputString.substr(index) + inputString.substr(0, index);\n        if(rotatedString < smallestString)\n            smallestString = rotatedString;\n    }\n    return smallestString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass RLEIterator\n{\n  public:\n    RLEIterator(vector<int> &encoding)\n    {\n        encodedData = encoding;\n        currentIndex = 0;\n    }\n\n    int next(int count)\n    {\n        while(currentIndex < encodedData.size())\n        {\n            if(count <= encodedData[currentIndex])\n            {\n                encodedData[currentIndex] -= count;\n                return encodedData[currentIndex + 1];\n            }\n            count -= encodedData[currentIndex];\n            currentIndex += 2;\n        }\n        return -1;\n    }\n\n  private:\n    vector<int> encodedData;\n    int currentIndex;\n};",
    "output": "#include <bits/stdc++.h>\nclass RLEIterator\n{\n  public:\n    RLEIterator(std::vector<int> &encoding)\n    {\n        encodedData = encoding;\n        currentIndex = 0;\n    }\n\n    int next(int count)\n    {\n        while(currentIndex < encodedData.size())\n        {\n            if(count <= encodedData[currentIndex])\n            {\n                encodedData[currentIndex] -= count;\n                return encodedData[currentIndex + 1];\n            }\n            count -= encodedData[currentIndex];\n            currentIndex += 2;\n        }\n        return -1;\n    }\n\n  private:\n    std::vector<int> encodedData;\n    int currentIndex;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass StockSpanner\n{\n  public:\n    vector<int> stockPrices;\n    stack<int> indexStack;\n\n    StockSpanner() {}\n\n    int next(int currentPrice)\n    {\n        while(!indexStack.empty() && stockPrices[indexStack.top()] <= currentPrice)\n        {\n            indexStack.pop();\n        }\n        int span= indexStack.empty() ? stockPrices.size() + 1 : stockPrices.size() - indexStack.top();\n        indexStack.push(stockPrices.size());\n        stockPrices.push_back(currentPrice);\n        return span;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass StockSpanner\n{\n  public:\n    std::vector<int> stockPrices;\n    std::stack<int> indexStack;\n\n    StockSpanner() {}\n\n    int next(int currentPrice)\n    {\n        while(!indexStack.empty() && stockPrices[indexStack.top()] <= currentPrice)\n        {\n            indexStack.pop();\n        }\n        int span= indexStack.empty() ? stockPrices.size() + 1 : stockPrices.size() - indexStack.top();\n        indexStack.push(stockPrices.size());\n        stockPrices.push_back(currentPrice);\n        return span;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countDigitsLessThanN(vector<int> &availableDigits, int targetNumber)\n{\n    int totalCount= 0, multiplier= 1;\n    string targetNumberStr= to_string(targetNumber);\n    for(int i= targetNumberStr.size() - 1; i >= 0; --i)\n    {\n        totalCount+= (upper_bound(availableDigits.begin(), availableDigits.end(), targetNumberStr[i] - '0') - availableDigits.begin()) * multiplier;\n        multiplier*= availableDigits.size();\n    }\n    return totalCount;\n}",
    "output": "#include <bits/stdc++.h>\n// Include for upper_bound\n\nint countDigitsLessThanN(std::vector<int> &availableDigits, int targetNumber)\n{\n    int totalCount= 0, multiplier= 1;\n    std::string targetNumberStr= std::to_string(targetNumber);\n    for(int i= targetNumberStr.size() - 1; i >= 0; --i)\n    {\n        totalCount+= (std::upper_bound(availableDigits.begin(), availableDigits.end(), targetNumberStr[i] - '0') - availableDigits.begin()) * multiplier;\n        multiplier*= availableDigits.size();\n    }\n    return totalCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\n\nint findValidPermutations(const string &inputString)\n{\n    int stringLength = inputString.size();\n    vector<long long> dynamicProgramming(stringLength + 2, 0);\n    dynamicProgramming[0] = 1;\n\n    for (int i = 0; i < stringLength; ++i)\n    {\n        char currentCharacter = inputString[i];\n        vector<long long> newDynamicProgramming(stringLength + 2, 0);\n        if (currentCharacter == 'I')\n        {\n            for (int index = 0; index < stringLength; ++index)\n            {\n                newDynamicProgramming[index + 1] = (newDynamicProgramming[index + 1] + dynamicProgramming[index]) % mod;\n            }\n        }\n        else\n        {\n            for (int index = stringLength - 1; index >= 0; --index)\n            {\n                newDynamicProgramming[index] = (newDynamicProgramming[index + 1] + dynamicProgramming[index + 1]) % mod;\n            }\n        }\n        dynamicProgramming = newDynamicProgramming;\n    }\n    return dynamicProgramming[0];\n}",
    "output": "#include <bits/stdc++.h>\n#define mod 1000000007\n\nint findValidPermutations(const std::string &inputString)\n{\n    int stringLength= inputString.size();\n    std::vector<long long> dynamicProgramming(stringLength + 2, 0);\n    dynamicProgramming[0]= 1;\n\n    for(char currentCharacter : inputString)\n    {\n        std::vector<long long> newDynamicProgramming(stringLength + 2, 0);\n        if(currentCharacter == 'I')\n        {\n            for(int index= 0; index < stringLength; ++index)\n            {\n                newDynamicProgramming[index + 1]= (newDynamicProgramming[index + 1] + dynamicProgramming[index]) % mod;\n            }\n        }\n        else\n        {\n            for(int index= stringLength - 1; index >= 0; --index)\n            {\n                newDynamicProgramming[index]= (newDynamicProgramming[index + 1] + dynamicProgramming[index + 1]) % mod;\n            }\n        }\n        dynamicProgramming= newDynamicProgramming;\n    }\n    return dynamicProgramming[0];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint totalFruit(vector<int> &fruitTypes)\n{\n    int leftPointer= 0, rightPointer= 0, maxCount= 0, totalFruits= fruitTypes.size();\n    unordered_map<int, int> fruitCount;\n\n    while(rightPointer < totalFruits)\n    {\n        fruitCount[fruitTypes[rightPointer]]++;\n        while(fruitCount.size() > 2)\n        {\n            fruitCount[fruitTypes[leftPointer]]--;\n            if(fruitCount[fruitTypes[leftPointer]] == 0)\n            {\n                fruitCount.erase(fruitTypes[leftPointer]);\n            }\n            leftPointer++;\n        }\n        maxCount= max(maxCount, rightPointer - leftPointer + 1);\n        rightPointer++;\n    }\n    return maxCount;\n}",
    "output": "#include <bits/stdc++.h>\nint totalFruit(std::vector<int> &fruitTypes)\n{\n    int leftPointer = 0, rightPointer = 0, maxCount = 0, totalFruits = fruitTypes.size();\n    std::unordered_map<int, int> fruitCount;\n\n    while (rightPointer < totalFruits)\n    {\n        fruitCount[fruitTypes[rightPointer]]++;\n        while (fruitCount.size() > 2)\n        {\n            fruitCount[fruitTypes[leftPointer]]--;\n            if (fruitCount[fruitTypes[leftPointer]] == 0)\n            {\n                fruitCount.erase(fruitTypes[leftPointer]);\n            }\n            leftPointer++;\n        }\n        maxCount = std::max(maxCount, rightPointer - leftPointer + 1);\n        rightPointer++;\n    }\n    return maxCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid moveEvenOdd(vector<int> &numbers)\n{\n    int evenIndex= 0;\n    int oddIndex= numbers.size() - 1;\n\n    while(evenIndex < oddIndex)\n    {\n        if(numbers[evenIndex] % 2 == 0)\n        {\n            evenIndex++;\n        }\n        else\n        {\n            swap(numbers[evenIndex], numbers[oddIndex]);\n            oddIndex--;\n        }\n    }\n}",
    "output": "#include <bits/stdc++.h>\n// Include for std::swap\n\nvoid moveEvenOdd(std::vector<int> &numbers)\n{\n    int evenIndex= 0;\n    int oddIndex= numbers.size() - 1;\n\n    while(evenIndex < oddIndex)\n    {\n        if(numbers[evenIndex] % 2 == 0)\n        {\n            evenIndex++;\n        }\n        else\n        {\n            std::swap(numbers[evenIndex], numbers[oddIndex]);\n            oddIndex--;\n        }\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPalindrome(long number)\n{\n    string numberAsString= to_string(number);\n    string reversedString= numberAsString;\n    reverse(reversedString.begin(), reversedString.end());\n    return numberAsString == reversedString;\n}\n\nint countSuperPalindromesInRange(string leftBound, string rightBound)\n{\n    long lowerBound= stol(leftBound);\n    long upperBound= stol(rightBound);\n    int count= 0;\n    for(long base= 1; base * base <= upperBound; ++base)\n    {\n        if(isPalindrome(base) && isPalindrome(base * base))\n        {\n            if(base * base >= lowerBound)\n            {\n                count++;\n            }\n        }\n    }\n    return count;\n}",
    "output": "#include <bits/stdc++.h>\nbool isPalindrome(long number)\n{\n    std::string numberAsString= std::to_string(number);\n    std::string reversedString= numberAsString;\n    std::reverse(reversedString.begin(), reversedString.end());\n    return numberAsString == reversedString;\n}\n\nint countSuperPalindromesInRange(std::string leftBound, std::string rightBound)\n{\n    long lowerBound= std::stol(leftBound);\n    long upperBound= std::stol(rightBound);\n    int count= 0;\n    for(long base= 1; base * base <= upperBound; ++base)\n    {\n        if(isPalindrome(base) && isPalindrome(base * base))\n        {\n            if(base * base >= lowerBound)\n            {\n                count++;\n            }\n        }\n    }\n    return count;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint sumOfMinimums(vector<int> &array)\n{\n    int modulus= 1e9 + 7;\n    int arraySize= array.size();\n    vector<int> leftIndices(arraySize), rightIndices(arraySize);\n    stack<int> indexStack;\n\n    for(int index= 0; index < arraySize; index++)\n    {\n        while(!indexStack.empty() && array[indexStack.top()] > array[index])\n        {\n            indexStack.pop();\n        }\n        leftIndices[index]= indexStack.empty() ? -1 : indexStack.top();\n        indexStack.push(index);\n    }\n\n    while(!indexStack.empty())\n        indexStack.pop();\n    for(int index= arraySize - 1; index >= 0; index--)\n    {\n        while(!indexStack.empty() && array[indexStack.top()] > array[index])\n        {\n            indexStack.pop();\n        }\n        rightIndices[index]= indexStack.empty() ? arraySize : indexStack.top();\n        indexStack.push(index);\n    }\n\n    int result= 0;\n    for(int index= 0; index < arraySize; index++)\n    {\n        result= (result + array[index] * (index - leftIndices[index]) * (rightIndices[index] - index)) % modulus;\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nint sumOfMinimums(std::vector<int> &array)\n{\n    int modulus= 1e9 + 7;\n    int arraySize= array.size();\n    std::vector<int> leftIndices(arraySize), rightIndices(arraySize);\n    std::stack<int> indexStack;\n\n    for(int index= 0; index < arraySize; index++)\n    {\n        while(!indexStack.empty() && array[indexStack.top()] > array[index])\n        {\n            indexStack.pop();\n        }\n        leftIndices[index]= indexStack.empty() ? -1 : indexStack.top();\n        indexStack.push(index);\n    }\n\n    while(!indexStack.empty())\n        indexStack.pop();\n    for(int index= arraySize - 1; index >= 0; index--)\n    {\n        while(!indexStack.empty() && array[indexStack.top()] > array[index])\n        {\n            indexStack.pop();\n        }\n        rightIndices[index]= indexStack.empty() ? arraySize : indexStack.top();\n        indexStack.push(index);\n    }\n\n    int result= 0;\n    for(int index= 0; index < arraySize; index++)\n    {\n        result= (result + array[index] * (index - leftIndices[index]) * (rightIndices[index] - index)) % modulus;\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minDifference(vector<int> &numbers, int k)\n{\n    if(numbers.size() <= 1)\n        return 0;\n    sort(numbers.begin(), numbers.end());\n    int minimumDifference= numbers.back() - numbers.front();\n    for(int index= 1; index < numbers.size(); index++)\n    {\n        int upperBound= max(numbers[index - 1] + k, numbers.back() - k);\n        int lowerBound= min(numbers[index] - k, numbers.front() + k);\n        minimumDifference= min(minimumDifference, upperBound - lowerBound);\n    }\n    return minimumDifference;\n}",
    "output": "#include <bits/stdc++.h>\nint minDifference(std::vector<int> &numbers, int k)\n{\n    if(numbers.size() <= 1)\n        return 0;\n    std::sort(numbers.begin(), numbers.end());\n    int minimumDifference= numbers.back() - numbers.front();\n    for(int index= 1; index < numbers.size(); index++)\n    {\n        int upperBound= std::max(numbers[index - 1] + k, numbers.back() - k);\n        int lowerBound= std::min(numbers[index] - k, numbers.front() + k);\n        minimumDifference= std::min(minimumDifference, upperBound - lowerBound);\n    }\n    return minimumDifference;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint snakesAndLadders(vector<vector<int>> &gameBoard)\n{\n    int boardSize = gameBoard.size();\n    auto getRowCol = [&](int position)\n    {\n        int row = (position - 1) / boardSize, col = (position - 1) % boardSize;\n        if (row % 2)\n            col = boardSize - 1 - col;\n        return make_pair(boardSize - 1 - row, col);\n    };\n\n    vector<bool> visitedPositions(boardSize * boardSize + 1, false);\n    queue<pair<int, int>> positionQueue;\n    positionQueue.push({1, 0});\n    visitedPositions[1] = true;\n\n    while (!positionQueue.empty())\n    {\n        auto currentPosition = positionQueue.front();\n        positionQueue.pop();\n        int currentX = currentPosition.first;\n        int currentSteps = currentPosition.second;\n        for (int jump = 1; jump <= 6; jump++)\n        {\n            int nextX = currentX + jump;\n            if (nextX > boardSize * boardSize)\n                break;\n            auto nextRowCol = getRowCol(nextX);\n            if (gameBoard[nextRowCol.first][nextRowCol.second] != -1)\n            {\n                nextX = gameBoard[nextRowCol.first][nextRowCol.second];\n            }\n            if (nextX == boardSize * boardSize)\n                return currentSteps + 1;\n            if (!visitedPositions[nextX])\n            {\n                visitedPositions[nextX] = true;\n                positionQueue.push({nextX, currentSteps + 1});\n            }\n        }\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint snakesAndLadders(std::vector<std::vector<int>> &gameBoard)\n{\n    int boardSize = gameBoard.size();\n    auto getRowCol = [&](int position)\n    {\n        int row = (position - 1) / boardSize, col = (position - 1) % boardSize;\n        if (row % 2)\n            col = boardSize - 1 - col;\n        return std::make_pair(boardSize - 1 - row, col);\n    };\n\n    std::vector<bool> visitedPositions(boardSize * boardSize + 1, false);\n    std::queue<std::pair<int, int>> positionQueue;\n    positionQueue.push({1, 0});\n    visitedPositions[1] = true;\n\n    while (!positionQueue.empty())\n    {\n        auto currentPosition = positionQueue.front();\n        positionQueue.pop();\n        int currentX = currentPosition.first;\n        int currentSteps = currentPosition.second;\n        for (int jump = 1; jump <= 6; jump++)\n        {\n            int nextX = currentX + jump;\n            if (nextX > boardSize * boardSize)\n                break;\n            auto nextRowCol = getRowCol(nextX);\n            if (gameBoard[nextRowCol.first][nextRowCol.second] != -1)\n            {\n                nextX = gameBoard[nextRowCol.first][nextRowCol.second];\n            }\n            if (nextX == boardSize * boardSize)\n                return currentSteps + 1;\n            if (!visitedPositions[nextX])\n            {\n                visitedPositions[nextX] = true;\n                positionQueue.push({nextX, currentSteps + 1});\n            }\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumScore(vector<int> &numberList, int adjustmentValue)\n{\n    sort(numberList.begin(), numberList.end());\n    int numberCount= numberList.size();\n    int minimumDifference= numberList[numberCount - 1] - numberList[0];\n\n    for(int index= 0; index < numberCount - 1; ++index)\n    {\n        int highValue= max(numberList[index] + adjustmentValue, numberList[numberCount - 1] - adjustmentValue);\n        int lowValue= min(numberList[index + 1] - adjustmentValue, numberList[0] + adjustmentValue);\n        minimumDifference= min(minimumDifference, highValue - lowValue);\n    }\n\n    return minimumDifference;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMinimumScore(std::vector<int> &numberList, int adjustmentValue)\n{\n    std::sort(numberList.begin(), numberList.end());\n    int numberCount= numberList.size();\n    int minimumDifference= numberList[numberCount - 1] - numberList[0];\n\n    for(int index= 0; index < numberCount - 1; ++index)\n    {\n        int highValue= std::max(numberList[index] + adjustmentValue, numberList[numberCount - 1] - adjustmentValue);\n        int lowValue= std::min(numberList[index + 1] - adjustmentValue, numberList[0] + adjustmentValue);\n        minimumDifference= std::min(minimumDifference, highValue - lowValue);\n    }\n\n    return minimumDifference;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TopVotedCandidate\n{\n  public:\n    map<int, int> leaderMap;\n\n    TopVotedCandidate(vector<int> voters, vector<int> voteTimes)\n    {\n        int currentLeader= -1;\n        map<int, int> voteCount;\n        for(int i= 0; i < voteTimes.size(); ++i)\n        {\n            voteCount[voters[i]]++;\n            if(voteCount[voters[i]] >= voteCount[currentLeader])\n            {\n                currentLeader= voters[i];\n            }\n            leaderMap[voteTimes[i]]= currentLeader;\n        }\n    }\n\n    int q(int queryTime)\n    {\n        auto it= leaderMap.upper_bound(queryTime);\n        return prev(it)->second;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass TopVotedCandidate\n{\n  public:\n    std::map<int, int> leaderMap;\n\n    TopVotedCandidate(std::vector<int> voters, std::vector<int> voteTimes)\n    {\n        int currentLeader= -1;\n        std::map<int, int> voteCount;\n        for(int i= 0; i < voteTimes.size(); ++i)\n        {\n            voteCount[voters[i]]++;\n            if(voteCount[voters[i]] >= voteCount[currentLeader])\n            {\n                currentLeader= voters[i];\n            }\n            leaderMap[voteTimes[i]]= currentLeader;\n        }\n    }\n\n    int q(int queryTime)\n    {\n        auto it= leaderMap.upper_bound(queryTime);\n        return std::prev(it)->second;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid sortArray(vector<int> &numberList)\n{\n    sort(numberList.begin(), numberList.end());\n}",
    "output": "#include <bits/stdc++.h>\nvoid sortArray(std::vector<int> &numberList)\n{\n    std::sort(numberList.begin(), numberList.end());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint catMouseGame(vector<vector<int>> &graph)\n{\n    int numberOfNodes = graph.size();\n    vector<vector<vector<int>>> gameStatus(numberOfNodes, vector<vector<int>>(numberOfNodes, vector<int>(3, -1)));\n    queue<tuple<int, int, int, int>> queue;\n    for (int mousePosition = 1; mousePosition < numberOfNodes; ++mousePosition)\n    {\n        gameStatus[mousePosition][mousePosition][1] = 2;\n        gameStatus[mousePosition][mousePosition][2] = 2;\n        queue.push({mousePosition, mousePosition, 2, 2});\n        queue.push({mousePosition, mousePosition, 1, 2});\n    }\n    while (!queue.empty())\n    {\n        tuple<int, int, int, int> currentState = queue.front();\n        queue.pop();\n        int currentMousePosition = get<0>(currentState), currentCatPosition = get<1>(currentState), turnType = get<2>(currentState), resultType = get<3>(currentState);\n        for (int j = 0; j < (turnType == 1 ? graph[currentMousePosition].size() : graph[currentCatPosition].size()); ++j)\n        {\n            int previousPosition = (turnType == 1 ? graph[currentMousePosition][j] : graph[currentCatPosition][j]);\n            if (turnType == 2 && previousPosition == 0 || resultType == 2 && gameStatus[previousPosition][currentCatPosition][3 - turnType] != -1)\n                continue;\n            if (gameStatus[previousPosition][currentCatPosition][3 - turnType] != -1)\n                continue;\n            queue.push({currentCatPosition, previousPosition, 3 - turnType, 3 - resultType});\n            gameStatus[previousPosition][currentCatPosition][3 - turnType] = 3 - resultType;\n        }\n    }\n    return gameStatus[1][2][1];\n}",
    "output": "#include <bits/stdc++.h>\nint catMouseGame(std::vector<std::vector<int>> &graph)\n{\n    int numberOfNodes= graph.size();\n    std::vector<std::vector<std::vector<int>>> gameStatus(numberOfNodes, std::vector<std::vector<int>>(numberOfNodes, std::vector<int>(3, -1)));\n    std::queue<std::tuple<int, int, int, int>> queue;\n    for(int mousePosition= 1; mousePosition < numberOfNodes; ++mousePosition)\n    {\n        gameStatus[mousePosition][mousePosition][1]= 2;\n        gameStatus[mousePosition][mousePosition][2]= 2;\n        queue.push({mousePosition, mousePosition, 2, 2});\n        queue.push({mousePosition, mousePosition, 1, 2});\n    }\n    while(!queue.empty())\n    {\n        std::tuple<int, int, int, int> currentState= queue.front();\n        queue.pop();\n        int currentMousePosition= std::get<0>(currentState), currentCatPosition= std::get<1>(currentState), turnType= std::get<2>(currentState), resultType= std::get<3>(currentState);\n        for(int previousPosition : turnType == 1 ? graph[currentMousePosition] : graph[currentCatPosition])\n        {\n            if(turnType == 2 && previousPosition == 0 || resultType == 2 && gameStatus[previousPosition][currentCatPosition][3 - turnType] != -1)\n                continue;\n            if(gameStatus[previousPosition][currentCatPosition][3 - turnType] != -1)\n                continue;\n            queue.push({currentCatPosition, previousPosition, 3 - turnType, 3 - resultType});\n            gameStatus[previousPosition][currentCatPosition][3 - turnType]= 3 - resultType;\n        }\n    }\n    return gameStatus[1][2][1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool hasGroupsSizeX(vector<int> &cardDeck)\n{\n    unordered_map<int, int> cardCounts;\n    for(int card : cardDeck)\n    {\n        cardCounts[card]++;\n    }\n    int gcdResult = 0;\n    for (auto it = cardCounts.begin(); it != cardCounts.end(); ++it)\n    {\n        gcdResult = gcd(gcdResult, it->second);\n    }\n    return gcdResult > 1;\n}",
    "output": "#include <bits/stdc++.h>\nbool hasGroupsSizeX(std::vector<int> &cardDeck)\n{\n    std::unordered_map<int, int> cardCounts;\n    for(int card : cardDeck)\n    {\n        cardCounts[card]++;\n    }\n    int gcdResult= 0;\n    for(auto &count : cardCounts)\n    {\n        gcdResult= std::gcd(gcdResult, count.second);\n    }\n    return gcdResult > 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint partitionDisjoint(vector<int> &numbers)\n{\n    int leftMax= numbers[0], globalMax= numbers[0], leftLength= 1;\n    for(int index= 1; index < numbers.size(); ++index)\n    {\n        if(numbers[index] < leftMax)\n        {\n            leftMax= globalMax;\n            leftLength= index + 1;\n        }\n        else\n        {\n            globalMax= max(globalMax, numbers[index]);\n        }\n    }\n    return leftLength;\n}",
    "output": "#include <bits/stdc++.h>\nint partitionDisjoint(std::vector<int> &numbers)\n{\n    int leftMax = numbers[0], globalMax = numbers[0], leftLength = 1;\n    for(int index = 1; index < numbers.size(); ++index)\n    {\n        if(numbers[index] < leftMax)\n        {\n            leftMax = globalMax;\n            leftLength = index + 1;\n        }\n        else\n        {\n            globalMax = std::max(globalMax, numbers[index]);\n        }\n    }\n    return leftLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> wordSubsets(vector<string> &words1, vector<string> &words2)\n{\n    unordered_map<char, int> maxCharacterCount;\n    for (int i = 0; i < words2.size(); ++i)\n    {\n        const auto &word = words2[i];\n        unordered_map<char, int> characterCount;\n        for (int j = 0; j < word.size(); ++j)\n        {\n            char character = word[j];\n            characterCount[character]++;\n        }\n        for (const auto &entry : characterCount)\n        {\n            maxCharacterCount[entry.first] = max(maxCharacterCount[entry.first], entry.second);\n        }\n    }\n\n    vector<string> result;\n    for (int i = 0; i < words1.size(); ++i)\n    {\n        const auto &word = words1[i];\n        unordered_map<char, int> wordCharacterCount;\n        for (int j = 0; j < word.size(); ++j)\n        {\n            char character = word[j];\n            wordCharacterCount[character]++;\n        }\n\n        bool isUniversal = true;\n        for (const auto &entry : maxCharacterCount)\n        {\n            if (wordCharacterCount[entry.first] < entry.second)\n            {\n                isUniversal = false;\n                break;\n            }\n        }\n\n        if (isUniversal)\n        {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> wordSubsets(std::vector<std::string> &words1, std::vector<std::string> &words2)\n{\n    std::unordered_map<char, int> maxCharacterCount;\n    for(const auto &word : words2)\n    {\n        std::unordered_map<char, int> characterCount;\n        for(char character : word)\n        {\n            characterCount[character]++;\n        }\n        for(const auto &entry : characterCount)\n        {\n            maxCharacterCount[entry.first]= std::max(maxCharacterCount[entry.first], entry.second);\n        }\n    }\n\n    std::vector<std::string> result;\n    for(const auto &word : words1)\n    {\n        std::unordered_map<char, int> wordCharacterCount;\n        for(char character : word)\n        {\n            wordCharacterCount[character]++;\n        }\n\n        bool isUniversal= true;\n        for(const auto &entry : maxCharacterCount)\n        {\n            if(wordCharacterCount[entry.first] < entry.second)\n            {\n                isUniversal= false;\n                break;\n            }\n        }\n\n        if(isUniversal)\n        {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring reverseString(const string &inputString)\n{\n    string reversedString = inputString;\n    reverse(reversedString.begin(), reversedString.end());\n    return reversedString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string reverseString(const std::string &inputString)\n{\n    std::string reversedString= inputString;\n    std::reverse(reversedString.begin(), reversedString.end());\n    return reversedString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canReorderDoubled(vector<int> &inputArray)\n{\n    map<int, int> elementCount;\n    for(int element : inputArray)\n    {\n        elementCount[element]++;\n    }\n\n    for(auto it = elementCount.begin(); it != elementCount.end(); ++it)\n    {\n        const int currentElement = it->first;\n        int count = it->second;\n        if(count > 0)\n        {\n            int targetElement = currentElement < 0 ? currentElement / 2 : currentElement * 2;\n            if(elementCount[targetElement] < count)\n                return false;\n            elementCount[targetElement] -= count;\n        }\n    }\n\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool canReorderDoubled(std::vector<int> &inputArray)\n{\n    std::map<int, int> elementCount;\n    for(int element : inputArray)\n    {\n        elementCount[element]++;\n    }\n\n    for(const auto &[currentElement, count] : elementCount)\n    {\n        if(count > 0)\n        {\n            int targetElement= currentElement < 0 ? currentElement / 2 : currentElement * 2;\n            if(elementCount[targetElement] < count)\n                return false;\n            elementCount[targetElement]-= count;\n        }\n    }\n\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass CBTInserter\n{\n  public:\n    TreeNode *rootNode;\n    queue<TreeNode *> nodeQueue;\n\n    CBTInserter(TreeNode *root)\n    {\n        this->rootNode= root;\n        nodeQueue.push(root);\n        while(!nodeQueue.empty())\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            if(!currentNode->leftChild || !currentNode->rightChild)\n                break;\n            nodeQueue.push(currentNode->leftChild);\n            nodeQueue.push(currentNode->rightChild);\n            nodeQueue.pop();\n        }\n    }\n\n    int insert(int value)\n    {\n        TreeNode *newNode= new TreeNode(value);\n        TreeNode *parentNode= nodeQueue.front();\n        if(!parentNode->leftChild)\n        {\n            parentNode->leftChild= newNode;\n        }\n        else\n        {\n            parentNode->rightChild= newNode;\n            nodeQueue.push(parentNode->leftChild);\n            nodeQueue.push(parentNode->rightChild);\n            nodeQueue.pop();\n        }\n        return parentNode->value;\n    }\n\n    TreeNode *getRoot()\n    {\n        return rootNode;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass CBTInserter\n{\n  public:\n    TreeNode *rootNode;\n    std::queue<TreeNode *> nodeQueue;\n\n    CBTInserter(TreeNode *root)\n    {\n        this->rootNode= root;\n        nodeQueue.push(root);\n        while(!nodeQueue.empty())\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            if(!currentNode->leftChild || !currentNode->rightChild)\n                break;\n            nodeQueue.push(currentNode->leftChild);\n            nodeQueue.push(currentNode->rightChild);\n            nodeQueue.pop();\n        }\n    }\n\n    int insert(int value)\n    {\n        TreeNode *newNode= new TreeNode(value);\n        TreeNode *parentNode= nodeQueue.front();\n        if(!parentNode->leftChild)\n        {\n            parentNode->leftChild= newNode;\n        }\n        else\n        {\n            parentNode->rightChild= newNode;\n            nodeQueue.push(parentNode->leftChild);\n            nodeQueue.push(parentNode->rightChild);\n            nodeQueue.pop();\n        }\n        return parentNode->value;\n    }\n\n    TreeNode *getRoot()\n    {\n        return rootNode;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\n\nint numMusicPlaylists(int totalSongs, int playlistLength, int maxRepeat)\n{\n    vector<vector<long long>> dynamicProgramming(playlistLength + 1, vector<long long>(totalSongs + 1, 0));\n    dynamicProgramming[0][0] = 1;\n    for(int currentLength = 1; currentLength <= playlistLength; currentLength++)\n    {\n        for(int currentSongs = 1; currentSongs <= totalSongs; currentSongs++)\n        {\n            dynamicProgramming[currentLength][currentSongs] = ((dynamicProgramming[currentLength - 1][currentSongs - 1] * (totalSongs - (currentSongs - 1))) % mod + (dynamicProgramming[currentLength - 1][currentSongs] * max(0, currentSongs - maxRepeat)) % mod) % mod;\n        }\n    }\n    return dynamicProgramming[playlistLength][totalSongs];\n}",
    "output": "#include <bits/stdc++.h>\n#define mod 1000000007\n\nint numMusicPlaylists(int totalSongs, int playlistLength, int maxRepeat)\n{\n    std::vector<std::vector<long long>> dynamicProgramming(playlistLength + 1, std::vector<long long>(totalSongs + 1, 0));\n    dynamicProgramming[0][0]= 1;\n    for(int currentLength= 1; currentLength <= playlistLength; currentLength++)\n    {\n        for(int currentSongs= 1; currentSongs <= totalSongs; currentSongs++)\n        {\n            dynamicProgramming[currentLength][currentSongs]= ((dynamicProgramming[currentLength - 1][currentSongs - 1] * (totalSongs - (currentSongs - 1))) % mod + (dynamicProgramming[currentLength - 1][currentSongs] * std::max(0, currentSongs - maxRepeat)) % mod) % mod;\n        }\n    }\n    return dynamicProgramming[playlistLength][totalSongs];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minAddToMakeValid(string parenthesesString)\n{\n    int invalidCount = 0, balanceCount = 0;\n    for (int i = 0; i < parenthesesString.size(); ++i)\n    {\n        char currentChar = parenthesesString[i];\n        balanceCount += (currentChar == '(') ? 1 : -1;\n        if (balanceCount == -1)\n        {\n            invalidCount++;\n            balanceCount++;\n        }\n    }\n    return invalidCount + balanceCount;\n}",
    "output": "#include <bits/stdc++.h>\nint minAddToMakeValid(std::string parenthesesString)\n{\n    int invalidCount= 0, balanceCount= 0;\n    for(char currentChar : parenthesesString)\n    {\n        balanceCount+= (currentChar == '(') ? 1 : -1;\n        if(balanceCount == -1)\n        {\n            invalidCount++;\n            balanceCount++;\n        }\n    }\n    return invalidCount + balanceCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// for std::swap\nusing namespace std;\n\nvector<int> sortArrayByParityII(vector<int> &inputArray)\n{\n    int oddIndex= 1;\n    for(int evenIndex= 0; evenIndex < inputArray.size(); evenIndex+= 2)\n    {\n        if(inputArray[evenIndex] % 2)\n        {\n            while(inputArray[oddIndex] % 2)\n            {\n                oddIndex+= 2;\n            }\n            swap(inputArray[evenIndex], inputArray[oddIndex]);\n        }\n    }\n    return inputArray;\n}",
    "output": "#include <bits/stdc++.h>\n// for std::swap\n\nstd::vector<int> sortArrayByParityII(std::vector<int> &inputArray)\n{\n    int oddIndex= 1;\n    for(int evenIndex= 0; evenIndex < inputArray.size(); evenIndex+= 2)\n    {\n        if(inputArray[evenIndex] % 2)\n        {\n            while(inputArray[oddIndex] % 2)\n            {\n                oddIndex+= 2;\n            }\n            std::swap(inputArray[evenIndex], inputArray[oddIndex]);\n        }\n    }\n    return inputArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint threeSumMulti(vector<int> &numberArray, int targetSum)\n{\n    const int modulo= 1000000007;\n    long long totalCount= 0;\n\n    sort(numberArray.begin(), numberArray.end());\n    int arraySize= numberArray.size();\n\n    for(int firstIndex= 0; firstIndex < arraySize - 2; ++firstIndex)\n    {\n        int secondIndex= firstIndex + 1, thirdIndex= arraySize - 1;\n        while(secondIndex < thirdIndex)\n        {\n            int currentSum= numberArray[firstIndex] + numberArray[secondIndex] + numberArray[thirdIndex];\n            if(currentSum > targetSum)\n            {\n                thirdIndex--;\n            }\n            else if(currentSum < targetSum)\n            {\n                secondIndex++;\n            }\n            else\n            {\n                if(numberArray[secondIndex] != numberArray[thirdIndex])\n                {\n                    int leftCount= 1, rightCount= 1;\n\n                    while(numberArray[secondIndex] == numberArray[secondIndex + 1])\n                    {\n                        leftCount++;\n                        secondIndex++;\n                    }\n                    while(numberArray[thirdIndex] == numberArray[thirdIndex - 1])\n                    {\n                        rightCount++;\n                        thirdIndex--;\n                    }\n\n                    totalCount+= leftCount * rightCount;\n                    totalCount%= modulo;\n                    secondIndex++, thirdIndex--;\n                }\n                else\n                {\n                    totalCount+= (long long)(thirdIndex - secondIndex + 1) * (thirdIndex - secondIndex) / 2;\n                    totalCount%= modulo;\n                    break;\n                }\n            }\n        }\n    }\n\n    return totalCount;\n}",
    "output": "#include <bits/stdc++.h>\nint threeSumMulti(std::vector<int> &numberArray, int targetSum)\n{\n    const int modulo= 1000000007;\n    long long totalCount= 0;\n\n    sort(numberArray.begin(), numberArray.end());\n    int arraySize= numberArray.size();\n\n    for(int firstIndex= 0; firstIndex < arraySize - 2; ++firstIndex)\n    {\n        int secondIndex= firstIndex + 1, thirdIndex= arraySize - 1;\n        while(secondIndex < thirdIndex)\n        {\n            int currentSum= numberArray[firstIndex] + numberArray[secondIndex] + numberArray[thirdIndex];\n            if(currentSum > targetSum)\n            {\n                thirdIndex--;\n            }\n            else if(currentSum < targetSum)\n            {\n                secondIndex++;\n            }\n            else\n            {\n                if(numberArray[secondIndex] != numberArray[thirdIndex])\n                {\n                    int leftCount= 1, rightCount= 1;\n\n                    while(numberArray[secondIndex] == numberArray[secondIndex + 1])\n                    {\n                        leftCount++;\n                        secondIndex++;\n                    }\n                    while(numberArray[thirdIndex] == numberArray[thirdIndex - 1])\n                    {\n                        rightCount++;\n                        thirdIndex--;\n                    }\n\n                    totalCount+= leftCount * rightCount;\n                    totalCount%= modulo;\n                    secondIndex++, thirdIndex--;\n                }\n                else\n                {\n                    totalCount+= (long long)(thirdIndex - secondIndex + 1) * (thirdIndex - secondIndex) / 2;\n                    totalCount%= modulo;\n                    break;\n                }\n            }\n        }\n    }\n\n    return totalCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minMalwareSpread(vector<vector<int>> &infectionGraph, vector<int> &initialMalwareNodes)\n{\n    int totalNodes = infectionGraph.size();\n    sort(initialMalwareNodes.begin(), initialMalwareNodes.end());\n\n    unordered_set<int> malwareSet(initialMalwareNodes.begin(), initialMalwareNodes.end());\n\n    int minNode = initialMalwareNodes[0], minSpreadCount = totalNodes + 1;\n    for (int i = 0; i < initialMalwareNodes.size(); ++i)\n    {\n        int malwareNode = initialMalwareNodes[i];\n        queue<int> bfsQueue;\n        vector<bool> visitedNodes(totalNodes, false);\n\n        for (int j = 0; j < initialMalwareNodes.size(); ++j)\n        {\n            int otherMalwareNode = initialMalwareNodes[j];\n            if (malwareNode != otherMalwareNode)\n            {\n                bfsQueue.push(otherMalwareNode);\n                visitedNodes[otherMalwareNode] = true;\n            }\n        }\n\n        while (!bfsQueue.empty())\n        {\n            int currentNode = bfsQueue.front();\n            bfsQueue.pop();\n            for (int nextNode = 0; nextNode < totalNodes; ++nextNode)\n            {\n                if (infectionGraph[currentNode][nextNode] == 1 && !visitedNodes[nextNode] && !malwareSet.count(nextNode))\n                {\n                    visitedNodes[nextNode] = true;\n                    bfsQueue.push(nextNode);\n                }\n            }\n        }\n\n        int spreadCount = 0;\n        for (int k = 0; k < visitedNodes.size(); ++k)\n        {\n            spreadCount += visitedNodes[k];\n        }\n\n        if (spreadCount < minSpreadCount)\n        {\n            minNode = malwareNode;\n            minSpreadCount = spreadCount;\n        }\n    }\n\n    return minNode;\n}",
    "output": "#include <bits/stdc++.h>\nint minMalwareSpread(std::vector<std::vector<int>> &infectionGraph, std::vector<int> &initialMalwareNodes)\n{\n    int totalNodes= infectionGraph.size();\n    std::sort(initialMalwareNodes.begin(), initialMalwareNodes.end());\n\n    std::unordered_set<int> malwareSet(initialMalwareNodes.begin(), initialMalwareNodes.end());\n\n    int minNode= initialMalwareNodes[0], minSpreadCount= totalNodes + 1;\n    for(int malwareNode : initialMalwareNodes)\n    {\n        std::queue<int> bfsQueue;\n        std::vector<bool> visitedNodes(totalNodes, false);\n\n        for(int otherMalwareNode : initialMalwareNodes)\n        {\n            if(malwareNode != otherMalwareNode)\n            {\n                bfsQueue.push(otherMalwareNode);\n                visitedNodes[otherMalwareNode]= true;\n            }\n        }\n\n        while(!bfsQueue.empty())\n        {\n            int currentNode= bfsQueue.front();\n            bfsQueue.pop();\n            for(int nextNode= 0; nextNode < totalNodes; ++nextNode)\n            {\n                if(infectionGraph[currentNode][nextNode] == 1 && !visitedNodes[nextNode] && !malwareSet.count(nextNode))\n                {\n                    visitedNodes[nextNode]= true;\n                    bfsQueue.push(nextNode);\n                }\n            }\n        }\n\n        int spreadCount= 0;\n        for(bool isVisited : visitedNodes)\n        {\n            spreadCount+= isVisited;\n        }\n\n        if(spreadCount < minSpreadCount)\n        {\n            minNode= malwareNode;\n            minSpreadCount= spreadCount;\n        }\n    }\n\n    return minNode;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isLongPressedName(string originalName, string typedName)\n{\n    int originalIndex= 0, typedIndex= 0;\n    while(typedIndex < typedName.length())\n    {\n        if(originalIndex < originalName.length() && originalName[originalIndex] == typedName[typedIndex])\n        {\n            originalIndex++;\n        }\n        else if(typedIndex == 0 || typedName[typedIndex] != typedName[typedIndex - 1])\n        {\n            return false;\n        }\n        typedIndex++;\n    }\n    return originalIndex == originalName.length();\n}",
    "output": "#include <bits/stdc++.h>\nbool isLongPressedName(std::string originalName, std::string typedName)\n{\n    int originalIndex= 0, typedIndex= 0;\n    while(typedIndex < typedName.length())\n    {\n        if(originalIndex < originalName.length() && originalName[originalIndex] == typedName[typedIndex])\n        {\n            originalIndex++;\n        }\n        else if(typedIndex == 0 || typedName[typedIndex] != typedName[typedIndex - 1])\n        {\n            return false;\n        }\n        typedIndex++;\n    }\n    return originalIndex == originalName.length();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minFlipsMonoIncr(string binaryString)\n{\n    int flipCount = 0, oneCount = 0;\n    for (int i = 0; i < binaryString.size(); ++i)\n    {\n        char currentChar = binaryString[i];\n        if (currentChar == '1')\n        {\n            oneCount++;\n        }\n        else\n        {\n            flipCount = min(flipCount + 1, oneCount);\n        }\n    }\n    return flipCount;\n}",
    "output": "#include <bits/stdc++.h>\nint minFlipsMonoIncr(std::string binaryString)\n{\n    int flipCount= 0, oneCount= 0;\n    for(char currentChar : binaryString)\n    {\n        if(currentChar == '1')\n        {\n            oneCount++;\n        }\n        else\n        {\n            flipCount= std::min(flipCount + 1, oneCount);\n        }\n    }\n    return flipCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findSameBinaryValueParts(const vector<int> &binaryArray)\n{\n    int totalOnes = 0;\n    for (int value : binaryArray)\n        totalOnes += value;\n\n    if (totalOnes % 3 != 0)\n        return {-1, -1};\n\n    int targetOnes = totalOnes / 3;\n    if (targetOnes == 0)\n        return {0, static_cast<int>(binaryArray.size()) - 2};\n\n    int foundCount = 0, firstIndex = -1, secondIndex = -1;\n    totalOnes = 0;\n    for (int currentIndex = 0; currentIndex < binaryArray.size(); ++currentIndex)\n    {\n        if (binaryArray[currentIndex] == 1)\n        {\n            totalOnes++;\n            if (totalOnes == targetOnes + 1)\n                foundCount++;\n            if (foundCount == 1 && firstIndex == -1)\n                firstIndex = currentIndex;\n            if (foundCount == 2 && secondIndex == -1)\n                secondIndex = currentIndex;\n            if (foundCount == 3)\n                break;\n        }\n    }\n\n    return {firstIndex, secondIndex};\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findSameBinaryValueParts(const std::vector<int> &binaryArray)\n{\n    int totalOnes= 0;\n    for(int value : binaryArray)\n        totalOnes+= value;\n\n    if(totalOnes % 3 != 0)\n        return {-1, -1};\n\n    int targetOnes= totalOnes / 3;\n    if(targetOnes == 0)\n        return {0, static_cast<int>(binaryArray.size()) - 2};\n\n    int foundCount= 0, firstIndex= -1, secondIndex= -1;\n    totalOnes= 0;\n    for(int currentIndex= 0; currentIndex < binaryArray.size(); ++currentIndex)\n    {\n        if(binaryArray[currentIndex] == 1)\n        {\n            totalOnes++;\n            if(totalOnes == targetOnes + 1)\n                foundCount++;\n            if(foundCount == 1 && firstIndex == -1)\n                firstIndex= currentIndex;\n            if(foundCount == 2 && secondIndex == -1)\n                secondIndex= currentIndex;\n            if(foundCount == 3)\n                break;\n        }\n    }\n\n    return {firstIndex, secondIndex};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minMalwareSpread(vector<vector<int>> &graph, vector<int> &initialInfected)\n{\n    int nodeCount = graph.size(), resultNode = 0, minimumAreaSize = INT_MAX;\n    vector<int> componentColor(nodeCount, -1);\n    int uniqueColors = 0;\n\n    for(int nodeIndex = 0; nodeIndex < nodeCount; ++nodeIndex)\n    {\n        if(componentColor[nodeIndex] == -1)\n        {\n            queue<int> nodeQueue;\n            nodeQueue.push(nodeIndex);\n            componentColor[nodeIndex] = uniqueColors;\n\n            while(!nodeQueue.empty())\n            {\n                int currentNode = nodeQueue.front();\n                nodeQueue.pop();\n                for(int neighborIndex = 0; neighborIndex < nodeCount; ++neighborIndex)\n                {\n                    if(graph[currentNode][neighborIndex] == 1 && componentColor[neighborIndex] == -1)\n                    {\n                        nodeQueue.push(neighborIndex);\n                        componentColor[neighborIndex] = uniqueColors;\n                    }\n                }\n            }\n            ++uniqueColors;\n        }\n    }\n\n    vector<int> areaSize(uniqueColors, 0), infectedCount(uniqueColors, 0);\n    set<int> initiallyInfectedSet(initialInfected.begin(), initialInfected.end());\n    for(int nodeIndex = 0; nodeIndex < nodeCount; ++nodeIndex)\n    {\n        ++areaSize[componentColor[nodeIndex]];\n        if(initiallyInfectedSet.count(nodeIndex))\n        {\n            ++infectedCount[componentColor[nodeIndex]];\n        }\n    }\n\n    for(int i = 0; i < initialInfected.size(); ++i)\n    {\n        int infectedNode = initialInfected[i];\n        if(infectedCount[componentColor[infectedNode]] == 1)\n        {\n            if(areaSize[componentColor[infectedNode]] < minimumAreaSize)\n            {\n                minimumAreaSize = areaSize[componentColor[infectedNode]];\n                resultNode = infectedNode;\n            }\n            else if(areaSize[componentColor[infectedNode]] == minimumAreaSize && infectedNode < resultNode)\n            {\n                resultNode = infectedNode;\n            }\n        }\n    }\n\n    return resultNode;\n}",
    "output": "#include <bits/stdc++.h>\nint minMalwareSpread(std::vector<std::vector<int>> &graph, std::vector<int> &initialInfected)\n{\n    int nodeCount= graph.size(), resultNode= 0, minimumAreaSize= INT_MAX;\n    std::vector<int> componentColor(nodeCount, -1);\n    int uniqueColors= 0;\n\n    for(int nodeIndex= 0; nodeIndex < nodeCount; ++nodeIndex)\n    {\n        if(componentColor[nodeIndex] == -1)\n        {\n            std::queue<int> nodeQueue;\n            nodeQueue.push(nodeIndex);\n            componentColor[nodeIndex]= uniqueColors;\n\n            while(!nodeQueue.empty())\n            {\n                int currentNode= nodeQueue.front();\n                nodeQueue.pop();\n                for(int neighborIndex= 0; neighborIndex < nodeCount; ++neighborIndex)\n                {\n                    if(graph[currentNode][neighborIndex] == 1 && componentColor[neighborIndex] == -1)\n                    {\n                        nodeQueue.push(neighborIndex);\n                        componentColor[neighborIndex]= uniqueColors;\n                    }\n                }\n            }\n            ++uniqueColors;\n        }\n    }\n\n    std::vector<int> areaSize(uniqueColors, 0), infectedCount(uniqueColors, 0);\n    std::set<int> initiallyInfectedSet(initialInfected.begin(), initialInfected.end());\n    for(int nodeIndex= 0; nodeIndex < nodeCount; ++nodeIndex)\n    {\n        ++areaSize[componentColor[nodeIndex]];\n        if(initiallyInfectedSet.count(nodeIndex))\n        {\n            ++infectedCount[componentColor[nodeIndex]];\n        }\n    }\n\n    for(int infectedNode : initialInfected)\n    {\n        if(infectedCount[componentColor[infectedNode]] == 1)\n        {\n            if(areaSize[componentColor[infectedNode]] < minimumAreaSize)\n            {\n                minimumAreaSize= areaSize[componentColor[infectedNode]];\n                resultNode= infectedNode;\n            }\n            else if(areaSize[componentColor[infectedNode]] == minimumAreaSize && infectedNode < resultNode)\n            {\n                resultNode= infectedNode;\n            }\n        }\n    }\n\n    return resultNode;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numUniqueEmails(vector<string> &emailList)\n{\n    set<string> uniqueEmails;\n\n    for (int i = 0; i < emailList.size(); ++i)\n    {\n        string email = emailList[i];\n        string localName, domainName;\n        bool atSignFound = false, plusSignFound = false;\n\n        for (int j = 0; j < email.size(); ++j)\n        {\n            char currentChar = email[j];\n            if (!atSignFound)\n            {\n                if (currentChar == '+')\n                    plusSignFound = true;\n                else if (currentChar == '@')\n                    atSignFound = true;\n                else if (!plusSignFound && currentChar != '.')\n                    localName += currentChar;\n            }\n            else\n                domainName += currentChar;\n        }\n\n        uniqueEmails.insert(localName + \"@\" + domainName);\n    }\n\n    return uniqueEmails.size();\n}",
    "output": "#include <bits/stdc++.h>\nint numUniqueEmails(std::vector<std::string> &emailList)\n{\n    std::set<std::string> uniqueEmails;\n\n    for(auto &email : emailList)\n    {\n        std::string localName, domainName;\n        bool atSignFound= false, plusSignFound= false;\n\n        for(char currentChar : email)\n        {\n            if(!atSignFound)\n            {\n                if(currentChar == '+')\n                    plusSignFound= true;\n                else if(currentChar == '@')\n                    atSignFound= true;\n                else if(!plusSignFound && currentChar != '.')\n                    localName+= currentChar;\n            }\n            else\n                domainName+= currentChar;\n        }\n\n        uniqueEmails.insert(localName + \"@\" + domainName);\n    }\n\n    return uniqueEmails.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numSubarraysWithSum(vector<int> &inputArray, int targetSum)\n{\n    unordered_map<int, int> prefixSumCount = {{0, 1}};\n    int currentSum = 0, totalCount = 0;\n\n    for (int i = 0; i < inputArray.size(); ++i)\n    {\n        const auto &element = inputArray[i];\n        currentSum += element;\n        totalCount += prefixSumCount[currentSum - targetSum];\n        prefixSumCount[currentSum]++;\n    }\n\n    return totalCount;\n}",
    "output": "#include <bits/stdc++.h>\nint numSubarraysWithSum(std::vector<int> &inputArray, int targetSum)\n{\n    std::unordered_map<int, int> prefixSumCount= {{0, 1}};\n    int currentSum= 0, totalCount= 0;\n\n    for(const auto &element : inputArray)\n    {\n        currentSum+= element;\n        totalCount+= prefixSumCount[currentSum - targetSum];\n        prefixSumCount[currentSum]++;\n    }\n\n    return totalCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minFallingPathSum(vector<vector<int>> &pathMatrix)\n{\n    int matrixSize= pathMatrix.size();\n    for(int rowIndex= 1; rowIndex < matrixSize; ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex < matrixSize; ++colIndex)\n        {\n            int minValue= pathMatrix[rowIndex - 1][colIndex];\n            if(colIndex > 0)\n                minValue= min(minValue, pathMatrix[rowIndex - 1][colIndex - 1]);\n            if(colIndex < matrixSize - 1)\n                minValue= min(minValue, pathMatrix[rowIndex - 1][colIndex + 1]);\n            pathMatrix[rowIndex][colIndex]+= minValue;\n        }\n    }\n    return *min_element(pathMatrix.back().begin(), pathMatrix.back().end());\n}",
    "output": "#include <bits/stdc++.h>\nint minFallingPathSum(std::vector<std::vector<int>> &pathMatrix)\n{\n    int matrixSize= pathMatrix.size();\n    for(int rowIndex= 1; rowIndex < matrixSize; ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex < matrixSize; ++colIndex)\n        {\n            int minValue= pathMatrix[rowIndex - 1][colIndex];\n            if(colIndex > 0)\n                minValue= std::min(minValue, pathMatrix[rowIndex - 1][colIndex - 1]);\n            if(colIndex < matrixSize - 1)\n                minValue= std::min(minValue, pathMatrix[rowIndex - 1][colIndex + 1]);\n            pathMatrix[rowIndex][colIndex]+= minValue;\n        }\n    }\n    return *std::min_element(pathMatrix.back().begin(), pathMatrix.back().end());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> beautifulArray(int arraySize)\n{\n    vector<int> beautifulNumbers = {1};\n    while(beautifulNumbers.size() < arraySize)\n    {\n        vector<int> tempArray;\n        for (int i = 0; i < beautifulNumbers.size(); ++i)\n        {\n            int number = beautifulNumbers[i];\n            if(number * 2 - 1 <= arraySize)\n                tempArray.push_back(number * 2 - 1);\n        }\n        for (int i = 0; i < beautifulNumbers.size(); ++i)\n        {\n            int number = beautifulNumbers[i];\n            if(number * 2 <= arraySize)\n                tempArray.push_back(number * 2);\n        }\n        beautifulNumbers = tempArray;\n    }\n    return beautifulNumbers;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> beautifulArray(int arraySize)\n{\n    std::vector<int> beautifulNumbers= {1};\n    while(beautifulNumbers.size() < arraySize)\n    {\n        std::vector<int> tempArray;\n        for(int number : beautifulNumbers)\n        {\n            if(number * 2 - 1 <= arraySize)\n                tempArray.push_back(number * 2 - 1);\n        }\n        for(int number : beautifulNumbers)\n        {\n            if(number * 2 <= arraySize)\n                tempArray.push_back(number * 2);\n        }\n        beautifulNumbers= tempArray;\n    }\n    return beautifulNumbers;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass RecentCounter\n{\n  public:\n    deque<int> requestTimes;\n\n    RecentCounter() {}\n\n    int ping(int currentTime)\n    {\n        requestTimes.push_back(currentTime);\n        while(requestTimes.front() < currentTime - 3000)\n        {\n            requestTimes.pop_front();\n        }\n        return requestTimes.size();\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass RecentCounter\n{\n  public:\n    std::deque<int> requestTimes;\n\n    RecentCounter() {}\n\n    int ping(int currentTime)\n    {\n        requestTimes.push_back(currentTime);\n        while(requestTimes.front() < currentTime - 3000)\n        {\n            requestTimes.pop_front();\n        }\n        return requestTimes.size();\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> powerfulIntegers(int baseX, int baseY, int upperBound)\n{\n    int maxExponentX= baseX == 1 ? 0 : ceil(log(upperBound) / log(baseX));\n    int maxExponentY= baseY == 1 ? 0 : ceil(log(upperBound) / log(baseY));\n    set<int> uniquePowerfulIntegers;\n\n    for(int exponentX= 0; exponentX <= maxExponentX; exponentX++)\n    {\n        for(int exponentY= 0; exponentY <= maxExponentY; exponentY++)\n        {\n            int powerfulInteger= pow(baseX, exponentX) + pow(baseY, exponentY);\n            if(powerfulInteger <= upperBound)\n            {\n                uniquePowerfulIntegers.insert(powerfulInteger);\n            }\n        }\n    }\n\n    return vector<int>(uniquePowerfulIntegers.begin(), uniquePowerfulIntegers.end());\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> powerfulIntegers(int baseX, int baseY, int upperBound)\n{\n    int maxExponentX= baseX == 1 ? 0 : std::ceil(std::log(upperBound) / std::log(baseX));\n    int maxExponentY= baseY == 1 ? 0 : std::ceil(std::log(upperBound) / std::log(baseY));\n    std::set<int> uniquePowerfulIntegers;\n\n    for(int exponentX= 0; exponentX <= maxExponentX; exponentX++)\n    {\n        for(int exponentY= 0; exponentY <= maxExponentY; exponentY++)\n        {\n            int powerfulInteger= std::pow(baseX, exponentX) + std::pow(baseY, exponentY);\n            if(powerfulInteger <= upperBound)\n            {\n                uniquePowerfulIntegers.insert(powerfulInteger);\n            }\n        }\n    }\n\n    return std::vector<int>(uniquePowerfulIntegers.begin(), uniquePowerfulIntegers.end());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestBridge(vector<vector<int>> &grid)\n{\n    int gridSize = grid.size();\n    queue<pair<int, int>> coordinateQueue;\n    bool isIslandFound = false;\n\n    for(int rowIndex = 0; rowIndex < gridSize && !isIslandFound; ++rowIndex)\n    {\n        for(int columnIndex = 0; columnIndex < gridSize; ++columnIndex)\n        {\n            if(grid[rowIndex][columnIndex] == 1)\n            {\n                dfs(grid, coordinateQueue, rowIndex, columnIndex);\n                isIslandFound = true;\n                break;\n            }\n        }\n    }\n\n    int steps = 0;\n    vector<vector<int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n    while(!coordinateQueue.empty())\n    {\n        int queueSize = coordinateQueue.size();\n        for(int i = 0; i < queueSize; ++i)\n        {\n            auto [currentX, currentY] = coordinateQueue.front();\n            coordinateQueue.pop();\n            for(int j = 0; j < directions.size(); ++j)\n            {\n                int directionX = directions[j][0];\n                int directionY = directions[j][1];\n                int newX = currentX + directionX, newY = currentY + directionY;\n                if(newX >= 0 && newX < gridSize && newY >= 0 && newY < gridSize && grid[newX][newY] != 2)\n                {\n                    if(grid[newX][newY] == 1)\n                        return steps;\n                    grid[newX][newY] = 2;\n                    coordinateQueue.push({newX, newY});\n                }\n            }\n        }\n        ++steps;\n    }\n\n    return -1;\n}\n\nvoid dfs(vector<vector<int>> &grid, queue<pair<int, int>> &coordinateQueue, int rowIndex, int columnIndex)\n{\n    int gridSize = grid.size();\n    if(rowIndex < 0 || rowIndex >= gridSize || columnIndex < 0 || columnIndex >= gridSize || grid[rowIndex][columnIndex] != 1)\n        return;\n    grid[rowIndex][columnIndex] = 2;\n    coordinateQueue.push({rowIndex, columnIndex});\n    dfs(grid, coordinateQueue, rowIndex - 1, columnIndex);\n    dfs(grid, coordinateQueue, rowIndex + 1, columnIndex);\n    dfs(grid, coordinateQueue, rowIndex, columnIndex - 1);\n    dfs(grid, coordinateQueue, rowIndex, columnIndex + 1);\n}",
    "output": "#include <bits/stdc++.h>\nint shortestBridge(std::vector<std::vector<int>> &grid)\n{\n    int gridSize= grid.size();\n    std::queue<std::pair<int, int>> coordinateQueue;\n    bool isIslandFound= false;\n\n    for(int rowIndex= 0; rowIndex < gridSize && !isIslandFound; ++rowIndex)\n    {\n        for(int columnIndex= 0; columnIndex < gridSize; ++columnIndex)\n        {\n            if(grid[rowIndex][columnIndex] == 1)\n            {\n                dfs(grid, coordinateQueue, rowIndex, columnIndex);\n                isIslandFound= true;\n                break;\n            }\n        }\n    }\n\n    int steps= 0;\n    std::vector<std::vector<int>> directions= {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n    while(!coordinateQueue.empty())\n    {\n        int queueSize= coordinateQueue.size();\n        for(int i= 0; i < queueSize; ++i)\n        {\n            auto [currentX, currentY]= coordinateQueue.front();\n            coordinateQueue.pop();\n            for(auto &[directionX, directionY] : directions)\n            {\n                int newX= currentX + directionX, newY= currentY + directionY;\n                if(newX >= 0 && newX < gridSize && newY >= 0 && newY < gridSize && grid[newX][newY] != 2)\n                {\n                    if(grid[newX][newY] == 1)\n                        return steps;\n                    grid[newX][newY]= 2;\n                    coordinateQueue.push({newX, newY});\n                }\n            }\n        }\n        ++steps;\n    }\n\n    return -1;\n}\n\nvoid dfs(std::vector<std::vector<int>> &grid, std::queue<std::pair<int, int>> &coordinateQueue, int rowIndex, int columnIndex)\n{\n    int gridSize= grid.size();\n    if(rowIndex < 0 || rowIndex >= gridSize || columnIndex < 0 || columnIndex >= gridSize || grid[rowIndex][columnIndex] != 1)\n        return;\n    grid[rowIndex][columnIndex]= 2;\n    coordinateQueue.push({rowIndex, columnIndex});\n    dfs(grid, coordinateQueue, rowIndex - 1, columnIndex);\n    dfs(grid, coordinateQueue, rowIndex + 1, columnIndex);\n    dfs(grid, coordinateQueue, rowIndex, columnIndex - 1);\n    dfs(grid, coordinateQueue, rowIndex, columnIndex + 1);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint knightDialer(int numberOfMoves)\n{\n    if(numberOfMoves == 1)\n        return 10;\n    const int modulo= 1e9 + 7;\n    vector<vector<int>> knightMoves= {\n        {4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9}, {}, {1, 7, 0}, {2, 6}, {1, 3}, {2, 4}};\n    vector<int> dynamicProgramming(10, 1);\n    for(int i= 2; i <= numberOfMoves; ++i)\n    {\n        vector<int> newDynamicProgramming(10, 0);\n        for(int j= 0; j < 10; ++j)\n        {\n            for(int k = 0; k < knightMoves[j].size(); ++k)\n            {\n                newDynamicProgramming[j] = (newDynamicProgramming[j] + dynamicProgramming[knightMoves[j][k]]) % modulo;\n            }\n        }\n        dynamicProgramming = move(newDynamicProgramming);\n    }\n    return accumulate(dynamicProgramming.begin(), dynamicProgramming.end(), 0, [&](int accumulator, int current)\n                      { return (accumulator + current) % modulo; });\n}",
    "output": "int knightDialer(int numberOfMoves)\n{\n    if(numberOfMoves == 1)\n        return 10;\n    const int modulo= 1e9 + 7;\n    vector<vector<int>> knightMoves= {\n        {4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9}, {}, {1, 7, 0}, {2, 6}, {1, 3}, {2, 4}};\n    vector<int> dynamicProgramming(10, 1);\n    for(int i= 2; i <= numberOfMoves; ++i)\n    {\n        vector<int> newDynamicProgramming(10, 0);\n        for(int j= 0; j < 10; ++j)\n            for(const auto &move : knightMoves[j])\n                newDynamicProgramming[j]= (newDynamicProgramming[j] + dynamicProgramming[move]) % modulo;\n        dynamicProgramming= std::move(newDynamicProgramming);\n    }\n    return accumulate(dynamicProgramming.begin(), dynamicProgramming.end(), 0, [&](int accumulator, int current)\n                      { return (accumulator + current) % modulo; });\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// Add this for std::reverse\nusing namespace std;\n\nvector<int> movesToStamp(string stamp, string target)\n{\n    vector<int> stampPositions;\n    int stampCount = 0;\n    bool isStamped[10000] = {false};\n\n    while(stampCount < 10 * target.length())\n    {\n        bool foundStamp = false;\n        for(int i = 0; i <= target.length() - stamp.length(); ++i)\n        {\n            if(isStamped[i])\n                continue;\n            int j = 0;\n            int overlapCount = 0;\n            while(j < stamp.length() && (target[i + j] == '?' || target[i + j] == stamp[j]))\n            {\n                if(target[i + j] == stamp[j])\n                    overlapCount++;\n                j++;\n            }\n            if(j == stamp.length() && overlapCount > 0)\n            {\n                for(j = 0; j < stamp.length(); ++j)\n                    target[i + j] = '?';\n                stampPositions.push_back(i);\n                isStamped[i] = true;\n                foundStamp = true;\n            }\n        }\n        if(!foundStamp)\n            break;\n\n        stampCount++;\n    }\n    for(int i = 0; i < target.length(); ++i)\n        if(target[i] != '?')\n            return {};\n\n    reverse(stampPositions.begin(), stampPositions.end());\n    return stampPositions;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> movesToStamp(std::string stamp, std::string target)\n{\n    std::vector<int> stampPositions;\n    int stampCount= 0;\n    bool isStamped[10000]= {false};\n\n    while(stampCount < 10 * target.length())\n    {\n        bool foundStamp= false;\n        for(int i= 0; i <= target.length() - stamp.length(); ++i)\n        {\n            if(isStamped[i])\n                continue;\n            int j= 0;\n            int overlapCount= 0;\n            while(j < stamp.length() && (target[i + j] == '?' || target[i + j] == stamp[j]))\n            {\n                if(target[i + j] == stamp[j])\n                    overlapCount++;\n                j++;\n            }\n            if(j == stamp.length() && overlapCount > 0)\n            {\n                for(j= 0; j < stamp.length(); ++j)\n                    target[i + j]= '?';\n                stampPositions.push_back(i);\n                isStamped[i]= true;\n                foundStamp= true;\n            }\n        }\n        if(!foundStamp)\n            break;\n\n        stampCount++;\n    }\n    for(char c : target)\n        if(c != '?')\n            return {};\n\n    std::reverse(stampPositions.begin(), stampPositions.end());\n    return stampPositions;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint subarraysDivByK(vector<int> &numArray, int divisor)\n{\n    vector<int> prefixSumsModK(divisor, 0);\n    prefixSumsModK[0]= 1;\n    int runningSum= 0;\n    int count= 0;\n\n    for(int index= 0; index < numArray.size(); ++index)\n    {\n        runningSum+= numArray[index];\n        int modulo= (runningSum % divisor + divisor) % divisor;\n        count+= prefixSumsModK[modulo]++;\n    }\n\n    return count;\n}",
    "output": "#include <bits/stdc++.h>\nint subarraysDivByK(std::vector<int> &numArray, int divisor)\n{\n    std::vector<int> prefixSumsModK(divisor, 0);\n    prefixSumsModK[0]= 1;\n    int runningSum= 0;\n    int count= 0;\n\n    for(int index= 0; index < numArray.size(); ++index)\n    {\n        runningSum+= numArray[index];\n        int modulo= (runningSum % divisor + divisor) % divisor;\n        count+= prefixSumsModK[modulo]++;\n    }\n\n    return count;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int rangeSumBST(TreeNode *root, int lowerBound, int upperBound)\n{\n    if(!root)\n        return 0;\n    if(root->val < lowerBound)\n        return rangeSumBST(root->right, lowerBound, upperBound);\n    if(root->val > upperBound)\n        return rangeSumBST(root->left, lowerBound, upperBound);\n    return root->val + rangeSumBST(root->left, lowerBound, upperBound) + rangeSumBST(root->right, lowerBound, upperBound);\n}",
    "output": "int rangeSumBST(TreeNode *root, int lowerBound, int upperBound)\n{\n    if(!root)\n        return 0;\n    if(root->val < lowerBound)\n        return rangeSumBST(root->right, lowerBound, upperBound);\n    if(root->val > upperBound)\n        return rangeSumBST(root->left, lowerBound, upperBound);\n    return root->val + rangeSumBST(root->left, lowerBound, upperBound) + rangeSumBST(root->right, lowerBound, upperBound);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble minAreaRect(vector<vector<int>> &points)\n{\n    set<pair<int, int>> pointSet;\n    for (int i = 0; i < points.size(); ++i)\n    {\n        pointSet.emplace(points[i][0], points[i][1]);\n    }\n\n    double minimumArea = INT32_MAX;\n    auto it1 = pointSet.begin();\n    for (; it1 != pointSet.end(); ++it1)\n    {\n        auto it2 = pointSet.begin();\n        for (; it2 != pointSet.end(); ++it2)\n        {\n            if (it1->first != it2->first && it1->second != it2->second)\n            {\n                if (pointSet.count({it1->first, it2->second}) && pointSet.count({it2->first, it1->second}))\n                {\n                    minimumArea = min(minimumArea, abs((it1->first - it2->first) * (it1->second - it2->second)));\n                }\n            }\n        }\n    }\n\n    return minimumArea == INT32_MAX ? 0 : minimumArea;\n}",
    "output": "#include <bits/stdc++.h>\ndouble minAreaRect(std::vector<std::vector<int>> &points)\n{\n    std::set<std::pair<int, int>> pointSet;\n    for(const auto &point : points)\n    {\n        pointSet.emplace(point[0], point[1]);\n    }\n\n    double minimumArea= INT32_MAX;\n    for(const auto &firstPoint : pointSet)\n    {\n        for(const auto &secondPoint : pointSet)\n        {\n            if(firstPoint.first != secondPoint.first && firstPoint.second != secondPoint.second)\n            {\n                if(pointSet.count({firstPoint.first, secondPoint.second}) && pointSet.count({secondPoint.first, firstPoint.second}))\n                {\n                    minimumArea= std::min(minimumArea, abs((firstPoint.first - secondPoint.first) * (firstPoint.second - secondPoint.second)));\n                }\n            }\n        }\n    }\n\n    return minimumArea == INT32_MAX ? 0 : minimumArea;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint distinctSubseqII(string inputString)\n{\n    int modulo= 1e9 + 7;\n    int stringLength= inputString.size();\n    vector<int> subsequenceCount(stringLength + 1);\n    subsequenceCount[0]= 1;\n    vector<int> lastOccurrence(26, -1);\n\n    for(int currentIndex= 1; currentIndex <= stringLength; ++currentIndex)\n    {\n        subsequenceCount[currentIndex]= (subsequenceCount[currentIndex - 1] * 2) % modulo;\n        if(lastOccurrence[inputString[currentIndex - 1] - 'a'] != -1)\n        {\n            subsequenceCount[currentIndex]= (subsequenceCount[currentIndex] - subsequenceCount[lastOccurrence[inputString[currentIndex - 1] - 'a']] + modulo) % modulo;\n        }\n        lastOccurrence[inputString[currentIndex - 1] - 'a']= currentIndex - 1;\n    }\n\n    subsequenceCount[stringLength]= (subsequenceCount[stringLength] - 1 + modulo) % modulo;\n    return subsequenceCount[stringLength];\n}",
    "output": "#include <bits/stdc++.h>\nint distinctSubseqII(std::string inputString)\n{\n    int modulo= 1e9 + 7;\n    int stringLength= inputString.size();\n    std::vector<int> subsequenceCount(stringLength + 1);\n    subsequenceCount[0]= 1;\n    std::vector<int> lastOccurrence(26, -1);\n\n    for(int currentIndex= 1; currentIndex <= stringLength; ++currentIndex)\n    {\n        subsequenceCount[currentIndex]= (subsequenceCount[currentIndex - 1] * 2) % modulo;\n        if(lastOccurrence[inputString[currentIndex - 1] - 'a'] != -1)\n        {\n            subsequenceCount[currentIndex]= (subsequenceCount[currentIndex] - subsequenceCount[lastOccurrence[inputString[currentIndex - 1] - 'a']] + modulo) % modulo;\n        }\n        lastOccurrence[inputString[currentIndex - 1] - 'a']= currentIndex - 1;\n    }\n\n    subsequenceCount[stringLength]= (subsequenceCount[stringLength] - 1 + modulo) % modulo;\n    return subsequenceCount[stringLength];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool validMountainArray(vector<int> &mountainArray)\n{\n    int arraySize= mountainArray.size(), leftIndex= 0, rightIndex= arraySize - 1;\n    while(leftIndex + 1 < arraySize && mountainArray[leftIndex] < mountainArray[leftIndex + 1])\n        leftIndex++;\n    while(rightIndex > 0 && mountainArray[rightIndex - 1] > mountainArray[rightIndex])\n        rightIndex--;\n    return leftIndex > 0 && leftIndex == rightIndex && rightIndex < arraySize - 1;\n}",
    "output": "#include <bits/stdc++.h>\nbool validMountainArray(std::vector<int> &mountainArray)\n{\n    int arraySize = mountainArray.size(), leftIndex = 0, rightIndex = arraySize - 1;\n    while (leftIndex + 1 < arraySize && mountainArray[leftIndex] < mountainArray[leftIndex + 1])\n        leftIndex++;\n    while (rightIndex > 0 && mountainArray[rightIndex - 1] > mountainArray[rightIndex])\n        rightIndex--;\n    return leftIndex > 0 && leftIndex == rightIndex && rightIndex < arraySize - 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> decodePermutation(string inputString)\n{\n    int stringLength = inputString.length();\n    vector<int> permutation(stringLength + 1);\n    int nextZeroIndex = 0, nextOneIndex = stringLength;\n\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentCharacter = inputString[i];\n        if (currentCharacter == '0')\n        {\n            permutation[nextZeroIndex++] = nextOneIndex--;\n        }\n        else\n        {\n            permutation[nextOneIndex--] = nextZeroIndex++;\n        }\n    }\n    permutation[nextZeroIndex] = nextOneIndex;\n    return permutation;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> decodePermutation(std::string inputString)\n{\n    int stringLength = inputString.length();\n    std::vector<int> permutation(stringLength + 1);\n    int nextZeroIndex = 0, nextOneIndex = stringLength;\n\n    for(char currentCharacter : inputString)\n    {\n        if(currentCharacter == '0')\n        {\n            permutation[nextZeroIndex++] = nextOneIndex--;\n        }\n        else\n        {\n            permutation[nextOneIndex--] = nextZeroIndex++;\n        }\n    }\n    permutation[nextZeroIndex] = nextOneIndex;\n    return permutation;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring smallestSuperstring(vector<string> &inputWords)\n{\n    while(inputWords.size() > 1)\n    {\n        int maxSharedLength= -1, firstWordIndex= 0, secondWordIndex= 0;\n        string combinedString;\n        for(int i= 0; i < inputWords.size(); ++i)\n        {\n            for(int j= i + 1; j < inputWords.size(); ++j)\n            {\n                int currentSharedLength= min(inputWords[i].length(), inputWords[j].length());\n                for(; currentSharedLength > maxSharedLength; --currentSharedLength)\n                {\n                    if(inputWords[i].substr(inputWords[i].length() - currentSharedLength) ==\n                       inputWords[j].substr(0, currentSharedLength))\n                    {\n                        maxSharedLength= currentSharedLength;\n                        firstWordIndex= i;\n                        secondWordIndex= j;\n                        combinedString= inputWords[i] + inputWords[j].substr(currentSharedLength);\n                        break;\n                    }\n                }\n            }\n        }\n        inputWords[firstWordIndex]= combinedString;\n        inputWords.erase(inputWords.begin() + secondWordIndex);\n    }\n    return inputWords[0];\n}",
    "output": "#include <bits/stdc++.h>\nstd::string smallestSuperstring(std::vector<std::string> &inputWords)\n{\n    while(inputWords.size() > 1)\n    {\n        int maxSharedLength= -1, firstWordIndex= 0, secondWordIndex= 0;\n        std::string combinedString;\n        for(int i= 0; i < inputWords.size(); ++i)\n        {\n            for(int j= i + 1; j < inputWords.size(); ++j)\n            {\n                int currentSharedLength= std::min(inputWords[i].length(), inputWords[j].length());\n                for(; currentSharedLength > maxSharedLength; --currentSharedLength)\n                {\n                    if(inputWords[i].substr(inputWords[i].length() - currentSharedLength) ==\n                       inputWords[j].substr(0, currentSharedLength))\n                    {\n                        maxSharedLength= currentSharedLength;\n                        firstWordIndex= i;\n                        secondWordIndex= j;\n                        combinedString= inputWords[i] + inputWords[j].substr(currentSharedLength);\n                        break;\n                    }\n                }\n            }\n        }\n        inputWords[firstWordIndex]= combinedString;\n        inputWords.erase(inputWords.begin() + secondWordIndex);\n    }\n    return inputWords[0];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minDeletionSize(vector<string> &stringArray)\n{\n    int deletedColumnCount= 0;\n    for(int columnIndex= 0; columnIndex < stringArray[0].size(); ++columnIndex)\n    {\n        for(int rowIndex= 1; rowIndex < stringArray.size(); ++rowIndex)\n        {\n            if(stringArray[rowIndex][columnIndex] < stringArray[rowIndex - 1][columnIndex])\n            {\n                ++deletedColumnCount;\n                break;\n            }\n        }\n    }\n    return deletedColumnCount;\n}",
    "output": "#include <bits/stdc++.h>\nint minDeletionSize(std::vector<std::string> &stringArray)\n{\n    int deletedColumnCount= 0;\n    for(int columnIndex= 0; columnIndex < stringArray[0].size(); ++columnIndex)\n    {\n        for(int rowIndex= 1; rowIndex < stringArray.size(); ++rowIndex)\n        {\n            if(stringArray[rowIndex][columnIndex] < stringArray[rowIndex - 1][columnIndex])\n            {\n                ++deletedColumnCount;\n                break;\n            }\n        }\n    }\n    return deletedColumnCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minMovesToUnique(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end());\n    int totalMoves= 0;\n    for(size_t index= 1; index < numbers.size(); ++index)\n    {\n        if(numbers[index] <= numbers[index - 1])\n        {\n            totalMoves+= numbers[index - 1] - numbers[index] + 1;\n            numbers[index]= numbers[index - 1] + 1;\n        }\n    }\n    return totalMoves;\n}",
    "output": "#include <bits/stdc++.h>\nint minMovesToUnique(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end());\n    int totalMoves= 0;\n    for(size_t index= 1; index < numbers.size(); ++index)\n    {\n        if(numbers[index] <= numbers[index - 1])\n        {\n            totalMoves+= numbers[index - 1] - numbers[index] + 1;\n            numbers[index]= numbers[index - 1] + 1;\n        }\n    }\n    return totalMoves;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool validateStackSequences(vector<int> &pushedSequence, vector<int> &poppedSequence)\n{\n    stack<int> stack;\n    int popIndex = 0;\n\n    for (int i = 0; i < pushedSequence.size(); ++i)\n    {\n        int pushValue = pushedSequence[i];\n        stack.push(pushValue);\n        while (!stack.empty() && stack.top() == poppedSequence[popIndex])\n        {\n            stack.pop();\n            popIndex++;\n        }\n    }\n\n    return stack.empty();\n}",
    "output": "#include <bits/stdc++.h>\nbool validateStackSequences(std::vector<int> &pushedSequence, std::vector<int> &poppedSequence)\n{\n    std::stack<int> stack;\n    int popIndex= 0;\n\n    for(int pushValue : pushedSequence)\n    {\n        stack.push(pushValue);\n        while(!stack.empty() && stack.top() == poppedSequence[popIndex])\n        {\n            stack.pop();\n            popIndex++;\n        }\n    }\n\n    return stack.empty();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint removeStones(vector<vector<int>> &stoneCoordinates)\n{\n    unordered_map<int, int> rowGroups, colGroups;\n    int groupCount = 0;\n\n    function<int(int, bool)> getGroupId = [&](int index, bool isRow) -> int\n    {\n        auto &groups = isRow ? rowGroups : colGroups;\n        if (!groups.count(index))\n        {\n            groups[index] = groupCount++;\n        }\n        return groups[index];\n    };\n\n    vector<vector<int>> groups(groupCount);\n    for (int i = 0; i < stoneCoordinates.size(); ++i)\n    {\n        int xCoordinate = stoneCoordinates[i][0];\n        int yCoordinate = stoneCoordinates[i][1];\n        int groupX = getGroupId(xCoordinate, true);\n        int groupY = getGroupId(10001 + yCoordinate, false); // Offset by max row index\n        groups[groupX].push_back(groupY);\n        groups[groupY].push_back(groupX);\n    }\n\n    int maxStones = 0;\n    vector<bool> visited(groupCount);\n\n    auto dfs = [&](int groupId, auto &dfs_ref) -> int\n    {\n        if (visited[groupId])\n            return 0;\n        visited[groupId] = true;\n        int size = 1;\n        for (int neighbor : groups[groupId])\n        {\n            size += dfs_ref(neighbor, dfs_ref);\n        }\n        return size;\n    };\n\n    for (int groupId = 0; groupId < groupCount; groupId++)\n    {\n        maxStones += dfs(groupId, dfs) - 1;\n    }\n\n    return maxStones;\n}",
    "output": "#include <bits/stdc++.h>\nint removeStones(std::vector<std::vector<int>> &stoneCoordinates)\n{\n    std::unordered_map<int, int> rowGroups, colGroups;\n    int groupCount= 0;\n\n    std::function<int(int, bool)> getGroupId= [&](int index, bool isRow) -> int\n    {\n        auto &groups= isRow ? rowGroups : colGroups;\n        if(!groups.count(index))\n        {\n            groups[index]= groupCount++;\n        }\n        return groups[index];\n    };\n\n    std::vector<std::vector<int>> groups(groupCount);\n    for(auto &[xCoordinate, yCoordinate] : stoneCoordinates)\n    {\n        int groupX= getGroupId(xCoordinate, true);\n        int groupY= getGroupId(10001 + yCoordinate, false); // Offset by max row index\n        groups[groupX].push_back(groupY);\n        groups[groupY].push_back(groupX);\n    }\n\n    int maxStones= 0;\n    std::vector<bool> visited(groupCount);\n\n    auto dfs= [&](int groupId, auto &dfs_ref) -> int\n    {\n        if(visited[groupId])\n            return 0;\n        visited[groupId]= true;\n        int size= 1;\n        for(int neighbor : groups[groupId])\n        {\n            size+= dfs_ref(neighbor, dfs_ref);\n        }\n        return size;\n    };\n\n    for(int groupId= 0; groupId < groupCount; groupId++)\n    {\n        maxStones+= dfs(groupId, dfs) - 1;\n    }\n\n    return maxStones;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint bagOfTokensScore(vector<int> &tokenValues, int availablePower)\n{\n    sort(tokenValues.begin(), tokenValues.end());\n    int currentScore= 0, maximumScore= 0;\n    int leftIndex= 0, rightIndex= tokenValues.size() - 1;\n\n    while(leftIndex <= rightIndex)\n    {\n        if(availablePower >= tokenValues[leftIndex])\n        {\n            availablePower-= tokenValues[leftIndex++];\n            currentScore++;\n            maximumScore= max(maximumScore, currentScore);\n        }\n        else if(currentScore > 0)\n        {\n            availablePower+= tokenValues[rightIndex--];\n            currentScore--;\n        }\n        else\n        {\n            break;\n        }\n    }\n    return maximumScore;\n}",
    "output": "#include <bits/stdc++.h>\nint bagOfTokensScore(std::vector<int> &tokenValues, int availablePower)\n{\n    std::sort(tokenValues.begin(), tokenValues.end());\n    int currentScore= 0, maximumScore= 0;\n    int leftIndex= 0, rightIndex= tokenValues.size() - 1;\n\n    while(leftIndex <= rightIndex)\n    {\n        if(availablePower >= tokenValues[leftIndex])\n        {\n            availablePower-= tokenValues[leftIndex++];\n            currentScore++;\n            maximumScore= std::max(maximumScore, currentScore);\n        }\n        else if(currentScore > 0)\n        {\n            availablePower+= tokenValues[rightIndex--];\n            currentScore--;\n        }\n        else\n        {\n            break;\n        }\n    }\n    return maximumScore;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestTimeFromDigits(vector<int> &digits)\n{\n    sort(digits.begin(), digits.end(), greater<>());\n    do\n    {\n        if((digits[0] < 3 || (digits[0] == 2 && digits[1] < 4)) && digits[2] < 6)\n        {\n            return to_string(digits[0]) + to_string(digits[1]) + ':' + to_string(digits[2]) + to_string(digits[3]);\n        }\n    } while(prev_permutation(digits.begin(), digits.end()));\n    return \"\";\n}",
    "output": "#include <bits/stdc++.h>\nstd::string largestTimeFromDigits(std::vector<int> &digits)\n{\n    std::sort(digits.begin(), digits.end(), std::greater<>());\n    do\n    {\n        if((digits[0] < 3 || (digits[0] == 2 && digits[1] < 4)) && digits[2] < 6)\n        {\n            return std::to_string(digits[0]) + std::to_string(digits[1]) + ':' + std::to_string(digits[2]) + std::to_string(digits[3]);\n        }\n    } while(std::prev_permutation(digits.begin(), digits.end()));\n    return \"\";\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> revealDeckInIncreasingOrder(vector<int> &cardDeck)\n{\n    int deckSize = cardDeck.size();\n    deque<int> indexQueue;\n    for(int i = 0; i < deckSize; ++i)\n        indexQueue.push_back(i);\n\n    vector<int> revealedDeck(deckSize);\n    sort(cardDeck.begin(), cardDeck.end());\n\n    for(int i = 0; i < cardDeck.size(); ++i)\n    {\n        int card = cardDeck[i];\n        revealedDeck[indexQueue.front()] = card;\n        indexQueue.pop_front();\n        if(!indexQueue.empty())\n        {\n            indexQueue.push_back(indexQueue.front());\n            indexQueue.pop_front();\n        }\n    }\n\n    return revealedDeck;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> revealDeckInIncreasingOrder(std::vector<int> &cardDeck)\n{\n    int deckSize= cardDeck.size();\n    std::deque<int> indexQueue;\n    for(int i= 0; i < deckSize; ++i)\n        indexQueue.push_back(i);\n\n    std::vector<int> revealedDeck(deckSize);\n    std::sort(cardDeck.begin(), cardDeck.end());\n\n    for(int card : cardDeck)\n    {\n        revealedDeck[indexQueue.front()]= card;\n        indexQueue.pop_front();\n        if(!indexQueue.empty())\n        {\n            indexQueue.push_back(indexQueue.front());\n            indexQueue.pop_front();\n        }\n    }\n\n    return revealedDeck;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int value) : value(value), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int value, TreeNode *leftChild, TreeNode *rightChild) : value(value), leftChild(leftChild), rightChild(rightChild) {}\n};\n\nbool flipEquiv(TreeNode *firstRoot, TreeNode *secondRoot)\n{\n    if(firstRoot == NULL && secondRoot == NULL)\n        return true;\n    if(firstRoot == NULL || secondRoot == NULL)\n        return false;\n    if(firstRoot->value != secondRoot->value)\n        return false;\n    return (flipEquiv(firstRoot->leftChild, secondRoot->leftChild) && flipEquiv(firstRoot->rightChild, secondRoot->rightChild)) ||\n           (flipEquiv(firstRoot->leftChild, secondRoot->rightChild) && flipEquiv(firstRoot->rightChild, secondRoot->leftChild));\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int value) : value(value), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int value, TreeNode *leftChild, TreeNode *rightChild) : value(value), leftChild(leftChild), rightChild(rightChild) {}\n};\n\nbool flipEquiv(TreeNode *firstRoot, TreeNode *secondRoot)\n{\n    if(firstRoot == NULL && secondRoot == NULL)\n        return true;\n    if(firstRoot == NULL || secondRoot == NULL)\n        return false;\n    if(firstRoot->value != secondRoot->value)\n        return false;\n    return (flipEquiv(firstRoot->leftChild, secondRoot->leftChild) && flipEquiv(firstRoot->rightChild, secondRoot->rightChild)) ||\n           (flipEquiv(firstRoot->leftChild, secondRoot->rightChild) && flipEquiv(firstRoot->rightChild, secondRoot->leftChild));\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findSmallestPrimeFactor(int number)\n{\n    for(int divisor = 2; divisor * divisor <= number; ++divisor)\n    {\n        if(number % divisor == 0)\n            return divisor;\n    }\n    return number;\n}\n\nint findLargestComponentSize(vector<int> &numberList)\n{\n    int largestSize = 0;\n    unordered_map<int, unordered_set<int>> primeFactorGraph;\n    unordered_set<int> visitedNodes;\n\n    for(int i = 0; i < numberList.size(); ++i)\n    {\n        int number = numberList[i];\n        int smallestPrimeFactor = findSmallestPrimeFactor(number);\n        primeFactorGraph[smallestPrimeFactor].insert(number);\n        if(number != smallestPrimeFactor)\n            primeFactorGraph[number].insert(smallestPrimeFactor);\n    }\n\n    function<int(int)> depthFirstSearch = [&](int currentNode)\n    {\n        if(!visitedNodes.insert(currentNode).second)\n            return 0;\n        int componentSize = 1;\n        for(int neighbor : primeFactorGraph[currentNode])\n        {\n            componentSize += depthFirstSearch(neighbor);\n        }\n        return componentSize;\n    };\n\n    for(int i = 0; i < numberList.size(); ++i)\n    {\n        int number = numberList[i];\n        largestSize = max(largestSize, depthFirstSearch(number));\n    }\n    return largestSize;\n}",
    "output": "#include <bits/stdc++.h>\nint findSmallestPrimeFactor(int number)\n{\n    for(int divisor= 2; divisor * divisor <= number; ++divisor)\n    {\n        if(number % divisor == 0)\n            return divisor;\n    }\n    return number;\n}\n\nint findLargestComponentSize(std::vector<int> &numberList)\n{\n    int largestSize= 0;\n    std::unordered_map<int, std::unordered_set<int>> primeFactorGraph;\n    std::unordered_set<int> visitedNodes;\n\n    for(int number : numberList)\n    {\n        int smallestPrimeFactor= findSmallestPrimeFactor(number);\n        primeFactorGraph[smallestPrimeFactor].insert(number);\n        if(number != smallestPrimeFactor)\n            primeFactorGraph[number].insert(smallestPrimeFactor);\n    }\n\n    std::function<int(int)> depthFirstSearch= [&](int currentNode)\n    {\n        if(!visitedNodes.insert(currentNode).second)\n            return 0;\n        int componentSize= 1;\n        for(int neighbor : primeFactorGraph[currentNode])\n        {\n            componentSize+= depthFirstSearch(neighbor);\n        }\n        return componentSize;\n    };\n\n    for(int number : numberList)\n    {\n        largestSize= std::max(largestSize, depthFirstSearch(number));\n    }\n    return largestSize;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isAlienSorted(vector<string> &alienWords, string alienOrder)\n{\n    int alienOrderMapping[26];\n    for(int index= 0; index < 26; ++index)\n    {\n        alienOrderMapping[alienOrder[index] - 'a']= index;\n    }\n\n    for(int wordIndex= 1; wordIndex < alienWords.size(); ++wordIndex)\n    {\n        for(int charIndex= 0; charIndex < alienWords[wordIndex - 1].size(); ++charIndex)\n        {\n            if(charIndex == alienWords[wordIndex].size())\n            {\n                return false;\n            }\n\n            if(alienWords[wordIndex - 1][charIndex] != alienWords[wordIndex][charIndex])\n            {\n                if(alienOrderMapping[alienWords[wordIndex - 1][charIndex] - 'a'] > alienOrderMapping[alienWords[wordIndex][charIndex] - 'a'])\n                {\n                    return false;\n                }\n                break;\n            }\n        }\n    }\n\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isAlienSorted(std::vector<std::string> &alienWords, std::string alienOrder)\n{\n    int alienOrderMapping[26];\n    for(int index= 0; index < 26; ++index)\n    {\n        alienOrderMapping[alienOrder[index] - 'a']= index;\n    }\n\n    for(int wordIndex= 1; wordIndex < alienWords.size(); ++wordIndex)\n    {\n        for(int charIndex= 0; charIndex < alienWords[wordIndex - 1].size(); ++charIndex)\n        {\n            if(charIndex == alienWords[wordIndex].size())\n            {\n                return false;\n            }\n\n            if(alienWords[wordIndex - 1][charIndex] != alienWords[wordIndex][charIndex])\n            {\n                if(alienOrderMapping[alienWords[wordIndex - 1][charIndex] - 'a'] > alienOrderMapping[alienWords[wordIndex][charIndex] - 'a'])\n                {\n                    return false;\n                }\n                break;\n            }\n        }\n    }\n\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canReorderArray(vector<int> &inputArray)\n{\n    unordered_map<int, int> elementCount;\n    for(int i = 0; i < inputArray.size(); ++i)\n    {\n        elementCount[inputArray[i]]++;\n    }\n    sort(inputArray.begin(), inputArray.end());\n    for(int i = 0; i < inputArray.size(); ++i)\n    {\n        int currentElement = inputArray[i];\n        if(elementCount[currentElement] == 0)\n        {\n            continue;\n        }\n        if(elementCount[2 * currentElement] > 0)\n        {\n            elementCount[currentElement]--;\n            elementCount[2 * currentElement]--;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool canReorderArray(std::vector<int> &inputArray)\n{\n    std::unordered_map<int, int> elementCount;\n    for(int currentElement : inputArray)\n    {\n        elementCount[currentElement]++;\n    }\n    sort(inputArray.begin(), inputArray.end());\n    for(int currentElement : inputArray)\n    {\n        if(elementCount[currentElement] == 0)\n        {\n            continue;\n        }\n        if(elementCount[2 * currentElement] > 0)\n        {\n            elementCount[currentElement]--;\n            elementCount[2 * currentElement]--;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minDeletionSize(vector<string> &stringArray)\n{\n    int numberOfStrings= stringArray.size();\n    int stringLength= stringArray[0].length();\n    vector<int> longestIncreasingSubsequence(stringLength, 1);\n\n    for(int currentColumn= 0; currentColumn < stringLength; ++currentColumn)\n        for(int previousColumn= 0; previousColumn < currentColumn; ++previousColumn)\n        {\n            bool isValid= true;\n            for(int row= 0; row < numberOfStrings - 1; ++row)\n                isValid= isValid && (stringArray[row][previousColumn] <= stringArray[row][currentColumn]);\n            longestIncreasingSubsequence[currentColumn]= isValid ? max(longestIncreasingSubsequence[currentColumn], longestIncreasingSubsequence[previousColumn] + 1) : longestIncreasingSubsequence[currentColumn];\n        }\n\n    return stringLength - *max_element(longestIncreasingSubsequence.begin(), longestIncreasingSubsequence.end());\n}",
    "output": "#include <bits/stdc++.h>\nint minDeletionSize(std::vector<std::string> &stringArray)\n{\n    int numberOfStrings= stringArray.size();\n    int stringLength= stringArray[0].length();\n    std::vector<int> longestIncreasingSubsequence(stringLength, 1);\n\n    for(int currentColumn= 0; currentColumn < stringLength; ++currentColumn)\n        for(int previousColumn= 0; previousColumn < currentColumn; ++previousColumn)\n        {\n            bool isValid= true;\n            for(int row= 0; row < numberOfStrings - 1; ++row)\n                isValid= isValid && (stringArray[row][previousColumn] <= stringArray[row][currentColumn]);\n            longestIncreasingSubsequence[currentColumn]= isValid ? std::max(longestIncreasingSubsequence[currentColumn], longestIncreasingSubsequence[previousColumn] + 1) : longestIncreasingSubsequence[currentColumn];\n        }\n\n    return stringLength - *std::max_element(longestIncreasingSubsequence.begin(), longestIncreasingSubsequence.end());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint tallestBillboard(vector<int> &rods)\n{\n    int numberOfRods= rods.size();\n    int totalLength= accumulate(rods.begin(), rods.end(), 0);\n    vector<vector<int>> dynamicProgramming(numberOfRods + 1, vector<int>(totalLength + 1, -1));\n    dynamicProgramming[0][0]= 0;\n\n    for(int currentRod= 1; currentRod <= numberOfRods; currentRod++)\n    {\n        for(int currentLength= 0; currentLength <= totalLength; currentLength++)\n        {\n            dynamicProgramming[currentRod][currentLength]= dynamicProgramming[currentRod - 1][currentLength];\n            if(rods[currentRod - 1] <= currentLength)\n                dynamicProgramming[currentRod][currentLength]= max(dynamicProgramming[currentRod][currentLength], dynamicProgramming[currentRod - 1][currentLength - rods[currentRod - 1]] + rods[currentRod - 1]);\n            if(rods[currentRod - 1] <= totalLength - currentLength)\n                dynamicProgramming[currentRod][currentLength]= max(dynamicProgramming[currentRod][currentLength], dynamicProgramming[currentRod - 1][currentLength + rods[currentRod - 1]]);\n        }\n    }\n\n    return dynamicProgramming[numberOfRods][0] / 2;\n}",
    "output": "#include <bits/stdc++.h>\nint tallestBillboard(std::vector<int> &rods)\n{\n    int numberOfRods= rods.size();\n    int totalLength= std::accumulate(rods.begin(), rods.end(), 0);\n    std::vector<std::vector<int>> dynamicProgramming(numberOfRods + 1, std::vector<int>(totalLength + 1, -1));\n    dynamicProgramming[0][0]= 0;\n\n    for(int currentRod= 1; currentRod <= numberOfRods; currentRod++)\n    {\n        for(int currentLength= 0; currentLength <= totalLength; currentLength++)\n        {\n            dynamicProgramming[currentRod][currentLength]= dynamicProgramming[currentRod - 1][currentLength];\n            if(rods[currentRod - 1] <= currentLength)\n                dynamicProgramming[currentRod][currentLength]= std::max(dynamicProgramming[currentRod][currentLength], dynamicProgramming[currentRod - 1][currentLength - rods[currentRod - 1]] + rods[currentRod - 1]);\n            if(rods[currentRod - 1] <= totalLength - currentLength)\n                dynamicProgramming[currentRod][currentLength]= std::max(dynamicProgramming[currentRod][currentLength], dynamicProgramming[currentRod - 1][currentLength + rods[currentRod - 1]]);\n        }\n    }\n\n    return dynamicProgramming[numberOfRods][0] / 2;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> prisonAfterNDays(vector<int> &prisonCells, int days)\n{\n    vector<int> nextState(8, 0);\n    days = days % 14 == 0 ? 14 : days % 14; // Pattern repeats every 14 days\n\n    for(int day = 1; day <= days; ++day)\n    {\n        for(int cellIndex = 1; cellIndex < 7; ++cellIndex)\n        {\n            nextState[cellIndex] = !(prisonCells[cellIndex - 1] ^ prisonCells[cellIndex + 1]);\n        }\n        prisonCells = nextState;\n    }\n\n    return prisonCells;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> prisonAfterNDays(std::vector<int> &prisonCells, int days)\n{\n    std::vector<int> nextState(8, 0);\n    days= days % 14 == 0 ? 14 : days % 14; // Pattern repeats every 14 days\n\n    for(int day= 1; day <= days; ++day)\n    {\n        for(int cellIndex= 1; cellIndex < 7; ++cellIndex)\n        {\n            nextState[cellIndex]= !(prisonCells[cellIndex - 1] ^ prisonCells[cellIndex + 1]);\n        }\n        prisonCells= nextState;\n    }\n\n    return prisonCells;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minKBitFlips(vector<int> &binaryArray, int flipSize)\n{\n    int arraySize= binaryArray.size();\n    vector<int> flipStatus(arraySize, 0);\n    int currentFlips= 0, totalFlips= 0;\n\n    for(int index= 0; index < arraySize; ++index)\n    {\n        if(index >= flipSize)\n            currentFlips= (currentFlips - flipStatus[index - flipSize]) % 2;\n        if((currentFlips + binaryArray[index]) % 2 == 0)\n        {\n            if(index + flipSize > arraySize)\n                return -1;\n            flipStatus[index]= 1;\n            currentFlips= (currentFlips + 1) % 2;\n            totalFlips++;\n        }\n    }\n\n    return totalFlips;\n}",
    "output": "#include <bits/stdc++.h>\nint minKBitFlips(std::vector<int> &binaryArray, int flipSize)\n{\n    int arraySize= binaryArray.size();\n    std::vector<int> flipStatus(arraySize, 0);\n    int currentFlips= 0, totalFlips= 0;\n\n    for(int index= 0; index < arraySize; ++index)\n    {\n        if(index >= flipSize)\n            currentFlips= (currentFlips - flipStatus[index - flipSize]) % 2;\n        if((currentFlips + binaryArray[index]) % 2 == 0)\n        {\n            if(index + flipSize > arraySize)\n                return -1;\n            flipStatus[index]= 1;\n            currentFlips= (currentFlips + 1) % 2;\n            totalFlips++;\n        }\n    }\n\n    return totalFlips;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// Include this for sqrt\nusing namespace std;\n\nbool isSquare(int number)\n{\n    int squareRoot = sqrt(number);\n    return squareRoot * squareRoot == number;\n}\n\nvoid dfs(vector<int> &permutation, int currentIndex, int &validCount,\n         unordered_map<int, int> &elementCounter)\n{\n    if(currentIndex == permutation.size())\n    {\n        validCount++;\n        return;\n    }\n\n    for(auto element : elementCounter) // This cannot be changed to a traditional for loop\n    {\n        if(element.second && (currentIndex == 0 || isSquare(permutation[currentIndex - 1] + element.first)))\n        {\n            elementCounter[element.first]--;\n            permutation[currentIndex] = element.first;\n            dfs(permutation, currentIndex + 1, validCount, elementCounter);\n            elementCounter[element.first]++;\n        }\n    }\n}\n\nint numSquarefulPerms(vector<int> &inputNumbers)\n{\n    unordered_map<int, int> elementCounter;\n    for(int number : inputNumbers)\n        elementCounter[number]++;\n\n    int validCount = 0;\n    dfs(inputNumbers, 0, validCount, elementCounter);\n    return validCount;\n}",
    "output": "#include <bits/stdc++.h>\nbool isSquare(int number)\n{\n    int squareRoot= sqrt(number);\n    return squareRoot * squareRoot == number;\n}\n\nvoid dfs(std::vector<int> &permutation, int currentIndex, int &validCount,\n         std::unordered_map<int, int> &elementCounter)\n{\n    if(currentIndex == permutation.size())\n    {\n        validCount++;\n        return;\n    }\n\n    for(auto element : elementCounter)\n    {\n        if(element.second && (currentIndex == 0 || isSquare(permutation[currentIndex - 1] + element.first)))\n        {\n            elementCounter[element.first]--;\n            permutation[currentIndex]= element.first;\n            dfs(permutation, currentIndex + 1, validCount, elementCounter);\n            elementCounter[element.first]++;\n        }\n    }\n}\n\nint numSquarefulPerms(std::vector<int> &inputNumbers)\n{\n    std::unordered_map<int, int> elementCounter;\n    for(int number : inputNumbers)\n        elementCounter[number]++;\n\n    int validCount= 0;\n    dfs(inputNumbers, 0, validCount, elementCounter);\n    return validCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findJudge(int numberOfPeople, vector<vector<int>> &trustRelationships)\n{\n    vector<int> trustCounts(numberOfPeople + 1, 0);\n    for (int i = 0; i < trustRelationships.size(); ++i)\n    {\n        trustCounts[trustRelationships[i][0]]--;\n        trustCounts[trustRelationships[i][1]]++;\n    }\n    for (int person = 1; person <= numberOfPeople; person++)\n    {\n        if (trustCounts[person] == numberOfPeople - 1)\n            return person;\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint findJudge(int numberOfPeople, std::vector<std::vector<int>> &trustRelationships)\n{\n    std::vector<int> trustCounts(numberOfPeople + 1, 0);\n    for(auto &relationship : trustRelationships)\n    {\n        trustCounts[relationship[0]]--;\n        trustCounts[relationship[1]]++;\n    }\n    for(int person= 1; person <= numberOfPeople; person++)\n    {\n        if(trustCounts[person] == numberOfPeople - 1)\n            return person;\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nbool isCompleteTree(TreeNode *root)\n{\n    if(!root)\n        return true;\n    queue<TreeNode *> nodeQueue;\n    nodeQueue.push(root);\n    while(nodeQueue.front() != NULL)\n    {\n        TreeNode *currentNode= nodeQueue.front();\n        nodeQueue.pop();\n        nodeQueue.push(currentNode->leftChild);\n        nodeQueue.push(currentNode->rightChild);\n    }\n    while(!nodeQueue.empty() && nodeQueue.front() == NULL)\n    {\n        nodeQueue.pop();\n    }\n    return nodeQueue.empty();\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nbool isCompleteTree(TreeNode *root)\n{\n    if(!root)\n        return true;\n    std::queue<TreeNode *> nodeQueue;\n    nodeQueue.push(root);\n    while(nodeQueue.front() != NULL)\n    {\n        TreeNode *currentNode= nodeQueue.front();\n        nodeQueue.pop();\n        nodeQueue.push(currentNode->leftChild);\n        nodeQueue.push(currentNode->rightChild);\n    }\n    while(!nodeQueue.empty() && nodeQueue.front() == NULL)\n    {\n        nodeQueue.pop();\n    }\n    return nodeQueue.empty();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countRegionsBySlashes(vector<string> &grid)\n{\n    int gridSize= grid.size();\n    vector<vector<int>> graph(gridSize * 3, vector<int>(gridSize * 3, 0));\n\n    for(int rowIndex= 0; rowIndex < gridSize; ++rowIndex)\n    {\n        for(int columnIndex= 0; columnIndex < gridSize; ++columnIndex)\n        {\n            if(grid[rowIndex][columnIndex] == '/')\n            {\n                graph[rowIndex * 3][columnIndex * 3 + 2]= graph[rowIndex * 3 + 1][columnIndex * 3 + 1]= graph[rowIndex * 3 + 2][columnIndex * 3]= 1;\n            }\n            if(grid[rowIndex][columnIndex] == '\\\\')\n            {\n                graph[rowIndex * 3][columnIndex * 3]= graph[rowIndex * 3 + 1][columnIndex * 3 + 1]= graph[rowIndex * 3 + 2][columnIndex * 3 + 2]= 1;\n            }\n        }\n    }\n\n    int regionCount= 0;\n    for(int i= 0; i < gridSize * 3; ++i)\n    {\n        for(int j= 0; j < gridSize * 3; ++j)\n        {\n            if(!graph[i][j])\n            {\n                regionCount++;\n                depthFirstSearch(graph, i, j);\n            }\n        }\n    }\n\n    return regionCount;\n}\n\nvoid depthFirstSearch(vector<vector<int>> &graph, int rowIndex, int columnIndex)\n{\n    int graphSize= graph.size();\n    if(rowIndex < 0 || columnIndex < 0 || rowIndex >= graphSize || columnIndex >= graphSize || graph[rowIndex][columnIndex])\n        return;\n\n    graph[rowIndex][columnIndex]= 1;\n    depthFirstSearch(graph, rowIndex - 1, columnIndex);\n    depthFirstSearch(graph, rowIndex + 1, columnIndex);\n    depthFirstSearch(graph, rowIndex, columnIndex - 1);\n    depthFirstSearch(graph, rowIndex, columnIndex + 1);\n}",
    "output": "#include <bits/stdc++.h>\nint countRegionsBySlashes(std::vector<std::string> &grid)\n{\n    int gridSize= grid.size();\n    std::vector<std::vector<int>> graph(gridSize * 3, std::vector<int>(gridSize * 3, 0));\n\n    for(int rowIndex= 0; rowIndex < gridSize; ++rowIndex)\n    {\n        for(int columnIndex= 0; columnIndex < gridSize; ++columnIndex)\n        {\n            if(grid[rowIndex][columnIndex] == '/')\n            {\n                graph[rowIndex * 3][columnIndex * 3 + 2]= graph[rowIndex * 3 + 1][columnIndex * 3 + 1]= graph[rowIndex * 3 + 2][columnIndex * 3]= 1;\n            }\n            if(grid[rowIndex][columnIndex] == '\\\\')\n            {\n                graph[rowIndex * 3][columnIndex * 3]= graph[rowIndex * 3 + 1][columnIndex * 3 + 1]= graph[rowIndex * 3 + 2][columnIndex * 3 + 2]= 1;\n            }\n        }\n    }\n\n    int regionCount= 0;\n    for(int i= 0; i < gridSize * 3; ++i)\n    {\n        for(int j= 0; j < gridSize * 3; ++j)\n        {\n            if(!graph[i][j])\n            {\n                regionCount++;\n                depthFirstSearch(graph, i, j);\n            }\n        }\n    }\n\n    return regionCount;\n}\n\nvoid depthFirstSearch(std::vector<std::vector<int>> &graph, int rowIndex, int columnIndex)\n{\n    int graphSize= graph.size();\n    if(rowIndex < 0 || columnIndex < 0 || rowIndex >= graphSize || columnIndex >= graphSize || graph[rowIndex][columnIndex])\n        return;\n\n    graph[rowIndex][columnIndex]= 1;\n    depthFirstSearch(graph, rowIndex - 1, columnIndex);\n    depthFirstSearch(graph, rowIndex + 1, columnIndex);\n    depthFirstSearch(graph, rowIndex, columnIndex - 1);\n    depthFirstSearch(graph, rowIndex, columnIndex + 1);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minDeletionSize(vector<string> &stringArray)\n{\n    int numberOfRows = stringArray.size(), numberOfColumns = stringArray[0].size();\n    int deletionCount = 0;\n    for(int columnIndex = 0; columnIndex < numberOfColumns; ++columnIndex)\n    {\n        for(int rowIndex = 1; rowIndex < numberOfRows; ++rowIndex)\n        {\n            if(stringArray[rowIndex - 1][columnIndex] > stringArray[rowIndex][columnIndex])\n            {\n                ++deletionCount;\n                break;\n            }\n        }\n    }\n    return deletionCount;\n}",
    "output": "#include <bits/stdc++.h>\nint minDeletionSize(std::vector<std::string> &stringArray)\n{\n    int numberOfRows= stringArray.size(), numberOfColumns= stringArray[0].size();\n    int deletionCount= 0;\n    for(int columnIndex= 0; columnIndex < numberOfColumns; ++columnIndex)\n    {\n        for(int rowIndex= 1; rowIndex < numberOfRows; ++rowIndex)\n        {\n            if(stringArray[rowIndex - 1][columnIndex] > stringArray[rowIndex][columnIndex])\n            {\n                ++deletionCount;\n                break;\n            }\n        }\n    }\n    return deletionCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findRepeatedNumber(vector<int> &numberList)\n{\n    unordered_map<int, int> occurrenceMap;\n    for (int i = 0; i < numberList.size(); ++i)\n    {\n        int currentNum = numberList[i];\n        if (++occurrenceMap[currentNum] > 1)\n            return currentNum;\n    }\n    return -1; // Return -1 if no repeated number is found (optional)\n}",
    "output": "#include <bits/stdc++.h>\nint findRepeatedNumber(std::vector<int> &numberList)\n{\n    std::unordered_map<int, int> occurrenceMap;\n    for(int currentNum : numberList)\n    {\n        if(++occurrenceMap[currentNum] > 1)\n            return currentNum;\n    }\n    return -1; // Added return statement to handle the case where no repeated number is found.\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxWidthRamp(vector<int> &numberArray)\n{\n    vector<int> indexArray(numberArray.size());\n    for(int currentIndex = 0; currentIndex < numberArray.size(); ++currentIndex)\n    {\n        indexArray[currentIndex] = currentIndex;\n    }\n\n    sort(indexArray.begin(), indexArray.end(), [&](int firstIndex, int secondIndex)\n              { return numberArray[firstIndex] == numberArray[secondIndex] ? firstIndex < secondIndex : numberArray[firstIndex] < numberArray[secondIndex]; });\n\n    int maximumWidth = 0;\n    int minimumIndex = numeric_limits<int>::max();\n    for(int i = 0; i < indexArray.size(); ++i)\n    {\n        int index = indexArray[i];\n        maximumWidth = max(maximumWidth, index - minimumIndex);\n        minimumIndex = min(minimumIndex, index);\n    }\n\n    return maximumWidth;\n}",
    "output": "#include <bits/stdc++.h>\nint maxWidthRamp(std::vector<int> &numberArray)\n{\n    std::vector<int> indexArray(numberArray.size());\n    for(int currentIndex= 0; currentIndex < numberArray.size(); ++currentIndex)\n    {\n        indexArray[currentIndex]= currentIndex;\n    }\n\n    std::sort(indexArray.begin(), indexArray.end(), [&](int firstIndex, int secondIndex)\n              { return numberArray[firstIndex] == numberArray[secondIndex] ? firstIndex < secondIndex : numberArray[firstIndex] < numberArray[secondIndex]; });\n\n    int maximumWidth= 0;\n    int minimumIndex= std::numeric_limits<int>::max();\n    for(int index : indexArray)\n    {\n        maximumWidth= std::max(maximumWidth, index - minimumIndex);\n        minimumIndex= std::min(minimumIndex, index);\n    }\n\n    return maximumWidth;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble minAreaFreeRect(vector<vector<int>> &points)\n{\n    double minimumArea = numeric_limits<double>::infinity();\n    unordered_map<int, set<int>> xCoordinateGroups;\n\n    for (const auto &point : points)\n    {\n        xCoordinateGroups[point[0]].insert(point[1]);\n    }\n\n    for (auto it1 = xCoordinateGroups.begin(); it1 != xCoordinateGroups.end(); ++it1)\n    {\n        int x1 = it1->first;\n        const set<int> &yCoordinates1 = it1->second;\n\n        for (auto it2 = xCoordinateGroups.begin(); it2 != xCoordinateGroups.end(); ++it2)\n        {\n            int x2 = it2->first;\n            const set<int> &yCoordinates2 = it2->second;\n\n            if (x1 == x2)\n                continue;\n\n            for (auto y1_it = yCoordinates1.begin(); y1_it != yCoordinates1.end(); ++y1_it)\n            {\n                int y1 = *y1_it;\n                for (auto y2_it = yCoordinates2.begin(); y2_it != yCoordinates2.end(); ++y2_it)\n                {\n                    int y2 = *y2_it;\n                    if (yCoordinates1.find(y2) != yCoordinates1.end() && yCoordinates2.find(y1) != yCoordinates2.end())\n                    {\n                        double area = sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2)) * sqrt(pow(x1 - x2, 2) + pow(y1 - y1, 2));\n                        minimumArea = min(minimumArea, area);\n                    }\n                }\n            }\n        }\n    }\n\n    return minimumArea == numeric_limits<double>::infinity() ? 0 : minimumArea;\n}",
    "output": "#include <bits/stdc++.h>\ndouble minAreaFreeRect(std::vector<std::vector<int>> &points)\n{\n    double minimumArea= std::numeric_limits<double>::infinity();\n    std::unordered_map<int, std::set<int>> xCoordinateGroups;\n\n    for(const auto &point : points)\n    {\n        xCoordinateGroups[point[0]].insert(point[1]);\n    }\n\n    for(const auto &[x1, yCoordinates1] : xCoordinateGroups)\n    {\n        for(const auto &[x2, yCoordinates2] : xCoordinateGroups)\n        {\n            if(x1 == x2)\n                continue;\n\n            for(int y1 : yCoordinates1)\n            {\n                for(int y2 : yCoordinates2)\n                {\n                    if(yCoordinates1.find(y2) != yCoordinates1.end() && yCoordinates2.find(y1) != yCoordinates2.end())\n                    {\n                        double area= std::sqrt(std::pow(x1 - x2, 2) + std::pow(y1 - y2, 2)) * std::sqrt(std::pow(x1 - x2, 2) + std::pow(y1 - y1, 2));\n                        minimumArea= std::min(minimumArea, area);\n                    }\n                }\n            }\n        }\n    }\n\n    return minimumArea == std::numeric_limits<double>::infinity() ? 0 : minimumArea;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int leastOperationsToExpressTarget(int base, int target)\n{\n    if(base == target)\n        return 0;\n    if(target == 1)\n        return 1;\n    if(base > target)\n        return min(2 * target - 1, 2 * (base - target));\n\n    int exponentCount= 0;\n    long long power= base;\n    while(power < target)\n    {\n        exponentCount++;\n        power*= base;\n    }\n\n    int minimumOperations= INT_MAX;\n    long long delta= 1;\n\n    for(int i= exponentCount - 1; i >= 0; i--)\n    {\n        while(power >= target + delta * (1 - base))\n        {\n            power-= delta;\n            minimumOperations= min(minimumOperations, i + (int)(log2(target / delta) + 1) + (int)(delta == 1 ? -1 : 0));\n        }\n        delta= delta * base + 1;\n    }\n\n    return minimumOperations;\n}",
    "output": "int leastOperationsToExpressTarget(int base, int target)\n{\n    if(base == target)\n        return 0;\n    if(target == 1)\n        return 1;\n    if(base > target)\n        return min(2 * target - 1, 2 * (base - target));\n\n    int exponentCount= 0;\n    long long power= base;\n    while(power < target)\n    {\n        exponentCount++;\n        power*= base;\n    }\n\n    int minimumOperations= INT_MAX;\n    long long delta= 1;\n\n    for(int i= exponentCount - 1; i >= 0; i--)\n    {\n        while(power >= target + delta * (1 - base))\n        {\n            power-= delta;\n            minimumOperations= min(minimumOperations, i + (int)(log2(target / delta) + 1) + (int)(delta == 1 ? -1 : 0));\n        }\n        delta= delta * base + 1;\n    }\n\n    return minimumOperations;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "bool isUnivalued(TreeNode *rootNode, int referenceValue= -1)\n{\n    if(!rootNode)\n        return true;\n    if(referenceValue == -1)\n        referenceValue= rootNode->val;\n    return rootNode->val == referenceValue && isUnivalued(rootNode->left, referenceValue) && isUnivalued(rootNode->right, referenceValue);\n}",
    "output": "bool isUnivalued(TreeNode *rootNode, int referenceValue= -1)\n{\n    if(!rootNode)\n        return true;\n    if(referenceValue == -1)\n        referenceValue= rootNode->val;\n    return rootNode->val == referenceValue && isUnivalued(rootNode->left, referenceValue) && isUnivalued(rootNode->right, referenceValue);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> spellchecker(vector<string> &wordList, vector<string> &queries)\n{\n    unordered_map<string, string> exactWordMap;\n    unordered_map<string, string> lowerCaseWordMap;\n    unordered_map<string, string> vowelReplacedWordMap;\n\n    for (int i = 0; i < wordList.size(); ++i)\n    {\n        const auto &word = wordList[i];\n        string lowerCaseWord = word;\n        for (int j = 0; j < lowerCaseWord.size(); ++j)\n            lowerCaseWord[j] = tolower(lowerCaseWord[j]);\n        string vowelReplacedWord = lowerCaseWord;\n        for (int j = 0; j < vowelReplacedWord.size(); ++j)\n            if (vowelReplacedWord[j] == 'a' || vowelReplacedWord[j] == 'e' || vowelReplacedWord[j] == 'i' || vowelReplacedWord[j] == 'o' || vowelReplacedWord[j] == 'u')\n                vowelReplacedWord[j] = '#';\n\n        exactWordMap[word] = word;\n        if (!lowerCaseWordMap.count(lowerCaseWord))\n            lowerCaseWordMap[lowerCaseWord] = word;\n        if (!vowelReplacedWordMap.count(vowelReplacedWord))\n            vowelReplacedWordMap[vowelReplacedWord] = word;\n    }\n\n    vector<string> result;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        const auto &query = queries[i];\n        string lowerCaseQuery = query;\n        for (int j = 0; j < lowerCaseQuery.size(); ++j)\n            lowerCaseQuery[j] = tolower(lowerCaseQuery[j]);\n        string vowelReplacedQuery = lowerCaseQuery;\n        for (int j = 0; j < vowelReplacedQuery.size(); ++j)\n            if (vowelReplacedQuery[j] == 'a' || vowelReplacedQuery[j] == 'e' || vowelReplacedQuery[j] == 'i' || vowelReplacedQuery[j] == 'o' || vowelReplacedQuery[j] == 'u')\n                vowelReplacedQuery[j] = '#';\n\n        if (exactWordMap.count(query))\n        {\n            result.push_back(exactWordMap[query]);\n        }\n        else if (lowerCaseWordMap.count(lowerCaseQuery))\n        {\n            result.push_back(lowerCaseWordMap[lowerCaseQuery]);\n        }\n        else if (vowelReplacedWordMap.count(vowelReplacedQuery))\n        {\n            result.push_back(vowelReplacedWordMap[vowelReplacedQuery]);\n        }\n        else\n        {\n            result.push_back(\"\");\n        }\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> spellchecker(std::vector<std::string> &wordList, std::vector<std::string> &queries)\n{\n    std::unordered_map<std::string, std::string> exactWordMap;\n    std::unordered_map<std::string, std::string> lowerCaseWordMap;\n    std::unordered_map<std::string, std::string> vowelReplacedWordMap;\n\n    for(const auto &word : wordList)\n    {\n        std::string lowerCaseWord= word;\n        for(auto &char : lowerCaseWord)\n            char= tolower(char);\n        std::string vowelReplacedWord= lowerCaseWord;\n        for(auto &char : vowelReplacedWord)\n            if(char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u')\n                char= '#';\n\n        exactWordMap[word]= word;\n        if(!lowerCaseWordMap.count(lowerCaseWord))\n            lowerCaseWordMap[lowerCaseWord]= word;\n        if(!vowelReplacedWordMap.count(vowelReplacedWord))\n            vowelReplacedWordMap[vowelReplacedWord]= word;\n    }\n\n    std::vector<std::string> result;\n    for(const auto &query : queries)\n    {\n        std::string lowerCaseQuery= query;\n        for(auto &char : lowerCaseQuery)\n            char= tolower(char);\n        std::string vowelReplacedQuery= lowerCaseQuery;\n        for(auto &char : vowelReplacedQuery)\n            if(char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u')\n                char= '#';\n\n        if(exactWordMap.count(query))\n        {\n            result.push_back(exactWordMap[query]);\n        }\n        else if(lowerCaseWordMap.count(lowerCaseQuery))\n        {\n            result.push_back(lowerCaseWordMap[lowerCaseQuery]);\n        }\n        else if(vowelReplacedWordMap.count(vowelReplacedQuery))\n        {\n            result.push_back(vowelReplacedWordMap[vowelReplacedQuery]);\n        }\n        else\n        {\n            result.push_back(\"\");\n        }\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> getNumbersWithSameConsecutiveDifference(int numberLength, int difference)\n{\n    vector<int> result;\n    if(numberLength == 1)\n        result.push_back(0);\n\n    function<void(string)> depthFirstSearch= [&](string currentNumber)\n    {\n        if(currentNumber.size() == numberLength)\n        {\n            result.push_back(stoi(currentNumber));\n            return;\n        }\n\n        char lastDigit= currentNumber.back();\n        if(lastDigit - difference >= '0')\n            depthFirstSearch(currentNumber + static_cast<char>(lastDigit - difference));\n        if(difference != 0 && lastDigit + difference <= '9')\n            depthFirstSearch(currentNumber + static_cast<char>(lastDigit + difference));\n    };\n\n    for(char i= '1'; i <= '9'; ++i)\n    {\n        depthFirstSearch(string(1, i));\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> getNumbersWithSameConsecutiveDifference(int numberLength, int difference)\n{\n    std::vector<int> result;\n    if(numberLength == 1)\n        result.push_back(0);\n\n    std::function<void(std::string)> depthFirstSearch= [&](std::string currentNumber)\n    {\n        if(currentNumber.size() == numberLength)\n        {\n            result.push_back(stoi(currentNumber));\n            return;\n        }\n\n        char lastDigit= currentNumber.back();\n        if(lastDigit - difference >= '0')\n            depthFirstSearch(currentNumber + static_cast<char>(lastDigit - difference));\n        if(difference != 0 && lastDigit + difference <= '9')\n            depthFirstSearch(currentNumber + static_cast<char>(lastDigit + difference));\n    };\n\n    for(char i= '1'; i <= '9'; ++i)\n    {\n        depthFirstSearch(std::string(1, i));\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int minCameraCover(TreeNode *root)\n{\n    int totalCameras= 0;\n    return (calculateCameras(root, totalCameras) < 1 ? 1 : 0) + totalCameras;\n}\n\nint calculateCameras(TreeNode *currentNode, int &totalCameras)\n{\n    if(!currentNode)\n        return 2;\n    int leftStatus= calculateCameras(currentNode->left, totalCameras);\n    int rightStatus= calculateCameras(currentNode->right, totalCameras);\n    if(leftStatus == 0 || rightStatus == 0)\n    {\n        totalCameras++;\n        return 1;\n    }\n    return leftStatus == 1 || rightStatus == 1 ? 2 : 0;\n}",
    "output": "int minCameraCover(TreeNode *root)\n{\n    int totalCameras= 0;\n    return (calculateCameras(root, totalCameras) < 1 ? 1 : 0) + totalCameras;\n}\n\nint calculateCameras(TreeNode *currentNode, int &totalCameras)\n{\n    if(!currentNode)\n        return 2;\n    int leftStatus= calculateCameras(currentNode->left, totalCameras);\n    int rightStatus= calculateCameras(currentNode->right, totalCameras);\n    if(leftStatus == 0 || rightStatus == 0)\n    {\n        totalCameras++;\n        return 1;\n    }\n    return leftStatus == 1 || rightStatus == 1 ? 2 : 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> pancakeSort(vector<int> &array)\n{\n    vector<int> flips;\n    for(int currentSize= array.size(); currentSize > 1; --currentSize)\n    {\n        int maxIndex= max_element(array.begin(), array.begin() + currentSize) - array.begin();\n        flips.push_back(maxIndex + 1);\n        flips.push_back(currentSize);\n        reverse(array.begin(), array.begin() + maxIndex + 1);\n        reverse(array.begin(), array.begin() + currentSize);\n    }\n    return flips;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> pancakeSort(std::vector<int> &array)\n{\n    std::vector<int> flips;\n    for(int currentSize= array.size(); currentSize > 1; --currentSize)\n    {\n        int maxIndex= std::max_element(array.begin(), array.begin() + currentSize) - array.begin();\n        flips.push_back(maxIndex + 1);\n        flips.push_back(currentSize);\n        std::reverse(array.begin(), array.begin() + maxIndex + 1);\n        std::reverse(array.begin(), array.begin() + currentSize);\n    }\n    return flips;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> powerfulIntegers(int baseX, int baseY, int upperBound)\n{\n    set<int> uniqueResults;\n    for(int exponentX= 0; pow(baseX, exponentX) <= upperBound; ++exponentX)\n    {\n        for(int exponentY= 0; pow(baseX, exponentX) + pow(baseY, exponentY) <= upperBound; ++exponentY)\n        {\n            uniqueResults.insert(pow(baseX, exponentX) + pow(baseY, exponentY));\n        }\n    }\n    return vector<int>(uniqueResults.begin(), uniqueResults.end());\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> powerfulIntegers(int baseX, int baseY, int upperBound)\n{\n    std::set<int> uniqueResults;\n    for(int exponentX= 0; pow(baseX, exponentX) <= upperBound; ++exponentX)\n    {\n        for(int exponentY= 0; pow(baseX, exponentX) + pow(baseY, exponentY) <= upperBound; ++exponentY)\n        {\n            uniqueResults.insert(pow(baseX, exponentX) + pow(baseY, exponentY));\n        }\n    }\n    return std::vector<int>(uniqueResults.begin(), uniqueResults.end());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid flipRecur(TreeNode *currentNode, vector<int> &voyage, int &currentIndex, vector<int> &flippedNodes)\n{\n    if(currentNode == NULL)\n        return;\n    if(currentNode->val != voyage[currentIndex++])\n    {\n        flippedNodes= {-1};\n        return;\n    }\n    if(currentIndex < voyage.size() && currentNode->left != NULL && currentNode->left->val != voyage[currentIndex])\n    {\n        flippedNodes.push_back(currentNode->val);\n        flipRecur(currentNode->right, voyage, currentIndex, flippedNodes);\n        flipRecur(currentNode->left, voyage, currentIndex, flippedNodes);\n    }\n    else\n    {\n        flipRecur(currentNode->left, voyage, currentIndex, flippedNodes);\n        flipRecur(currentNode->right, voyage, currentIndex, flippedNodes);\n    }\n}\n\nvector<int> flipMatchVoyage(TreeNode *rootNode, vector<int> &voyage)\n{\n    vector<int> flippedNodes;\n    int currentIndex= 0;\n    flipRecur(rootNode, voyage, currentIndex, flippedNodes);\n    return flippedNodes;\n}",
    "output": "#include <bits/stdc++.h>\nvoid flipRecur(TreeNode *currentNode, std::vector<int> &voyage, int &currentIndex, std::vector<int> &flippedNodes)\n{\n    if(currentNode == NULL)\n        return;\n    if(currentNode->val != voyage[currentIndex++])\n    {\n        flippedNodes= {-1};\n        return;\n    }\n    if(currentIndex < voyage.size() && currentNode->left != NULL && currentNode->left->val != voyage[currentIndex])\n    {\n        flippedNodes.push_back(currentNode->val);\n        flipRecur(currentNode->right, voyage, currentIndex, flippedNodes);\n        flipRecur(currentNode->left, voyage, currentIndex, flippedNodes);\n    }\n    else\n    {\n        flipRecur(currentNode->left, voyage, currentIndex, flippedNodes);\n        flipRecur(currentNode->right, voyage, currentIndex, flippedNodes);\n    }\n}\n\nstd::vector<int> flipMatchVoyage(TreeNode *rootNode, std::vector<int> &voyage)\n{\n    std::vector<int> flippedNodes;\n    int currentIndex= 0;\n    flipRecur(rootNode, voyage, currentIndex, flippedNodes);\n    return flippedNodes;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isRationalEqual(string firstNumber, string secondNumber)\n{\n    auto evaluate = [](string number)\n    {\n        int parenthesisIndex = number.find('(');\n        if(parenthesisIndex != string::npos)\n        {\n            string baseValue = number.substr(0, parenthesisIndex);\n            string repeatingPart = number.substr(parenthesisIndex + 1, number.length() - parenthesisIndex - 2);\n            for(int k = 0; k < 20; ++k)\n                baseValue += repeatingPart;\n            return stod(baseValue);\n        }\n        return stod(number);\n    };\n    return fabs(evaluate(firstNumber) - evaluate(secondNumber)) < 1e-12;\n}",
    "output": "bool isRationalEqual(std::string firstNumber, std::string secondNumber)\n{\n    auto evaluate= [](std::string number)\n    {\n        int parenthesisIndex= number.find('(');\n        if(parenthesisIndex != std::string::npos)\n        {\n            std::string baseValue= number.substr(0, parenthesisIndex);\n            std::string repeatingPart= number.substr(parenthesisIndex + 1, number.length() - parenthesisIndex - 2);\n            for(int k= 0; k < 20; ++k)\n                baseValue+= repeatingPart;\n            return stod(baseValue);\n        }\n        return stod(number);\n    };\n    return fabs(evaluate(firstNumber) - evaluate(secondNumber)) < 1e-12;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int fib(int number)\n{\n    if(number <= 1)\n        return number;\n    int firstTerm= 0, secondTerm= 1, nextTerm;\n    for(int index= 2; index <= number; index++)\n    {\n        nextTerm= firstTerm + secondTerm;\n        firstTerm= secondTerm;\n        secondTerm= nextTerm;\n    }\n    return secondTerm;\n}",
    "output": "int fib(int number)\n{\n    if(number <= 1)\n        return number;\n    int firstTerm= 0, secondTerm= 1, nextTerm;\n    for(int index= 2; index <= number; index++)\n    {\n        nextTerm= firstTerm + secondTerm;\n        firstTerm= secondTerm;\n        secondTerm= nextTerm;\n    }\n    return secondTerm;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> kClosestPoints(vector<vector<int>> &points, int numberOfPoints)\n{\n    partial_sort(points.begin(), points.begin() + numberOfPoints, points.end(), [](const vector<int> &pointA, const vector<int> &pointB)\n                  { return pointA[0] * pointA[0] + pointA[1] * pointA[1] < pointB[0] * pointB[0] + pointB[1] * pointB[1]; });\n\n    return vector<vector<int>>(points.begin(), points.begin() + numberOfPoints);\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> kClosestPoints(std::vector<std::vector<int>> &points, int numberOfPoints)\n{\n    std::partial_sort(points.begin(), points.begin() + numberOfPoints, points.end(), [](const std::vector<int> &pointA, const std::vector<int> &pointB)\n                      { return pointA[0] * pointA[0] + pointA[1] * pointA[1] < pointB[0] * pointB[0] + pointB[1] * pointB[1]; });\n\n    return std::vector<std::vector<int>>(points.begin(), points.begin() + numberOfPoints);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int findSmallestRepunitDivisibleByK(int divisor)\n{\n    if(divisor % 2 == 0 || divisor % 5 == 0)\n        return -1;\n    int remainder= 0;\n    for(int length= 1; length <= divisor; length++)\n    {\n        remainder= (remainder * 10 + 1) % divisor;\n        if(remainder == 0)\n            return length;\n    }\n    return -1;\n}",
    "output": "int findSmallestRepunitDivisibleByK(int divisor)\n{\n    if(divisor % 2 == 0 || divisor % 5 == 0)\n        return -1;\n    int remainder= 0;\n    for(int length= 1; length <= divisor; length++)\n    {\n        remainder= (remainder * 10 + 1) % divisor;\n        if(remainder == 0)\n            return length;\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint subarraysDivByK(vector<int> &numberArray, int divisor)\n{\n    unordered_map<int, int> remainderCounts;\n    remainderCounts[0] = 1;\n    int cumulativeSum = 0, subarrayCount = 0;\n\n    for (int i = 0; i < numberArray.size(); ++i)\n    {\n        int currentNumber = numberArray[i];\n        cumulativeSum += currentNumber;\n        int remainder = ((cumulativeSum % divisor) + divisor) % divisor;\n        subarrayCount += remainderCounts[remainder];\n        remainderCounts[remainder]++;\n    }\n\n    return subarrayCount;\n}",
    "output": "#include <bits/stdc++.h>\nint subarraysDivByK(std::vector<int> &numberArray, int divisor)\n{\n    std::unordered_map<int, int> remainderCounts;\n    remainderCounts[0] = 1;\n    int cumulativeSum = 0, subarrayCount = 0;\n\n    for(int currentNumber : numberArray)\n    {\n        cumulativeSum += currentNumber;\n        int remainder = ((cumulativeSum % divisor) + divisor) % divisor;\n        subarrayCount += remainderCounts[remainder];\n        remainderCounts[remainder]++;\n    }\n\n    return subarrayCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint oddEvenJumps(vector<int> &jumpArray)\n{\n    int arraySize= jumpArray.size();\n    vector<bool> canReachOdd(arraySize, false), canReachEven(arraySize, false);\n    canReachOdd[arraySize - 1]= canReachEven[arraySize - 1]= true;\n    map<int, int> indexMap;\n    indexMap[jumpArray[arraySize - 1]]= arraySize - 1;\n\n    int goodIndicesCount= 1;\n    for(int currentIndex= arraySize - 2; currentIndex >= 0; --currentIndex)\n    {\n        auto oddJumpIterator= indexMap.lower_bound(jumpArray[currentIndex]);\n        auto evenJumpIterator= indexMap.upper_bound(jumpArray[currentIndex]);\n\n        if(oddJumpIterator != indexMap.end())\n            canReachOdd[currentIndex]= canReachEven[oddJumpIterator->second];\n        if(evenJumpIterator != indexMap.begin())\n            canReachEven[currentIndex]= canReachOdd[(--evenJumpIterator)->second];\n\n        if(canReachOdd[currentIndex])\n            ++goodIndicesCount;\n\n        indexMap[jumpArray[currentIndex]]= currentIndex;\n    }\n\n    return goodIndicesCount;\n}",
    "output": "#include <bits/stdc++.h>\nint oddEvenJumps(std::vector<int> &jumpArray)\n{\n    int arraySize= jumpArray.size();\n    std::vector<bool> canReachOdd(arraySize, false), canReachEven(arraySize, false);\n    canReachOdd[arraySize - 1]= canReachEven[arraySize - 1]= true;\n    std::map<int, int> indexMap;\n    indexMap[jumpArray[arraySize - 1]]= arraySize - 1;\n\n    int goodIndicesCount= 1;\n    for(int currentIndex= arraySize - 2; currentIndex >= 0; --currentIndex)\n    {\n        auto oddJumpIterator= indexMap.lower_bound(jumpArray[currentIndex]);\n        auto evenJumpIterator= indexMap.upper_bound(jumpArray[currentIndex]);\n\n        if(oddJumpIterator != indexMap.end())\n            canReachOdd[currentIndex]= canReachEven[oddJumpIterator->second];\n        if(evenJumpIterator != indexMap.begin())\n            canReachEven[currentIndex]= canReachOdd[(--evenJumpIterator)->second];\n\n        if(canReachOdd[currentIndex])\n            ++goodIndicesCount;\n\n        indexMap[jumpArray[currentIndex]]= currentIndex;\n    }\n\n    return goodIndicesCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint largestPerimeter(vector<int> &sideLengths)\n{\n    sort(sideLengths.begin(), sideLengths.end(), greater<int>());\n\n    for(size_t index= 0; index < sideLengths.size() - 2; ++index)\n    {\n        if(sideLengths[index] < sideLengths[index + 1] + sideLengths[index + 2])\n        {\n            return sideLengths[index] + sideLengths[index + 1] + sideLengths[index + 2];\n        }\n    }\n\n    return 0;\n}",
    "output": "#include <bits/stdc++.h>\nint largestPerimeter(std::vector<int> &sideLengths)\n{\n    std::sort(sideLengths.begin(), sideLengths.end(), std::greater<int>());\n\n    for(size_t index= 0; index < sideLengths.size() - 2; ++index)\n    {\n        if(sideLengths[index] < sideLengths[index + 1] + sideLengths[index + 2])\n        {\n            return sideLengths[index] + sideLengths[index + 1] + sideLengths[index + 2];\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> sortedSquares(vector<int> &inputNumbers)\n{\n    for(int index= 0; index < inputNumbers.size(); index++)\n    {\n        inputNumbers[index]*= inputNumbers[index];\n    }\n    sort(inputNumbers.begin(), inputNumbers.end());\n    return inputNumbers;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> sortedSquares(std::vector<int> &inputNumbers)\n{\n    for(int index= 0; index < inputNumbers.size(); index++)\n    {\n        inputNumbers[index]*= inputNumbers[index];\n    }\n    std::sort(inputNumbers.begin(), inputNumbers.end());\n    return inputNumbers;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxTurbulenceSize(vector<int> &array)\n{\n    int arraySize= array.size();\n    int maxTurbulenceLength= 1;\n    int index= 0;\n\n    while(index < arraySize - 1)\n    {\n        if(array[index] == array[index + 1])\n        {\n            index++;\n            continue;\n        }\n\n        int tempIndex= index + 1;\n        while(tempIndex < arraySize - 1 && ((array[tempIndex] > array[tempIndex + 1]) != (array[tempIndex - 1] > array[tempIndex])))\n        {\n            tempIndex++;\n        }\n\n        maxTurbulenceLength= max(maxTurbulenceLength, tempIndex - index + 1);\n        index= tempIndex;\n    }\n\n    return maxTurbulenceLength;\n}",
    "output": "#include <bits/stdc++.h>\nint maxTurbulenceSize(std::vector<int> &array)\n{\n    int arraySize= array.size();\n    int maxTurbulenceLength= 1;\n    int index= 0;\n\n    while(index < arraySize - 1)\n    {\n        if(array[index] == array[index + 1])\n        {\n            index++;\n            continue;\n        }\n\n        int tempIndex= index + 1;\n        while(tempIndex < arraySize - 1 && ((array[tempIndex] > array[tempIndex + 1]) != (array[tempIndex - 1] > array[tempIndex])))\n        {\n            tempIndex++;\n        }\n\n        maxTurbulenceLength= std::max(maxTurbulenceLength, tempIndex - index + 1);\n        index= tempIndex;\n    }\n\n    return maxTurbulenceLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int distributeCoins(TreeNode *rootNode, int &totalMoves)\n{\n    if(rootNode == NULL)\n        return 0;\n    int leftBalance= distributeCoins(rootNode->left, totalMoves);\n    int rightBalance= distributeCoins(rootNode->right, totalMoves);\n    totalMoves+= abs(leftBalance) + abs(rightBalance);\n    return rootNode->val + leftBalance + rightBalance - 1;\n}\n\nint distributeCoins(TreeNode *rootNode)\n{\n    int totalMoves= 0;\n    distributeCoins(rootNode, totalMoves);\n    return totalMoves;\n}",
    "output": "int distributeCoins(TreeNode *rootNode, int &totalMoves)\n{\n    if(rootNode == NULL)\n        return 0;\n    int leftBalance= distributeCoins(rootNode->left, totalMoves);\n    int rightBalance= distributeCoins(rootNode->right, totalMoves);\n    totalMoves+= abs(leftBalance) + abs(rightBalance);\n    return rootNode->val + leftBalance + rightBalance - 1;\n}\n\nint distributeCoins(TreeNode *rootNode)\n{\n    int totalMoves= 0;\n    distributeCoins(rootNode, totalMoves);\n    return totalMoves;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(vector<vector<int>> &grid, int currentX, int currentY, int remainingEmpty)\n{\n    if(currentX < 0 || currentX >= grid.size() || currentY < 0 || currentY >= grid[0].size() || grid[currentX][currentY] == -1)\n    {\n        return 0;\n    }\n    if(grid[currentX][currentY] == 2)\n    {\n        return remainingEmpty == -1 ? 1 : 0;\n    }\n    grid[currentX][currentY]= -1;\n    int pathCount= depthFirstSearch(grid, currentX + 1, currentY, remainingEmpty - 1) +\n                   depthFirstSearch(grid, currentX - 1, currentY, remainingEmpty - 1) +\n                   depthFirstSearch(grid, currentX, currentY + 1, remainingEmpty - 1) +\n                   depthFirstSearch(grid, currentX, currentY - 1, remainingEmpty - 1);\n    grid[currentX][currentY]= 0;\n    return pathCount;\n}\n\nint uniquePathsIII(vector<vector<int>> &grid)\n{\n    int startX= 0, startY= 0, totalEmpty= 1;\n    for(int rowIndex= 0; rowIndex < grid.size(); ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex < grid[0].size(); ++colIndex)\n        {\n            if(grid[rowIndex][colIndex] == 1)\n            {\n                startX= rowIndex, startY= colIndex;\n            }\n            else if(grid[rowIndex][colIndex] == 0)\n            {\n                totalEmpty++;\n            }\n        }\n    }\n    return depthFirstSearch(grid, startX, startY, totalEmpty);\n}",
    "output": "#include <bits/stdc++.h>\nint depthFirstSearch(std::vector<std::vector<int>> &grid, int currentX, int currentY, int remainingEmpty)\n{\n    if(currentX < 0 || currentX >= grid.size() || currentY < 0 || currentY >= grid[0].size() || grid[currentX][currentY] == -1)\n    {\n        return 0;\n    }\n    if(grid[currentX][currentY] == 2)\n    {\n        return remainingEmpty == -1 ? 1 : 0;\n    }\n    grid[currentX][currentY]= -1;\n    int pathCount= depthFirstSearch(grid, currentX + 1, currentY, remainingEmpty - 1) +\n                   depthFirstSearch(grid, currentX - 1, currentY, remainingEmpty - 1) +\n                   depthFirstSearch(grid, currentX, currentY + 1, remainingEmpty - 1) +\n                   depthFirstSearch(grid, currentX, currentY - 1, remainingEmpty - 1);\n    grid[currentX][currentY]= 0;\n    return pathCount;\n}\n\nint uniquePathsIII(std::vector<std::vector<int>> &grid)\n{\n    int startX= 0, startY= 0, totalEmpty= 1;\n    for(int rowIndex= 0; rowIndex < grid.size(); ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex < grid[0].size(); ++colIndex)\n        {\n            if(grid[rowIndex][colIndex] == 1)\n            {\n                startX= rowIndex, startY= colIndex;\n            }\n            else if(grid[rowIndex][colIndex] == 0)\n            {\n                totalEmpty++;\n            }\n        }\n    }\n    return depthFirstSearch(grid, startX, startY, totalEmpty);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TimeMap\n{\n  public:\n    map<string, map<int, string>> keyValueData;\n\n    void set(const string &key, const string &value, int timestamp)\n    {\n        keyValueData[key][timestamp]= value;\n    }\n\n    string get(const string &key, int timestamp)\n    {\n        if(!keyValueData.count(key))\n            return \"\";\n        auto iterator= keyValueData[key].upper_bound(timestamp);\n        if(iterator == keyValueData[key].begin())\n            return \"\";\n        return prev(iterator)->second;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass TimeMap\n{\n  public:\n    std::map<std::string, std::map<int, std::string>> keyValueData;\n\n    void set(const std::string &key, const std::string &value, int timestamp)\n    {\n        keyValueData[key][timestamp]= value;\n    }\n\n    std::string get(const std::string &key, int timestamp)\n    {\n        if(!keyValueData.count(key))\n            return \"\";\n        auto iterator= keyValueData[key].upper_bound(timestamp);\n        if(iterator == keyValueData[key].begin())\n            return \"\";\n        return prev(iterator)->second;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countAndTriples(vector<int> &numbers)\n{\n    int tripleCount= 0;\n    for(int firstIndex= 0; firstIndex < numbers.size(); ++firstIndex)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < numbers.size(); ++secondIndex)\n        {\n            for(int thirdIndex= secondIndex + 1; thirdIndex < numbers.size(); ++thirdIndex)\n            {\n                if(numbers[firstIndex] & numbers[secondIndex] & numbers[thirdIndex])\n                    ++tripleCount;\n            }\n        }\n    }\n    return tripleCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countAndTriples(std::vector<int> &numbers)\n{\n    int tripleCount= 0;\n    for(int firstIndex= 0; firstIndex < numbers.size(); ++firstIndex)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < numbers.size(); ++secondIndex)\n        {\n            for(int thirdIndex= secondIndex + 1; thirdIndex < numbers.size(); ++thirdIndex)\n            {\n                if(numbers[firstIndex] & numbers[secondIndex] & numbers[thirdIndex])\n                    ++tripleCount;\n            }\n        }\n    }\n    return tripleCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minCostTickets(vector<int> &travelDays, vector<int> &ticketCosts)\n{\n    unordered_set<int> travelDaysSet(travelDays.begin(), travelDays.end());\n    vector<int> minCosts(366, 0);\n\n    for(int currentDay= 1; currentDay <= 365; ++currentDay)\n    {\n        if(travelDaysSet.count(currentDay) == 0)\n        {\n            minCosts[currentDay]= minCosts[currentDay - 1];\n        }\n        else\n        {\n            minCosts[currentDay]= min({minCosts[currentDay - 1] + ticketCosts[0],\n                                       minCosts[max(0, currentDay - 7)] + ticketCosts[1],\n                                       minCosts[max(0, currentDay - 30)] + ticketCosts[2]});\n        }\n    }\n\n    return minCosts[365];\n}",
    "output": "#include <bits/stdc++.h>\nint minCostTickets(std::vector<int> &travelDays, std::vector<int> &ticketCosts)\n{\n    std::unordered_set<int> travelDaysSet(travelDays.begin(), travelDays.end());\n    std::vector<int> minCosts(366, 0);\n\n    for(int currentDay= 1; currentDay <= 365; ++currentDay)\n    {\n        if(travelDaysSet.count(currentDay) == 0)\n        {\n            minCosts[currentDay]= minCosts[currentDay - 1];\n        }\n        else\n        {\n            minCosts[currentDay]= std::min({minCosts[currentDay - 1] + ticketCosts[0],\n                                       minCosts[std::max(0, currentDay - 7)] + ticketCosts[1],\n                                       minCosts[std::max(0, currentDay - 30)] + ticketCosts[2]});\n        }\n    }\n\n    return minCosts[365];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nint maxAncestorDifference(TreeNode *root)\n{\n    return helper(root, root->value, root->value);\n}\n\nint helper(TreeNode *currentNode, int minValue, int maxValue)\n{\n    if(currentNode == NULL)\n    {\n        return maxValue - minValue;\n    }\n\n    maxValue= max(maxValue, currentNode->value);\n    minValue= min(minValue, currentNode->value);\n\n    int leftDifference= helper(currentNode->leftChild, minValue, maxValue);\n    int rightDifference= helper(currentNode->rightChild, minValue, maxValue);\n\n    return max(leftDifference, rightDifference);\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nint maxAncestorDifference(TreeNode *root)\n{\n    return helper(root, root->value, root->value);\n}\n\nint helper(TreeNode *currentNode, int minValue, int maxValue)\n{\n    if(currentNode == NULL)\n    {\n        return maxValue - minValue;\n    }\n\n    maxValue= max(maxValue, currentNode->value);\n    minValue= min(minValue, currentNode->value);\n\n    int leftDifference= helper(currentNode->leftChild, minValue, maxValue);\n    int rightDifference= helper(currentNode->rightChild, minValue, maxValue);\n\n    return max(leftDifference, rightDifference);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> sumEvenAfterQueries(vector<int> &numbers, vector<vector<int>> &queries)\n{\n    vector<int> result;\n    int evenSum = 0;\n\n    for(int number : numbers)\n    {\n        if(number % 2 == 0)\n        {\n            evenSum += number;\n        }\n    }\n\n    for(int i = 0; i < queries.size(); ++i)\n    {\n        vector<int> &query = queries[i];\n        int value = query[0];\n        int index = query[1];\n\n        if(numbers[index] % 2 == 0)\n        {\n            evenSum -= numbers[index];\n        }\n        numbers[index] += value;\n        if(numbers[index] % 2 == 0)\n        {\n            evenSum += numbers[index];\n        }\n        result.push_back(evenSum);\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> sumEvenAfterQueries(std::vector<int> &numbers, std::vector<std::vector<int>> &queries)\n{\n    std::vector<int> result;\n    int evenSum= 0;\n\n    for(int number : numbers)\n    {\n        if(number % 2 == 0)\n        {\n            evenSum+= number;\n        }\n    }\n\n    for(std::vector<int> &query : queries)\n    {\n        int value= query[0];\n        int index= query[1];\n\n        if(numbers[index] % 2 == 0)\n        {\n            evenSum-= numbers[index];\n        }\n        numbers[index]+= value;\n        if(numbers[index] % 2 == 0)\n        {\n            evenSum+= numbers[index];\n        }\n        result.push_back(evenSum);\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> intervalIntersection(vector<vector<int>> &firstList, vector<vector<int>> &secondList)\n{\n    vector<vector<int>> intersectionResult;\n    int firstIndex= 0, secondIndex= 0;\n\n    while(firstIndex < firstList.size() && secondIndex < secondList.size())\n    {\n        int startPoint= max(firstList[firstIndex][0], secondList[secondIndex][0]);\n        int endPoint= min(firstList[firstIndex][1], secondList[secondIndex][1]);\n\n        if(startPoint <= endPoint)\n        {\n            intersectionResult.push_back({startPoint, endPoint});\n        }\n\n        if(firstList[firstIndex][1] < secondList[secondIndex][1])\n        {\n            firstIndex++;\n        }\n        else\n        {\n            secondIndex++;\n        }\n    }\n\n    return intersectionResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> intervalIntersection(std::vector<std::vector<int>> &firstList, std::vector<std::vector<int>> &secondList)\n{\n    std::vector<std::vector<int>> intersectionResult;\n    int firstIndex = 0, secondIndex = 0;\n\n    while(firstIndex < firstList.size() && secondIndex < secondList.size())\n    {\n        int startPoint = std::max(firstList[firstIndex][0], secondList[secondIndex][0]);\n        int endPoint = std::min(firstList[firstIndex][1], secondList[secondIndex][1]);\n\n        if(startPoint <= endPoint)\n        {\n            intersectionResult.push_back({startPoint, endPoint});\n        }\n\n        if(firstList[firstIndex][1] < secondList[secondIndex][1])\n        {\n            firstIndex++;\n        }\n        else\n        {\n            secondIndex++;\n        }\n    }\n\n    return intersectionResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nvector<vector<int>> verticalTraversal(TreeNode *rootNode)\n{\n    vector<vector<int>> traversalResult;\n    if(!rootNode)\n        return traversalResult;\n\n    map<int, map<int, multiset<int>>> columnData;\n    queue<tuple<TreeNode *, int, int>> nodeQueue;\n    nodeQueue.push({rootNode, 0, 0});\n\n    while(!nodeQueue.empty())\n    {\n        auto [currentNode, rowIndex, columnIndex] = nodeQueue.front();\n        nodeQueue.pop();\n        columnData[columnIndex][rowIndex].insert(currentNode->value);\n\n        if(currentNode->leftChild)\n            nodeQueue.push({currentNode->leftChild, rowIndex + 1, columnIndex - 1});\n        if(currentNode->rightChild)\n            nodeQueue.push({currentNode->rightChild, rowIndex + 1, columnIndex + 1});\n    }\n\n    for(auto it = columnData.begin(); it != columnData.end(); ++it)\n    {\n        traversalResult.emplace_back();\n        for(auto jt = it->second.begin(); jt != it->second.end(); ++jt)\n        {\n            traversalResult.back().insert(traversalResult.back().end(), jt->second.begin(), jt->second.end());\n        }\n    }\n\n    return traversalResult;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nstd::vector<std::vector<int>> verticalTraversal(TreeNode *rootNode)\n{\n    std::vector<std::vector<int>> traversalResult;\n    if(!rootNode)\n        return traversalResult;\n\n    std::map<int, std::map<int, std::multiset<int>>> columnData;\n    std::queue<std::tuple<TreeNode *, int, int>> nodeQueue;\n    nodeQueue.push({rootNode, 0, 0});\n\n    while(!nodeQueue.empty())\n    {\n        auto [currentNode, rowIndex, columnIndex]= nodeQueue.front();\n        nodeQueue.pop();\n        columnData[columnIndex][rowIndex].insert(currentNode->value);\n\n        if(currentNode->leftChild)\n            nodeQueue.push({currentNode->leftChild, rowIndex + 1, columnIndex - 1});\n        if(currentNode->rightChild)\n            nodeQueue.push({currentNode->rightChild, rowIndex + 1, columnIndex + 1});\n    }\n\n    for(auto &[_, columnEntries] : columnData)\n    {\n        traversalResult.emplace_back();\n        for(auto &[_, nodesInRow] : columnEntries)\n        {\n            traversalResult.back().insert(traversalResult.back().end(), nodesInRow.begin(), nodesInRow.end());\n        }\n    }\n\n    return traversalResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nstring smallestFromLeaf(TreeNode *root)\n{\n    if(!root)\n        return \"|\";\n    string currentCharacter(1, root->value + 'a');\n    if(!root->leftChild && !root->rightChild)\n        return currentCharacter;\n    string leftPath= smallestFromLeaf(root->leftChild);\n    string rightPath= smallestFromLeaf(root->rightChild);\n    return min(leftPath, rightPath) + currentCharacter;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nstd::string smallestFromLeaf(TreeNode *root)\n{\n    if(!root)\n        return \"|\";\n    std::string currentCharacter(1, root->value + 'a');\n    if(!root->leftChild && !root->rightChild)\n        return currentCharacter;\n    std::string leftPath= smallestFromLeaf(root->leftChild);\n    std::string rightPath= smallestFromLeaf(root->rightChild);\n    return std::min(leftPath, rightPath) + currentCharacter;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> addToArrayForm(vector<int> &numberArray, int addend)\n{\n    // add addend to the least significant digit of the integer represented by numberArray\n    numberArray.back()+= addend;\n    // sum digits from least to most significant digit\n    for(int index= numberArray.size() - 1; index > 0 && numberArray[index]; --index)\n    {\n        numberArray[index - 1]+= numberArray[index] / 10;\n        numberArray[index]%= 10;\n    }\n    // handle possible remaining carry\n    while(numberArray[0] >= 10)\n    {\n        numberArray.insert(numberArray.begin(), numberArray[0] / 10);\n        numberArray[1]%= 10;\n    }\n    return numberArray;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> addToArrayForm(std::vector<int> &numberArray, int addend)\n{\n    // add addend to the least significant digit of the integer represented by numberArray\n    numberArray.back() += addend;\n    // sum digits from least to most significant digit\n    for(int index = numberArray.size() - 1; index > 0 && numberArray[index]; --index)\n    {\n        numberArray[index - 1] += numberArray[index] / 10;\n        numberArray[index] %= 10;\n    }\n    // handle possible remaining carry\n    while(numberArray[0] >= 10)\n    {\n        numberArray.insert(numberArray.begin(), numberArray[0] / 10);\n        numberArray[1] %= 10;\n    }\n    return numberArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool equationsPossible(vector<string> &equations)\n{\n    vector<int> parent(26, 0);\n\n    for(int index = 0; index < 26; ++index)\n    {\n        parent[index] = index;\n    }\n\n    for (int i = 0; i < equations.size(); ++i)\n    {\n        const auto &equation = equations[i];\n        if(equation[1] == '=')\n        {\n            int firstCharIndex = equation[0] - 'a';\n            int secondCharIndex = equation[3] - 'a';\n            parent[find(firstCharIndex, parent)] = find(secondCharIndex, parent);\n        }\n    }\n\n    for (int i = 0; i < equations.size(); ++i)\n    {\n        const auto &equation = equations[i];\n        if(equation[1] == '!' && find(equation[0] - 'a', parent) == find(equation[3] - 'a', parent))\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint find(int characterIndex, vector<int> &parent)\n{\n    if(parent[characterIndex] != characterIndex)\n    {\n        parent[characterIndex] = find(parent[characterIndex], parent);\n    }\n\n    return parent[characterIndex];\n}",
    "output": "#include <bits/stdc++.h>\nbool equationsPossible(std::vector<std::string> &equations)\n{\n    std::vector<int> parent(26, 0);\n\n    for(int index= 0; index < 26; ++index)\n    {\n        parent[index]= index;\n    }\n\n    for(const auto &equation : equations)\n    {\n        if(equation[1] == '=')\n        {\n            int firstCharIndex= equation[0] - 'a';\n            int secondCharIndex= equation[3] - 'a';\n            parent[find(firstCharIndex, parent)]= find(secondCharIndex, parent);\n        }\n    }\n\n    for(const auto &equation : equations)\n    {\n        if(equation[1] == '!' && find(equation[0] - 'a', parent) == find(equation[3] - 'a', parent))\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint find(int characterIndex, std::vector<int> &parent)\n{\n    if(parent[characterIndex] != characterIndex)\n    {\n        parent[characterIndex]= find(parent[characterIndex], parent);\n    }\n\n    return parent[characterIndex];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int brokenCalc(int startValue, int target)\n{\n    int operationCount= 0;\n    while(target > startValue)\n    {\n        target= (target % 2 == 0) ? target / 2 : target + 1;\n        operationCount++;\n    }\n    return operationCount + startValue - target;\n}",
    "output": "int brokenCalc(int startValue, int target)\n{\n    int operationCount= 0;\n    while(target > startValue)\n    {\n        target= (target % 2 == 0) ? target / 2 : target + 1;\n        operationCount++;\n    }\n    return operationCount + startValue - target;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint goodSubarrays(vector<int> &numbers, int targetDistinctCount)\n{\n    int goodSubarrayCount= 0;\n    for(int startIndex= 0; startIndex < numbers.size(); startIndex++)\n    {\n        unordered_map<int, int> elementFrequency;\n        for(int endIndex= startIndex; endIndex < numbers.size(); endIndex++)\n        {\n            elementFrequency[numbers[endIndex]]++;\n            if(elementFrequency.size() > targetDistinctCount)\n                break;\n            if(elementFrequency.size() == targetDistinctCount)\n                goodSubarrayCount++;\n        }\n    }\n    return goodSubarrayCount;\n}",
    "output": "#include <bits/stdc++.h>\nint goodSubarrays(std::vector<int> &numbers, int targetDistinctCount)\n{\n    int goodSubarrayCount= 0;\n    for(int startIndex= 0; startIndex < numbers.size(); startIndex++)\n    {\n        std::unordered_map<int, int> elementFrequency;\n        for(int endIndex= startIndex; endIndex < numbers.size(); endIndex++)\n        {\n            elementFrequency[numbers[endIndex]]++;\n            if(elementFrequency.size() > targetDistinctCount)\n                break;\n            if(elementFrequency.size() == targetDistinctCount)\n                goodSubarrayCount++;\n        }\n    }\n    return goodSubarrayCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nclass Solution\n{\n  public:\n    bool areCousins(TreeNode *root, int firstValue, int secondValue)\n    {\n        int firstDepth= findDepth(root, firstValue, 0);\n        int secondDepth= findDepth(root, secondValue, 0);\n        TreeNode *firstParent= findParent(root, firstValue);\n        TreeNode *secondParent= findParent(root, secondValue);\n        return (firstDepth == secondDepth) && (firstParent != secondParent);\n    }\n\n  private:\n    int findDepth(TreeNode *node, int searchValue, int currentDepth)\n    {\n        if(!node)\n            return -1;\n        if(node->value == searchValue)\n            return currentDepth;\n        int leftDepth= findDepth(node->leftChild, searchValue, currentDepth + 1);\n        if(leftDepth != -1)\n            return leftDepth;\n        return findDepth(node->rightChild, searchValue, currentDepth + 1);\n    }\n\n    TreeNode *findParent(TreeNode *node, int searchValue)\n    {\n        if(!node || (!node->leftChild && !node->rightChild))\n            return NULL;\n        if((node->leftChild && node->leftChild->value == searchValue) || (node->rightChild && node->rightChild->value == searchValue))\n            return node;\n        TreeNode *leftParent= findParent(node->leftChild, searchValue);\n        if(leftParent)\n            return leftParent;\n        return findParent(node->rightChild, searchValue);\n    }\n};",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nclass Solution\n{\n  public:\n    bool areCousins(TreeNode *root, int firstValue, int secondValue)\n    {\n        int firstDepth= findDepth(root, firstValue, 0);\n        int secondDepth= findDepth(root, secondValue, 0);\n        TreeNode *firstParent= findParent(root, firstValue);\n        TreeNode *secondParent= findParent(root, secondValue);\n        return (firstDepth == secondDepth) && (firstParent != secondParent);\n    }\n\n  private:\n    int findDepth(TreeNode *node, int searchValue, int currentDepth)\n    {\n        if(!node)\n            return -1;\n        if(node->value == searchValue)\n            return currentDepth;\n        int leftDepth= findDepth(node->leftChild, searchValue, currentDepth + 1);\n        if(leftDepth != -1)\n            return leftDepth;\n        return findDepth(node->rightChild, searchValue, currentDepth + 1);\n    }\n\n    TreeNode *findParent(TreeNode *node, int searchValue)\n    {\n        if(!node || (!node->leftChild && !node->rightChild))\n            return NULL;\n        if((node->leftChild && node->leftChild->value == searchValue) || (node->rightChild && node->rightChild->value == searchValue))\n            return node;\n        TreeNode *leftParent= findParent(node->leftChild, searchValue);\n        if(leftParent)\n            return leftParent;\n        return findParent(node->rightChild, searchValue);\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint orangesRotting(vector<vector<int>> &orangeGrid)\n{\n    int rowCount = orangeGrid.size();\n    int columnCount = orangeGrid[0].size();\n    int freshOrangeCount = 0;\n    queue<pair<int, int>> rottenQueue;\n\n    for (int row = 0; row < rowCount; ++row)\n    {\n        for (int column = 0; column < columnCount; ++column)\n        {\n            if (orangeGrid[row][column] == 1)\n                freshOrangeCount++;\n            else if (orangeGrid[row][column] == 2)\n                rottenQueue.push({row, column});\n        }\n    }\n\n    int timeElapsed = 0;\n    vector<vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    while (!rottenQueue.empty() && freshOrangeCount != 0)\n    {\n        int currentQueueSize = rottenQueue.size();\n        for (int i = 0; i < currentQueueSize; ++i)\n        {\n            auto currentRottenOrange = rottenQueue.front();\n            rottenQueue.pop();\n\n            for (int j = 0; j < directions.size(); ++j)\n            {\n                int newRow = currentRottenOrange.first + directions[j][0];\n                int newColumn = currentRottenOrange.second + directions[j][1];\n\n                if (newRow < 0 || newColumn < 0 || newRow >= rowCount || newColumn >= columnCount || orangeGrid[newRow][newColumn] != 1)\n                    continue;\n\n                orangeGrid[newRow][newColumn] = 2;\n                freshOrangeCount--;\n                rottenQueue.push({newRow, newColumn});\n            }\n        }\n        timeElapsed++;\n    }\n\n    return freshOrangeCount == 0 ? timeElapsed : -1;\n}",
    "output": "#include <bits/stdc++.h>\nint orangesRotting(std::vector<std::vector<int>> &orangeGrid)\n{\n    int rowCount= orangeGrid.size();\n    int columnCount= orangeGrid[0].size();\n    int freshOrangeCount= 0;\n    std::queue<std::pair<int, int>> rottenQueue;\n\n    for(int row= 0; row < rowCount; ++row)\n    {\n        for(int column= 0; column < columnCount; ++column)\n        {\n            if(orangeGrid[row][column] == 1)\n                freshOrangeCount++;\n            else if(orangeGrid[row][column] == 2)\n                rottenQueue.push({row, column});\n        }\n    }\n\n    int timeElapsed= 0;\n    std::vector<std::vector<int>> directions= {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    while(!rottenQueue.empty() && freshOrangeCount != 0)\n    {\n        int currentQueueSize= rottenQueue.size();\n        for(int i= 0; i < currentQueueSize; ++i)\n        {\n            auto currentRottenOrange= rottenQueue.front();\n            rottenQueue.pop();\n\n            for(auto &direction : directions)\n            {\n                int newRow= currentRottenOrange.first + direction[0];\n                int newColumn= currentRottenOrange.second + direction[1];\n\n                if(newRow < 0 || newColumn < 0 || newRow >= rowCount || newColumn >= columnCount || orangeGrid[newRow][newColumn] != 1)\n                    continue;\n\n                orangeGrid[newRow][newColumn]= 2;\n                freshOrangeCount--;\n                rottenQueue.push({newRow, newColumn});\n            }\n        }\n        timeElapsed++;\n    }\n\n    return freshOrangeCount == 0 ? timeElapsed : -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minKBitFlips(vector<int> &numArray, int k)\n{\n    int arraySize= numArray.size(), flipCount= 0, currentFlipped= 0;\n    vector<int> changeArray(arraySize, 0);\n    for(int i= 0; i <= arraySize - k; i++)\n    {\n        currentFlipped^= changeArray[i];\n        if(numArray[i] ^ currentFlipped == 0)\n        {\n            flipCount++;\n            currentFlipped^= 1;\n            if(i + k < arraySize)\n                changeArray[i + k]^= 1;\n        }\n    }\n    for(int i= arraySize - k + 1; i < arraySize; i++)\n    {\n        currentFlipped^= changeArray[i];\n        if(numArray[i] ^ currentFlipped == 0)\n            return -1;\n    }\n    return flipCount;\n}",
    "output": "#include <bits/stdc++.h>\nint minKBitFlips(std::vector<int> &numArray, int k)\n{\n    int arraySize= numArray.size(), flipCount= 0, currentFlipped= 0;\n    std::vector<int> changeArray(arraySize, 0);\n    for(int i= 0; i <= arraySize - k; i++)\n    {\n        currentFlipped^= changeArray[i];\n        if(numArray[i] ^ currentFlipped == 0)\n        {\n            flipCount++;\n            currentFlipped^= 1;\n            if(i + k < arraySize)\n                changeArray[i + k]^= 1;\n        }\n    }\n    for(int i= arraySize - k + 1; i < arraySize; i++)\n    {\n        currentFlipped^= changeArray[i];\n        if(numArray[i] ^ currentFlipped == 0)\n            return -1;\n    }\n    return flipCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isSquareful(int firstNum, int secondNum)\n{\n    int sumSquareRoot= sqrt(firstNum + secondNum);\n    return sumSquareRoot * sumSquareRoot == firstNum + secondNum;\n}\n\nvoid countPermutations(vector<int> &numList, int currentIdx, int &permCount)\n{\n    if(currentIdx == numList.size())\n    {\n        permCount++;\n        return;\n    }\n    for(int i= currentIdx; i < numList.size(); i++)\n    {\n        if(i == currentIdx || numList[i] != numList[currentIdx])\n        {\n            if(currentIdx == 0 || isSquareful(numList[currentIdx - 1], numList[i]))\n            {\n                swap(numList[i], numList[currentIdx]);\n                countPermutations(numList, currentIdx + 1, permCount);\n                swap(numList[i], numList[currentIdx]);\n            }\n        }\n    }\n}\n\nint squarefulPerms(vector<int> numList)\n{\n    int permCount= 0;\n    sort(numList.begin(), numList.end());\n    countPermutations(numList, 0, permCount);\n    return permCount;\n}",
    "output": "#include <bits/stdc++.h>\nbool isSquareful(int firstNum, int secondNum)\n{\n    int sumSquareRoot= std::sqrt(firstNum + secondNum);\n    return sumSquareRoot * sumSquareRoot == firstNum + secondNum;\n}\n\nvoid countPermutations(const std::vector<int> &numList, int currentIdx, int &permCount)\n{\n    if(currentIdx == numList.size())\n    {\n        permCount++;\n        return;\n    }\n    for(int i= currentIdx; i < numList.size(); i++)\n    {\n        if(i == currentIdx || numList[i] != numList[currentIdx])\n        {\n            if(currentIdx == 0 || isSquareful(numList[currentIdx - 1], numList[i]))\n            {\n                std::swap(numList[i], numList[currentIdx]);\n                countPermutations(numList, currentIdx + 1, permCount);\n                std::swap(numList[i], numList[currentIdx]);\n            }\n        }\n    }\n}\n\nint squarefulPerms(std::vector<int> numList)\n{\n    int permCount= 0;\n    std::sort(numList.begin(), numList.end());\n    countPermutations(numList, 0, permCount);\n    return permCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findJudge(int numberOfPeople, vector<vector<int>> &trustRelations)\n{\n    vector<int> trustCounts(numberOfPeople + 1, 0);\n    for (int i = 0; i < trustRelations.size(); ++i)\n    {\n        vector<int> &relation = trustRelations[i];\n        trustCounts[relation[0]]--;\n        trustCounts[relation[1]]++;\n    }\n\n    for (int person = 1; person <= numberOfPeople; ++person)\n    {\n        if (trustCounts[person] == numberOfPeople - 1)\n        {\n            return person;\n        }\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint findJudge(int numberOfPeople, std::vector<std::vector<int>> &trustRelations)\n{\n    std::vector<int> trustCounts(numberOfPeople + 1, 0);\n    for(std::vector<int> &relation : trustRelations)\n    {\n        trustCounts[relation[0]]--;\n        trustCounts[relation[1]]++;\n    }\n\n    for(int person= 1; person <= numberOfPeople; ++person)\n    {\n        if(trustCounts[person] == numberOfPeople - 1)\n        {\n            return person;\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "TreeNode *insertIntoMaxTree(TreeNode *currentRoot, int newValue)\n{\n    if(!currentRoot || newValue > currentRoot->val)\n    {\n        TreeNode *newNode= new TreeNode(newValue);\n        newNode->left= currentRoot;\n        return newNode;\n    }\n    currentRoot->right= insertIntoMaxTree(currentRoot->right, newValue);\n    return currentRoot;\n}",
    "output": "TreeNode *insertIntoMaxTree(TreeNode *currentRoot, int newValue)\n{\n    if(!currentRoot || newValue > currentRoot->val)\n    {\n        TreeNode *newNode= new TreeNode(newValue);\n        newNode->left= currentRoot;\n        return newNode;\n    }\n    currentRoot->right= insertIntoMaxTree(currentRoot->right, newValue);\n    return currentRoot;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numRookCaptures(vector<string> &chessBoard)\n{\n    int rookPositionX = 0, rookPositionY = 0, totalCaptures = 0;\n    for (rookPositionX = 0; rookPositionX < 8; ++rookPositionX)\n    {\n        for (rookPositionY = 0; rookPositionY < 8; ++rookPositionY)\n        {\n            if (chessBoard[rookPositionX][rookPositionY] == 'R')\n            {\n                break;\n            }\n        }\n        if (rookPositionY < 8)\n            break;\n    }\n\n    vector<pair<int, int>> directionVectors = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    for (int i = 0; i < directionVectors.size(); ++i)\n    {\n        auto &direction = directionVectors[i];\n        int nextX = rookPositionX + direction.first;\n        int nextY = rookPositionY + direction.second;\n        while (nextX >= 0 && nextX < 8 && nextY >= 0 && nextY < 8)\n        {\n            if (chessBoard[nextX][nextY] == 'p')\n            {\n                totalCaptures++;\n                break;\n            }\n            else if (chessBoard[nextX][nextY] == 'B')\n            {\n                break;\n            }\n            nextX += direction.first;\n            nextY += direction.second;\n        }\n    }\n\n    return totalCaptures;\n}",
    "output": "#include <bits/stdc++.h>\nint numRookCaptures(std::vector<std::string> &chessBoard)\n{\n    int rookPositionX= 0, rookPositionY= 0, totalCaptures= 0;\n    for(rookPositionX= 0; rookPositionX < 8; ++rookPositionX)\n    {\n        for(rookPositionY= 0; rookPositionY < 8; ++rookPositionY)\n        {\n            if(chessBoard[rookPositionX][rookPositionY] == 'R')\n            {\n                break;\n            }\n        }\n        if(rookPositionY < 8)\n            break;\n    }\n\n    std::vector<std::pair<int, int>> directionVectors= {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    for(auto &direction : directionVectors)\n    {\n        int nextX= rookPositionX + direction.first;\n        int nextY= rookPositionY + direction.second;\n        while(nextX >= 0 && nextX < 8 && nextY >= 0 && nextY < 8)\n        {\n            if(chessBoard[nextX][nextY] == 'p')\n            {\n                totalCaptures++;\n                break;\n            }\n            else if(chessBoard[nextX][nextY] == 'B')\n            {\n                break;\n            }\n            nextX+= direction.first;\n            nextY+= direction.second;\n        }\n    }\n\n    return totalCaptures;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint mergeStones(vector<int> &stonePiles, int groupSize)\n{\n    int totalStones= stonePiles.size();\n    if((totalStones - 1) % (groupSize - 1) != 0)\n        return -1;\n    vector<int> prefixSum(totalStones + 1, 0);\n    vector<vector<vector<int>>> dynamicProgramming(totalStones, vector<vector<int>>(totalStones, vector<int>(groupSize + 1, 0)));\n\n    for(int index= 0; index < totalStones; ++index)\n    {\n        prefixSum[index + 1]= prefixSum[index] + stonePiles[index];\n    }\n\n    for(int length= 2; length <= totalStones; ++length)\n    {\n        for(int startIndex= 0; startIndex <= totalStones - length; ++startIndex)\n        {\n            int endIndex= startIndex + length - 1;\n            for(int mergeCount= 2; mergeCount <= groupSize; ++mergeCount)\n            {\n                for(int position= startIndex; position + mergeCount <= endIndex + 1; position+= groupSize - 1)\n                {\n                    dynamicProgramming[startIndex][endIndex][mergeCount]= (dynamicProgramming[startIndex][position][1] + dynamicProgramming[position + 1][endIndex][mergeCount - 1]) % (1e9 + 7);\n                }\n            }\n            if((endIndex - startIndex) % (groupSize - 1) == 0)\n            {\n                dynamicProgramming[startIndex][endIndex][1]= (dynamicProgramming[startIndex][endIndex][groupSize] + prefixSum[endIndex + 1] - prefixSum[startIndex]) % (1e9 + 7);\n            }\n        }\n    }\n    return dynamicProgramming[0][totalStones - 1][1];\n}",
    "output": "#include <bits/stdc++.h>\nint mergeStones(std::vector<int> &stonePiles, int groupSize)\n{\n    int totalStones= stonePiles.size();\n    if((totalStones - 1) % (groupSize - 1) != 0)\n        return -1;\n    std::vector<int> prefixSum(totalStones + 1, 0);\n    std::vector<std::vector<std::vector<int>>> dynamicProgramming(totalStones, std::vector<std::vector<int>>(totalStones, std::vector<int>(groupSize + 1, 0)));\n\n    for(int index= 0; index < totalStones; ++index)\n    {\n        prefixSum[index + 1]= prefixSum[index] + stonePiles[index];\n    }\n\n    for(int length= 2; length <= totalStones; ++length)\n    {\n        for(int startIndex= 0; startIndex <= totalStones - length; ++startIndex)\n        {\n            int endIndex= startIndex + length - 1;\n            for(int mergeCount= 2; mergeCount <= groupSize; ++mergeCount)\n            {\n                for(int position= startIndex; position + mergeCount <= endIndex + 1; position+= groupSize - 1)\n                {\n                    dynamicProgramming[startIndex][endIndex][mergeCount]= (dynamicProgramming[startIndex][position][1] + dynamicProgramming[position + 1][endIndex][mergeCount - 1]) % (1e9 + 7);\n                }\n            }\n            if((endIndex - startIndex) % (groupSize - 1) == 0)\n            {\n                dynamicProgramming[startIndex][endIndex][1]= (dynamicProgramming[startIndex][endIndex][groupSize] + prefixSum[endIndex + 1] - prefixSum[startIndex]) % (1e9 + 7);\n            }\n        }\n    }\n    return dynamicProgramming[0][totalStones - 1][1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> gridIllumination(int gridSize, vector<vector<int>> &lampPositions, vector<vector<int>> &queryPositions)\n{\n    unordered_set<int> activeLampColumns, activeLampRows, activeLampLeftDiagonals, activeLampRightDiagonals;\n    vector<int> illuminationResults;\n\n    for(int i = 0; i < lampPositions.size(); ++i)\n    {\n        auto &lamp = lampPositions[i];\n        int lampRow = lamp[0];\n        int lampCol = lamp[1];\n        activeLampRows.insert(lampRow);\n        activeLampColumns.insert(lampCol);\n        activeLampLeftDiagonals.insert(lampRow - lampCol);\n        activeLampRightDiagonals.insert(lampRow + lampCol);\n    }\n\n    for(int i = 0; i < queryPositions.size(); ++i)\n    {\n        auto &query = queryPositions[i];\n        int queryRow = query[0];\n        int queryCol = query[1];\n        if(activeLampRows.count(queryRow) || activeLampColumns.count(queryCol) || activeLampLeftDiagonals.count(queryRow - queryCol) || activeLampRightDiagonals.count(queryRow + queryCol))\n        {\n            illuminationResults.push_back(1);\n        }\n        else\n        {\n            illuminationResults.push_back(0);\n        }\n        for(int rowOffset = -1; rowOffset <= 1; rowOffset++)\n        {\n            for(int colOffset = -1; colOffset <= 1; colOffset++)\n            {\n                int newLampRow = queryRow + rowOffset;\n                int newLampCol = queryCol + colOffset;\n                activeLampRows.erase(newLampRow);\n                activeLampColumns.erase(newLampCol);\n                activeLampLeftDiagonals.erase(newLampRow - newLampCol);\n                activeLampRightDiagonals.erase(newLampRow + newLampCol);\n            }\n        }\n    }\n    return illuminationResults;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> gridIllumination(int gridSize, std::vector<std::vector<int>> &lampPositions, std::vector<std::vector<int>> &queryPositions)\n{\n    std::unordered_set<int> activeLampColumns, activeLampRows, activeLampLeftDiagonals, activeLampRightDiagonals;\n    std::vector<int> illuminationResults;\n\n    for(auto &lamp : lampPositions)\n    {\n        int lampRow = lamp[0];\n        int lampCol = lamp[1];\n        activeLampRows.insert(lampRow);\n        activeLampColumns.insert(lampCol);\n        activeLampLeftDiagonals.insert(lampRow - lampCol);\n        activeLampRightDiagonals.insert(lampRow + lampCol);\n    }\n\n    for(auto &query : queryPositions)\n    {\n        int queryRow = query[0];\n        int queryCol = query[1];\n        if(activeLampRows.count(queryRow) || activeLampColumns.count(queryCol) || activeLampLeftDiagonals.count(queryRow - queryCol) || activeLampRightDiagonals.count(queryRow + queryCol))\n        {\n            illuminationResults.push_back(1);\n        }\n        else\n        {\n            illuminationResults.push_back(0);\n        }\n        for(int rowOffset = -1; rowOffset <= 1; rowOffset++)\n        {\n            for(int colOffset = -1; colOffset <= 1; colOffset++)\n            {\n                int newLampRow = queryRow + rowOffset;\n                int newLampCol = queryCol + colOffset;\n                activeLampRows.erase(newLampRow);\n                activeLampColumns.erase(newLampCol);\n                activeLampLeftDiagonals.erase(newLampRow - newLampCol);\n                activeLampRightDiagonals.erase(newLampRow + newLampCol);\n            }\n        }\n    }\n    return illuminationResults;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<char> commonCharacters(vector<string> &inputWords)\n{\n    unordered_map<char, int> characterCountMap;\n    for (int i = 0; i < inputWords.size(); ++i)\n    {\n        const auto &currentWord = inputWords[i];\n        unordered_map<char, int> wordCharacterCount;\n        for (int j = 0; j < currentWord.size(); ++j)\n        {\n            char currentChar = currentWord[j];\n            ++wordCharacterCount[currentChar];\n        }\n        if (characterCountMap.empty())\n        {\n            characterCountMap = wordCharacterCount;\n        }\n        else\n        {\n            for (auto &characterEntry : characterCountMap)\n            {\n                characterEntry.second = min(characterEntry.second, wordCharacterCount[characterEntry.first]);\n            }\n        }\n    }\n\n    vector<char> commonCharacterList;\n    for (const auto &characterEntry : characterCountMap)\n    {\n        for (int i = 0; i < characterEntry.second; ++i)\n        {\n            commonCharacterList.push_back(characterEntry.first);\n        }\n    }\n    return commonCharacterList;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<char> commonCharacters(std::vector<std::string> &inputWords)\n{\n    std::unordered_map<char, int> characterCountMap;\n    for(const auto &currentWord : inputWords)\n    {\n        std::unordered_map<char, int> wordCharacterCount;\n        for(char currentChar : currentWord)\n        {\n            ++wordCharacterCount[currentChar];\n        }\n        if(characterCountMap.empty())\n        {\n            characterCountMap= wordCharacterCount;\n        }\n        else\n        {\n            for(auto &characterEntry : characterCountMap)\n            {\n                characterEntry.second= std::min(characterEntry.second, wordCharacterCount[characterEntry.first]);\n            }\n        }\n    }\n\n    std::vector<char> commonCharacterList;\n    for(const auto &characterEntry : characterCountMap)\n    {\n        for(int i= 0; i < characterEntry.second; ++i)\n        {\n            commonCharacterList.push_back(characterEntry.first);\n        }\n    }\n    return commonCharacterList;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findLongestOnes(vector<int> &binaryArray, int maxAllowedZeros)\n{\n    int leftPointer= 0, rightPointer= 0, maxOnesCount= 0, zeroCount= 0;\n    while(rightPointer < binaryArray.size())\n    {\n        if(binaryArray[rightPointer] == 0)\n            zeroCount++;\n        while(zeroCount > maxAllowedZeros)\n        {\n            if(binaryArray[leftPointer] == 0)\n                zeroCount--;\n            leftPointer++;\n        }\n        maxOnesCount= max(maxOnesCount, rightPointer - leftPointer + 1);\n        rightPointer++;\n    }\n    return maxOnesCount;\n}",
    "output": "#include <bits/stdc++.h>\nint findLongestOnes(std::vector<int> &binaryArray, int maxAllowedZeros)\n{\n    int leftPointer= 0, rightPointer= 0, maxOnesCount= 0, zeroCount= 0;\n    while(rightPointer < binaryArray.size())\n    {\n        if(binaryArray[rightPointer] == 0)\n            zeroCount++;\n        while(zeroCount > maxAllowedZeros)\n        {\n            if(binaryArray[leftPointer] == 0)\n                zeroCount--;\n            leftPointer++;\n        }\n        maxOnesCount= std::max(maxOnesCount, rightPointer - leftPointer + 1);\n        rightPointer++;\n    }\n    return maxOnesCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumAfterKOperations(vector<int> &numbers, int operations)\n{\n    priority_queue<int, vector<int>, greater<int>> minHeap(numbers.begin(), numbers.end());\n    while(operations--)\n    {\n        int currentMinimum= minHeap.top();\n        minHeap.pop();\n        minHeap.push(-currentMinimum);\n    }\n    return accumulate(numbers.begin(), numbers.end(), 0);\n}",
    "output": "#include <bits/stdc++.h>\nint maxSumAfterKOperations(std::vector<int> &numbers, int operations)\n{\n    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap(numbers.begin(), numbers.end());\n    while(operations--)\n    {\n        int currentMinimum= minHeap.top();\n        minHeap.pop();\n        minHeap.push(-currentMinimum);\n    }\n    return std::accumulate(numbers.begin(), numbers.end(), 0);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int calculateClumsy(int inputNumber)\n{\n    if(inputNumber <= 2)\n    {\n        return inputNumber;\n    }\n    if(inputNumber == 3)\n    {\n        return 6;\n    }\n    int clumsyResult= inputNumber * (inputNumber - 1) / (inputNumber - 2) + (inputNumber - 3);\n    inputNumber-= 4;\n    while(inputNumber >= 4)\n    {\n        clumsyResult= clumsyResult - (inputNumber * (inputNumber - 1) / (inputNumber - 2)) + (inputNumber - 3);\n        inputNumber-= 4;\n    }\n    return clumsyResult - calculateClumsy(inputNumber);\n}",
    "output": "int calculateClumsy(int inputNumber)\n{\n    if(inputNumber <= 2)\n    {\n        return inputNumber;\n    }\n    if(inputNumber == 3)\n    {\n        return 6;\n    }\n    int clumsyResult= inputNumber * (inputNumber - 1) / (inputNumber - 2) + (inputNumber - 3);\n    inputNumber-= 4;\n    while(inputNumber >= 4)\n    {\n        clumsyResult= clumsyResult - (inputNumber * (inputNumber - 1) / (inputNumber - 2)) + (inputNumber - 3);\n        inputNumber-= 4;\n    }\n    return clumsyResult - calculateClumsy(inputNumber);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minRotations(vector<int> &topRow, vector<int> &bottomRow)\n{\n    int minimumRotations = INT_MAX;\n\n    for (int targetValue : {topRow[0], bottomRow[0]})\n    {\n        int topRotations = 0, bottomRotations = 0;\n        for (int index = 0; index < topRow.size(); ++index)\n        {\n            if (topRow[index] != targetValue && bottomRow[index] != targetValue)\n            {\n                topRotations = bottomRotations = INT_MAX;\n                break;\n            }\n            topRotations += topRow[index] != targetValue;\n            bottomRotations += bottomRow[index] != targetValue;\n        }\n        minimumRotations = min({minimumRotations, topRotations, bottomRotations});\n    }\n\n    return minimumRotations == INT_MAX ? -1 : minimumRotations;\n}",
    "output": "#include <bits/stdc++.h>\nint minRotations(std::vector<int> &topRow, std::vector<int> &bottomRow)\n{\n    int minimumRotations= INT_MAX;\n\n    for(int targetValue : {topRow[0], bottomRow[0]})\n    {\n        int topRotations= 0, bottomRotations= 0;\n        for(int index= 0; index < topRow.size(); ++index)\n        {\n            if(topRow[index] != targetValue && bottomRow[index] != targetValue)\n            {\n                topRotations= bottomRotations= INT_MAX;\n                break;\n            }\n            topRotations+= topRow[index] != targetValue;\n            bottomRotations+= bottomRow[index] != targetValue;\n        }\n        minimumRotations= std::min({minimumRotations, topRotations, bottomRotations});\n    }\n\n    return minimumRotations == INT_MAX ? -1 : minimumRotations;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint heightChecker(vector<int> &heightList)\n{\n    vector<int> expectedHeights = heightList;\n    sort(expectedHeights.begin(), expectedHeights.end());\n\n    int mismatchCount = 0;\n    for(int index = 0; index < heightList.size(); ++index)\n    {\n        if(heightList[index] != expectedHeights[index])\n        {\n            ++mismatchCount;\n        }\n    }\n\n    return mismatchCount;\n}",
    "output": "#include <bits/stdc++.h>\nint heightChecker(std::vector<int> &heightList)\n{\n    std::vector<int> expectedHeights= heightList;\n    std::sort(expectedHeights.begin(), expectedHeights.end());\n\n    int mismatchCount= 0;\n    for(int index= 0; index < heightList.size(); ++index)\n    {\n        if(heightList[index] != expectedHeights[index])\n        {\n            ++mismatchCount;\n        }\n    }\n\n    return mismatchCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSatisfied(vector<int> &customerCounts, vector<int> &grumpyStatus, int timeWindow)\n{\n    int totalCustomers= 0, maxExtraCustomers= 0, extraCustomers= 0;\n    for(int i= 0; i < customerCounts.size(); ++i)\n    {\n        if(grumpyStatus[i] == 0)\n        {\n            totalCustomers+= customerCounts[i];\n        }\n        if(i < timeWindow)\n        {\n            extraCustomers+= customerCounts[i] * grumpyStatus[i];\n        }\n        else\n        {\n            extraCustomers+= (customerCounts[i] * grumpyStatus[i]) - (customerCounts[i - timeWindow] * grumpyStatus[i - timeWindow]);\n        }\n        maxExtraCustomers= max(maxExtraCustomers, extraCustomers);\n    }\n    return totalCustomers + maxExtraCustomers;\n}",
    "output": "#include <bits/stdc++.h>\nint maxSatisfied(std::vector<int> &customerCounts, std::vector<int> &grumpyStatus, int timeWindow)\n{\n    int totalCustomers= 0, maxExtraCustomers= 0, extraCustomers= 0;\n    for(int i= 0; i < customerCounts.size(); ++i)\n    {\n        if(grumpyStatus[i] == 0)\n        {\n            totalCustomers+= customerCounts[i];\n        }\n        if(i < timeWindow)\n        {\n            extraCustomers+= customerCounts[i] * grumpyStatus[i];\n        }\n        else\n        {\n            extraCustomers+= (customerCounts[i] * grumpyStatus[i]) - (customerCounts[i - timeWindow] * grumpyStatus[i - timeWindow]);\n        }\n        maxExtraCustomers= std::max(maxExtraCustomers, extraCustomers);\n    }\n    return totalCustomers + maxExtraCustomers;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> prevPermOpt1(vector<int> &permutationArray)\n{\n    int arraySize= permutationArray.size();\n    for(int currentIndex= arraySize - 2; currentIndex >= 0; currentIndex--)\n    {\n        if(permutationArray[currentIndex] > permutationArray[currentIndex + 1])\n        {\n            int nextIndex= currentIndex + 1;\n            while(nextIndex < arraySize && permutationArray[nextIndex] < permutationArray[currentIndex])\n                nextIndex++;\n            swap(permutationArray[currentIndex], permutationArray[nextIndex - 1]);\n            break;\n        }\n    }\n    return permutationArray;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> prevPermOpt1(std::vector<int> &permutationArray)\n{\n    int arraySize= permutationArray.size();\n    for(int currentIndex= arraySize - 2; currentIndex >= 0; currentIndex--)\n    {\n        if(permutationArray[currentIndex] > permutationArray[currentIndex + 1])\n        {\n            int nextIndex= currentIndex + 1;\n            while(nextIndex < arraySize && permutationArray[nextIndex] < permutationArray[currentIndex])\n                nextIndex++;\n            std::swap(permutationArray[currentIndex], permutationArray[nextIndex - 1]);\n            break;\n        }\n    }\n    return permutationArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int bitwiseComplement(int number)\n{\n    int mask= 1;\n    while(number > mask)\n    {\n        mask= mask * 2 + 1;\n    }\n    return mask - number;\n}",
    "output": "int bitwiseComplement(int number)\n{\n    int mask= 1;\n    while(number > mask)\n    {\n        mask= mask * 2 + 1;\n    }\n    return mask - number;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numPairsDivisibleBy60(vector<int> &songDurations)\n{\n    int durationCount[60] = {0};\n    int totalPairs = 0;\n\n    for (int i = 0; i < songDurations.size(); ++i)\n    {\n        int songDuration = songDurations[i];\n        int remainder = songDuration % 60;\n        totalPairs += durationCount[(60 - remainder) % 60];\n        durationCount[remainder]++;\n    }\n\n    return totalPairs;\n}",
    "output": "#include <bits/stdc++.h>\nint numPairsDivisibleBy60(std::vector<int> &songDurations)\n{\n    int durationCount[60]= {0};\n    int totalPairs= 0;\n\n    for(int songDuration : songDurations)\n    {\n        int remainder= songDuration % 60;\n        totalPairs+= durationCount[(60 - remainder) % 60];\n        durationCount[remainder]++;\n    }\n\n    return totalPairs;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint shipWithinDays(vector<int> &weightArray, int totalDays)\n{\n    int minimumCapacity = *max_element(weightArray.begin(), weightArray.end());\n    int maximumCapacity = accumulate(weightArray.begin(), weightArray.end(), 0);\n    while (minimumCapacity < maximumCapacity)\n    {\n        int midCapacity = minimumCapacity + (maximumCapacity - minimumCapacity) / 2;\n        int dayCount = 1, currentCapacity = 0;\n        for (int i = 0; i < weightArray.size(); ++i)\n        {\n            int weight = weightArray[i];\n            currentCapacity += weight;\n            if (currentCapacity > midCapacity)\n            {\n                dayCount++;\n                currentCapacity = weight;\n            }\n        }\n        if (dayCount > totalDays)\n        {\n            minimumCapacity = midCapacity + 1;\n        }\n        else\n        {\n            maximumCapacity = midCapacity;\n        }\n    }\n    return minimumCapacity;\n}",
    "output": "#include <bits/stdc++.h>\nint shipWithinDays(std::vector<int> &weightArray, int totalDays)\n{\n    int minimumCapacity= *max_element(weightArray.begin(), weightArray.end());\n    int maximumCapacity= accumulate(weightArray.begin(), weightArray.end(), 0);\n    while(minimumCapacity < maximumCapacity)\n    {\n        int midCapacity= minimumCapacity + (maximumCapacity - minimumCapacity) / 2;\n        int dayCount= 1, currentCapacity= 0;\n        for(int weight : weightArray)\n        {\n            currentCapacity+= weight;\n            if(currentCapacity > midCapacity)\n            {\n                dayCount++;\n                currentCapacity= weight;\n            }\n        }\n        if(dayCount > totalDays)\n        {\n            minimumCapacity= midCapacity + 1;\n        }\n        else\n        {\n            maximumCapacity= midCapacity;\n        }\n    }\n    return minimumCapacity;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numDupDigitsAtMostN(int maxNumber)\n{\n    int duplicateCount= 0;\n    for(int currentNumber= 1; currentNumber <= maxNumber; currentNumber++)\n    {\n        set<int> uniqueDigits;\n        int number= currentNumber;\n        while(number != 0)\n        {\n            int digit= number % 10;\n            if(uniqueDigits.count(digit))\n            {\n                duplicateCount++;\n                break;\n            }\n            else\n            {\n                uniqueDigits.insert(digit);\n            }\n            number/= 10;\n        }\n    }\n    return duplicateCount;\n}",
    "output": "#include <bits/stdc++.h>\nint numDupDigitsAtMostN(int maxNumber)\n{\n    int duplicateCount = 0;\n    for(int currentNumber = 1; currentNumber <= maxNumber; currentNumber++)\n    {\n        std::set<int> uniqueDigits;\n        int number = currentNumber;\n        while(number != 0)\n        {\n            int digit = number % 10;\n            if(uniqueDigits.count(digit))\n            {\n                duplicateCount++;\n                break;\n            }\n            else\n            {\n                uniqueDigits.insert(digit);\n            }\n            number /= 10;\n        }\n    }\n    return duplicateCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring findRoundingError(vector<string> &priceStrings, int targetAmount)\n{\n    int numberOfPrices= priceStrings.size();\n    vector<double> decimalParts(numberOfPrices);\n    int roundedSum= 0;\n    double errorSum= 0.0;\n\n    for(int i= 0; i < numberOfPrices; ++i)\n    {\n        double priceValue= stod(priceStrings[i]);\n        decimalParts[i]= priceValue - floor(priceValue);\n        roundedSum+= floor(priceValue);\n        errorSum+= decimalParts[i];\n    }\n\n    if(targetAmount < roundedSum || targetAmount > roundedSum + numberOfPrices)\n    {\n        return \"-1 \";\n    }\n\n    int ceilCount= targetAmount - roundedSum;\n    double roundingError= 0.0;\n\n    for(int i= 0; i < numberOfPrices; ++i)\n    {\n        if(ceilCount > 0)\n        {\n            roundingError+= 1 - decimalParts[i];\n            --ceilCount;\n        }\n        else\n        {\n            roundingError+= decimalParts[i];\n        }\n    }\n\n    return to_string(roundingError).substr(0, 5) + \" \";\n}",
    "output": "#include <bits/stdc++.h>\nstd::string findRoundingError(std::vector<std::string> &priceStrings, int targetAmount)\n{\n    int numberOfPrices = priceStrings.size();\n    std::vector<double> decimalParts(numberOfPrices);\n    int roundedSum = 0;\n    double errorSum = 0.0;\n\n    for(int i = 0; i < numberOfPrices; ++i)\n    {\n        double priceValue = std::stod(priceStrings[i]);\n        decimalParts[i] = priceValue - std::floor(priceValue);\n        roundedSum += std::floor(priceValue);\n        errorSum += decimalParts[i];\n    }\n\n    if(targetAmount < roundedSum || targetAmount > roundedSum + numberOfPrices)\n    {\n        return \"-1 \";\n    }\n\n    int ceilCount = targetAmount - roundedSum;\n    double roundingError = 0.0;\n\n    for(int i = 0; i < numberOfPrices; ++i)\n    {\n        if(ceilCount > 0)\n        {\n            roundingError += 1 - decimalParts[i];\n            --ceilCount;\n        }\n        else\n        {\n            roundingError += decimalParts[i];\n        }\n    }\n\n    return std::to_string(roundingError).substr(0, 5) + \" \";\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool depthFirstSearch(int currentNode, const unordered_map<int, vector<int>> &graph, vector<int> &visitedNodes, int destinationNode)\n{\n    if(graph.find(currentNode) == graph.end())\n        return currentNode == destinationNode;\n    if(visitedNodes[currentNode] != 0)\n        return visitedNodes[currentNode] == 2;\n\n    visitedNodes[currentNode] = 1;\n    for(int i = 0; i < graph.at(currentNode).size(); ++i)\n    {\n        int neighbor = graph.at(currentNode)[i];\n        if(!depthFirstSearch(neighbor, graph, visitedNodes, destinationNode))\n            return false;\n    }\n\n    visitedNodes[currentNode] = 2;\n    return true;\n}\n\nbool leadsToDestination(int nodeCount, const vector<vector<int>> &edgeList, int sourceNode, int destinationNode)\n{\n    unordered_map<int, vector<int>> graph;\n    for(int i = 0; i < edgeList.size(); ++i)\n    {\n        graph[edgeList[i][0]].push_back(edgeList[i][1]);\n    }\n\n    vector<int> visitedNodes(nodeCount, 0);\n    return depthFirstSearch(sourceNode, graph, visitedNodes, destinationNode);\n}",
    "output": "#include <bits/stdc++.h>\nbool depthFirstSearch(int currentNode, const std::unordered_map<int, std::vector<int>> &graph, std::vector<int> &visitedNodes, int destinationNode)\n{\n    if(graph.find(currentNode) == graph.end())\n        return currentNode == destinationNode;\n    if(visitedNodes[currentNode] != 0)\n        return visitedNodes[currentNode] == 2;\n\n    visitedNodes[currentNode]= 1;\n    for(int neighbor : graph.at(currentNode))\n    {\n        if(!depthFirstSearch(neighbor, graph, visitedNodes, destinationNode))\n            return false;\n    }\n\n    visitedNodes[currentNode]= 2;\n    return true;\n}\n\nbool leadsToDestination(int nodeCount, const std::vector<std::vector<int>> &edgeList, int sourceNode, int destinationNode)\n{\n    std::unordered_map<int, std::vector<int>> graph;\n    for(const auto &edge : edgeList)\n    {\n        graph[edge[0]].push_back(edge[1]);\n    }\n\n    std::vector<int> visitedNodes(nodeCount, 0);\n    return depthFirstSearch(sourceNode, graph, visitedNodes, destinationNode);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findKthPositive(vector<int> &numbers, int k)\n{\n    int leftIndex= 0, rightIndex= numbers.size();\n    while(leftIndex < rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(numbers[midIndex] - midIndex - 1 < k)\n        {\n            leftIndex= midIndex + 1;\n        }\n        else\n        {\n            rightIndex= midIndex;\n        }\n    }\n    return leftIndex + k;\n}",
    "output": "#include <bits/stdc++.h>\nint findKthPositive(std::vector<int> &numbers, int k)\n{\n    int leftIndex= 0, rightIndex= numbers.size();\n    while(leftIndex < rightIndex)\n    {\n        int midIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(numbers[midIndex] - midIndex - 1 < k)\n        {\n            leftIndex= midIndex + 1;\n        }\n        else\n        {\n            rightIndex= midIndex;\n        }\n    }\n    return leftIndex + k;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring lexSmallestEquivalent(string firstString, string secondString, string baseString)\n{\n    map<char, char> characterParent;\n    for(char character= 'a'; character <= 'z'; character++)\n    {\n        characterParent[character]= character;\n    }\n\n    for(int index= 0; index < firstString.size(); index++)\n    {\n        char rootFirst= firstString[index], rootSecond= secondString[index];\n        while(characterParent[rootFirst] != rootFirst)\n            rootFirst= characterParent[rootFirst];\n        while(characterParent[rootSecond] != rootSecond)\n            rootSecond= characterParent[rootSecond];\n        if(rootFirst != rootSecond)\n        {\n            characterParent[rootFirst]= min(rootFirst, rootSecond);\n            characterParent[rootSecond]= min(rootFirst, rootSecond);\n        }\n    }\n\n    for(int index= 0; index < baseString.size(); index++)\n    {\n        char currentCharacter= baseString[index];\n        while(characterParent[currentCharacter] != currentCharacter)\n            currentCharacter= characterParent[currentCharacter];\n        baseString[index]= currentCharacter;\n    }\n\n    return baseString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string lexSmallestEquivalent(std::string firstString, std::string secondString, std::string baseString)\n{\n    std::map<char, char> characterParent;\n    for(char character= 'a'; character <= 'z'; character++)\n    {\n        characterParent[character]= character;\n    }\n\n    for(int index= 0; index < firstString.size(); index++)\n    {\n        char rootFirst= firstString[index], rootSecond= secondString[index];\n        while(characterParent[rootFirst] != rootFirst)\n            rootFirst= characterParent[rootFirst];\n        while(characterParent[rootSecond] != rootSecond)\n            rootSecond= characterParent[rootSecond];\n        if(rootFirst != rootSecond)\n        {\n            characterParent[rootFirst]= std::min(rootFirst, rootSecond);\n            characterParent[rootSecond]= std::min(rootFirst, rootSecond);\n        }\n    }\n\n    for(int index= 0; index < baseString.size(); index++)\n    {\n        char currentCharacter= baseString[index];\n        while(characterParent[currentCharacter] != currentCharacter)\n            currentCharacter= characterParent[currentCharacter];\n        baseString[index]= currentCharacter;\n    }\n\n    return baseString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findLongestRepeatingSubstring(const string &inputString)\n{\n    int stringLength = inputString.length();\n    int longestSubstringLength = 0;\n    for (int substringLength = 1; substringLength <= stringLength / 2; ++substringLength)\n    {\n        int maxRepeatCount = 0, currentRepeatCount = 0;\n        for (int index = 0; index < stringLength - substringLength; ++index)\n        {\n            if (inputString.substr(index, substringLength) == inputString.substr(index + substringLength, substringLength))\n            {\n                currentRepeatCount++;\n            }\n            else\n            {\n                maxRepeatCount = max(maxRepeatCount, currentRepeatCount);\n                currentRepeatCount = 0;\n            }\n        }\n        longestSubstringLength = max(longestSubstringLength, maxRepeatCount * substringLength);\n    }\n    return longestSubstringLength;\n}",
    "output": "int findLongestRepeatingSubstring(const std::string &inputString)\n{\n    int stringLength= inputString.length();\n    int longestSubstringLength= 0;\n    for(int substringLength= 1; substringLength <= stringLength / 2; ++substringLength)\n    {\n        int maxRepeatCount= 0, currentRepeatCount= 0;\n        for(int index= 0; index < stringLength - substringLength; ++index)\n        {\n            if(inputString.substr(index, substringLength) == inputString.substr(index + substringLength, substringLength))\n            {\n                currentRepeatCount++;\n            }\n            else\n            {\n                maxRepeatCount= std::max(maxRepeatCount, currentRepeatCount);\n                currentRepeatCount= 0;\n            }\n        }\n        longestSubstringLength= std::max(longestSubstringLength, maxRepeatCount * substringLength);\n    }\n    return longestSubstringLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScoreSightseeingPair(vector<int> &sightseeingValues)\n{\n    int maxScore= 0, maxScoreLeft= sightseeingValues[0] + 0;\n    for(int index= 1; index < sightseeingValues.size(); ++index)\n    {\n        maxScore= max(maxScore, maxScoreLeft + sightseeingValues[index] - index);\n        maxScoreLeft= max(maxScoreLeft, sightseeingValues[index] + index);\n    }\n    return maxScore;\n}",
    "output": "#include <bits/stdc++.h>\nint maxScoreSightseeingPair(std::vector<int> &sightseeingValues)\n{\n    int maxScore= 0, maxScoreLeft= sightseeingValues[0] + 0;\n    for(int index= 1; index < sightseeingValues.size(); ++index)\n    {\n        maxScore= std::max(maxScore, maxScoreLeft + sightseeingValues[index] - index);\n        maxScoreLeft= std::max(maxScoreLeft, sightseeingValues[index] + index);\n    }\n    return maxScore;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findFixedPoint(vector<int> &sortedArray)\n{\n    int leftIndex= 0, rightIndex= sortedArray.size() - 1;\n    while(leftIndex < rightIndex)\n    {\n        int middleIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(sortedArray[middleIndex] < middleIndex)\n        {\n            leftIndex= middleIndex + 1;\n        }\n        else\n        {\n            rightIndex= middleIndex;\n        }\n    }\n    return sortedArray[leftIndex] == leftIndex ? leftIndex : -1;\n}",
    "output": "#include <bits/stdc++.h>\nint findFixedPoint(std::vector<int> &sortedArray)\n{\n    int leftIndex= 0, rightIndex= sortedArray.size() - 1;\n    while(leftIndex < rightIndex)\n    {\n        int middleIndex= leftIndex + (rightIndex - leftIndex) / 2;\n        if(sortedArray[middleIndex] < middleIndex)\n        {\n            leftIndex= middleIndex + 1;\n        }\n        else\n        {\n            rightIndex= middleIndex;\n        }\n    }\n    return sortedArray[leftIndex] == leftIndex ? leftIndex : -1;\n}\n"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool hasAllCodesInRange(const string &inputString, int totalCodes)\n{\n    unordered_set<string> uniqueSubstrings;\n    int codeLength = to_string(totalCodes).length();\n    for(int index = 0; index < inputString.length() - codeLength + 1; ++index)\n    {\n        uniqueSubstrings.insert(inputString.substr(index, codeLength));\n    }\n    return uniqueSubstrings.size() == totalCodes;\n}",
    "output": "bool hasAllCodesInRange(const std::string &inputString, int totalCodes)\n{\n    std::unordered_set<std::string> uniqueSubstrings;\n    int codeLength= std::to_string(totalCodes).length();\n    for(int index= 0; index < inputString.length() - codeLength + 1; ++index)\n    {\n        uniqueSubstrings.insert(inputString.substr(index, codeLength));\n    }\n    return uniqueSubstrings.size() == totalCodes;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateManhattanDistance(vector<int> &worker, vector<int> &bike)\n{\n    return abs(worker[0] - bike[0]) + abs(worker[1] - bike[1]);\n}\n\nvoid depthFirstSearch(vector<vector<int>> &workers, vector<vector<int>> &bikes, vector<bool> &usedBikes, int workerIndex, int currentDistance, int &minimumDistance)\n{\n    if(workerIndex == workers.size())\n    {\n        minimumDistance= min(minimumDistance, currentDistance);\n        return;\n    }\n\n    if(currentDistance >= minimumDistance)\n    {\n        return;\n    }\n\n    for(int i= 0; i < bikes.size(); i++)\n    {\n        if(usedBikes[i])\n        {\n            continue;\n        }\n        usedBikes[i]= true;\n        int distanceToCurrentBike= calculateManhattanDistance(workers[workerIndex], bikes[i]);\n        depthFirstSearch(workers, bikes, usedBikes, workerIndex + 1, currentDistance + distanceToCurrentBike, minimumDistance);\n        usedBikes[i]= false;\n    }\n}\n\nint assignBikes(vector<vector<int>> &workers, vector<vector<int>> &bikes)\n{\n    int minimumDistance= INT_MAX;\n    vector<bool> usedBikes(bikes.size(), false);\n    depthFirstSearch(workers, bikes, usedBikes, 0, 0, minimumDistance);\n    return minimumDistance;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateManhattanDistance(std::vector<int> &worker, std::vector<int> &bike)\n{\n    return std::abs(worker[0] - bike[0]) + std::abs(worker[1] - bike[1]);\n}\n\nvoid depthFirstSearch(std::vector<std::vector<int>> &workers, std::vector<std::vector<int>> &bikes, std::vector<bool> &usedBikes, int workerIndex, int currentDistance, int &minimumDistance)\n{\n    if(workerIndex == workers.size())\n    {\n        minimumDistance= std::min(minimumDistance, currentDistance);\n        return;\n    }\n\n    if(currentDistance >= minimumDistance)\n    {\n        return;\n    }\n\n    for(int i= 0; i < bikes.size(); i++)\n    {\n        if(usedBikes[i])\n        {\n            continue;\n        }\n        usedBikes[i]= true;\n        int distanceToCurrentBike= calculateManhattanDistance(workers[workerIndex], bikes[i]);\n        depthFirstSearch(workers, bikes, usedBikes, workerIndex + 1, currentDistance + distanceToCurrentBike, minimumDistance);\n        usedBikes[i]= false;\n    }\n}\n\nint assignBikes(std::vector<std::vector<int>> &workers, std::vector<std::vector<int>> &bikes)\n{\n    int minimumDistance= INT_MAX;\n    std::vector<bool> usedBikes(bikes.size(), false);\n    depthFirstSearch(workers, bikes, usedBikes, 0, 0, minimumDistance);\n    return minimumDistance;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int countDigitOccurrences(int digit, int lowerBound, int upperBound)\n{\n    int occurrenceCount= 0;\n    for(int currentNumber= lowerBound; currentNumber <= upperBound; ++currentNumber)\n    {\n        int tempNumber= currentNumber;\n        while(tempNumber)\n        {\n            if(tempNumber % 10 == digit)\n            {\n                occurrenceCount++;\n            }\n            tempNumber/= 10;\n        }\n    }\n    return occurrenceCount;\n}",
    "output": "int countDigitOccurrences(int digit, int lowerBound, int upperBound)\n{\n    int occurrenceCount= 0;\n    for(int currentNumber= lowerBound; currentNumber <= upperBound; ++currentNumber)\n    {\n        int tempNumber= currentNumber;\n        while(tempNumber)\n        {\n            if(tempNumber % 10 == digit)\n            {\n                occurrenceCount++;\n            }\n            tempNumber/= 10;\n        }\n    }\n    return occurrenceCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<bool> prefixesDivBy5(vector<int> &binaryNumbers)\n{\n    vector<bool> divisibleByFiveResults;\n    int currentRemainder = 0;\n    for (int i = 0; i < binaryNumbers.size(); ++i)\n    {\n        int binaryDigit = binaryNumbers[i];\n        currentRemainder = ((currentRemainder << 1) | binaryDigit) % 5;\n        divisibleByFiveResults.push_back(currentRemainder == 0);\n    }\n    return divisibleByFiveResults;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<bool> prefixesDivBy5(std::vector<int> &binaryNumbers)\n{\n    std::vector<bool> divisibleByFiveResults;\n    int currentRemainder= 0;\n    for(int binaryDigit : binaryNumbers)\n    {\n        currentRemainder= ((currentRemainder << 1) | binaryDigit) % 5;\n        divisibleByFiveResults.push_back(currentRemainder == 0);\n    }\n    return divisibleByFiveResults;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nvector<int> nextGreaterNodes(ListNode *head)\n{\n    vector<int> result;\n    stack<int> greaterValues;\n    while(head)\n    {\n        while(!greaterValues.empty() && greaterValues.top() < head->value)\n        {\n            greaterValues.top()= head->value;\n            greaterValues.pop();\n        }\n        result.push_back(head->value);\n        greaterValues.push(0);\n        head= head->next;\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstruct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nstd::vector<int> nextGreaterNodes(ListNode *head)\n{\n    std::vector<int> result;\n    std::stack<int> greaterValues;\n    while(head)\n    {\n        while(!greaterValues.empty() && greaterValues.top() < head->value)\n        {\n            greaterValues.top()= head->value;\n            greaterValues.pop();\n        }\n        result.push_back(head->value);\n        greaterValues.push(0);\n        head= head->next;\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> addNegabinary(vector<int> &firstArray, vector<int> &secondArray)\n{\n    vector<int> resultArray;\n    int carry= 0, index1= firstArray.size() - 1, index2= secondArray.size() - 1;\n    while(index1 >= 0 || index2 >= 0 || carry)\n    {\n        if(index1 >= 0)\n            carry+= firstArray[index1--];\n        if(index2 >= 0)\n            carry+= secondArray[index2--];\n        resultArray.push_back(carry & 1);\n        carry= -(carry >> 1);\n    }\n    while(resultArray.size() > 1 && resultArray.back() == 0)\n        resultArray.pop_back();\n    reverse(resultArray.begin(), resultArray.end());\n    return resultArray;\n}",
    "output": "#include <bits/stdc++.h>\n// Include this for std::reverse\n\nstd::vector<int> addNegabinary(std::vector<int> &firstArray, std::vector<int> &secondArray)\n{\n    std::vector<int> resultArray;\n    int carry = 0, index1 = firstArray.size() - 1, index2 = secondArray.size() - 1;\n    while(index1 >= 0 || index2 >= 0 || carry)\n    {\n        if(index1 >= 0)\n            carry += firstArray[index1--];\n        if(index2 >= 0)\n            carry += secondArray[index2--];\n        resultArray.push_back(carry & 1);\n        carry = -(carry >> 1);\n    }\n    while(resultArray.size() > 1 && resultArray.back() == 0)\n        resultArray.pop_back();\n    std::reverse(resultArray.begin(), resultArray.end());\n    return resultArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countSubmatricesWithSumTarget(vector<vector<int>> &matrix, int target)\n{\n    int rowCount= matrix.size(), colCount= matrix[0].size();\n    for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n        for(int colIndex= 1; colIndex < colCount; ++colIndex)\n            matrix[rowIndex][colIndex]+= matrix[rowIndex][colIndex - 1];\n\n    int submatrixCount= 0;\n    unordered_map<int, int> sumCounter;\n    for(int colStart= 0; colStart < colCount; ++colStart)\n    {\n        for(int colEnd= colStart; colEnd < colCount; ++colEnd)\n        {\n            sumCounter.clear();\n            sumCounter[0]= 1;\n            int currentSum= 0;\n            for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n            {\n                currentSum+= matrix[rowIndex][colEnd] - (colStart > 0 ? matrix[rowIndex][colStart - 1] : 0);\n                submatrixCount+= sumCounter[currentSum - target];\n                ++sumCounter[currentSum];\n            }\n        }\n    }\n    return submatrixCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countSubmatricesWithSumTarget(std::vector<std::vector<int>> &matrix, int target)\n{\n    int rowCount= matrix.size(), colCount= matrix[0].size();\n    for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n        for(int colIndex= 1; colIndex < colCount; ++colIndex)\n            matrix[rowIndex][colIndex]+= matrix[rowIndex][colIndex - 1];\n\n    int submatrixCount= 0;\n    std::unordered_map<int, int> sumCounter;\n    for(int colStart= 0; colStart < colCount; ++colStart)\n    {\n        for(int colEnd= colStart; colEnd < colCount; ++colEnd)\n        {\n            sumCounter.clear();\n            sumCounter[0]= 1;\n            int currentSum= 0;\n            for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n            {\n                currentSum+= matrix[rowIndex][colEnd] - (colStart > 0 ? matrix[rowIndex][colStart - 1] : 0);\n                submatrixCount+= sumCounter[currentSum - target];\n                ++sumCounter[currentSum];\n            }\n        }\n    }\n    return submatrixCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring removeOuterParentheses(string parenthesesString)\n{\n    string result;\n    int openedCount = 0;\n\n    for (int i = 0; i < parenthesesString.size(); ++i)\n    {\n        char currentChar = parenthesesString[i];\n        if (currentChar == '(' && openedCount++ > 0)\n        {\n            result += currentChar;\n        }\n        if (currentChar == ')' && openedCount-- > 1)\n        {\n            result += currentChar;\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string removeOuterParentheses(std::string parenthesesString)\n{\n    std::string result;\n    int openedCount= 0;\n\n    for(char currentChar : parenthesesString)\n    {\n        if(currentChar == '(' && openedCount++ > 0)\n        {\n            result+= currentChar;\n        }\n        if(currentChar == ')' && openedCount-- > 1)\n        {\n            result+= currentChar;\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int sumRootToLeaf(TreeNode *rootNode, int currentPathValue= 0)\n{\n    if(!rootNode)\n        return 0;\n    currentPathValue= currentPathValue * 2 + rootNode->val;\n    if(!rootNode->left && !rootNode->right)\n        return currentPathValue;\n    return sumRootToLeaf(rootNode->left, currentPathValue) + sumRootToLeaf(rootNode->right, currentPathValue);\n}",
    "output": "int sumRootToLeaf(TreeNode *rootNode, int currentPathValue= 0)\n{\n    if(!rootNode)\n        return 0;\n    currentPathValue= currentPathValue * 2 + rootNode->val;\n    if(!rootNode->left && !rootNode->right)\n        return currentPathValue;\n    return sumRootToLeaf(rootNode->left, currentPathValue) + sumRootToLeaf(rootNode->right, currentPathValue);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For NULL\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    TreeNode *sufficientSubset(TreeNode *rootNode, int limitValue)\n    {\n        if(!rootNode)\n            return NULL;\n        if(!rootNode->leftChild && !rootNode->rightChild)\n        {\n            if(rootNode->value < limitValue)\n                return NULL;\n            return rootNode;\n        }\n        rootNode->leftChild= sufficientSubset(rootNode->leftChild, limitValue - rootNode->value);\n        rootNode->rightChild= sufficientSubset(rootNode->rightChild, limitValue - rootNode->value);\n        if(!rootNode->leftChild && !rootNode->rightChild)\n            return NULL;\n\n        return rootNode;\n    }\n};",
    "output": "// Definition for a binary tree node.\nstruct TreeNode {\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    TreeNode *sufficientSubset(TreeNode *rootNode, int limitValue)\n    {\n        if(!rootNode)\n            return NULL;\n        if(!rootNode->leftChild && !rootNode->rightChild)\n        {\n            if(rootNode->value < limitValue)\n                return NULL;\n            return rootNode;\n        }\n        rootNode->leftChild= sufficientSubset(rootNode->leftChild, limitValue - rootNode->value);\n        rootNode->rightChild= sufficientSubset(rootNode->rightChild, limitValue - rootNode->value);\n        if(!rootNode->leftChild && !rootNode->rightChild)\n            return NULL;\n\n        return rootNode;\n    }\n};\n"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint videoStitching(vector<vector<int>> &videoClips, int targetTime)\n{\n    vector<int> minimumClips(targetTime + 1, INT_MAX);\n    minimumClips[0] = 0;\n    for (int currentTime = 1; currentTime <= targetTime; ++currentTime)\n    {\n        for (int i = 0; i < videoClips.size(); ++i)\n        {\n            const auto &clip = videoClips[i];\n            if (clip[0] < currentTime && currentTime <= clip[1])\n            {\n                minimumClips[currentTime] = min(minimumClips[currentTime], minimumClips[clip[0]] + 1);\n            }\n        }\n    }\n    return minimumClips[targetTime] == INT_MAX ? -1 : minimumClips[targetTime];\n}",
    "output": "#include <bits/stdc++.h>\nint videoStitching(std::vector<std::vector<int>> &videoClips, int targetTime)\n{\n    std::vector<int> minimumClips(targetTime + 1, INT_MAX);\n    minimumClips[0] = 0;\n    for(int currentTime = 1; currentTime <= targetTime; ++currentTime)\n    {\n        for(const auto &clip : videoClips)\n        {\n            if(clip[0] < currentTime && currentTime <= clip[1])\n            {\n                minimumClips[currentTime] = std::min(minimumClips[currentTime], minimumClips[clip[0]] + 1);\n            }\n        }\n    }\n    return minimumClips[targetTime] == INT_MAX ? -1 : minimumClips[targetTime];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint sumOfDigits(vector<int> &numbers)\n{\n    int minimumValue= *min_element(numbers.begin(), numbers.end());\n    int digitSum= 0;\n    while(minimumValue > 0)\n    {\n        digitSum+= minimumValue % 10;\n        minimumValue/= 10;\n    }\n    return digitSum % 2 == 0 ? 1 : 0;\n}",
    "output": "#include <bits/stdc++.h>\nint sumOfDigits(std::vector<int> &numbers)\n{\n    int minimumValue= *std::min_element(numbers.begin(), numbers.end());\n    int digitSum= 0;\n    while(minimumValue > 0)\n    {\n        digitSum+= minimumValue % 10;\n        minimumValue/= 10;\n    }\n    return digitSum % 2 == 0 ? 1 : 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "bool isAliceWinner(int number)\n{\n    return number % 2 == 0;\n}",
    "output": "bool isAliceWinner(int number)\n{\n    return number % 2 == 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint longestArithSeqLength(vector<int> &numberList)\n{\n    int listSize= numberList.size();\n    int longestSequence= 0;\n    vector<unordered_map<int, int>> differenceMap(listSize);\n\n    for(int currentIndex= 0; currentIndex < listSize; ++currentIndex)\n    {\n        for(int previousIndex= 0; previousIndex < currentIndex; ++previousIndex)\n        {\n            int difference= numberList[currentIndex] - numberList[previousIndex];\n            differenceMap[currentIndex][difference]= differenceMap[previousIndex].count(difference) ? differenceMap[previousIndex][difference] + 1 : 2;\n            longestSequence= max(longestSequence, differenceMap[currentIndex][difference]);\n        }\n    }\n\n    return longestSequence;\n}",
    "output": "#include <bits/stdc++.h>\nint longestArithSeqLength(std::vector<int> &numberList)\n{\n    int listSize= numberList.size();\n    int longestSequence= 0;\n    std::vector<std::unordered_map<int, int>> differenceMap(listSize);\n\n    for(int currentIndex= 0; currentIndex < listSize; ++currentIndex)\n    {\n        for(int previousIndex= 0; previousIndex < currentIndex; ++previousIndex)\n        {\n            int difference= numberList[currentIndex] - numberList[previousIndex];\n            differenceMap[currentIndex][difference]= differenceMap[previousIndex].count(difference) ? differenceMap[previousIndex][difference] + 1 : 2;\n            longestSequence= std::max(longestSequence, differenceMap[currentIndex][difference]);\n        }\n    }\n\n    return longestSequence;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findConfusingNumbers(int currentNumber, int &maxLimit, unordered_map<int, int> &rotationMap)\n{\n    if(currentNumber > maxLimit)\n        return 0;\n    int rotatedNumber= 0, sourceNumber= currentNumber, newNumber;\n    while(sourceNumber > 0)\n    {\n        rotatedNumber= rotatedNumber * 10 + rotationMap[sourceNumber % 10];\n        sourceNumber/= 10;\n    }\n    return (currentNumber != rotatedNumber) + findConfusingNumbers(currentNumber * 10 + 6, maxLimit, rotationMap) + findConfusingNumbers(currentNumber * 10 + 9, maxLimit, rotationMap) + findConfusingNumbers(currentNumber * 10 + 0, maxLimit, rotationMap) + findConfusingNumbers(currentNumber * 10 + 1, maxLimit, rotationMap) + findConfusingNumbers(currentNumber * 10 + 8, maxLimit, rotationMap);\n}\n\nint confusingNumberII(int maxLimit)\n{\n    unordered_map<int, int> rotationMap= {{0, 0}, {1, 1}, {6, 9}, {8, 8}, {9, 6}};\n    return findConfusingNumbers(6, maxLimit, rotationMap) + findConfusingNumbers(9, maxLimit, rotationMap) +\n           findConfusingNumbers(1, maxLimit, rotationMap) + findConfusingNumbers(8, maxLimit, rotationMap) + findConfusingNumbers(0, maxLimit, rotationMap);\n}",
    "output": "#include <bits/stdc++.h>\nint findConfusingNumbers(int currentNumber, int &maxLimit, std::unordered_map<int, int> &rotationMap)\n{\n    if(currentNumber > maxLimit)\n        return 0;\n    int rotatedNumber= 0, sourceNumber= currentNumber, newNumber;\n    while(sourceNumber > 0)\n    {\n        rotatedNumber= rotatedNumber * 10 + rotationMap[sourceNumber % 10];\n        sourceNumber/= 10;\n    }\n    return (currentNumber != rotatedNumber) + findConfusingNumbers(currentNumber * 10 + 6, maxLimit, rotationMap) + findConfusingNumbers(currentNumber * 10 + 9, maxLimit, rotationMap) + findConfusingNumbers(currentNumber * 10 + 0, maxLimit, rotationMap) + findConfusingNumbers(currentNumber * 10 + 1, maxLimit, rotationMap) + findConfusingNumbers(currentNumber * 10 + 8, maxLimit, rotationMap);\n}\n\nint confusingNumberII(int maxLimit)\n{\n    std::unordered_map<int, int> rotationMap= {{0, 0}, {1, 1}, {6, 9}, {8, 8}, {9, 6}};\n    return findConfusingNumbers(6, maxLimit, rotationMap) + findConfusingNumbers(9, maxLimit, rotationMap) +\n           findConfusingNumbers(1, maxLimit, rotationMap) + findConfusingNumbers(8, maxLimit, rotationMap) + findConfusingNumbers(0, maxLimit, rotationMap);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid duplicateZeros(vector<int> &inputArray)\n{\n    int arraySize= inputArray.size();\n    for(int currentIndex= 0; currentIndex < arraySize - 1; ++currentIndex)\n    {\n        if(inputArray[currentIndex] == 0)\n        {\n            for(int shiftIndex= arraySize - 1; shiftIndex > currentIndex + 1; --shiftIndex)\n            {\n                inputArray[shiftIndex]= inputArray[shiftIndex - 1];\n            }\n            inputArray[++currentIndex]= 0;\n        }\n    }\n}",
    "output": "#include <bits/stdc++.h>\nvoid duplicateZeros(std::vector<int> &inputArray)\n{\n    int arraySize= inputArray.size();\n    for(int currentIndex= 0; currentIndex < arraySize - 1; ++currentIndex)\n    {\n        if(inputArray[currentIndex] == 0)\n        {\n            for(int shiftIndex= arraySize - 1; shiftIndex > currentIndex + 1; --shiftIndex)\n            {\n                inputArray[shiftIndex]= inputArray[shiftIndex - 1];\n            }\n            inputArray[++currentIndex]= 0;\n        }\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint largestValsFromLabels(vector<int> &itemValues, vector<int> &itemLabels, int numWanted, int useLimit)\n{\n    vector<pair<int, int>> itemPairs;\n    for(int index = 0; index < itemValues.size(); ++index)\n    {\n        itemPairs.push_back({itemValues[index], itemLabels[index]});\n    }\n\n    sort(itemPairs.begin(), itemPairs.end(), [](const pair<int, int> &firstPair, const pair<int, int> &secondPair)\n              { return firstPair.first > secondPair.first; });\n\n    unordered_map<int, int> labelCount;\n    int totalValue = 0;\n\n    for (int i = 0; i < itemPairs.size(); ++i)\n    {\n        const auto &item = itemPairs[i];\n        if (labelCount[item.second] < useLimit)\n        {\n            totalValue += item.first;\n            labelCount[item.second]++;\n            if (--numWanted == 0)\n                break;\n        }\n    }\n    return totalValue;\n}",
    "output": "#include <bits/stdc++.h>\nint largestValsFromLabels(std::vector<int> &itemValues, std::vector<int> &itemLabels, int numWanted, int useLimit)\n{\n    std::vector<std::pair<int, int>> itemPairs;\n    for(int index= 0; index < itemValues.size(); ++index)\n    {\n        itemPairs.push_back({itemValues[index], itemLabels[index]});\n    }\n\n    std::sort(itemPairs.begin(), itemPairs.end(), [](const std::pair<int, int> &firstPair, const std::pair<int, int> &secondPair)\n              { return firstPair.first > secondPair.first; });\n\n    std::unordered_map<int, int> labelCount;\n    int totalValue= 0;\n\n    for(const auto &item : itemPairs)\n    {\n        if(labelCount[item.second] < useLimit)\n        {\n            totalValue+= item.first;\n            labelCount[item.second]++;\n            if(--numWanted == 0)\n                break;\n        }\n    }\n    return totalValue;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPathBinaryMatrix(vector<vector<int>> &binaryMatrix)\n{\n    int matrixSize = binaryMatrix.size();\n    if (binaryMatrix[0][0] == 1 || binaryMatrix[matrixSize - 1][matrixSize - 1] == 1)\n        return -1;\n\n    vector<vector<int>> directions = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n    queue<pair<int, int>> positionQueue;\n    positionQueue.push({0, 0});\n    binaryMatrix[0][0] = 1;\n\n    int pathLength = 1;\n\n    while (!positionQueue.empty())\n    {\n        int queueLength = positionQueue.size();\n        for (int i = 0; i < queueLength; i++)\n        {\n            int currentX = positionQueue.front().first;\n            int currentY = positionQueue.front().second;\n            positionQueue.pop();\n\n            if (currentX == matrixSize - 1 && currentY == matrixSize - 1)\n                return pathLength;\n\n            for (int j = 0; j < directions.size(); j++) // Changed to traditional for loop\n            {\n                vector<int> &direction = directions[j];\n                int newX = currentX + direction[0];\n                int newY = currentY + direction[1];\n\n                if (newX >= 0 && newX < matrixSize && newY >= 0 && newY < matrixSize && binaryMatrix[newX][newY] == 0)\n                {\n                    positionQueue.push({newX, newY});\n                    binaryMatrix[newX][newY] = 1;\n                }\n            }\n        }\n        pathLength++;\n    }\n\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> directions= {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\nstd::queue<std::pair<int, int>> positionQueue;\n\nint shortestPathBinaryMatrix(std::vector<std::vector<int>> &binaryMatrix)\n{\n    int matrixSize= binaryMatrix.size();\n    if(binaryMatrix[0][0] == 1 || binaryMatrix[matrixSize - 1][matrixSize - 1] == 1)\n        return -1;\n\n    positionQueue.push({0, 0});\n    binaryMatrix[0][0]= 1;\n\n    int pathLength= 1;\n\n    while(!positionQueue.empty())\n    {\n        int queueLength= positionQueue.size();\n        for(int i= 0; i < queueLength; i++)\n        {\n            int currentX= positionQueue.front().first;\n            int currentY= positionQueue.front().second;\n            positionQueue.pop();\n\n            if(currentX == matrixSize - 1 && currentY == matrixSize - 1)\n                return pathLength;\n\n            for(std::vector<int> &direction : directions)\n            {\n                int newX= currentX + direction[0];\n                int newY= currentY + direction[1];\n\n                if(newX >= 0 && newX < matrixSize && newY >= 0 && newY < matrixSize && binaryMatrix[newX][newY] == 0)\n                {\n                    positionQueue.push({newX, newY});\n                    binaryMatrix[newX][newY]= 1;\n                }\n            }\n        }\n        pathLength++;\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int valueIn) : value(valueIn), leftChild(NULL), rightChild(NULL) {}\n};\n\nint depthFirstSearch(TreeNode *currentNode, int &minValue, int &maxValue)\n{\n    if(!currentNode)\n        return 0;\n    int leftMin= currentNode->value, rightMin= currentNode->value;\n    int leftMax= currentNode->value, rightMax= currentNode->value;\n    int leftDifference= depthFirstSearch(currentNode->leftChild, leftMin, leftMax);\n    int rightDifference= depthFirstSearch(currentNode->rightChild, rightMin, rightMax);\n    minValue= min(currentNode->value, min(leftMin, rightMin));\n    maxValue= max(currentNode->value, max(leftMax, rightMax));\n    return max(max(leftDifference, rightDifference), max(abs(currentNode->value - leftMin), abs(currentNode->value - rightMax)));\n}\n\nint maxAncestorDifference(TreeNode *root)\n{\n    int minValue= root->value, maxValue= root->value;\n    return depthFirstSearch(root, minValue, maxValue);\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int valueIn) : value(valueIn), leftChild(NULL), rightChild(NULL) {}\n};\n\nint depthFirstSearch(TreeNode *currentNode, int &minValue, int &maxValue)\n{\n    if(!currentNode)\n        return 0;\n    int leftMin= currentNode->value, rightMin= currentNode->value;\n    int leftMax= currentNode->value, rightMax= currentNode->value;\n    int leftDifference= depthFirstSearch(currentNode->leftChild, leftMin, leftMax);\n    int rightDifference= depthFirstSearch(currentNode->rightChild, rightMin, rightMax);\n    minValue= min(currentNode->value, min(leftMin, rightMin));\n    maxValue= max(currentNode->value, max(leftMax, rightMax));\n    return max(max(leftDifference, rightDifference), max(abs(currentNode->value - leftMin), abs(currentNode->value - rightMax)));\n}\n\nint maxAncestorDifference(TreeNode *root)\n{\n    int minValue= root->value, maxValue= root->value;\n    return depthFirstSearch(root, minValue, maxValue);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nvoid buildTree(istringstream &inputStream, TreeNode *&currentNode, int currentDepth)\n{\n    int depthCount= 0;\n    while(inputStream.peek() == '-')\n    {\n        inputStream.get();\n        depthCount++;\n    }\n    if(depthCount != currentDepth)\n    {\n        inputStream.putback('-');\n        return;\n    }\n    int nodeValue;\n    inputStream >> nodeValue;\n    currentNode= new TreeNode(nodeValue);\n    buildTree(inputStream, currentNode->leftChild, currentDepth + 1);\n    buildTree(inputStream, currentNode->rightChild, currentDepth + 1);\n}\n\nTreeNode *recoverFromPreorder(string preorderString)\n{\n    istringstream inputStream(preorderString);\n    TreeNode *rootNode= NULL;\n    buildTree(inputStream, rootNode, 0);\n    return rootNode;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nvoid buildTree(std::istringstream &inputStream, TreeNode *&currentNode, int currentDepth)\n{\n    int depthCount= 0;\n    while(inputStream.peek() == '-')\n    {\n        inputStream.get();\n        depthCount++;\n    }\n    if(depthCount != currentDepth)\n    {\n        inputStream.putback('-');\n        return;\n    }\n    int nodeValue;\n    inputStream >> nodeValue;\n    currentNode= new TreeNode(nodeValue);\n    buildTree(inputStream, currentNode->leftChild, currentDepth + 1);\n    buildTree(inputStream, currentNode->rightChild, currentDepth + 1);\n}\n\nTreeNode *recoverFromPreorder(std::string preorderString)\n{\n    std::istringstream inputStream(preorderString);\n    TreeNode *rootNode= NULL;\n    buildTree(inputStream, rootNode, 0);\n    return rootNode;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> allCellsDistanceOrder(int totalRows, int totalCols, int centerRow, int centerCol)\n{\n    vector<vector<int>> cellCoordinates;\n\n    for(int rowIndex= 0; rowIndex < totalRows; ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex < totalCols; ++colIndex)\n        {\n            cellCoordinates.push_back({rowIndex, colIndex});\n        }\n    }\n\n    sort(cellCoordinates.begin(), cellCoordinates.end(), [&](const vector<int> &firstCell, const vector<int> &secondCell)\n              { return abs(firstCell[0] - centerRow) + abs(firstCell[1] - centerCol) < abs(secondCell[0] - centerRow) + abs(secondCell[1] - centerCol); });\n\n    return cellCoordinates;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> allCellsDistanceOrder(int totalRows, int totalCols, int centerRow, int centerCol)\n{\n    std::vector<std::vector<int>> cellCoordinates;\n\n    for(int rowIndex= 0; rowIndex < totalRows; ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex < totalCols; ++colIndex)\n        {\n            cellCoordinates.push_back({rowIndex, colIndex});\n        }\n    }\n\n    std::sort(cellCoordinates.begin(), cellCoordinates.end(), [&](const std::vector<int> &firstCell, const std::vector<int> &secondCell)\n              { return abs(firstCell[0] - centerRow) + abs(firstCell[1] - centerCol) < abs(secondCell[0] - centerRow) + abs(secondCell[1] - centerCol); });\n\n    return cellCoordinates;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint twoCitySchedCost(vector<vector<int>> &cityCosts)\n{\n    sort(cityCosts.begin(), cityCosts.end(), [](const vector<int> &firstCityCost, const vector<int> &secondCityCost)\n              { return (firstCityCost[0] - firstCityCost[1]) < (secondCityCost[0] - secondCityCost[1]); });\n\n    int totalCost= 0;\n    int halfSize= cityCosts.size() / 2;\n\n    for(int index= 0; index < halfSize; index++)\n    {\n        totalCost+= cityCosts[index][0] + cityCosts[index + halfSize][1];\n    }\n\n    return totalCost;\n}",
    "output": "#include <bits/stdc++.h>\nint twoCitySchedCost(std::vector<std::vector<int>> &cityCosts)\n{\n    std::sort(cityCosts.begin(), cityCosts.end(), [](const std::vector<int> &firstCityCost, const std::vector<int> &secondCityCost)\n              { return (firstCityCost[0] - firstCityCost[1]) < (secondCityCost[0] - secondCityCost[1]); });\n\n    int totalCost= 0;\n    int halfSize= cityCosts.size() / 2;\n\n    for(int index= 0; index < halfSize; index++)\n    {\n        totalCost+= cityCosts[index][0] + cityCosts[index + halfSize][1];\n    }\n\n    return totalCost;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution\n{\n  public:\n    vector<string> braceExpansionII(string expression)\n    {\n        int currentIndex = 0;\n        return vector<string>(parse(expression, currentIndex).begin(), parse(expression, currentIndex).end());\n    }\n\n    set<string> parse(string &inputExpression, int &currentIndex)\n    {\n        set<string> currentCombinations;\n        currentCombinations.insert(\"\");\n        set<string> resultCombinations;\n\n        for (; currentIndex < inputExpression.size(); ++currentIndex)\n        {\n            char currentChar = inputExpression[currentIndex];\n            if (currentChar == '{')\n            {\n                set<string> updatedCombinations;\n                for (set<string>::iterator it = parse(inputExpression, ++currentIndex).begin(); it != parse(inputExpression, ++currentIndex).end(); ++it)\n                {\n                    string postfix = *it;\n                    for (set<string>::iterator jt = currentCombinations.begin(); jt != currentCombinations.end(); ++jt)\n                    {\n                        string prefix = *jt;\n                        updatedCombinations.insert(prefix + postfix);\n                    }\n                }\n                currentCombinations = updatedCombinations;\n            }\n            else if (currentChar == ',')\n            {\n                resultCombinations.insert(currentCombinations.begin(), currentCombinations.end());\n                currentCombinations.clear();\n                currentCombinations.insert(\"\");\n            }\n            else if (currentChar == '}')\n            {\n                break;\n            }\n            else\n            {\n                set<string> updatedCombinations;\n                for (set<string>::iterator it = currentCombinations.begin(); it != currentCombinations.end(); ++it)\n                {\n                    string element = *it;\n                    updatedCombinations.insert(element + currentChar);\n                }\n                currentCombinations = updatedCombinations;\n            }\n        }\n\n        resultCombinations.insert(currentCombinations.begin(), currentCombinations.end());\n        return resultCombinations;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Solution\n{\n  public:\n    std::vector<std::string> braceExpansionII(std::string expression)\n    {\n        int currentIndex = 0;\n        return std::vector<std::string>(parse(expression, currentIndex).begin(), parse(expression, currentIndex).end());\n    }\n\n    std::set<std::string> parse(std::string &inputExpression, int &currentIndex)\n    {\n        std::set<std::string> currentCombinations;\n        currentCombinations.insert(\"\");\n        std::set<std::string> resultCombinations;\n\n        for (; currentIndex < inputExpression.size(); ++currentIndex)\n        {\n            char currentChar = inputExpression[currentIndex];\n            if (currentChar == '{')\n            {\n                std::set<std::string> updatedCombinations;\n                for (std::string postfix : parse(inputExpression, ++currentIndex))\n                {\n                    for (std::string prefix : currentCombinations)\n                    {\n                        updatedCombinations.insert(prefix + postfix);\n                    }\n                }\n                currentCombinations = updatedCombinations;\n            }\n            else if (currentChar == ',')\n            {\n                resultCombinations.insert(currentCombinations.begin(), currentCombinations.end());\n                currentCombinations.clear();\n                currentCombinations.insert(\"\");\n            }\n            else if (currentChar == '}')\n            {\n                break;\n            }\n            else\n            {\n                std::set<std::string> updatedCombinations;\n                for (std::string element : currentCombinations)\n                {\n                    updatedCombinations.insert(element + currentChar);\n                }\n                currentCombinations = updatedCombinations;\n            }\n        }\n\n        resultCombinations.insert(currentCombinations.begin(), currentCombinations.end());\n        return resultCombinations;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumUnderK(vector<int> &numbers, int limit)\n{\n    int maxSum= -1;\n    for(int firstIndex= 0; firstIndex < numbers.size(); firstIndex++)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < numbers.size(); secondIndex++)\n        {\n            int currentSum= numbers[firstIndex] + numbers[secondIndex];\n            if(currentSum < limit && currentSum > maxSum)\n            {\n                maxSum= currentSum;\n            }\n        }\n    }\n    return maxSum;\n}",
    "output": "#include <bits/stdc++.h>\nint maxSumUnderK(std::vector<int> &numbers, int limit)\n{\n    int maxSum= -1;\n    for(int firstIndex= 0; firstIndex < numbers.size(); firstIndex++)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < numbers.size(); secondIndex++)\n        {\n            int currentSum= numbers[firstIndex] + numbers[secondIndex];\n            if(currentSum < limit && currentSum > maxSum)\n            {\n                maxSum= currentSum;\n            }\n        }\n    }\n    return maxSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countKLengthSubstringsWithoutRepeats(string inputString, int substringLength)\n{\n    int stringLength= inputString.length();\n    if(substringLength > stringLength)\n        return 0;\n\n    int validSubstringCount= 0;\n    unordered_set<char> characterWindow;\n\n    for(int startIndex= 0, endIndex= 0; endIndex < stringLength; ++endIndex)\n    {\n        while(characterWindow.find(inputString[endIndex]) != characterWindow.end())\n        {\n            characterWindow.erase(inputString[startIndex++]);\n        }\n        characterWindow.insert(inputString[endIndex]);\n        if(endIndex - startIndex + 1 == substringLength)\n        {\n            ++validSubstringCount;\n            characterWindow.erase(inputString[startIndex++]);\n        }\n    }\n    return validSubstringCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countKLengthSubstringsWithoutRepeats(std::string inputString, int substringLength)\n{\n    int stringLength= inputString.length();\n    if(substringLength > stringLength)\n        return 0;\n\n    int validSubstringCount= 0;\n    std::unordered_set<char> characterWindow;\n\n    for(int startIndex= 0, endIndex= 0; endIndex < stringLength; ++endIndex)\n    {\n        while(characterWindow.find(inputString[endIndex]) != characterWindow.end())\n        {\n            characterWindow.erase(inputString[startIndex++]);\n        }\n        characterWindow.insert(inputString[endIndex]);\n        if(endIndex - startIndex + 1 == substringLength)\n        {\n            ++validSubstringCount;\n            characterWindow.erase(inputString[startIndex++]);\n        }\n    }\n    return validSubstringCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findParent(int person, vector<int> &parentArray)\n{\n    return person == parentArray[person] ? person : parentArray[person] = findParent(parentArray[person], parentArray);\n}\n\nint earliestAcquisition(vector<vector<int>> &logs, int totalPeople)\n{\n    vector<int> parentArray(totalPeople);\n    for(int index = 0; index < totalPeople; ++index)\n        parentArray[index] = index;\n\n    sort(logs.begin(), logs.end());\n\n    int groupCount = totalPeople;\n    for (int i = 0; i < logs.size(); ++i) // Changed from range-based for loop to traditional for loop\n    {\n        const auto &logEntry = logs[i];\n        int rootPersonX = findParent(logEntry[1], parentArray);\n        int rootPersonY = findParent(logEntry[2], parentArray);\n        if(rootPersonX != rootPersonY)\n        {\n            parentArray[rootPersonX] = rootPersonY;\n            groupCount--;\n        }\n        if(groupCount == 1)\n        {\n            return logEntry[0];\n        }\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint findParent(int person, std::vector<int> &parentArray)\n{\n    return person == parentArray[person] ? person : parentArray[person]= findParent(parentArray[person], parentArray);\n}\n\nint earliestAcquisition(std::vector<std::vector<int>> &logs, int totalPeople)\n{\n    std::vector<int> parentArray(totalPeople);\n    for(int index= 0; index < totalPeople; ++index)\n        parentArray[index]= index;\n\n    std::sort(logs.begin(), logs.end());\n\n    int groupCount= totalPeople;\n    for(const auto &logEntry : logs)\n    {\n        int rootPersonX= findParent(logEntry[1], parentArray);\n        int rootPersonY= findParent(logEntry[2], parentArray);\n        if(rootPersonX != rootPersonY)\n        {\n            parentArray[rootPersonX]= rootPersonY;\n            groupCount--;\n        }\n        if(groupCount == 1)\n        {\n            return logEntry[0];\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(vector<vector<int>> &scoreGrid)\n{\n    int rowCount= scoreGrid.size(), columnCount= scoreGrid[0].size();\n\n    for(int columnIndex= 1; columnIndex < columnCount; columnIndex++)\n    {\n        scoreGrid[0][columnIndex]= min(scoreGrid[0][columnIndex], scoreGrid[0][columnIndex - 1]);\n    }\n\n    for(int rowIndex= 1; rowIndex < rowCount; rowIndex++)\n    {\n        scoreGrid[rowIndex][0]= min(scoreGrid[rowIndex][0], scoreGrid[rowIndex - 1][0]);\n\n        for(int columnIndex= 1; columnIndex < columnCount; columnIndex++)\n        {\n            scoreGrid[rowIndex][columnIndex]= max(min(scoreGrid[rowIndex - 1][columnIndex], scoreGrid[rowIndex][columnIndex]), min(scoreGrid[rowIndex][columnIndex - 1], scoreGrid[rowIndex][columnIndex]));\n        }\n    }\n\n    return scoreGrid[rowCount - 1][columnCount - 1];\n}",
    "output": "#include <bits/stdc++.h>\nint maxScore(std::vector<std::vector<int>> &scoreGrid)\n{\n    int rowCount= scoreGrid.size(), columnCount= scoreGrid[0].size();\n\n    for(int columnIndex= 1; columnIndex < columnCount; columnIndex++)\n    {\n        scoreGrid[0][columnIndex]= std::min(scoreGrid[0][columnIndex], scoreGrid[0][columnIndex - 1]);\n    }\n\n    for(int rowIndex= 1; rowIndex < rowCount; rowIndex++)\n    {\n        scoreGrid[rowIndex][0]= std::min(scoreGrid[rowIndex][0], scoreGrid[rowIndex - 1][0]);\n\n        for(int columnIndex= 1; columnIndex < columnCount; columnIndex++)\n        {\n            scoreGrid[rowIndex][columnIndex]= std::max(\n                std::min(scoreGrid[rowIndex - 1][columnIndex], scoreGrid[rowIndex][columnIndex]), \n                std::min(scoreGrid[rowIndex][columnIndex - 1], scoreGrid[rowIndex][columnIndex])\n            );\n        }\n    }\n\n    return scoreGrid[rowCount - 1][columnCount - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> distributeCandies(int totalCandies, int numberOfPeople)\n{\n    vector<int> candyDistribution(numberOfPeople, 0);\n    int currentIndex= 0, currentCount= 1;\n\n    while(totalCandies > 0)\n    {\n        candyDistribution[currentIndex % numberOfPeople]+= min(totalCandies, currentCount);\n        totalCandies-= currentCount;\n        currentCount++;\n        currentIndex++;\n    }\n\n    return candyDistribution;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> distributeCandies(int totalCandies, int numberOfPeople)\n{\n    std::vector<int> candyDistribution(numberOfPeople, 0);\n    int currentIndex= 0, currentCount= 1;\n\n    while(totalCandies > 0)\n    {\n        candyDistribution[currentIndex % numberOfPeople]+= std::min(totalCandies, currentCount);\n        totalCandies-= currentCount;\n        currentCount++;\n        currentIndex++;\n    }\n\n    return candyDistribution;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(vector<vector<int>> &grid, int row, int col, int currentColor, int newColor)\n{\n    if(row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] != currentColor)\n        return;\n\n    grid[row][col] = newColor;\n    depthFirstSearch(grid, row + 1, col, currentColor, newColor);\n    depthFirstSearch(grid, row - 1, col, currentColor, newColor);\n    depthFirstSearch(grid, row, col + 1, currentColor, newColor);\n    depthFirstSearch(grid, row, col - 1, currentColor, newColor);\n}\n\nvector<vector<int>> colorBorder(vector<vector<int>> &grid, int row, int col, int newColor)\n{\n    int currentColor = grid[row][col];\n    if(currentColor == newColor)\n        return grid;\n\n    depthFirstSearch(grid, row, col, currentColor, newColor + 1000);\n\n    for(int i = 0; i < grid.size(); ++i)\n    {\n        for(int j = 0; j < grid[0].size(); ++j)\n        {\n            if(grid[i][j] > 1000)\n                grid[i][j] -= 1000;\n        }\n    }\n\n    return grid;\n}",
    "output": "#include <bits/stdc++.h>\nvoid depthFirstSearch(std::vector<std::vector<int>> &grid, int row, int col, int currentColor, int newColor)\n{\n    if(row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] != currentColor)\n        return;\n\n    grid[row][col]= newColor;\n    depthFirstSearch(grid, row + 1, col, currentColor, newColor);\n    depthFirstSearch(grid, row - 1, col, currentColor, newColor);\n    depthFirstSearch(grid, row, col + 1, currentColor, newColor);\n    depthFirstSearch(grid, row, col - 1, currentColor, newColor);\n}\n\nstd::vector<std::vector<int>> colorBorder(std::vector<std::vector<int>> &grid, int row, int col, int newColor)\n{\n    int currentColor= grid[row][col];\n    if(currentColor == newColor)\n        return grid;\n\n    depthFirstSearch(grid, row, col, currentColor, newColor + 1000);\n\n    for(int i= 0; i < grid.size(); ++i)\n    {\n        for(int j= 0; j < grid[0].size(); ++j)\n        {\n            if(grid[i][j] > 1000)\n                grid[i][j]-= 1000;\n        }\n    }\n\n    return grid;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxUncrossedLines(vector<int> &firstArray, vector<int> &secondArray)\n{\n    int firstArraySize= firstArray.size();\n    int secondArraySize= secondArray.size();\n    vector<vector<int>> dynamicProgramming(firstArraySize + 1, vector<int>(secondArraySize + 1, 0));\n\n    for(int rowIndex= 1; rowIndex <= firstArraySize; rowIndex++)\n    {\n        for(int columnIndex= 1; columnIndex <= secondArraySize; columnIndex++)\n        {\n            if(firstArray[rowIndex - 1] == secondArray[columnIndex - 1])\n            {\n                dynamicProgramming[rowIndex][columnIndex]= dynamicProgramming[rowIndex - 1][columnIndex - 1] + 1;\n            }\n            else\n            {\n                dynamicProgramming[rowIndex][columnIndex]= max(dynamicProgramming[rowIndex - 1][columnIndex], dynamicProgramming[rowIndex][columnIndex - 1]);\n            }\n        }\n    }\n    return dynamicProgramming[firstArraySize][secondArraySize];\n}",
    "output": "#include <bits/stdc++.h>\nint maxUncrossedLines(std::vector<int> &firstArray, std::vector<int> &secondArray)\n{\n    int firstArraySize= firstArray.size();\n    int secondArraySize= secondArray.size();\n    std::vector<std::vector<int>> dynamicProgramming(firstArraySize + 1, std::vector<int>(secondArraySize + 1, 0));\n\n    for(int rowIndex= 1; rowIndex <= firstArraySize; rowIndex++)\n    {\n        for(int columnIndex= 1; columnIndex <= secondArraySize; columnIndex++)\n        {\n            if(firstArray[rowIndex - 1] == secondArray[columnIndex - 1])\n            {\n                dynamicProgramming[rowIndex][columnIndex]= dynamicProgramming[rowIndex - 1][columnIndex - 1] + 1;\n            }\n            else\n            {\n                dynamicProgramming[rowIndex][columnIndex]= std::max(dynamicProgramming[rowIndex - 1][columnIndex], dynamicProgramming[rowIndex][columnIndex - 1]);\n            }\n        }\n    }\n    return dynamicProgramming[firstArraySize][secondArraySize];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxSteps = 200;\n\nbool depthFirstSearch(int currentX, int currentY, int targetX, int targetY, unordered_set<string> &blockedPositions, unordered_set<string> &visitedPositions, int stepCount)\n{\n    string currentPosition = to_string(currentX) + \"_\" + to_string(currentY);\n    if(currentX < 0 || currentX >= 1000000 || currentY < 0 || currentY >= 1000000 || stepCount >= maxSteps || blockedPositions.count(currentPosition) || visitedPositions.count(currentPosition))\n        return false;\n\n    if(currentX == targetX && currentY == targetY)\n        return true;\n\n    visitedPositions.insert(currentPosition);\n\n    if(depthFirstSearch(currentX + 1, currentY, targetX, targetY, blockedPositions, visitedPositions, stepCount + 1) ||\n       depthFirstSearch(currentX, currentY + 1, targetX, targetY, blockedPositions, visitedPositions, stepCount + 1) ||\n       depthFirstSearch(currentX - 1, currentY, targetX, targetY, blockedPositions, visitedPositions, stepCount + 1) ||\n       depthFirstSearch(currentX, currentY - 1, targetX, targetY, blockedPositions, visitedPositions, stepCount + 1))\n        return true;\n\n    return false;\n}\n\nbool isEscapePossible(vector<vector<int>> &blockedCells, vector<int> &sourceCoordinates, vector<int> &targetCoordinates)\n{\n    unordered_set<string> blockedSet, visitedSet;\n    for (int i = 0; i < blockedCells.size(); ++i)\n    {\n        blockedSet.insert(to_string(blockedCells[i][0]) + \"_\" + to_string(blockedCells[i][1]));\n    }\n\n    return depthFirstSearch(sourceCoordinates[0], sourceCoordinates[1], targetCoordinates[0], targetCoordinates[1], blockedSet, visitedSet, 0);\n}",
    "output": "#include <bits/stdc++.h>\nconst int maxSteps= 200;\n\nbool depthFirstSearch(int currentX, int currentY, int targetX, int targetY, std::unordered_set<std::string> &blockedPositions, std::unordered_set<std::string> &visitedPositions, int stepCount)\n{\n    std::string currentPosition= std::to_string(currentX) + \"_\" + std::to_string(currentY);\n    if(currentX < 0 || currentX >= 1000000 || currentY < 0 || currentY >= 1000000 || stepCount >= maxSteps || blockedPositions.count(currentPosition) || visitedPositions.count(currentPosition))\n        return false;\n\n    if(currentX == targetX && currentY == targetY)\n        return true;\n\n    visitedPositions.insert(currentPosition);\n\n    if(depthFirstSearch(currentX + 1, currentY, targetX, targetY, blockedPositions, visitedPositions, stepCount + 1) ||\n       depthFirstSearch(currentX, currentY + 1, targetX, targetY, blockedPositions, visitedPositions, stepCount + 1) ||\n       depthFirstSearch(currentX - 1, currentY, targetX, targetY, blockedPositions, visitedPositions, stepCount + 1) ||\n       depthFirstSearch(currentX, currentY - 1, targetX, targetY, blockedPositions, visitedPositions, stepCount + 1))\n        return true;\n\n    return false;\n}\n\nbool isEscapePossible(std::vector<std::vector<int>> &blockedCells, std::vector<int> &sourceCoordinates, std::vector<int> &targetCoordinates)\n{\n    std::unordered_set<std::string> blockedSet, visitedSet;\n    for(auto &block : blockedCells)\n        blockedSet.insert(std::to_string(block[0]) + \"_\" + std::to_string(block[1]));\n\n    return depthFirstSearch(sourceCoordinates[0], sourceCoordinates[1], targetCoordinates[0], targetCoordinates[1], blockedSet, visitedSet, 0);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring defangIpAddress(string ipAddress)\n{\n    string defangedAddress = \"\";\n    for (int i = 0; i < ipAddress.size(); ++i)\n    {\n        char character = ipAddress[i];\n        if (character == '.')\n            defangedAddress += \"[.]\";\n        else\n            defangedAddress += character;\n    }\n    return defangedAddress;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string defangIpAddress(std::string ipAddress)\n{\n    std::string defangedAddress= \"\";\n    for(char character : ipAddress)\n    {\n        if(character == '.')\n            defangedAddress+= \"[.]\";\n        else\n            defangedAddress+= character;\n    }\n    return defangedAddress;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> corpFlightBookings(vector<vector<int>> &flightBookings, int totalSeats)\n{\n    vector<int> seatAllocations(totalSeats, 0);\n    for (int i = 0; i < flightBookings.size(); ++i)\n    {\n        auto &booking = flightBookings[i];\n        seatAllocations[booking[0] - 1] += booking[2];\n        if (booking[1] < totalSeats)\n        {\n            seatAllocations[booking[1]] -= booking[2];\n        }\n    }\n    for (int index = 1; index < totalSeats; ++index)\n    {\n        seatAllocations[index] += seatAllocations[index - 1];\n    }\n    return seatAllocations;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> corpFlightBookings(std::vector<std::vector<int>> &flightBookings, int totalSeats)\n{\n    std::vector<int> seatAllocations(totalSeats, 0);\n    for(auto &booking : flightBookings)\n    {\n        seatAllocations[booking[0] - 1]+= booking[2];\n        if(booking[1] < totalSeats)\n        {\n            seatAllocations[booking[1]]-= booking[2];\n        }\n    }\n    for(int index= 1; index < totalSeats; ++index)\n    {\n        seatAllocations[index]+= seatAllocations[index - 1];\n    }\n    return seatAllocations;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nvector<TreeNode *> deleteNodes(TreeNode *rootNode, vector<int> &nodesToDelete)\n{\n    set<int> nodesToDeleteSet(nodesToDelete.begin(), nodesToDelete.end());\n    vector<TreeNode *> remainingTrees;\n\n    function<TreeNode *(TreeNode *)> removeNodes= [&](TreeNode *currentNode) -> TreeNode *\n    {\n        if(currentNode == NULL)\n            return NULL;\n        currentNode->leftChild= removeNodes(currentNode->leftChild);\n        currentNode->rightChild= removeNodes(currentNode->rightChild);\n        if(nodesToDeleteSet.count(currentNode->value))\n        {\n            if(currentNode->leftChild)\n                remainingTrees.push_back(currentNode->leftChild);\n            if(currentNode->rightChild)\n                remainingTrees.push_back(currentNode->rightChild);\n            return NULL;\n        }\n        return currentNode;\n    };\n\n    if(removeNodes(rootNode))\n        remainingTrees.push_back(rootNode);\n    return remainingTrees;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nstd::vector<TreeNode *> deleteNodes(TreeNode *rootNode, std::vector<int> &nodesToDelete)\n{\n    std::set<int> nodesToDeleteSet(nodesToDelete.begin(), nodesToDelete.end());\n    std::vector<TreeNode *> remainingTrees;\n\n    std::function<TreeNode *(TreeNode *)> removeNodes= [&](TreeNode *currentNode) -> TreeNode *\n    {\n        if(currentNode == NULL)\n            return NULL;\n        currentNode->leftChild= removeNodes(currentNode->leftChild);\n        currentNode->rightChild= removeNodes(currentNode->rightChild);\n        if(nodesToDeleteSet.count(currentNode->value))\n        {\n            if(currentNode->leftChild)\n                remainingTrees.push_back(currentNode->leftChild);\n            if(currentNode->rightChild)\n                remainingTrees.push_back(currentNode->rightChild);\n            return NULL;\n        }\n        return currentNode;\n    };\n\n    if(removeNodes(rootNode))\n        remainingTrees.push_back(rootNode);\n    return remainingTrees;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minScoreTriangulation(vector<int> &polygonValues)\n{\n    int polygonSize= polygonValues.size();\n    vector<vector<int>> minimumScoreDP(polygonSize, vector<int>(polygonSize, 0));\n\n    for(int triangleLength= 3; triangleLength <= polygonSize; ++triangleLength)\n    {\n        for(int startIndex= 0; startIndex + triangleLength - 1 < polygonSize; ++startIndex)\n        {\n            int endIndex= startIndex + triangleLength - 1;\n            minimumScoreDP[startIndex][endIndex]= INT_MAX;\n            for(int midIndex= startIndex + 1; midIndex < endIndex; ++midIndex)\n            {\n                minimumScoreDP[startIndex][endIndex]= min(minimumScoreDP[startIndex][endIndex],\n                                                          polygonValues[startIndex] * polygonValues[endIndex] * polygonValues[midIndex] +\n                                                              minimumScoreDP[startIndex][midIndex] + minimumScoreDP[midIndex][endIndex]);\n            }\n        }\n    }\n\n    return minimumScoreDP[0][polygonSize - 1];\n}",
    "output": "#include <bits/stdc++.h>\nint minScoreTriangulation(std::vector<int> &polygonValues)\n{\n    int polygonSize= polygonValues.size();\n    std::vector<std::vector<int>> minimumScoreDP(polygonSize, std::vector<int>(polygonSize, 0));\n\n    for(int triangleLength= 3; triangleLength <= polygonSize; ++triangleLength)\n    {\n        for(int startIndex= 0; startIndex + triangleLength - 1 < polygonSize; ++startIndex)\n        {\n            int endIndex= startIndex + triangleLength - 1;\n            minimumScoreDP[startIndex][endIndex]= INT_MAX;\n            for(int midIndex= startIndex + 1; midIndex < endIndex; ++midIndex)\n            {\n                minimumScoreDP[startIndex][endIndex]= std::min(minimumScoreDP[startIndex][endIndex],\n                                                          polygonValues[startIndex] * polygonValues[endIndex] * polygonValues[midIndex] +\n                                                              minimumScoreDP[startIndex][midIndex] + minimumScoreDP[midIndex][endIndex]);\n            }\n        }\n    }\n\n    return minimumScoreDP[0][polygonSize - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int getNumberOfDays(int year, int month)\n{\n    if(month == 2)\n    {\n        if((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n            return 29;\n        return 28;\n    }\n    if(month == 4 || month == 6 || month == 9 || month == 11)\n        return 30;\n    return 31;\n}",
    "output": "int getNumberOfDays(int year, int month)\n{\n    if(month == 2)\n    {\n        if((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n            return 29;\n        return 28;\n    }\n    if(month == 4 || month == 6 || month == 9 || month == 11)\n        return 30;\n    return 31;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isRobotBounded(string instructions)\n{\n    int positionX = 0, positionY = 0, direction = 0;\n    vector<vector<int>> movement{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    for (int i = 0; i < instructions.size(); ++i)\n    {\n        char command = instructions[i];\n        if (command == 'G')\n        {\n            positionX += movement[direction][0];\n            positionY += movement[direction][1];\n        }\n        else if (command == 'L')\n        {\n            direction = (direction + 3) % 4;\n        }\n        else\n        {\n            direction = (direction + 1) % 4;\n        }\n    }\n\n    return (positionX == 0 && positionY == 0) || direction != 0;\n}",
    "output": "#include <bits/stdc++.h>\nbool isRobotBounded(std::string instructions)\n{\n    int positionX= 0, positionY= 0, direction= 0;\n    std::vector<std::vector<int>> movement{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    for(char command : instructions)\n    {\n        if(command == 'G')\n        {\n            positionX+= movement[direction][0];\n            positionY+= movement[direction][1];\n        }\n        else if(command == 'L')\n        {\n            direction= (direction + 3) % 4;\n        }\n        else\n        {\n            direction= (direction + 1) % 4;\n        }\n    }\n\n    return (positionX == 0 && positionY == 0) || direction != 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> gardenNoAdj(int numberOfGardens, vector<vector<int>> &gardenPaths)\n{\n    vector<unordered_set<int>> gardenGraph(numberOfGardens);\n    for (int i = 0; i < gardenPaths.size(); ++i)\n    {\n        gardenGraph[gardenPaths[i][0] - 1].insert(gardenPaths[i][1] - 1);\n        gardenGraph[gardenPaths[i][1] - 1].insert(gardenPaths[i][0] - 1);\n    }\n\n    vector<int> flowerAssignment(numberOfGardens);\n    for (int gardenIndex = 0; gardenIndex < numberOfGardens; ++gardenIndex)\n    {\n        unordered_set<int> usedFlowers;\n        for (int neighborIndex = 0; neighborIndex < gardenGraph[gardenIndex].size(); ++neighborIndex)\n        {\n            usedFlowers.insert(flowerAssignment[*next(gardenGraph[gardenIndex].begin(), neighborIndex)]);\n        }\n        for (int flowerType = 1; flowerType <= 4; ++flowerType)\n        {\n            if (usedFlowers.count(flowerType) == 0)\n            {\n                flowerAssignment[gardenIndex] = flowerType;\n                break;\n            }\n        }\n    }\n    return flowerAssignment;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> gardenNoAdj(int numberOfGardens, std::vector<std::vector<int>> &gardenPaths)\n{\n    std::vector<std::unordered_set<int>> gardenGraph(numberOfGardens);\n    for(const auto &path : gardenPaths)\n    {\n        gardenGraph[path[0] - 1].insert(path[1] - 1);\n        gardenGraph[path[1] - 1].insert(path[0] - 1);\n    }\n\n    std::vector<int> flowerAssignment(numberOfGardens);\n    for(int gardenIndex= 0; gardenIndex < numberOfGardens; ++gardenIndex)\n    {\n        std::unordered_set<int> usedFlowers;\n        for(int neighborIndex : gardenGraph[gardenIndex])\n        {\n            usedFlowers.insert(flowerAssignment[neighborIndex]);\n        }\n        for(int flowerType= 1; flowerType <= 4; ++flowerType)\n        {\n            if(usedFlowers.count(flowerType) == 0)\n            {\n                flowerAssignment[gardenIndex]= flowerType;\n                break;\n            }\n        }\n    }\n    return flowerAssignment;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumAfterPartitioning(vector<int> &inputArray, int partitionSize)\n{\n    int arraySize= inputArray.size();\n    vector<int> dynamicProgramming(arraySize + 1, 0);\n    for(int currentIndex= 1; currentIndex <= arraySize; ++currentIndex)\n    {\n        int currentMax= 0;\n        for(int partitionIndex= 1; partitionIndex <= partitionSize && currentIndex - partitionIndex >= 0; ++partitionIndex)\n        {\n            currentMax= max(currentMax, inputArray[currentIndex - partitionIndex]);\n            dynamicProgramming[currentIndex]= max(dynamicProgramming[currentIndex], dynamicProgramming[currentIndex - partitionIndex] + currentMax * partitionIndex);\n        }\n    }\n    return dynamicProgramming[arraySize];\n}",
    "output": "#include <bits/stdc++.h>\nint maxSumAfterPartitioning(std::vector<int> &inputArray, int partitionSize)\n{\n    int arraySize = inputArray.size();\n    std::vector<int> dynamicProgramming(arraySize + 1, 0);\n    for(int currentIndex = 1; currentIndex <= arraySize; ++currentIndex)\n    {\n        int currentMax = 0;\n        for(int partitionIndex = 1; partitionIndex <= partitionSize && currentIndex - partitionIndex >= 0; ++partitionIndex)\n        {\n            currentMax = std::max(currentMax, inputArray[currentIndex - partitionIndex]);\n            dynamicProgramming[currentIndex] = std::max(dynamicProgramming[currentIndex], dynamicProgramming[currentIndex - partitionIndex] + currentMax * partitionIndex);\n        }\n    }\n    return dynamicProgramming[arraySize];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring longestDupSubstring(string inputString)\n{\n    int stringLength = inputString.length();\n    string longestDuplicateSubstring;\n    for(int currentLength = stringLength - 1; currentLength > 0; --currentLength)\n    {\n        for(int startIndex = 0; startIndex <= stringLength - currentLength; ++startIndex)\n        {\n            string currentSubstring = inputString.substr(startIndex, currentLength);\n            if(inputString.find(currentSubstring, startIndex + 1) != string::npos)\n            {\n                longestDuplicateSubstring = currentSubstring;\n                return longestDuplicateSubstring;\n            }\n        }\n    }\n    return longestDuplicateSubstring;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string longestDupSubstring(std::string inputString)\n{\n    int stringLength= inputString.length();\n    std::string longestDuplicateSubstring;\n    for(int currentLength= stringLength - 1; currentLength > 0; --currentLength)\n    {\n        for(int startIndex= 0; startIndex <= stringLength - currentLength; ++startIndex)\n        {\n            std::string currentSubstring= inputString.substr(startIndex, currentLength);\n            if(inputString.find(currentSubstring, startIndex + 1) != std::string::npos)\n            {\n                longestDuplicateSubstring= currentSubstring;\n                return longestDuplicateSubstring;\n            }\n        }\n    }\n    return longestDuplicateSubstring;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\npair<TreeNode *, int> findLCAUtil(TreeNode *currentNode)\n{\n    if(currentNode == NULL)\n    {\n        return {NULL, 0};\n    }\n\n    pair<TreeNode *, int> leftLCA = findLCAUtil(currentNode->leftChild);\n    pair<TreeNode *, int> rightLCA = findLCAUtil(currentNode->rightChild);\n\n    if(leftLCA.second > rightLCA.second)\n    {\n        return {leftLCA.first, leftLCA.second + 1};\n    }\n    else if(leftLCA.second < rightLCA.second)\n    {\n        return {rightLCA.first, rightLCA.second + 1};\n    }\n    else\n    {\n        return {currentNode, leftLCA.second + 1};\n    }\n}\n\nTreeNode *lCADeepestLeaves(TreeNode *rootNode)\n{\n    return findLCAUtil(rootNode).first;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nstd::pair<TreeNode *, int> findLCAUtil(TreeNode *currentNode)\n{\n    if(currentNode == NULL)\n    {\n        return {NULL, 0};\n    }\n\n    std::pair<TreeNode *, int> leftLCA= findLCAUtil(currentNode->leftChild);\n    std::pair<TreeNode *, int> rightLCA= findLCAUtil(currentNode->rightChild);\n\n    if(leftLCA.second > rightLCA.second)\n    {\n        return {leftLCA.first, leftLCA.second + 1};\n    }\n    else if(leftLCA.second < rightLCA.second)\n    {\n        return {rightLCA.first, rightLCA.second + 1};\n    }\n    else\n    {\n        return {currentNode, leftLCA.second + 1};\n    }\n}\n\nTreeNode *lCADeepestLeaves(TreeNode *rootNode)\n{\n    return findLCAUtil(rootNode).first;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint longestWellPerformingInterval(vector<int> &workHours)\n{\n    int cumulativeSum = 0;\n    int longestInterval = 0;\n    unordered_map<int, int> firstSumIndex;\n\n    for(int currentIndex = 0; currentIndex < workHours.size(); ++currentIndex)\n    {\n        cumulativeSum += (workHours[currentIndex] > 8) ? 1 : -1;\n        if(cumulativeSum > 0)\n        {\n            longestInterval = currentIndex + 1;\n        }\n        else\n        {\n            if(firstSumIndex.find(cumulativeSum - 1) != firstSumIndex.end())\n            {\n                longestInterval = max(longestInterval, currentIndex - firstSumIndex[cumulativeSum - 1]);\n            }\n            if(firstSumIndex.find(cumulativeSum) == firstSumIndex.end())\n            {\n                firstSumIndex[cumulativeSum] = currentIndex;\n            }\n        }\n    }\n    return longestInterval;\n}",
    "output": "#include <bits/stdc++.h>\nint longestWellPerformingInterval(std::vector<int> &workHours)\n{\n    int cumulativeSum= 0;\n    int longestInterval= 0;\n    std::unordered_map<int, int> firstSumIndex;\n\n    for(int currentIndex= 0; currentIndex < workHours.size(); ++currentIndex)\n    {\n        cumulativeSum+= (workHours[currentIndex] > 8) ? 1 : -1;\n        if(cumulativeSum > 0)\n        {\n            longestInterval= currentIndex + 1;\n        }\n        else\n        {\n            if(firstSumIndex.find(cumulativeSum - 1) != firstSumIndex.end())\n            {\n                longestInterval= std::max(longestInterval, currentIndex - firstSumIndex[cumulativeSum - 1]);\n            }\n            if(firstSumIndex.find(cumulativeSum) == firstSumIndex.end())\n            {\n                firstSumIndex[cumulativeSum]= currentIndex;\n            }\n        }\n    }\n    return longestInterval;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> smallestSufficientTeam(vector<string> &requiredSkills, vector<vector<string>> &people)\n{\n    unordered_map<int, string> skillIdMap;\n    unordered_map<string, int> idSkillMap;\n    int skillIndex = 0;\n    for (int i = 0; i < requiredSkills.size(); ++i)\n    {\n        const auto &skill = requiredSkills[i];\n        idSkillMap[skill] = skillIndex++;\n        skillIdMap[skillIndex - 1] = skill;\n    }\n\n    vector<int> result;\n    vector<bitset<16>> dynamicProgramming(1 << skillIndex, bitset<16>());\n    vector<int> previousMask(1 << skillIndex, -1);\n    dynamicProgramming[0].set(31);\n\n    int peopleCount = people.size();\n    for (int personIndex = 0; personIndex < peopleCount; ++personIndex)\n    {\n        int skillMask = 0;\n        for (int i = 0; i < people[personIndex].size(); ++i)\n        {\n            const auto &skill = people[personIndex][i];\n            skillMask |= 1 << idSkillMap[skill];\n        }\n        for (int currentMask = (1 << skillIndex) - 1; currentMask >= 0; --currentMask)\n        {\n            int nextMask = currentMask | skillMask;\n            if (dynamicProgramming[nextMask].count() > dynamicProgramming[currentMask].count() + 1)\n            {\n                dynamicProgramming[nextMask] = dynamicProgramming[currentMask];\n                dynamicProgramming[nextMask].set(personIndex);\n                previousMask[nextMask] = currentMask;\n            }\n        }\n    }\n\n    int finalMask = (1 << skillIndex) - 1;\n    while (finalMask != 0)\n    {\n        int previousSkillMask = previousMask[finalMask];\n        int maskDifference = finalMask ^ previousSkillMask;\n        int skillId = log2(maskDifference);\n        result.push_back(skillId);\n        finalMask = previousSkillMask;\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> smallestSufficientTeam(std::vector<std::string> &requiredSkills, std::vector<std::vector<std::string>> &people)\n{\n    std::unordered_map<int, std::string> skillIdMap;\n    std::unordered_map<std::string, int> idSkillMap;\n    int skillIndex= 0;\n    for(const auto &skill : requiredSkills)\n    {\n        idSkillMap[skill]= skillIndex++;\n        skillIdMap[skillIndex - 1]= skill;\n    }\n\n    std::vector<int> result;\n    std::vector<std::bitset<16>> dynamicProgramming(1 << skillIndex, std::bitset<16>());\n    std::vector<int> previousMask(1 << skillIndex, -1);\n    dynamicProgramming[0].set(31);\n\n    int peopleCount= people.size();\n    for(int personIndex= 0; personIndex < peopleCount; ++personIndex)\n    {\n        int skillMask= 0;\n        for(const auto &skill : people[personIndex])\n        {\n            skillMask|= 1 << idSkillMap[skill];\n        }\n        for(int currentMask= (1 << skillIndex) - 1; currentMask >= 0; --currentMask)\n        {\n            int nextMask= currentMask | skillMask;\n            if(dynamicProgramming[nextMask].count() > dynamicProgramming[currentMask].count() + 1)\n            {\n                dynamicProgramming[nextMask]= dynamicProgramming[currentMask];\n                dynamicProgramming[nextMask].set(personIndex);\n                previousMask[nextMask]= currentMask;\n            }\n        }\n    }\n\n    int finalMask= (1 << skillIndex) - 1;\n    while(finalMask != 0)\n    {\n        int previousSkillMask= previousMask[finalMask];\n        int maskDifference= finalMask ^ previousSkillMask;\n        int skillId= log2(maskDifference);\n        result.push_back(skillId);\n        finalMask= previousSkillMask;\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring removeDuplicates(string inputString)\n{\n    stack<char> characterStack;\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentCharacter = inputString[i];\n        if (!characterStack.empty() && characterStack.top() == currentCharacter)\n        {\n            characterStack.pop();\n        }\n        else\n        {\n            characterStack.push(currentCharacter);\n        }\n    }\n\n    string resultString;\n    while (!characterStack.empty())\n    {\n        resultString = characterStack.top() + resultString;\n        characterStack.pop();\n    }\n\n    return resultString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string removeDuplicates(std::string inputString)\n{\n    std::stack<char> characterStack;\n    for(char currentCharacter : inputString)\n    {\n        if(!characterStack.empty() && characterStack.top() == currentCharacter)\n        {\n            characterStack.pop();\n        }\n        else\n        {\n            characterStack.push(currentCharacter);\n        }\n    }\n\n    std::string resultString;\n    while(!characterStack.empty())\n    {\n        resultString= characterStack.top() + resultString;\n        characterStack.pop();\n    }\n\n    return resultString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint longestStrChain(vector<string> &wordList)\n{\n    sort(wordList.begin(), wordList.end(), [](const string &firstWord, const string &secondWord)\n         { return firstWord.size() < secondWord.size(); });\n\n    unordered_map<string, int> wordChainLength;\n    int maximumLength = 0;\n\n    for (int i = 0; i < wordList.size(); ++i)\n    {\n        const string &currentWord = wordList[i];\n        for (int index = 0; index < currentWord.size(); ++index)\n        {\n            string predecessor = currentWord.substr(0, index) + currentWord.substr(index + 1);\n            wordChainLength[currentWord] = max(wordChainLength[currentWord], wordChainLength[predecessor] + 1);\n        }\n        maximumLength = max(maximumLength, wordChainLength[currentWord]);\n    }\n\n    return maximumLength;\n}",
    "output": "#include <bits/stdc++.h>\nint longestStrChain(std::vector<std::string> &wordList)\n{\n    std::sort(wordList.begin(), wordList.end(), [](const std::string &firstWord, const std::string &secondWord)\n         { return firstWord.size() < secondWord.size(); });\n\n    std::unordered_map<std::string, int> wordChainLength;\n    int maximumLength= 0;\n\n    for(const std::string &currentWord : wordList)\n    {\n        for(int index= 0; index < currentWord.size(); ++index)\n        {\n            std::string predecessor= currentWord.substr(0, index) + currentWord.substr(index + 1);\n            wordChainLength[currentWord]= std::max(wordChainLength[currentWord], wordChainLength[predecessor] + 1);\n        }\n        maximumLength= std::max(maximumLength, wordChainLength[currentWord]);\n    }\n\n    return maximumLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint lastStoneWeight(vector<int> &stoneWeights)\n{\n    priority_queue<int> priorityQueue(stoneWeights.begin(), stoneWeights.end());\n    while(priorityQueue.size() > 1)\n    {\n        int heaviestStone= priorityQueue.top();\n        priorityQueue.pop();\n        int secondHeaviestStone= priorityQueue.top();\n        priorityQueue.pop();\n        if(heaviestStone != secondHeaviestStone)\n        {\n            priorityQueue.push(secondHeaviestStone - heaviestStone);\n        }\n    }\n    return priorityQueue.empty() ? 0 : priorityQueue.top();\n}",
    "output": "#include <bits/stdc++.h>\nint lastStoneWeight(std::vector<int> &stoneWeights)\n{\n    std::priority_queue<int> priorityQueue(stoneWeights.begin(), stoneWeights.end());\n    while(priorityQueue.size() > 1)\n    {\n        int heaviestStone= priorityQueue.top();\n        priorityQueue.pop();\n        int secondHeaviestStone= priorityQueue.top();\n        priorityQueue.pop();\n        if(heaviestStone != secondHeaviestStone)\n        {\n            priorityQueue.push(secondHeaviestStone - heaviestStone);\n        }\n    }\n    return priorityQueue.empty() ? 0 : priorityQueue.top();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For INT_MIN\nusing namespace std;\n\nint maxAbsoluteValueExpression(vector<int> &firstArray, vector<int> &secondArray)\n{\n    int maxResult= 0;\n    int maxSum[4]= {INT_MIN, INT_MIN, INT_MIN, INT_MIN};\n\n    for(int index= 0; index < firstArray.size(); ++index)\n    {\n        maxSum[0]= max(maxSum[0], firstArray[index] + secondArray[index] + index);\n        maxSum[1]= max(maxSum[1], firstArray[index] - secondArray[index] + index);\n        maxSum[2]= max(maxSum[2], -firstArray[index] + secondArray[index] + index);\n        maxSum[3]= max(maxSum[3], -firstArray[index] - secondArray[index] + index);\n    }\n\n    for(int index= 0; index < firstArray.size(); ++index)\n    {\n        maxResult= max(maxResult, maxSum[0] - firstArray[index] - secondArray[index] - index);\n        maxResult= max(maxResult, maxSum[1] - firstArray[index] + secondArray[index] - index);\n        maxResult= max(maxResult, maxSum[2] + firstArray[index] - secondArray[index] - index);\n        maxResult= max(maxResult, maxSum[3] + firstArray[index] + secondArray[index] - index);\n    }\n\n    return maxResult;\n}",
    "output": "#include <bits/stdc++.h>\nint maxAbsoluteValueExpression(std::vector<int> &firstArray, std::vector<int> &secondArray)\n{\n    int maxResult= 0;\n    int maxSum[4]= {std::numeric_limits<int>::min(), std::numeric_limits<int>::min(), std::numeric_limits<int>::min(), std::numeric_limits<int>::min()};\n\n    for(int index= 0; index < firstArray.size(); ++index)\n    {\n        maxSum[0]= std::max(maxSum[0], firstArray[index] + secondArray[index] + index);\n        maxSum[1]= std::max(maxSum[1], firstArray[index] - secondArray[index] + index);\n        maxSum[2]= std::max(maxSum[2], -firstArray[index] + secondArray[index] + index);\n        maxSum[3]= std::max(maxSum[3], -firstArray[index] - secondArray[index] + index);\n    }\n\n    for(int index= 0; index < firstArray.size(); ++index)\n    {\n        maxResult= std::max(maxResult, maxSum[0] - firstArray[index] - secondArray[index] - index);\n        maxResult= std::max(maxResult, maxSum[1] - firstArray[index] + secondArray[index] - index);\n        maxResult= std::max(maxResult, maxSum[2] + firstArray[index] - secondArray[index] - index);\n        maxResult= std::max(maxResult, maxSum[3] + firstArray[index] + secondArray[index] - index);\n    }\n\n    return maxResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring lastSubstring(string inputString)\n{\n    int firstIndex= 0, secondIndex= 1, offset= 0, stringLength= inputString.length();\n    while(secondIndex + offset < stringLength)\n    {\n        if(inputString[firstIndex + offset] == inputString[secondIndex + offset])\n        {\n            offset++;\n        }\n        else if(inputString[firstIndex + offset] < inputString[secondIndex + offset])\n        {\n            firstIndex= secondIndex;\n            secondIndex++;\n            offset= 0;\n        }\n        else\n        {\n            secondIndex++;\n            offset= 0;\n        }\n    }\n    return inputString.substr(firstIndex);\n}",
    "output": "std::string lastSubstring(std::string inputString)\n{\n    int firstIndex= 0, secondIndex= 1, offset= 0, stringLength= inputString.length();\n    while(secondIndex + offset < stringLength)\n    {\n        if(inputString[firstIndex + offset] == inputString[secondIndex + offset])\n        {\n            offset++;\n        }\n        else if(inputString[firstIndex + offset] < inputString[secondIndex + offset])\n        {\n            firstIndex= secondIndex;\n            secondIndex++;\n            offset= 0;\n        }\n        else\n        {\n            secondIndex++;\n            offset= 0;\n        }\n    }\n    return inputString.substr(firstIndex);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isArmstrong(int number)\n{\n    int powerSum= 0, originalNumber= number;\n    int digitCount= to_string(number).length();\n    while(number > 0)\n    {\n        int digit= number % 10;\n        powerSum+= pow(digit, digitCount);\n        number/= 10;\n    }\n    return powerSum == originalNumber;\n}",
    "output": "#include <bits/stdc++.h>\nbool isArmstrong(int number)\n{\n    int powerSum= 0, originalNumber= number;\n    int digitCount= std::to_string(number).length();\n    while(number > 0)\n    {\n        int digit= number % 10;\n        powerSum+= std::pow(digit, digitCount);\n        number/= 10;\n    }\n    return powerSum == originalNumber;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findParent(vector<int> &parentArray, int node)\n{\n    if(parentArray[node] != node)\n    {\n        parentArray[node] = findParent(parentArray, parentArray[node]);\n    }\n    return parentArray[node];\n}\n\nint minimumCost(int numberOfNodes, vector<vector<int>> &connections)\n{\n    sort(connections.begin(), connections.end(), [](const vector<int> &a, const vector<int> &b)\n         { return a[2] < b[2]; });\n\n    vector<int> parentArray(numberOfNodes + 1);\n    for(int index = 1; index <= numberOfNodes; ++index)\n    {\n        parentArray[index] = index;\n    }\n\n    int totalCost = 0;\n    int edgeCount = 0;\n    for(int i = 0; i < connections.size(); ++i)\n    {\n        const auto &connection = connections[i];\n        int rootNodeX = findParent(parentArray, connection[0]);\n        int rootNodeY = findParent(parentArray, connection[1]);\n\n        if(rootNodeX != rootNodeY)\n        {\n            parentArray[rootNodeY] = rootNodeX;\n            totalCost += connection[2];\n            edgeCount += 1;\n        }\n\n        if(edgeCount == numberOfNodes - 1)\n        {\n            break;\n        }\n    }\n\n    return edgeCount == numberOfNodes - 1 ? totalCost : -1;\n}",
    "output": "#include <bits/stdc++.h>\nint findParent(std::vector<int> &parentArray, int node)\n{\n    if(parentArray[node] != node)\n    {\n        parentArray[node]= findParent(parentArray, parentArray[node]);\n    }\n    return parentArray[node];\n}\n\nint minimumCost(int numberOfNodes, std::vector<std::vector<int>> &connections)\n{\n    std::sort(connections.begin(), connections.end(), [](const std::vector<int> &a, const std::vector<int> &b)\n              { return a[2] < b[2]; });\n\n    std::vector<int> parentArray(numberOfNodes + 1);\n    for(int index= 1; index <= numberOfNodes; ++index)\n    {\n        parentArray[index]= index;\n    }\n\n    int totalCost= 0;\n    int edgeCount= 0;\n    for(const auto &connection : connections)\n    {\n        int rootNodeX= findParent(parentArray, connection[0]);\n        int rootNodeY= findParent(parentArray, connection[1]);\n\n        if(rootNodeX != rootNodeY)\n        {\n            parentArray[rootNodeY]= rootNodeX;\n            totalCost+= connection[2];\n            edgeCount+= 1;\n        }\n\n        if(edgeCount == numberOfNodes - 1)\n        {\n            break;\n        }\n    }\n\n    return edgeCount == numberOfNodes - 1 ? totalCost : -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumSemesters(int totalCourses, vector<vector<int>> &courseRelations)\n{\n    vector<int> inDegree(totalCourses + 1, 0);\n    vector<vector<int>> courseGraph(totalCourses + 1);\n\n    for (const auto &relation : courseRelations)\n    {\n        courseGraph[relation[0]].push_back(relation[1]);\n        inDegree[relation[1]]++;\n    }\n\n    queue<int> courseQueue;\n    for (int i = 1; i <= totalCourses; i++)\n    {\n        if (inDegree[i] == 0)\n        {\n            courseQueue.push(i);\n        }\n    }\n\n    int totalSemesters = 0;\n    while (!courseQueue.empty())\n    {\n        int currentSize = courseQueue.size();\n        totalSemesters++;\n        while (currentSize--)\n        {\n            int currentCourse = courseQueue.front();\n            courseQueue.pop();\n            totalCourses--;\n\n            for (int j = 0; j < courseGraph[currentCourse].size(); ++j)\n            {\n                int nextCourse = courseGraph[currentCourse][j];\n                if (--inDegree[nextCourse] == 0)\n                {\n                    courseQueue.push(nextCourse);\n                }\n            }\n        }\n    }\n\n    return totalCourses == 0 ? totalSemesters : -1;\n}",
    "output": "#include <bits/stdc++.h>\nint minimumSemesters(int totalCourses, std::vector<std::vector<int>> &courseRelations)\n{\n    std::vector<int> inDegree(totalCourses + 1, 0);\n    std::vector<std::vector<int>> courseGraph(totalCourses + 1);\n\n    for(auto &relation : courseRelations)\n    {\n        courseGraph[relation[0]].push_back(relation[1]);\n        inDegree[relation[1]]++;\n    }\n\n    std::queue<int> courseQueue;\n    for(int i= 1; i <= totalCourses; i++)\n    {\n        if(inDegree[i] == 0)\n        {\n            courseQueue.push(i);\n        }\n    }\n\n    int totalSemesters= 0;\n    while(!courseQueue.empty())\n    {\n        int currentSize= courseQueue.size();\n        totalSemesters++;\n        while(currentSize--)\n        {\n            int currentCourse= courseQueue.front();\n            courseQueue.pop();\n            totalCourses--;\n\n            for(int nextCourse : courseGraph[currentCourse])\n            {\n                if(--inDegree[nextCourse] == 0)\n                {\n                    courseQueue.push(nextCourse);\n                }\n            }\n        }\n    }\n\n    return totalCourses == 0 ? totalSemesters : -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint heightChecker(vector<int> &currentHeights)\n{\n    vector<int> expectedHeights = currentHeights;\n    sort(expectedHeights.begin(), expectedHeights.end());\n    int mismatchCount = 0;\n    for(size_t index = 0; index < currentHeights.size(); index++)\n    {\n        if(currentHeights[index] != expectedHeights[index])\n        {\n            mismatchCount++;\n        }\n    }\n    return mismatchCount;\n}",
    "output": "#include <bits/stdc++.h>\nint heightChecker(std::vector<int> &currentHeights)\n{\n    std::vector<int> expectedHeights= currentHeights;\n    std::sort(expectedHeights.begin(), expectedHeights.end());\n    int mismatchCount= 0;\n    for(size_t index= 0; index < currentHeights.size(); index++)\n    {\n        if(currentHeights[index] != expectedHeights[index])\n        {\n            mismatchCount++;\n        }\n    }\n    return mismatchCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSatisfiedCustomers(vector<int> &customerCounts, vector<int> &grumpyStatus, int timeWindow)\n{\n    int totalSatisfied= 0, maxAdditionalSatisfaction= 0, currentWindowIncrease= 0;\n    for(int currentIndex= 0, startIndex= 0; currentIndex < customerCounts.size(); ++currentIndex)\n    {\n        if(currentIndex - startIndex == timeWindow)\n        {\n            currentWindowIncrease-= customerCounts[startIndex] * grumpyStatus[startIndex];\n            ++startIndex;\n        }\n        currentWindowIncrease+= customerCounts[currentIndex] * grumpyStatus[currentIndex];\n        totalSatisfied+= customerCounts[currentIndex] * (1 - grumpyStatus[currentIndex]);\n        maxAdditionalSatisfaction= max(maxAdditionalSatisfaction, currentWindowIncrease);\n    }\n    return totalSatisfied + maxAdditionalSatisfaction;\n}",
    "output": "#include <bits/stdc++.h>\nint maxSatisfiedCustomers(std::vector<int> &customerCounts, std::vector<int> &grumpyStatus, int timeWindow)\n{\n    int totalSatisfied= 0, maxAdditionalSatisfaction= 0, currentWindowIncrease= 0;\n    for(int currentIndex= 0, startIndex= 0; currentIndex < customerCounts.size(); ++currentIndex)\n    {\n        if(currentIndex - startIndex == timeWindow)\n        {\n            currentWindowIncrease-= customerCounts[startIndex] * grumpyStatus[startIndex];\n            ++startIndex;\n        }\n        currentWindowIncrease+= customerCounts[currentIndex] * grumpyStatus[currentIndex];\n        totalSatisfied+= customerCounts[currentIndex] * (1 - grumpyStatus[currentIndex]);\n        maxAdditionalSatisfaction= std::max(maxAdditionalSatisfaction, currentWindowIncrease);\n    }\n    return totalSatisfied + maxAdditionalSatisfaction;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> previousPermutationOptimized(vector<int> &numberList)\n{\n    int size = numberList.size();\n    for(int currentIndex = size - 2; currentIndex >= 0; currentIndex--)\n    {\n        if(numberList[currentIndex] > numberList[currentIndex + 1])\n        {\n            int nextIndex = currentIndex + 1;\n            while(nextIndex < size && numberList[nextIndex] < numberList[currentIndex])\n                nextIndex++;\n            swap(numberList[currentIndex], numberList[nextIndex - 1]);\n            return numberList;\n        }\n    }\n    return numberList;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> previousPermutationOptimized(std::vector<int> &numberList)\n{\n    int size= numberList.size();\n    for(int currentIndex= size - 2; currentIndex >= 0; currentIndex--)\n    {\n        if(numberList[currentIndex] > numberList[currentIndex + 1])\n        {\n            int nextIndex= currentIndex + 1;\n            while(nextIndex < size && numberList[nextIndex] < numberList[currentIndex])\n                nextIndex++;\n            std::swap(numberList[currentIndex], numberList[nextIndex - 1]);\n            return numberList;\n        }\n    }\n    return numberList;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> rearrangeBarcodes(vector<int> &barcodes)\n{\n    int totalBarcodes= barcodes.size();\n    vector<int> frequencyCount(10001, 0);\n    for(int i= 0; i < totalBarcodes; ++i)\n    {\n        ++frequencyCount[barcodes[i]];\n    }\n\n    auto comparator= [](const pair<int, int> &a, const pair<int, int> &b)\n    { return a.second < b.second; };\n    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comparator)> priorityQueue(comparator);\n    for(int i= 1; i <= 10000; ++i)\n    {\n        if(frequencyCount[i] > 0)\n        {\n            priorityQueue.push({i, frequencyCount[i]});\n        }\n    }\n\n    int currentIndex= 0;\n    while(!priorityQueue.empty())\n    {\n        auto currentPair= priorityQueue.top();\n        priorityQueue.pop();\n        while(currentPair.second > 0)\n        {\n            barcodes[currentIndex]= currentPair.first;\n            currentPair.second--;\n            currentIndex+= 2;\n            if(currentIndex >= totalBarcodes)\n            {\n                currentIndex= 1;\n            }\n        }\n    }\n    return barcodes;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> rearrangeBarcodes(std::vector<int> &barcodes)\n{\n    int totalBarcodes = barcodes.size();\n    std::vector<int> frequencyCount(10001, 0);\n    for(int i = 0; i < totalBarcodes; ++i)\n    {\n        ++frequencyCount[barcodes[i]];\n    }\n\n    auto comparator = [](const std::pair<int, int> &a, const std::pair<int, int> &b)\n    { return a.second < b.second; };\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, decltype(comparator)> priorityQueue(comparator);\n    for(int i = 1; i <= 10000; ++i)\n    {\n        if(frequencyCount[i] > 0)\n        {\n            priorityQueue.push({i, frequencyCount[i]});\n        }\n    }\n\n    int currentIndex = 0;\n    while(!priorityQueue.empty())\n    {\n        auto currentPair = priorityQueue.top();\n        priorityQueue.pop();\n        while(currentPair.second > 0)\n        {\n            barcodes[currentIndex] = currentPair.first;\n            currentPair.second--;\n            currentIndex += 2;\n            if(currentIndex >= totalBarcodes)\n            {\n                currentIndex = 1;\n            }\n        }\n    }\n    return barcodes;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint longestCommonSubsequence(string firstText, string secondText)\n{\n    int firstTextLength= firstText.size();\n    int secondTextLength= secondText.size();\n    vector<vector<int>> dynamicProgrammingTable(firstTextLength + 1, vector<int>(secondTextLength + 1));\n    for(int rowIndex= 1; rowIndex <= firstTextLength; rowIndex++)\n    {\n        for(int columnIndex= 1; columnIndex <= secondTextLength; columnIndex++)\n        {\n            if(firstText[rowIndex - 1] == secondText[columnIndex - 1])\n            {\n                dynamicProgrammingTable[rowIndex][columnIndex]= dynamicProgrammingTable[rowIndex - 1][columnIndex - 1] + 1;\n            }\n            else\n            {\n                dynamicProgrammingTable[rowIndex][columnIndex]= max(dynamicProgrammingTable[rowIndex - 1][columnIndex], dynamicProgrammingTable[rowIndex][columnIndex - 1]);\n            }\n        }\n    }\n    return dynamicProgrammingTable[firstTextLength][secondTextLength];\n}",
    "output": "#include <bits/stdc++.h>\nint longestCommonSubsequence(std::string firstText, std::string secondText)\n{\n    int firstTextLength= firstText.size();\n    int secondTextLength= secondText.size();\n    std::vector<std::vector<int>> dynamicProgrammingTable(firstTextLength + 1, std::vector<int>(secondTextLength + 1));\n    for(int rowIndex= 1; rowIndex <= firstTextLength; rowIndex++)\n    {\n        for(int columnIndex= 1; columnIndex <= secondTextLength; columnIndex++)\n        {\n            if(firstText[rowIndex - 1] == secondText[columnIndex - 1])\n            {\n                dynamicProgrammingTable[rowIndex][columnIndex]= dynamicProgrammingTable[rowIndex - 1][columnIndex - 1] + 1;\n            }\n            else\n            {\n                dynamicProgrammingTable[rowIndex][columnIndex]= std::max(dynamicProgrammingTable[rowIndex - 1][columnIndex], dynamicProgrammingTable[rowIndex][columnIndex - 1]);\n            }\n        }\n    }\n    return dynamicProgrammingTable[firstTextLength][secondTextLength];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint movesToMakeZigzag(vector<int> &numberList)\n{\n    int evenMoves= 0, oddMoves= 0;\n    for(int index= 0; index < numberList.size(); index++)\n    {\n        int leftNeighbor= index > 0 ? numberList[index - 1] : 1001;\n        int rightNeighbor= index < numberList.size() - 1 ? numberList[index + 1] : 1001;\n        int minimumValue= min(leftNeighbor, rightNeighbor);\n        if(numberList[index] >= minimumValue)\n        {\n            if(index % 2 == 0)\n            {\n                evenMoves+= numberList[index] - minimumValue + 1;\n            }\n            else\n            {\n                oddMoves+= numberList[index] - minimumValue + 1;\n            }\n        }\n    }\n    return min(evenMoves, oddMoves);\n}",
    "output": "int movesToMakeZigzag(std::vector<int> &numberList)\n{\n    int evenMoves= 0, oddMoves= 0;\n    for(int index= 0; index < numberList.size(); index++)\n    {\n        int leftNeighbor= index > 0 ? numberList[index - 1] : 1001;\n        int rightNeighbor= index < numberList.size() - 1 ? numberList[index + 1] : 1001;\n        int minimumValue= std::min(leftNeighbor, rightNeighbor);\n        if(numberList[index] >= minimumValue)\n        {\n            if(index % 2 == 0)\n            {\n                evenMoves+= numberList[index] - minimumValue + 1;\n            }\n            else\n            {\n                oddMoves+= numberList[index] - minimumValue + 1;\n            }\n        }\n    }\n    return std::min(evenMoves, oddMoves);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nint countNodes(TreeNode *currentNode)\n{\n    if(!currentNode)\n        return 0;\n    return countNodes(currentNode->leftChild) + countNodes(currentNode->rightChild) + 1;\n}\n\nbool btreeGameWinningMove(TreeNode *rootNode, int totalNodes, int targetValue)\n{\n    TreeNode *targetNode= findNode(rootNode, targetValue);\n    int leftChildNodes= countNodes(targetNode->leftChild);\n    int rightChildNodes= countNodes(targetNode->rightChild);\n    int parentNodes= totalNodes - leftChildNodes - rightChildNodes - 1;\n\n    return max(max(leftChildNodes, rightChildNodes), parentNodes) > totalNodes / 2;\n}\n\nTreeNode *findNode(TreeNode *currentNode, int targetValue)\n{\n    if(!currentNode)\n        return NULL;\n    if(currentNode->value == targetValue)\n        return currentNode;\n    TreeNode *leftSearchResult= findNode(currentNode->leftChild, targetValue);\n    if(leftSearchResult)\n        return leftSearchResult;\n    return findNode(currentNode->rightChild, targetValue);\n}",
    "output": "#include <bits/stdc++.h>\nclass TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nint countNodes(TreeNode *currentNode)\n{\n    if(!currentNode)\n        return 0;\n    return countNodes(currentNode->leftChild) + countNodes(currentNode->rightChild) + 1;\n}\n\nbool btreeGameWinningMove(TreeNode *rootNode, int totalNodes, int targetValue)\n{\n    TreeNode *targetNode= findNode(rootNode, targetValue);\n    int leftChildNodes= countNodes(targetNode->leftChild);\n    int rightChildNodes= countNodes(targetNode->rightChild);\n    int parentNodes= totalNodes - leftChildNodes - rightChildNodes - 1;\n\n    return std::max(std::max(leftChildNodes, rightChildNodes), parentNodes) > totalNodes / 2;\n}\n\nTreeNode *findNode(TreeNode *currentNode, int targetValue)\n{\n    if(!currentNode)\n        return NULL;\n    if(currentNode->value == targetValue)\n        return currentNode;\n    TreeNode *leftSearchResult= findNode(currentNode->leftChild, targetValue);\n    if(leftSearchResult)\n        return leftSearchResult;\n    return findNode(currentNode->rightChild, targetValue);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring gcdOfStrings(string firstString, string secondString)\n{\n    if(firstString + secondString != secondString + firstString)\n    {\n        return \"\";\n    }\n    int greatestCommonDivisor = __gcd(firstString.size(), secondString.size());\n    return firstString.substr(0, greatestCommonDivisor);\n}\n",
    "output": "#include <bits/stdc++.h>\nstd::string gcdOfStrings(std::string firstString, std::string secondString)\n{\n    if(firstString + secondString != secondString + firstString)\n    {\n        return \"\";\n    }\n    int greatestCommonDivisor= std::__gcd(firstString.size(), secondString.size());\n    return firstString.substr(0, greatestCommonDivisor);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxEqualRowsAfterFlips(vector<vector<int>> &matrix)\n{\n    unordered_map<string, int> rowCount;\n    for (int i = 0; i < matrix.size(); ++i)\n    {\n        string rowString;\n        if (matrix[i][0] == 1)\n        {\n            for (int j = 0; j < matrix[i].size(); ++j)\n                rowString += '0' + 1 - matrix[i][j];\n        }\n        else\n        {\n            for (int j = 0; j < matrix[i].size(); ++j)\n                rowString += '0' + matrix[i][j];\n        }\n        rowCount[rowString]++;\n    }\n    int result = 0;\n    for (auto &[key, value] : rowCount)\n        result = max(result, value);\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nint maxEqualRowsAfterFlips(std::vector<std::vector<int>> &matrix)\n{\n    std::unordered_map<std::string, int> rowCount;\n    for(auto &row : matrix)\n    {\n        std::string rowString;\n        if(row[0] == 1)\n        {\n            for(int value : row)\n                rowString+= '0' + 1 - value;\n        }\n        else\n        {\n            for(int value : row)\n                rowString+= '0' + value;\n        }\n        rowCount[rowString]++;\n    }\n    int result= 0;\n    for(auto &[key, value] : rowCount)\n        result= std::max(result, value);\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isMajorityElement(vector<int> &numberList, int targetNumber)\n{\n    int elementCount = 0;\n    for (int i = 0; i < numberList.size(); ++i)\n    {\n        int currentNumber = numberList[i];\n        if (currentNumber == targetNumber)\n            elementCount++;\n        if (elementCount > numberList.size() / 2)\n            return true;\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool isMajorityElement(std::vector<int> &numberList, int targetNumber)\n{\n    int elementCount= 0;\n    for(int currentNumber : numberList)\n    {\n        if(currentNumber == targetNumber)\n            elementCount++;\n        if(elementCount > numberList.size() / 2)\n            return true;\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minSwaps(vector<int> &data)\n{\n    int totalOnes = 0;\n    for (int i = 0; i < data.size(); i++)\n    {\n        totalOnes += data[i];\n    }\n    int currentOnes = 0, maxOnes = 0;\n    for (int index = 0; index < data.size(); index++)\n    {\n        currentOnes += data[index];\n        if (index >= totalOnes)\n        {\n            currentOnes -= data[index - totalOnes];\n        }\n        maxOnes = max(maxOnes, currentOnes);\n    }\n    return totalOnes - maxOnes;\n}",
    "output": "#include <bits/stdc++.h>\nint minSwaps(std::vector<int> &data)\n{\n    int totalOnes= 0;\n    for(int element : data)\n    {\n        totalOnes+= element;\n    }\n    int currentOnes= 0, maxOnes= 0;\n    for(int index= 0; index < data.size(); index++)\n    {\n        currentOnes+= data[index];\n        if(index >= totalOnes)\n        {\n            currentOnes-= data[index - totalOnes];\n        }\n        maxOnes= std::max(maxOnes, currentOnes);\n    }\n    return totalOnes - maxOnes;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution\n{\n  public:\n    vector<string> mostVisitedPattern(vector<string> &usernames, vector<int> &timestamps, vector<string> &websites)\n    {\n        int userCount = usernames.size();\n        vector<vector<string>> visitingPatterns;\n        unordered_map<string, vector<pair<int, int>>> userVisits;\n\n        for(int i = 0; i < userCount; i++)\n        {\n            userVisits[usernames[i]].push_back({timestamps[i], i});\n        }\n\n        for(auto &userVisit : userVisits)\n        {\n            sort(userVisit.second.begin(), userVisit.second.end());\n            int visitCount = userVisit.second.size();\n            for(int i = 0; i < visitCount; i++)\n            {\n                for(int j = i + 1; j < visitCount; j++)\n                {\n                    for(int k = j + 1; k < visitCount; k++)\n                    {\n                        visitingPatterns.push_back({websites[userVisit.second[i].second], websites[userVisit.second[j].second], websites[userVisit.second[k].second]});\n                    }\n                }\n            }\n        }\n\n        sort(visitingPatterns.begin(), visitingPatterns.end());\n\n        vector<string> mostVisitedPattern = visitingPatterns[0];\n        int maxScore = 0, currentScore = 1;\n\n        for(int i = 1; i < visitingPatterns.size(); i++)\n        {\n            if(visitingPatterns[i] == visitingPatterns[i - 1])\n            {\n                currentScore++;\n            }\n            else\n            {\n                currentScore = 1;\n            }\n\n            if(currentScore > maxScore)\n            {\n                maxScore = currentScore;\n                mostVisitedPattern = visitingPatterns[i];\n            }\n        }\n\n        return mostVisitedPattern;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Solution\n{\n  public:\n    std::vector<std::string> mostVisitedPattern(std::vector<std::string> &usernames, std::vector<int> &timestamps, std::vector<std::string> &websites)\n    {\n        int userCount = usernames.size();\n        std::vector<std::vector<std::string>> visitingPatterns;\n        std::unordered_map<std::string, std::vector<std::pair<int, int>>> userVisits;\n\n        for(int i = 0; i < userCount; i++)\n        {\n            userVisits[usernames[i]].push_back({timestamps[i], i});\n        }\n\n        for(auto &userVisit : userVisits)\n        {\n            std::sort(userVisit.second.begin(), userVisit.second.end());\n            int visitCount = userVisit.second.size();\n            for(int i = 0; i < visitCount; i++)\n            {\n                for(int j = i + 1; j < visitCount; j++)\n                {\n                    for(int k = j + 1; k < visitCount; k++)\n                    {\n                        visitingPatterns.push_back({websites[userVisit.second[i].second], websites[userVisit.second[j].second], websites[userVisit.second[k].second]});\n                    }\n                }\n            }\n        }\n\n        std::sort(visitingPatterns.begin(), visitingPatterns.end());\n\n        std::vector<std::string> mostVisitedPattern = visitingPatterns[0];\n        int maxScore = 0, currentScore = 1;\n\n        for(int i = 1; i < visitingPatterns.size(); i++)\n        {\n            if(visitingPatterns[i] == visitingPatterns[i - 1])\n            {\n                currentScore++;\n            }\n            else\n            {\n                currentScore = 1;\n            }\n\n            if(currentScore > maxScore)\n            {\n                maxScore = currentScore;\n                mostVisitedPattern = visitingPatterns[i];\n            }\n        }\n\n        return mostVisitedPattern;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canConvert(string sourceString, string targetString)\n{\n    if(sourceString == targetString)\n        return true;\n    unordered_map<char, char> characterConversionMap;\n    for(int index= 0; index < sourceString.length(); ++index)\n    {\n        if(characterConversionMap.count(sourceString[index]) && characterConversionMap[sourceString[index]] != targetString[index])\n            return false;\n        characterConversionMap[sourceString[index]]= targetString[index];\n    }\n    return unordered_set<char>(targetString.begin(), targetString.end()).size() < 26;\n}",
    "output": "bool canConvert(std::string sourceString, std::string targetString)\n{\n    if(sourceString == targetString)\n        return true;\n    std::unordered_map<char, char> characterConversionMap;\n    for(int index= 0; index < sourceString.length(); ++index)\n    {\n        if(characterConversionMap.count(sourceString[index]) && characterConversionMap[sourceString[index]] != targetString[index])\n            return false;\n        characterConversionMap[sourceString[index]]= targetString[index];\n    }\n    return std::unordered_set<char>(targetString.begin(), targetString.end()).size() < 26;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isLeapYear(int year)\n{\n    return ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n}\n\nint dayOfYear(string date)\n{\n    vector<int> daysInMonth= {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    int year= stoi(date.substr(0, 4));\n    int month= stoi(date.substr(5, 2));\n    int day= stoi(date.substr(8, 2));\n\n    if(isLeapYear(year))\n    {\n        daysInMonth[1]= 29;\n    }\n\n    int totalDays= 0;\n    for(int i= 0; i < month - 1; ++i)\n    {\n        totalDays+= daysInMonth[i];\n    }\n\n    return totalDays + day;\n}",
    "output": "#include <bits/stdc++.h>\nbool isLeapYear(int year)\n{\n    return ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n}\n\nint dayOfYear(std::string date)\n{\n    std::vector<int> daysInMonth= {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    int year= std::stoi(date.substr(0, 4));\n    int month= std::stoi(date.substr(5, 2));\n    int day= std::stoi(date.substr(8, 2));\n\n    if(isLeapYear(year))\n    {\n        daysInMonth[1]= 29;\n    }\n\n    int totalDays= 0;\n    for(int i= 0; i < month - 1; ++i)\n    {\n        totalDays+= daysInMonth[i];\n    }\n\n    return totalDays + day;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateNumRollsToTarget(int numberOfDice, int sidesPerDie, int targetSum)\n{\n    const int modulo= 1e9 + 7;\n    vector<vector<int>> dynamicProgrammingTable(numberOfDice + 1, vector<int>(targetSum + 1, 0));\n    dynamicProgrammingTable[0][0]= 1;\n    for(int diceCount= 1; diceCount <= numberOfDice; ++diceCount)\n    {\n        for(int currentTarget= diceCount; currentTarget <= targetSum; ++currentTarget)\n        {\n            for(int dieValue= 1; dieValue <= sidesPerDie && currentTarget - dieValue >= 0; ++dieValue)\n            {\n                dynamicProgrammingTable[diceCount][currentTarget]= (dynamicProgrammingTable[diceCount][currentTarget] + dynamicProgrammingTable[diceCount - 1][currentTarget - dieValue]) % modulo;\n            }\n        }\n    }\n    return dynamicProgrammingTable[numberOfDice][targetSum];\n}",
    "output": "#include <bits/stdc++.h>\nint calculateNumRollsToTarget(int numberOfDice, int sidesPerDie, int targetSum)\n{\n    const int modulo= 1e9 + 7;\n    std::vector<std::vector<int>> dynamicProgrammingTable(numberOfDice + 1, std::vector<int>(targetSum + 1, 0));\n    dynamicProgrammingTable[0][0]= 1;\n    for(int diceCount= 1; diceCount <= numberOfDice; ++diceCount)\n    {\n        for(int currentTarget= diceCount; currentTarget <= targetSum; ++currentTarget)\n        {\n            for(int dieValue= 1; dieValue <= sidesPerDie && currentTarget - dieValue >= 0; ++dieValue)\n            {\n                dynamicProgrammingTable[diceCount][currentTarget]= (dynamicProgrammingTable[diceCount][currentTarget] + dynamicProgrammingTable[diceCount - 1][currentTarget - dieValue]) % modulo;\n            }\n        }\n    }\n    return dynamicProgrammingTable[numberOfDice][targetSum];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> findThirdWords(const string &text, const string &firstWord, const string &secondWord)\n{\n    vector<string> thirdWords;\n    istringstream stringStream(text);\n    string currentWord, previousWord, previousPreviousWord;\n\n    while(stringStream >> currentWord)\n    {\n        if(previousPreviousWord == firstWord && previousWord == secondWord)\n        {\n            thirdWords.push_back(currentWord);\n        }\n        previousPreviousWord = previousWord;\n        previousWord = currentWord;\n    }\n\n    return thirdWords;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> findThirdWords(const std::string &text, const std::string &firstWord, const std::string &secondWord)\n{\n    std::vector<std::string> thirdWords;\n    std::istringstream stringStream(text);\n    std::string currentWord, previousWord, previousPreviousWord;\n\n    while(stringStream >> currentWord)\n    {\n        if(previousPreviousWord == firstWord && previousWord == secondWord)\n        {\n            thirdWords.push_back(currentWord);\n        }\n        previousPreviousWord= previousWord;\n        previousWord= currentWord;\n    }\n\n    return thirdWords;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nbool isInsufficient(TreeNode *currentNode, int limit, int currentSum)\n{\n    if(!currentNode)\n    {\n        return true;\n    }\n\n    currentSum += currentNode->value;\n    if(!currentNode->leftChild && !currentNode->rightChild)\n    {\n        return currentSum < limit;\n    }\n\n    bool isLeftInsufficient = isInsufficient(currentNode->leftChild, limit, currentSum);\n    bool isRightInsufficient = isInsufficient(currentNode->rightChild, limit, currentSum);\n\n    if(isLeftInsufficient)\n    {\n        delete(currentNode->leftChild);\n        currentNode->leftChild = NULL;\n    }\n    if(isRightInsufficient)\n    {\n        delete(currentNode->rightChild);\n        currentNode->rightChild = NULL;\n    }\n\n    return isLeftInsufficient && isRightInsufficient;\n}\n\nTreeNode *sufficientSubset(TreeNode *rootNode, int limit)\n{\n    if(isInsufficient(rootNode, limit, 0))\n    {\n        delete(rootNode);\n        return NULL;\n    }\n    return rootNode;\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nbool isInsufficient(TreeNode *currentNode, int limit, int currentSum)\n{\n    if(!currentNode)\n    {\n        return true;\n    }\n\n    currentSum+= currentNode->value;\n    if(!currentNode->leftChild && !currentNode->rightChild)\n    {\n        return currentSum < limit;\n    }\n\n    bool isLeftInsufficient= isInsufficient(currentNode->leftChild, limit, currentSum);\n    bool isRightInsufficient= isInsufficient(currentNode->rightChild, limit, currentSum);\n\n    if(isLeftInsufficient)\n    {\n        delete(currentNode->leftChild);\n        currentNode->leftChild= NULL;\n    }\n    if(isRightInsufficient)\n    {\n        delete(currentNode->rightChild);\n        currentNode->rightChild= NULL;\n    }\n\n    return isLeftInsufficient && isRightInsufficient;\n}\n\nTreeNode *sufficientSubset(TreeNode *rootNode, int limit)\n{\n    if(isInsufficient(rootNode, limit, 0))\n    {\n        delete(rootNode);\n        return NULL;\n    }\n    return rootNode;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numTilePossibilities(string tiles)\n{\n    vector<int> frequency(26, 0);\n    for (int i = 0; i < tiles.size(); ++i)\n    {\n        frequency[tiles[i] - 'A']++;\n    }\n\n    int totalPossibilities = 0;\n    for (int index = 0; index < 26; index++)\n    {\n        if (frequency[index])\n        {\n            frequency[index]--;\n            totalPossibilities += 1 + numTilePossibilities(tiles);\n            frequency[index]++;\n        }\n    }\n    return totalPossibilities;\n}",
    "output": "#include <bits/stdc++.h>\nint numTilePossibilities(std::string tiles)\n{\n    std::vector<int> frequency(26, 0);\n    for(char character : tiles)\n    {\n        frequency[character - 'A']++;\n    }\n\n    int totalPossibilities= 0;\n    for(int index= 0; index < 26; index++)\n    {\n        if(frequency[index])\n        {\n            frequency[index]--;\n            totalPossibilities+= 1 + numTilePossibilities(tiles);\n            frequency[index]++;\n        }\n    }\n    return totalPossibilities;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nint maxLevelSum(TreeNode *root)\n{\n    if(!root)\n        return 0;\n\n    queue<TreeNode *> nodeQueue;\n    nodeQueue.push(root);\n    int currentLevel= 0, maxSum= INT_MIN, resultLevel;\n\n    while(!nodeQueue.empty())\n    {\n        int nodeCount= nodeQueue.size();\n        int levelSum= 0;\n        currentLevel++;\n\n        while(nodeCount--)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n            levelSum+= currentNode->value;\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n\n        if(levelSum > maxSum)\n        {\n            maxSum= levelSum;\n            resultLevel= currentLevel;\n        }\n    }\n\n    return resultLevel;\n}",
    "output": "#include <bits/stdc++.h>\nclass TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nint maxLevelSum(TreeNode *root)\n{\n    if(!root)\n        return 0;\n\n    std::queue<TreeNode *> nodeQueue;\n    nodeQueue.push(root);\n    int currentLevel= 0, maxSum= INT_MIN, resultLevel;\n\n    while(!nodeQueue.empty())\n    {\n        int nodeCount= nodeQueue.size();\n        int levelSum= 0;\n        currentLevel++;\n\n        while(nodeCount--)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n            levelSum+= currentNode->value;\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n\n        if(levelSum > maxSum)\n        {\n            maxSum= levelSum;\n            resultLevel= currentLevel;\n        }\n    }\n\n    return resultLevel;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxDistance(vector<vector<int>> &grid)\n{\n    int maxDistanceValue = -1;\n    queue<pair<int, int>> waterCellsQueue;\n    int gridSize = grid.size();\n\n    for (int rowIndex = 0; rowIndex < gridSize; rowIndex++)\n    {\n        for (int colIndex = 0; colIndex < gridSize; colIndex++)\n        {\n            if (grid[rowIndex][colIndex] == 1)\n            {\n                waterCellsQueue.push({rowIndex, colIndex});\n            }\n        }\n    }\n\n    if (waterCellsQueue.size() == 0 || waterCellsQueue.size() == gridSize * gridSize)\n    {\n        return maxDistanceValue;\n    }\n\n    vector<vector<int>> movementDirections{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    while (!waterCellsQueue.empty())\n    {\n        int currentLevelSize = waterCellsQueue.size();\n        while (currentLevelSize--)\n        {\n            auto [currentX, currentY] = waterCellsQueue.front();\n            waterCellsQueue.pop();\n\n            for (int i = 0; i < movementDirections.size(); i++)\n            {\n                int newX = currentX + movementDirections[i][0], newY = currentY + movementDirections[i][1];\n                if (newX >= 0 && newX < gridSize && newY >= 0 && newY < gridSize && grid[newX][newY] == 0)\n                {\n                    grid[newX][newY] = 1;\n                    waterCellsQueue.push({newX, newY});\n                }\n            }\n        }\n        maxDistanceValue++;\n    }\n\n    return maxDistanceValue - 1;\n}",
    "output": "#include <bits/stdc++.h>\nint maxDistance(std::vector<std::vector<int>> &grid)\n{\n    int maxDistanceValue= -1;\n    std::queue<std::pair<int, int>> waterCellsQueue;\n    int gridSize= grid.size();\n\n    for(int rowIndex= 0; rowIndex < gridSize; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < gridSize; colIndex++)\n        {\n            if(grid[rowIndex][colIndex] == 1)\n            {\n                waterCellsQueue.push({rowIndex, colIndex});\n            }\n        }\n    }\n\n    if(waterCellsQueue.size() == 0 || waterCellsQueue.size() == gridSize * gridSize)\n    {\n        return maxDistanceValue;\n    }\n\n    std::vector<std::vector<int>> movementDirections{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    while(!waterCellsQueue.empty())\n    {\n        int currentLevelSize= waterCellsQueue.size();\n        while(currentLevelSize--)\n        {\n            auto [currentX, currentY]= waterCellsQueue.front();\n            waterCellsQueue.pop();\n\n            for(const auto &direction : movementDirections)\n            {\n                int newX= currentX + direction[0], newY= currentY + direction[1];\n                if(newX >= 0 && newX < gridSize && newY >= 0 && newY < gridSize && grid[newX][newY] == 0)\n                {\n                    grid[newX][newY]= 1;\n                    waterCellsQueue.push({newX, newY});\n                }\n            }\n        }\n        maxDistanceValue++;\n    }\n\n    return maxDistanceValue - 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring lastSubstring(string inputString)\n{\n    int maxIndex= 0;\n    int currentIndex= 1;\n    while(currentIndex < inputString.length())\n    {\n        int comparisonIndex= 0;\n        while(currentIndex + comparisonIndex < inputString.length() && inputString[maxIndex + comparisonIndex] == inputString[currentIndex + comparisonIndex])\n        {\n            comparisonIndex++;\n        }\n        if(currentIndex + comparisonIndex == inputString.length())\n            break;\n        if(inputString[maxIndex + comparisonIndex] < inputString[currentIndex + comparisonIndex])\n        {\n            maxIndex= currentIndex;\n        }\n        currentIndex++;\n    }\n    return inputString.substr(maxIndex);\n}",
    "output": "std::string lastSubstring(std::string inputString)\n{\n    int maxIndex= 0;\n    int currentIndex= 1;\n    while(currentIndex < inputString.length())\n    {\n        int comparisonIndex= 0;\n        while(currentIndex + comparisonIndex < inputString.length() && inputString[maxIndex + comparisonIndex] == inputString[currentIndex + comparisonIndex])\n        {\n            comparisonIndex++;\n        }\n        if(currentIndex + comparisonIndex == inputString.length())\n            break;\n        if(inputString[maxIndex + comparisonIndex] < inputString[currentIndex + comparisonIndex])\n        {\n            maxIndex= currentIndex;\n        }\n        currentIndex++;\n    }\n    return inputString.substr(maxIndex);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateTime(string keyboardLayout, string targetWord)\n{\n    int totalTime = 0;\n    int previousIndex = 0;\n    unordered_map<char, int> charToIndexMap;\n\n    for (int i = 0; i < keyboardLayout.length(); i++)\n    {\n        charToIndexMap[keyboardLayout[i]] = i;\n    }\n\n    for (int i = 0; i < targetWord.length(); i++)\n    {\n        char character = targetWord[i];\n        totalTime += abs(charToIndexMap[character] - previousIndex);\n        previousIndex = charToIndexMap[character];\n    }\n\n    return totalTime;\n}",
    "output": "int calculateTime(std::string keyboardLayout, std::string targetWord)\n{\n    int totalTime= 0;\n    int previousIndex= 0;\n    std::unordered_map<char, int> charToIndexMap;\n\n    for(int i= 0; i < keyboardLayout.length(); i++)\n    {\n        charToIndexMap[keyboardLayout[i]]= i;\n    }\n\n    for(char character : targetWord)\n    {\n        totalTime+= std::abs(charToIndexMap[character] - previousIndex);\n        previousIndex= charToIndexMap[character];\n    }\n\n    return totalTime;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass FileSystem\n{\n  public:\n    unordered_map<string, int> pathValueMap;\n\n    bool createPath(string newPath, int value)\n    {\n        if(pathValueMap.count(newPath) != 0)\n            return false;\n        string parentPath= newPath.substr(0, newPath.find_last_of('/'));\n        if(!parentPath.empty() && pathValueMap.count(parentPath) == 0)\n            return false;\n        pathValueMap[newPath]= value;\n        return true;\n    }\n\n    int get(string requestedPath)\n    {\n        if(pathValueMap.count(requestedPath) == 0)\n            return -1;\n        return pathValueMap[requestedPath];\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass FileSystem\n{\n  public:\n    std::unordered_map<std::string, int> pathValueMap;\n\n    bool createPath(std::string newPath, int value)\n    {\n        if(pathValueMap.count(newPath) != 0)\n            return false;\n        std::string parentPath= newPath.substr(0, newPath.find_last_of('/'));\n        if(!parentPath.empty() && pathValueMap.count(parentPath) == 0)\n            return false;\n        pathValueMap[newPath]= value;\n        return true;\n    }\n\n    int get(std::string requestedPath)\n    {\n        if(pathValueMap.count(requestedPath) == 0)\n            return -1;\n        return pathValueMap[requestedPath];\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint connectSticks(vector<int> &stickLengths)\n{\n    priority_queue<int, vector<int>, greater<int>> minHeap;\n\n    for (int i = 0; i < stickLengths.size(); ++i)\n    {\n        minHeap.push(stickLengths[i]);\n    }\n\n    int totalCost = 0;\n    while (minHeap.size() > 1)\n    {\n        int firstStick = minHeap.top();\n        minHeap.pop();\n        int secondStick = minHeap.top();\n        minHeap.pop();\n        totalCost += firstStick + secondStick;\n        minHeap.push(firstStick + secondStick);\n    }\n    return totalCost;\n}",
    "output": "#include <bits/stdc++.h>\nint connectSticks(std::vector<int> &stickLengths)\n{\n    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;\n\n    for(int stickLength : stickLengths)\n    {\n        minHeap.push(stickLength);\n    }\n\n    int totalCost= 0;\n    while(minHeap.size() > 1)\n    {\n        int firstStick= minHeap.top();\n        minHeap.pop();\n        int secondStick= minHeap.top();\n        minHeap.pop();\n        totalCost+= firstStick + secondStick;\n        minHeap.push(firstStick + secondStick);\n    }\n    return totalCost;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid duplicateZeros(vector<int> &inputArray)\n{\n    int arraySize= inputArray.size();\n    for(int currentIndex= 0; currentIndex < arraySize - 1; currentIndex++)\n    {\n        if(inputArray[currentIndex] == 0)\n        {\n            for(int shiftIndex= arraySize - 2; shiftIndex > currentIndex; shiftIndex--)\n            {\n                inputArray[shiftIndex + 1]= inputArray[shiftIndex];\n            }\n            inputArray[currentIndex + 1]= 0;\n            currentIndex++;\n        }\n    }\n}",
    "output": "#include <bits/stdc++.h>\nvoid duplicateZeros(std::vector<int> &inputArray)\n{\n    int arraySize= inputArray.size();\n    for(int currentIndex= 0; currentIndex < arraySize - 1; currentIndex++)\n    {\n        if(inputArray[currentIndex] == 0)\n        {\n            for(int shiftIndex= arraySize - 2; shiftIndex > currentIndex; shiftIndex--)\n            {\n                inputArray[shiftIndex + 1]= inputArray[shiftIndex];\n            }\n            inputArray[currentIndex + 1]= 0;\n            currentIndex++;\n        }\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint largestValsFromLabels(vector<int> &valueList, vector<int> &labelList, int numWanted, int useLimit)\n{\n    vector<pair<int, int>> itemPairs;\n    for(int index = 0; index < valueList.size(); ++index)\n    {\n        itemPairs.emplace_back(valueList[index], labelList[index]);\n    }\n    sort(itemPairs.rbegin(), itemPairs.rend());\n\n    unordered_map<int, int> labelCountMap;\n    int totalValue = 0;\n    for (int i = 0; i < itemPairs.size(); ++i)\n    {\n        const auto &[value, label] = itemPairs[i];\n        if (labelCountMap[label] < useLimit && numWanted > 0)\n        {\n            totalValue += value;\n            labelCountMap[label]++;\n            numWanted--;\n        }\n    }\n\n    return totalValue;\n}",
    "output": "#include <bits/stdc++.h>\nint largestValsFromLabels(std::vector<int> &valueList, std::vector<int> &labelList, int numWanted, int useLimit)\n{\n    std::vector<std::pair<int, int>> itemPairs;\n    for(int index= 0; index < valueList.size(); ++index)\n    {\n        itemPairs.emplace_back(valueList[index], labelList[index]);\n    }\n    std::sort(itemPairs.rbegin(), itemPairs.rend());\n\n    std::unordered_map<int, int> labelCountMap;\n    int totalValue= 0;\n    for(const auto &[value, label] : itemPairs)\n    {\n        if(labelCountMap[label] < useLimit && numWanted > 0)\n        {\n            totalValue+= value;\n            labelCountMap[label]++;\n            numWanted--;\n        }\n    }\n\n    return totalValue;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring shortestCommonSupersequence(string firstString, string secondString)\n{\n    int firstStringLength = firstString.length();\n    int secondStringLength = secondString.length();\n    vector<vector<int>> dynamicProgrammingTable(firstStringLength + 1, vector<int>(secondStringLength + 1));\n\n    for(int row = 0; row <= firstStringLength; row++)\n    {\n        for(int column = 0; column <= secondStringLength; column++)\n        {\n            if(row == 0)\n            {\n                dynamicProgrammingTable[row][column] = column;\n            }\n            else if(column == 0)\n            {\n                dynamicProgrammingTable[row][column] = row;\n            }\n            else if(firstString[row - 1] == secondString[column - 1])\n            {\n                dynamicProgrammingTable[row][column] = 1 + dynamicProgrammingTable[row - 1][column - 1];\n            }\n            else\n            {\n                dynamicProgrammingTable[row][column] = 1 + min(dynamicProgrammingTable[row - 1][column], dynamicProgrammingTable[row][column - 1]);\n            }\n        }\n    }\n\n    int row = firstStringLength, column = secondStringLength;\n    string result;\n\n    while(row > 0 && column > 0)\n    {\n        if(firstString[row - 1] == secondString[column - 1])\n        {\n            result.push_back(firstString[row - 1]);\n            row--;\n            column--;\n        }\n        else if(dynamicProgrammingTable[row - 1][column] > dynamicProgrammingTable[row][column - 1])\n        {\n            column--;\n            result.push_back(secondString[column]);\n        }\n        else\n        {\n            row--;\n            result.push_back(firstString[row]);\n        }\n    }\n\n    while(row > 0)\n    {\n        result.push_back(firstString[row - 1]);\n        row--;\n    }\n\n    while(column > 0)\n    {\n        result.push_back(secondString[column - 1]);\n        column--;\n    }\n\n    reverse(result.begin(), result.end());\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string shortestCommonSupersequence(std::string firstString, std::string secondString)\n{\n    int firstStringLength= firstString.length();\n    int secondStringLength= secondString.length();\n    std::vector<std::vector<int>> dynamicProgrammingTable(firstStringLength + 1, std::vector<int>(secondStringLength + 1));\n\n    for(int row= 0; row <= firstStringLength; row++)\n    {\n        for(int column= 0; column <= secondStringLength; column++)\n        {\n            if(row == 0)\n            {\n                dynamicProgrammingTable[row][column]= column;\n            }\n            else if(column == 0)\n            {\n                dynamicProgrammingTable[row][column]= row;\n            }\n            else if(firstString[row - 1] == secondString[column - 1])\n            {\n                dynamicProgrammingTable[row][column]= 1 + dynamicProgrammingTable[row - 1][column - 1];\n            }\n            else\n            {\n                dynamicProgrammingTable[row][column]= 1 + std::min(dynamicProgrammingTable[row - 1][column], dynamicProgrammingTable[row][column - 1]);\n            }\n        }\n    }\n\n    int row= firstStringLength, column= secondStringLength;\n    std::string result;\n\n    while(row > 0 && column > 0)\n    {\n        if(firstString[row - 1] == secondString[column - 1])\n        {\n            result.push_back(firstString[row - 1]);\n            row--;\n            column--;\n        }\n        else if(dynamicProgrammingTable[row - 1][column] > dynamicProgrammingTable[row][column - 1])\n        {\n            column--;\n            result.push_back(secondString[column]);\n        }\n        else\n        {\n            row--;\n            result.push_back(firstString[row]);\n        }\n    }\n\n    while(row > 0)\n    {\n        result.push_back(firstString[row - 1]);\n        row--;\n    }\n\n    while(column > 0)\n    {\n        result.push_back(secondString[column - 1]);\n        column--;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPathBinaryMatrix(vector<vector<int>> &binaryGrid)\n{\n    int gridSize = binaryGrid.size();\n    if (binaryGrid[0][0] == 1 || binaryGrid[gridSize - 1][gridSize - 1] == 1)\n        return -1;\n    queue<pair<int, int>> positionQueue;\n    vector<vector<int>> directions = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n    positionQueue.push({0, 0});\n    binaryGrid[0][0] = 1;\n    int stepCount = 1;\n\n    while (!positionQueue.empty())\n    {\n        int queueSize = positionQueue.size();\n        for (int i = 0; i < queueSize; ++i)\n        {\n            int currentX = positionQueue.front().first;\n            int currentY = positionQueue.front().second;\n            positionQueue.pop();\n\n            if (currentX == gridSize - 1 && currentY == gridSize - 1)\n                return stepCount;\n\n            for (int j = 0; j < directions.size(); ++j)\n            {\n                vector<int> direction = directions[j];\n                int newX = currentX + direction[0];\n                int newY = currentY + direction[1];\n\n                if (newX >= 0 && newX < gridSize && newY >= 0 && newY < gridSize && binaryGrid[newX][newY] == 0)\n                {\n                    positionQueue.push({newX, newY});\n                    binaryGrid[newX][newY] = 1;\n                }\n            }\n        }\n        stepCount++;\n    }\n\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint shortestPathBinaryMatrix(std::vector<std::vector<int>> &binaryGrid)\n{\n    int gridSize= binaryGrid.size();\n    if(binaryGrid[0][0] == 1 || binaryGrid[gridSize - 1][gridSize - 1] == 1)\n        return -1;\n    std::queue<std::pair<int, int>> positionQueue;\n    std::vector<std::vector<int>> directions= {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n    positionQueue.push({0, 0});\n    binaryGrid[0][0]= 1;\n    int stepCount= 1;\n\n    while(!positionQueue.empty())\n    {\n        int queueSize= positionQueue.size();\n        for(int i= 0; i < queueSize; ++i)\n        {\n            int currentX= positionQueue.front().first;\n            int currentY= positionQueue.front().second;\n            positionQueue.pop();\n\n            if(currentX == gridSize - 1 && currentY == gridSize - 1)\n                return stepCount;\n\n            for(std::vector<int> direction : directions)\n            {\n                int newX= currentX + direction[0];\n                int newY= currentY + direction[1];\n\n                if(newX >= 0 && newX < gridSize && newY >= 0 && newY < gridSize && binaryGrid[newX][newY] == 0)\n                {\n                    positionQueue.push({newX, newY});\n                    binaryGrid[newX][newY]= 1;\n                }\n            }\n        }\n        stepCount++;\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass DinnerPlates\n{\n  public:\n    int stackCapacity;\n    vector<vector<int>> plateStacks;\n\n    DinnerPlates(int capacity)\n    {\n        this->stackCapacity = capacity;\n    }\n\n    void push(int value)\n    {\n        for (int i = 0; i < plateStacks.size(); ++i)\n        {\n            if (plateStacks[i].size() < stackCapacity)\n            {\n                plateStacks[i].push_back(value);\n                return;\n            }\n        }\n        plateStacks.push_back({value});\n    }\n\n    int pop()\n    {\n        while (!plateStacks.empty() && plateStacks.back().empty())\n        {\n            plateStacks.pop_back();\n        }\n        if (plateStacks.empty())\n            return -1;\n        int result = plateStacks.back().back();\n        plateStacks.back().pop_back();\n        return result;\n    }\n\n    int popAtStack(int index)\n    {\n        if (index >= plateStacks.size() || plateStacks[index].empty())\n        {\n            return -1;\n        }\n        int result = plateStacks[index].back();\n        plateStacks[index].pop_back();\n        return result;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass DinnerPlates\n{\n  public:\n    int stackCapacity;\n    std::vector<std::vector<int>> plateStacks;\n\n    DinnerPlates(int capacity)\n    {\n        this->stackCapacity= capacity;\n    }\n\n    void push(int value)\n    {\n        for(auto &stack : plateStacks)\n        {\n            if(stack.size() < stackCapacity)\n            {\n                stack.push_back(value);\n                return;\n            }\n        }\n        plateStacks.push_back({value});\n    }\n\n    int pop()\n    {\n        while(!plateStacks.empty() && plateStacks.back().empty())\n        {\n            plateStacks.pop_back();\n        }\n        if(plateStacks.empty())\n            return -1;\n        int result= plateStacks.back().back();\n        plateStacks.back().pop_back();\n        return result;\n    }\n\n    int popAtStack(int index)\n    {\n        if(index >= plateStacks.size() || plateStacks[index].empty())\n        {\n            return -1;\n        }\n        int result= plateStacks[index].back();\n        plateStacks[index].pop_back();\n        return result;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod= 1e9 + 7;\n\nint numPrimeArrangements(int totalCount)\n{\n    vector<bool> isPrime(totalCount + 1, true);\n    isPrime[0]= false;\n    isPrime[1]= false;\n    for(int currentNumber= 2; currentNumber * currentNumber <= totalCount; currentNumber++)\n    {\n        if(isPrime[currentNumber])\n        {\n            for(int multiple= currentNumber * currentNumber; multiple <= totalCount; multiple+= currentNumber)\n            {\n                isPrime[multiple]= false;\n            }\n        }\n    }\n\n    int primeCount= 0;\n    for(int index= 2; index <= totalCount; index++)\n    {\n        if(isPrime[index])\n            primeCount++;\n    }\n    int compositeCount= totalCount - primeCount;\n\n    long long result= 1;\n    for(int i= 1; i <= primeCount; i++)\n    {\n        result= result * i % mod;\n    }\n    for(int i= 1; i <= compositeCount; i++)\n    {\n        result= result * i % mod;\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nconst int mod = 1e9 + 7;\n\nint numPrimeArrangements(int totalCount)\n{\n    std::vector<bool> isPrime(totalCount + 1, true);\n    isPrime[0] = false;\n    isPrime[1] = false;\n    for(int currentNumber = 2; currentNumber * currentNumber <= totalCount; currentNumber++)\n    {\n        if(isPrime[currentNumber])\n        {\n            for(int multiple = currentNumber * currentNumber; multiple <= totalCount; multiple += currentNumber)\n            {\n                isPrime[multiple] = false;\n            }\n        }\n    }\n\n    int primeCount = 0;\n    for(int index = 2; index <= totalCount; index++)\n    {\n        if(isPrime[index])\n            primeCount++;\n    }\n    int compositeCount = totalCount - primeCount;\n\n    long long result = 1;\n    for(int i = 1; i <= primeCount; i++)\n    {\n        result = result * i % mod;\n    }\n    for(int i = 1; i <= compositeCount; i++)\n    {\n        result = result * i % mod;\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dietPlanPerformance(vector<int> &dailyCalories, int duration, int lowerBound, int upperBound)\n{\n    int points= 0;\n    int totalCalories= 0;\n\n    for(int dayIndex= 0; dayIndex < dailyCalories.size(); dayIndex++)\n    {\n        totalCalories+= dailyCalories[dayIndex];\n        if(dayIndex >= duration)\n        {\n            totalCalories-= dailyCalories[dayIndex - duration];\n        }\n        if(dayIndex >= duration - 1)\n        {\n            if(totalCalories < lowerBound)\n                points--;\n            if(totalCalories > upperBound)\n                points++;\n        }\n    }\n\n    return points;\n}",
    "output": "#include <bits/stdc++.h>\nint dietPlanPerformance(std::vector<int> &dailyCalories, int duration, int lowerBound, int upperBound)\n{\n    int points= 0;\n    int totalCalories= 0;\n\n    for(int dayIndex= 0; dayIndex < dailyCalories.size(); dayIndex++)\n    {\n        totalCalories+= dailyCalories[dayIndex];\n        if(dayIndex >= duration)\n        {\n            totalCalories-= dailyCalories[dayIndex - duration];\n        }\n        if(dayIndex >= duration - 1)\n        {\n            if(totalCalories < lowerBound)\n                points--;\n            if(totalCalories > upperBound)\n                points++;\n        }\n    }\n\n    return points;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<bool> canMakePaliQueries(string inputString, vector<vector<int>> &queries)\n{\n    vector<bool> result;\n    vector<int> prefixSum(inputString.length() + 1);\n\n    for(int index = 0; index < inputString.length(); ++index)\n    {\n        prefixSum[index + 1] = prefixSum[index] ^ (1 << (inputString[index] - 'a'));\n    }\n\n    for(int i = 0; i < queries.size(); ++i)\n    {\n        auto &query = queries[i];\n        int leftIndex = query[0], rightIndex = query[1], maxChanges = query[2];\n        int oddCount = __builtin_popcount(prefixSum[rightIndex + 1] ^ prefixSum[leftIndex]);\n        result.push_back((oddCount / 2) <= maxChanges);\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<bool> canMakePaliQueries(std::string inputString, std::vector<std::vector<int>> &queries)\n{\n    std::vector<bool> result;\n    std::vector<int> prefixSum(inputString.length() + 1);\n\n    for(int index= 0; index < inputString.length(); ++index)\n    {\n        prefixSum[index + 1]= prefixSum[index] ^ (1 << (inputString[index] - 'a'));\n    }\n\n    for(auto &query : queries)\n    {\n        int leftIndex= query[0], rightIndex= query[1], maxChanges= query[2];\n        int oddCount= __builtin_popcount(prefixSum[rightIndex + 1] ^ prefixSum[leftIndex]);\n        result.push_back((oddCount / 2) <= maxChanges);\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findNumOfValidWords(vector<string> &wordList, vector<string> &puzzleList)\n{\n    vector<int> validWordCounts;\n    for (int i = 0; i < puzzleList.size(); ++i)\n    {\n        const string &currentPuzzle = puzzleList[i];\n        int validWordCount = 0;\n        unordered_set<char> puzzleCharacterSet(currentPuzzle.begin(), currentPuzzle.end());\n        for (int j = 0; j < wordList.size(); ++j)\n        {\n            const string &currentWord = wordList[j];\n            if (currentWord.find(currentPuzzle[0]) != string::npos)\n            {\n                if (all_of(currentWord.begin(), currentWord.end(), [&](char character)\n                           { return puzzleCharacterSet.count(character) > 0; }))\n                {\n                    validWordCount++;\n                }\n            }\n        }\n        validWordCounts.push_back(validWordCount);\n    }\n    return validWordCounts;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findNumOfValidWords(std::vector<std::string> &wordList, std::vector<std::string> &puzzleList)\n{\n    std::vector<int> validWordCounts;\n    for(const std::string &currentPuzzle : puzzleList)\n    {\n        int validWordCount= 0;\n        std::unordered_set<char> puzzleCharacterSet(currentPuzzle.begin(), currentPuzzle.end());\n        for(const std::string &currentWord : wordList)\n        {\n            if(currentWord.find(currentPuzzle[0]) != std::string::npos)\n            {\n                if(std::all_of(currentWord.begin(), currentWord.end(), [&](char character)\n                               { return puzzleCharacterSet.count(character) > 0; }))\n                {\n                    validWordCount++;\n                }\n            }\n        }\n        validWordCounts.push_back(validWordCount);\n    }\n    return validWordCounts;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countConsecutiveLetters(string inputString)\n{\n    int totalCount= 0, currentCount= 1;\n\n    for(int index= 1; index < inputString.length(); index++)\n    {\n        if(inputString[index] == inputString[index - 1])\n        {\n            currentCount++;\n        }\n        else\n        {\n            totalCount+= (currentCount * (currentCount + 1)) / 2;\n            currentCount= 1;\n        }\n    }\n\n    totalCount+= (currentCount * (currentCount + 1)) / 2;\n    return totalCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countConsecutiveLetters(std::string inputString)\n{\n    int totalCount= 0, currentCount= 1;\n\n    for(int index= 1; index < inputString.length(); index++)\n    {\n        if(inputString[index] == inputString[index - 1])\n        {\n            currentCount++;\n        }\n        else\n        {\n            totalCount+= (currentCount * (currentCount + 1)) / 2;\n            currentCount= 1;\n        }\n    }\n\n    totalCount+= (currentCount * (currentCount + 1)) / 2;\n    return totalCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> beforeAndAfterPuzzles(vector<string> &phrases)\n{\n    unordered_map<string, set<string>> firstWordMap;\n    set<string> resultSet;\n\n    for (int i = 0; i < phrases.size(); ++i)\n    {\n        const string &phrase = phrases[i];\n        string firstWord = phrase.substr(0, phrase.find(' '));\n        if (firstWordMap.find(firstWord) != firstWordMap.end())\n        {\n            firstWordMap[firstWord].insert(phrase);\n        }\n        else\n        {\n            firstWordMap[firstWord] = {phrase};\n        }\n    }\n\n    for (int i = 0; i < phrases.size(); ++i)\n    {\n        const string &phrase = phrases[i];\n        string lastWord = phrase.substr(phrase.rfind(' ') + 1);\n        if (firstWordMap.find(lastWord) != firstWordMap.end())\n        {\n            for (const string &currentPhrase : firstWordMap[lastWord])\n            {\n                if (phrase != currentPhrase)\n                {\n                    resultSet.insert(phrase + currentPhrase.substr(currentPhrase.find(' ')));\n                }\n            }\n        }\n    }\n\n    return vector<string>(resultSet.begin(), resultSet.end());\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> beforeAndAfterPuzzles(std::vector<std::string> &phrases)\n{\n    std::unordered_map<std::string, std::set<std::string>> firstWordMap;\n    std::set<std::string> resultSet;\n\n    for(const std::string &phrase : phrases)\n    {\n        std::string firstWord= phrase.substr(0, phrase.find(' '));\n        if(firstWordMap.find(firstWord) != firstWordMap.end())\n        {\n            firstWordMap[firstWord].insert(phrase);\n        }\n        else\n        {\n            firstWordMap[firstWord]= {phrase};\n        }\n    }\n\n    for(const std::string &phrase : phrases)\n    {\n        std::string lastWord= phrase.substr(phrase.rfind(' ') + 1);\n        if(firstWordMap.find(lastWord) != firstWordMap.end())\n        {\n            for(const std::string &currentPhrase : firstWordMap[lastWord])\n            {\n                if(phrase != currentPhrase)\n                {\n                    resultSet.insert(phrase + currentPhrase.substr(currentPhrase.find(' ')));\n                }\n            }\n        }\n    }\n\n    return std::vector<std::string>(resultSet.begin(), resultSet.end());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> shortestDistance(vector<int> &colorArray, vector<vector<int>> &queries)\n{\n    vector<int> result;\n    vector<vector<int>> colorPositions(3);\n\n    for(int index = 0; index < colorArray.size(); index++)\n    {\n        colorPositions[colorArray[index] - 1].push_back(index);\n    }\n\n    for(int i = 0; i < queries.size(); i++)\n    {\n        auto &query = queries[i];\n        auto &indexPositions = colorPositions[query[1] - 1];\n\n        if(indexPositions.empty())\n        {\n            result.push_back(-1);\n        }\n        else\n        {\n            int minimumDistance = INT_MAX;\n\n            for(int j = 0; j < indexPositions.size(); j++)\n            {\n                int position = indexPositions[j];\n                minimumDistance = min(minimumDistance, abs(position - query[0]));\n            }\n\n            result.push_back(minimumDistance);\n        }\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> shortestDistance(std::vector<int> &colorArray, std::vector<std::vector<int>> &queries)\n{\n    std::vector<int> result;\n    std::vector<std::vector<int>> colorPositions(3);\n\n    for(int index= 0; index < colorArray.size(); index++)\n    {\n        colorPositions[colorArray[index] - 1].push_back(index);\n    }\n\n    for(auto &query : queries)\n    {\n        auto &indexPositions= colorPositions[query[1] - 1];\n\n        if(indexPositions.empty())\n        {\n            result.push_back(-1);\n        }\n        else\n        {\n            int minimumDistance= INT_MAX;\n\n            for(auto position : indexPositions)\n            {\n                minimumDistance= std::min(minimumDistance, std::abs(position - query[0]));\n            }\n\n            result.push_back(minimumDistance);\n        }\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<double> sampleStats(vector<int> &frequencyCount)\n{\n    double minimumValue= -1, maximumValue= -1, modeValue= 0, medianValue= 0, meanValue= 0;\n    long long totalValuesCount= 0, highestFrequencyCount= 0, currentFrequencyCount= 0;\n    double totalSum= 0;\n\n    for(int index= 0; index <= 255; index++)\n    {\n        if(frequencyCount[index] > 0)\n        {\n            if(minimumValue == -1)\n                minimumValue= index;\n            maximumValue= index;\n            totalSum+= static_cast<double>(index) * frequencyCount[index];\n            totalValuesCount+= frequencyCount[index];\n            if(frequencyCount[index] > highestFrequencyCount)\n            {\n                highestFrequencyCount= frequencyCount[index];\n                modeValue= index;\n            }\n        }\n    }\n\n    meanValue= totalSum / totalValuesCount;\n    bool isEvenCount= (totalValuesCount % 2 == 0);\n    long long midIndex1= totalValuesCount / 2, midIndex2= midIndex1 - 1;\n    if(isEvenCount)\n        midIndex2++;\n\n    for(int index= 0; index <= 255; index++)\n    {\n        currentFrequencyCount+= frequencyCount[index];\n        if(isEvenCount && currentFrequencyCount >= midIndex2)\n        {\n            medianValue+= index;\n            midIndex2= totalValuesCount;\n            isEvenCount= false;\n        }\n\n        if(currentFrequencyCount >= midIndex1)\n        {\n            medianValue+= index;\n            break;\n        }\n    }\n\n    if(!isEvenCount)\n        medianValue/= 2;\n    return {minimumValue, maximumValue, meanValue, medianValue, modeValue};\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<double> sampleStats(std::vector<int> &frequencyCount)\n{\n    double minimumValue= -1, maximumValue= -1, modeValue= 0, medianValue= 0, meanValue= 0;\n    long long totalValuesCount= 0, highestFrequencyCount= 0, currentFrequencyCount= 0;\n    double totalSum= 0;\n\n    for(int index= 0; index <= 255; index++)\n    {\n        if(frequencyCount[index] > 0)\n        {\n            if(minimumValue == -1)\n                minimumValue= index;\n            maximumValue= index;\n            totalSum+= static_cast<double>(index) * frequencyCount[index];\n            totalValuesCount+= frequencyCount[index];\n            if(frequencyCount[index] > highestFrequencyCount)\n            {\n                highestFrequencyCount= frequencyCount[index];\n                modeValue= index;\n            }\n        }\n    }\n\n    meanValue= totalSum / totalValuesCount;\n    bool isEvenCount= (totalValuesCount % 2 == 0);\n    long long midIndex1= totalValuesCount / 2, midIndex2= midIndex1 - 1;\n    if(isEvenCount)\n        midIndex2++;\n\n    for(int index= 0; index <= 255; index++)\n    {\n        currentFrequencyCount+= frequencyCount[index];\n        if(isEvenCount && currentFrequencyCount >= midIndex2)\n        {\n            medianValue+= index;\n            midIndex2= totalValuesCount;\n            isEvenCount= false;\n        }\n\n        if(currentFrequencyCount >= midIndex1)\n        {\n            medianValue+= index;\n            break;\n        }\n    }\n\n    if(!isEvenCount)\n        medianValue/= 2;\n    return {minimumValue, maximumValue, meanValue, medianValue, modeValue};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool carPooling(vector<vector<int>> &tripDetails, int vehicleCapacity)\n{\n    vector<int> passengerStops(1001, 0);\n    for (int i = 0; i < tripDetails.size(); ++i)\n    {\n        const vector<int> &tripDetail = tripDetails[i];\n        passengerStops[tripDetail[1]] += tripDetail[0];\n        passengerStops[tripDetail[2]] -= tripDetail[0];\n    }\n    for (int index = 0; index < passengerStops.size(); ++index)\n    {\n        vehicleCapacity -= passengerStops[index];\n        if (vehicleCapacity < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool carPooling(std::vector<std::vector<int>> &tripDetails, int vehicleCapacity)\n{\n    std::vector<int> passengerStops(1001, 0);\n    for(const std::vector<int> &tripDetail : tripDetails)\n    {\n        passengerStops[tripDetail[1]]+= tripDetail[0];\n        passengerStops[tripDetail[2]]-= tripDetail[0];\n    }\n    for(int index= 0; index < passengerStops.size(); ++index)\n    {\n        vehicleCapacity-= passengerStops[index];\n        if(vehicleCapacity < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring dayOfTheWeek(int day, int month, int year)\n{\n    int daysInMonth[]= {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    string weekdays[]= {\"Sunday \", \"Monday \", \"Tuesday \", \"Wednesday \", \"Thursday \", \"Friday \", \"Saturday \"};\n    if(year < 1971)\n        year+= (1971 - year) / 400 * 400;\n    int totalDays= -1;\n    for(int currentYear= 1971; currentYear < year; ++currentYear)\n    {\n        totalDays+= 365;\n        if(currentYear % 4 == 0 && (currentYear % 100 != 0 || currentYear % 400 == 0))\n            ++totalDays;\n    }\n    for(int currentMonth= 1; currentMonth < month; ++currentMonth)\n    {\n        totalDays+= daysInMonth[currentMonth];\n        if(currentMonth == 2 && year % 4 == 0 && (year % 100 != 0 || year % 400 == 0))\n            ++totalDays;\n    }\n    return weekdays[(totalDays + day) % 7];\n}",
    "output": "#include <bits/stdc++.h>\nstd::string dayOfTheWeek(int day, int month, int year)\n{\n    int daysInMonth[]= {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    std::string weekdays[]= {\"Sunday \", \"Monday \", \"Tuesday \", \"Wednesday \", \"Thursday \", \"Friday \", \"Saturday \"};\n    if(year < 1971)\n        year+= (1971 - year) / 400 * 400;\n    int totalDays= -1;\n    for(int currentYear= 1971; currentYear < year; ++currentYear)\n    {\n        totalDays+= 365;\n        if(currentYear % 4 == 0 && (currentYear % 100 != 0 || currentYear % 400 == 0))\n            ++totalDays;\n    }\n    for(int currentMonth= 1; currentMonth < month; ++currentMonth)\n    {\n        totalDays+= daysInMonth[currentMonth];\n        if(currentMonth == 2 && year % 4 == 0 && (year % 100 != 0 || year % 400 == 0))\n            ++totalDays;\n    }\n    return weekdays[(totalDays + day) % 7];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass H2O\n{\n  public:\n    sem_t hydrogenSemaphore;\n    sem_t oxygenSemaphore;\n\n    H2O()\n    {\n        sem_init(&hydrogenSemaphore, 0, 2);\n        sem_init(&oxygenSemaphore, 0, 1);\n    }\n\n    void hydrogen(function<void()> releaseHydrogen)\n    {\n        sem_wait(&hydrogenSemaphore);\n        releaseHydrogen();\n        sem_post(&oxygenSemaphore);\n    }\n\n    void oxygen(function<void()> releaseOxygen)\n    {\n        sem_wait(&oxygenSemaphore);\n        releaseOxygen();\n        sem_post(&hydrogenSemaphore);\n        sem_post(&hydrogenSemaphore);\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass H2O\n{\n  public:\n    sem_t hydrogenSemaphore;\n    sem_t oxygenSemaphore;\n\n    H2O()\n    {\n        sem_init(&hydrogenSemaphore, 0, 2);\n        sem_init(&oxygenSemaphore, 0, 1);\n    }\n\n    void hydrogen(std::function<void()> releaseHydrogen)\n    {\n        sem_wait(&hydrogenSemaphore);\n        releaseHydrogen();\n        sem_post(&oxygenSemaphore);\n    }\n\n    void oxygen(std::function<void()> releaseOxygen)\n    {\n        sem_wait(&oxygenSemaphore);\n        releaseOxygen();\n        sem_post(&hydrogenSemaphore);\n        sem_post(&hydrogenSemaphore);\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass FooBar\n{\n  private:\n    int totalIterations;\n    mutex mutexLock;\n    condition_variable conditionVariable;\n    bool isFooDone = false;\n\n  public:\n    FooBar(int totalIterations)\n    {\n        this->totalIterations = totalIterations;\n    }\n\n    void foo(function<void()> printFoo)\n    {\n        for(int i = 0; i < totalIterations; i++)\n        {\n            unique_lock<mutex> lock(mutexLock);\n            conditionVariable.wait(lock, [this]()\n                                   { return !isFooDone; });\n            printFoo();\n            isFooDone = true;\n            conditionVariable.notify_all();\n        }\n    }\n\n    void bar(function<void()> printBar)\n    {\n        for(int i = 0; i < totalIterations; i++)\n        {\n            unique_lock<mutex> lock(mutexLock);\n            conditionVariable.wait(lock, [this]()\n                                   { return isFooDone; });\n            printBar();\n            isFooDone = false;\n            conditionVariable.notify_all();\n        }\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass FooBar\n{\n  private:\n    int totalIterations;\n    std::mutex mutexLock;\n    std::condition_variable conditionVariable;\n    bool isFooDone= false;\n\n  public:\n    FooBar(int totalIterations)\n    {\n        this->totalIterations= totalIterations;\n    }\n\n    void foo(function<void()> printFoo)\n    {\n        for(int i= 0; i < totalIterations; i++)\n        {\n            std::unique_lock<std::mutex> lock(mutexLock);\n            conditionVariable.wait(lock, [this]()\n                                   { return !isFooDone; });\n            printFoo();\n            isFooDone= true;\n            conditionVariable.notify_all();\n        }\n    }\n\n    void bar(function<void()> printBar)\n    {\n        for(int i= 0; i < totalIterations; i++)\n        {\n            std::unique_lock<std::mutex> lock(mutexLock);\n            conditionVariable.wait(lock, [this]()\n                                   { return isFooDone; });\n            printBar();\n            isFooDone= false;\n            conditionVariable.notify_all();\n        }\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// for min_element\nusing namespace std;\n\nint maxNumberOfBalloons(string text)\n{\n    int letterCount[5] = {0};\n    for (int i = 0; i < text.size(); ++i)\n    {\n        char character = text[i];\n        if (character == 'b')\n            letterCount[0]++;\n        if (character == 'a')\n            letterCount[1]++;\n        if (character == 'l')\n            letterCount[2]++;\n        if (character == 'o')\n            letterCount[3]++;\n        if (character == 'n')\n            letterCount[4]++;\n    }\n    letterCount[2] /= 2; // 'l' appears twice in \"balloon\"\n    letterCount[3] /= 2; // 'o' appears twice in \"balloon\"\n    return *min_element(letterCount, letterCount + 5);\n}",
    "output": "#include <bits/stdc++.h>\nint maxNumberOfBalloons(std::string text)\n{\n    int letterCount[5]= {0};\n    for(char character : text)\n    {\n        if(character == 'b')\n            letterCount[0]++;\n        if(character == 'a')\n            letterCount[1]++;\n        if(character == 'l')\n            letterCount[2]++;\n        if(character == 'o')\n            letterCount[3]++;\n        if(character == 'n')\n            letterCount[4]++;\n    }\n    letterCount[2]/= 2;\n    letterCount[3]/= 2;\n    return *std::min_element(letterCount, letterCount + 5);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring reverseParentheses(string inputString)\n{\n\n    stack<int> indexStack;\n    for(int currentIndex= 0; currentIndex < inputString.length(); ++currentIndex)\n    {\n\n        if(inputString[currentIndex] == '(')\n            indexStack.push(currentIndex);\n        else if(inputString[currentIndex] == ')')\n        {\n            reverse(inputString.begin() + indexStack.top() + 1, inputString.begin() + currentIndex);\n            indexStack.pop();\n        }\n    }\n    string outputString= \"\";\n    for(int currentIndex= 0; currentIndex < inputString.length(); ++currentIndex)\n    {\n\n        if(inputString[currentIndex] != '(' && inputString[currentIndex] != ')')\n            outputString+= inputString[currentIndex];\n    }\n    return outputString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string reverseParentheses(std::string inputString)\n{\n    std::stack<int> indexStack;\n    for(int currentIndex= 0; currentIndex < inputString.length(); ++currentIndex)\n    {\n        if(inputString[currentIndex] == '(')\n            indexStack.push(currentIndex);\n        else if(inputString[currentIndex] == ')')\n        {\n            std::reverse(inputString.begin() + indexStack.top() + 1, inputString.begin() + currentIndex);\n            indexStack.pop();\n        }\n    }\n    std::string outputString= \"\";\n    for(int currentIndex= 0; currentIndex < inputString.length(); ++currentIndex)\n    {\n        if(inputString[currentIndex] != '(' && inputString[currentIndex] != ')')\n            outputString+= inputString[currentIndex];\n    }\n    return outputString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint kConcatenationMaxSum(vector<int> &array, int concatenationCount)\n{\n    long long modulus= 1e9 + 7, arraySize= array.size(), totalSum= 0, maximumSum= 0, temporarySum= 0, maximumLeft= 0, maximumRight= 0;\n    for(int index= 0; index < arraySize; ++index)\n    {\n        totalSum+= array[index];\n        temporarySum+= array[index];\n        maximumSum= max(maximumSum, temporarySum);\n        temporarySum= max(0LL, temporarySum);\n        maximumLeft= max(maximumLeft, totalSum);\n    }\n    long long temporaryTotal= totalSum;\n    for(int index= arraySize - 1; index >= 0; --index)\n    {\n        temporaryTotal-= array[index];\n        maximumRight= max(maximumRight, temporaryTotal);\n    }\n    long long result= max({maximumSum, maximumLeft + maximumRight + totalSum * (concatenationCount - 2), 0LL});\n    return result % modulus;\n}",
    "output": "#include <bits/stdc++.h>\nint kConcatenationMaxSum(std::vector<int> &array, int concatenationCount)\n{\n    long long modulus= 1e9 + 7, arraySize= array.size(), totalSum= 0, maximumSum= 0, temporarySum= 0, maximumLeft= 0, maximumRight= 0;\n    for(int index= 0; index < arraySize; ++index)\n    {\n        totalSum+= array[index];\n        temporarySum+= array[index];\n        maximumSum= std::max(maximumSum, temporarySum);\n        temporarySum= std::max(0LL, temporarySum);\n        maximumLeft= std::max(maximumLeft, totalSum);\n    }\n    long long temporaryTotal= totalSum;\n    for(int index= arraySize - 1; index >= 0; --index)\n    {\n        temporaryTotal-= array[index];\n        maximumRight= std::max(maximumRight, temporaryTotal);\n    }\n    long long result= std::max({maximumSum, maximumLeft + maximumRight + totalSum * (concatenationCount - 2), 0LL});\n    return result % modulus;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(int currentNode, int parentNode, int currentDepth, vector<int> &depthRank, unordered_map<int, vector<int>> &adjacencyList, vector<vector<int>> &criticalConnections)\n{\n    depthRank[currentNode] = currentDepth;\n    for (const int &neighborNode : adjacencyList[currentNode])\n    {\n        if (neighborNode == parentNode)\n        {\n            continue;\n        }\n        if (depthRank[neighborNode] == -1)\n        {\n            depthFirstSearch(neighborNode, currentNode, currentDepth + 1, depthRank, adjacencyList, criticalConnections);\n        }\n        depthRank[currentNode] = min(depthRank[currentNode], depthRank[neighborNode]);\n        if (depthRank[neighborNode] == currentDepth + 1)\n        {\n            criticalConnections.push_back({currentNode, neighborNode});\n        }\n    }\n}\n\nvector<vector<int>> findCriticalConnections(int numberOfNodes, vector<vector<int>> &connections)\n{\n    vector<vector<int>> criticalConnections;\n    unordered_map<int, vector<int>> adjacencyList;\n    for (int i = 0; i < connections.size(); ++i)\n    {\n        const vector<int> &connection = connections[i];\n        adjacencyList[connection[0]].push_back(connection[1]);\n        adjacencyList[connection[1]].push_back(connection[0]);\n    }\n    vector<int> depthRank(numberOfNodes, -1);\n    depthFirstSearch(0, -1, 0, depthRank, adjacencyList, criticalConnections);\n    return criticalConnections;\n}",
    "output": "#include <bits/stdc++.h>\nvoid depthFirstSearch(int currentNode, int parentNode, int currentDepth, std::vector<int> &depthRank, std::unordered_map<int, std::vector<int>> &adjacencyList, std::vector<std::vector<int>> &criticalConnections)\n{\n    depthRank[currentNode]= currentDepth;\n    for(const int &neighborNode : adjacencyList[currentNode])\n    {\n        if(neighborNode == parentNode)\n        {\n            continue;\n        }\n        if(depthRank[neighborNode] == -1)\n        {\n            depthFirstSearch(neighborNode, currentNode, currentDepth + 1, depthRank, adjacencyList, criticalConnections);\n        }\n        depthRank[currentNode]= std::min(depthRank[currentNode], depthRank[neighborNode]);\n        if(depthRank[neighborNode] == currentDepth + 1)\n        {\n            criticalConnections.push_back({currentNode, neighborNode});\n        }\n    }\n}\n\nstd::vector<std::vector<int>> findCriticalConnections(int numberOfNodes, std::vector<std::vector<int>> &connections)\n{\n    std::vector<std::vector<int>> criticalConnections;\n    std::unordered_map<int, std::vector<int>> adjacencyList;\n    for(const std::vector<int> &connection : connections)\n    {\n        adjacencyList[connection[0]].push_back(connection[1]);\n        adjacencyList[connection[1]].push_back(connection[0]);\n    }\n    std::vector<int> depthRank(numberOfNodes, -1);\n    depthFirstSearch(0, -1, 0, depthRank, adjacencyList, criticalConnections);\n    return criticalConnections;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minHeightShelves(vector<vector<int>> &books, int shelfWidth)\n{\n    int numberOfBooks = books.size();\n    vector<int> dynamicProgramming(numberOfBooks + 1, 1000000);\n    dynamicProgramming[0] = 0;\n\n    for(int currentBook = 1; currentBook <= numberOfBooks; ++currentBook)\n    {\n        int totalWidth = 0, maxHeight = 0;\n        for(int j = currentBook; j >= 1; --j)\n        {\n            totalWidth += books[j - 1][0];\n            maxHeight = max(maxHeight, books[j - 1][1]);\n\n            if(totalWidth <= shelfWidth)\n                dynamicProgramming[currentBook] = min(dynamicProgramming[currentBook], dynamicProgramming[j - 1] + maxHeight);\n        }\n    }\n\n    return dynamicProgramming[numberOfBooks];\n}",
    "output": "#include <bits/stdc++.h>\nint minHeightShelves(std::vector<std::vector<int>> &books, int shelfWidth)\n{\n    int numberOfBooks= books.size();\n    std::vector<int> dynamicProgramming(numberOfBooks + 1, 1000000);\n    dynamicProgramming[0]= 0;\n\n    for(int currentBook= 1; currentBook <= numberOfBooks; ++currentBook)\n    {\n        int totalWidth= 0, maxHeight= 0;\n        for(int j= currentBook; j >= 1; --j)\n        {\n            totalWidth+= books[j - 1][0];\n            maxHeight= std::max(maxHeight, books[j - 1][1]);\n\n            if(totalWidth <= shelfWidth)\n                dynamicProgramming[currentBook]= std::min(dynamicProgramming[currentBook], dynamicProgramming[j - 1] + maxHeight);\n        }\n    }\n\n    return dynamicProgramming[numberOfBooks];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool parseBooleanExpression(string expression, int &currentPosition)\n{\n    switch(expression[currentPosition++])\n    {\n    case 't':\n        return true;\n    case 'f':\n        return false;\n    case '!':\n        return !parseBooleanExpression(expression, ++currentPosition);\n    case '&':\n    {\n        currentPosition++;\n        bool result= true;\n        while(expression[currentPosition] != ')')\n        {\n            result&= parseBooleanExpression(expression, currentPosition);\n            if(expression[currentPosition] == ',')\n                currentPosition++;\n        }\n        currentPosition++;\n        return result;\n    }\n    case '|':\n    {\n        currentPosition++;\n        bool result= false;\n        while(expression[currentPosition] != ')')\n        {\n            result|= parseBooleanExpression(expression, currentPosition);\n            if(expression[currentPosition] == ',')\n                currentPosition++;\n        }\n        currentPosition++;\n        return result;\n    }\n    }\n}\n\nbool parseBooleanExpression(string expression)\n{\n    int currentPosition= 0;\n    return parseBooleanExpression(expression, currentPosition);\n}",
    "output": "#include <bits/stdc++.h>\nbool parseBooleanExpression(std::string expression, int &currentPosition)\n{\n    switch(expression[currentPosition++])\n    {\n    case 't':\n        return true;\n    case 'f':\n        return false;\n    case '!':\n        return !parseBooleanExpression(expression, ++currentPosition);\n    case '&':\n    {\n        currentPosition++;\n        bool result= true;\n        while(expression[currentPosition] != ')')\n        {\n            result &= parseBooleanExpression(expression, currentPosition);\n            if(expression[currentPosition] == ',')\n                currentPosition++;\n        }\n        currentPosition++;\n        return result;\n    }\n    case '|':\n    {\n        currentPosition++;\n        bool result= false;\n        while(expression[currentPosition] != ')')\n        {\n            result |= parseBooleanExpression(expression, currentPosition);\n            if(expression[currentPosition] == ',')\n                currentPosition++;\n        }\n        currentPosition++;\n        return result;\n    }\n    }\n    return false; // Add a return statement to handle cases where none of the cases match\n}\n\nbool parseBooleanExpression(std::string expression)\n{\n    int currentPosition= 0;\n    return parseBooleanExpression(expression, currentPosition);\n}\n"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findSmallestCommonElement(vector<vector<int>> &matrix)\n{\n    unordered_map<int, int> elementCounts;\n    for (int i = 0; i < matrix.size(); ++i)\n    {\n        const auto &row = matrix[i];\n        for (int j = 0; j < row.size(); ++j)\n        {\n            int element = row[j];\n            ++elementCounts[element];\n            if (elementCounts[element] == matrix.size())\n            {\n                return element;\n            }\n        }\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint findSmallestCommonElement(std::vector<std::vector<int>> &matrix)\n{\n    std::unordered_map<int, int> elementCounts;\n    for(const auto &row : matrix)\n    {\n        for(int element : row)\n        {\n            ++elementCounts[element];\n            if(elementCounts[element] == matrix.size())\n            {\n                return element;\n            }\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minBuildTime(vector<int> &blockTimes, int splitTime)\n{\n    priority_queue<int, vector<int>, greater<int>> priorityQueue(blockTimes.begin(), blockTimes.end());\n\n    while(priorityQueue.size() > 1)\n    {\n        int firstBlock = priorityQueue.top();\n        priorityQueue.pop();\n        int secondBlock = priorityQueue.top();\n        priorityQueue.pop();\n        priorityQueue.push(secondBlock + splitTime);\n    }\n\n    return priorityQueue.top();\n}",
    "output": "#include <bits/stdc++.h>\nint minBuildTime(std::vector<int> &blockTimes, int splitTime)\n{\n    std::priority_queue<int, std::vector<int>, std::greater<int>> priorityQueue(blockTimes.begin(), blockTimes.end());\n\n    while(priorityQueue.size() > 1)\n    {\n        int firstBlock= priorityQueue.top();\n        priorityQueue.pop();\n        int secondBlock= priorityQueue.top();\n        priorityQueue.pop();\n        priorityQueue.push(secondBlock + splitTime);\n    }\n\n    return priorityQueue.top();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> minimumAbsDifference(vector<int> &sortedArray)\n{\n    sort(sortedArray.begin(), sortedArray.end());\n    int minimumDifference= INT_MAX;\n    for(int index= 1; index < sortedArray.size(); index++)\n    {\n        minimumDifference= min(minimumDifference, sortedArray[index] - sortedArray[index - 1]);\n    }\n\n    vector<vector<int>> resultPairs;\n    for(int index= 1; index < sortedArray.size(); index++)\n    {\n        if(sortedArray[index] - sortedArray[index - 1] == minimumDifference)\n        {\n            resultPairs.push_back({sortedArray[index - 1], sortedArray[index]});\n        }\n    }\n\n    return resultPairs;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> minimumAbsDifference(std::vector<int> &sortedArray)\n{\n    std::sort(sortedArray.begin(), sortedArray.end());\n    int minimumDifference = INT_MAX;\n    for(int index = 1; index < sortedArray.size(); index++)\n    {\n        minimumDifference = std::min(minimumDifference, sortedArray[index] - sortedArray[index - 1]);\n    }\n\n    std::vector<std::vector<int>> resultPairs;\n    for(int index = 1; index < sortedArray.size(); index++)\n    {\n        if(sortedArray[index] - sortedArray[index - 1] == minimumDifference)\n        {\n            resultPairs.push_back({sortedArray[index - 1], sortedArray[index]});\n        }\n    }\n\n    return resultPairs;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint nthUglyNumber(int n, int factorA, int factorB, int factorC)\n{\n    long long lowerBound= 1, upperBound= 2 * 1e9, gcdAB= gcd(factorA, factorB), gcdAC= gcd(factorA, factorC), gcdBC= gcd(factorB, factorC);\n    long long lcmAB= factorA / gcdAB * factorB, lcmAC= factorA / gcdAC * factorC, lcmBC= factorB / gcdBC * factorC, lcmABC= factorA / gcdAB * lcmBC;\n\n    while(lowerBound < upperBound)\n    {\n        long long midPoint= lowerBound + (upperBound - lowerBound) / 2;\n        long long count= midPoint / factorA + midPoint / factorB + midPoint / factorC - midPoint / lcmAB - midPoint / lcmAC - midPoint / lcmBC + midPoint / lcmABC;\n        if(count < n)\n        {\n            lowerBound= midPoint + 1;\n        }\n        else\n        {\n            upperBound= midPoint;\n        }\n    }\n    return lowerBound;\n}",
    "output": "#include <bits/stdc++.h>\nint nthUglyNumber(int n, int factorA, int factorB, int factorC)\n{\n    long long lowerBound= 1, upperBound= 2 * 1e9, gcdAB= std::__gcd(factorA, factorB), gcdAC= std::__gcd(factorA, factorC), gcdBC= std::__gcd(factorB, factorC);\n    long long lcmAB= factorA / gcdAB * factorB, lcmAC= factorA / gcdAC * factorC, lcmBC= factorB / gcdBC * factorC, lcmABC= factorA / gcdAB * lcmBC;\n\n    while(lowerBound < upperBound)\n    {\n        long long midPoint= lowerBound + (upperBound - lowerBound) / 2;\n        long long count= midPoint / factorA + midPoint / factorB + midPoint / factorC - midPoint / lcmAB - midPoint / lcmAC - midPoint / lcmBC + midPoint / lcmABC;\n        if(count < n)\n        {\n            lowerBound= midPoint + 1;\n        }\n        else\n        {\n            upperBound= midPoint;\n        }\n    }\n    return lowerBound;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution\n{\n  public:\n    string smallestStringWithSwaps(string inputString, vector<vector<int>> &swapPairs)\n    {\n        int stringLength = inputString.size();\n        vector<int> parent(stringLength, 0);\n        for (int index = 0; index < stringLength; ++index)\n        {\n            parent[index] = index;\n        }\n\n        // find the parent for each index\n        function<int(int)> findParent = [&](int currentIndex)\n        {\n            if (parent[currentIndex] != currentIndex)\n            {\n                parent[currentIndex] = findParent(parent[currentIndex]);\n            }\n            return parent[currentIndex];\n        };\n\n        // union-find and create the connected groups\n        for (int i = 0; i < swapPairs.size(); ++i)\n        {\n            int root1 = findParent(swapPairs[i][0]);\n            int root2 = findParent(swapPairs[i][1]);\n            if (root1 != root2)\n            {\n                parent[root2] = root1;\n            }\n        }\n\n        vector<string> connectedGroups(stringLength);\n        for (int index = 0; index < stringLength; ++index)\n        {\n            connectedGroups[findParent(index)].push_back(inputString[index]);\n        }\n\n        // Sort each group\n        for (int i = 0; i < connectedGroups.size(); ++i)\n        {\n            sort(connectedGroups[i].begin(), connectedGroups[i].end(), greater<char>());\n        }\n\n        // Build the result string\n        string resultString;\n        for (int index = 0; index < stringLength; ++index)\n        {\n            char smallestCharacter = connectedGroups[findParent(index)].back();\n            resultString += smallestCharacter;\n            connectedGroups[findParent(index)].pop_back();\n        }\n\n        return resultString;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Solution\n{\n  public:\n    std::string smallestStringWithSwaps(std::string inputString, std::vector<std::vector<int>> &swapPairs)\n    {\n        int stringLength= inputString.size();\n        std::vector<int> parent(stringLength, 0);\n        for(int index= 0; index < stringLength; ++index)\n        {\n            parent[index]= index;\n        }\n\n        // find the parent for each index\n        std::function<int(int)> findParent= [&](int currentIndex)\n        {\n            if(parent[currentIndex] != currentIndex)\n            {\n                parent[currentIndex]= findParent(parent[currentIndex]);\n            }\n            return parent[currentIndex];\n        };\n\n        // union-find and create the connected groups\n        for(const auto &swapPair : swapPairs)\n        {\n            int root1= findParent(swapPair[0]);\n            int root2= findParent(swapPair[1]);\n            if(root1 != root2)\n            {\n                parent[root2]= root1;\n            }\n        }\n\n        std::vector<std::string> connectedGroups(stringLength);\n        for(int index= 0; index < stringLength; ++index)\n        {\n            connectedGroups[findParent(index)].push_back(inputString[index]);\n        }\n\n        // Sort each group\n        for(std::string &group : connectedGroups)\n        {\n            std::sort(group.begin(), group.end(), std::greater<char>());\n        }\n\n        // Build the result string\n        std::string resultString;\n        for(int index= 0; index < stringLength; ++index)\n        {\n            char smallestCharacter= connectedGroups[findParent(index)].back();\n            resultString+= smallestCharacter;\n            connectedGroups[findParent(index)].pop_back();\n        }\n\n        return resultString;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Foo\n{\n    mutex mutexLock;\n    condition_variable conditionVar;\n    int currentOrder = 1;\n\n  public:\n    Foo() {}\n\n    void first()\n    {\n        unique_lock<mutex> lock(mutexLock);\n        // printFirst() outputs \"first\". Do not change or remove this line.\n        printFirst();\n        currentOrder = 2;\n        conditionVar.notify_all();\n    }\n\n    void second()\n    {\n        unique_lock<mutex> lock(mutexLock);\n        conditionVar.wait(lock, [&]()\n                          { return currentOrder == 2; });\n        // printSecond() outputs \"second\". Do not change or remove this line.\n        printSecond();\n        currentOrder = 3;\n        conditionVar.notify_all();\n    }\n\n    void third()\n    {\n        unique_lock<mutex> lock(mutexLock);\n        conditionVar.wait(lock, [&]()\n                          { return currentOrder == 3; });\n        // printThird() outputs \"third\". Do not change or remove this line.\n        printThird();\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Foo\n{\n    std::mutex mutexLock;\n    std::condition_variable conditionVar;\n    int currentOrder= 1;\n\n  public:\n    Foo() {}\n\n    void first()\n    {\n        std::unique_lock<std::mutex> lock(mutexLock);\n        // printFirst() outputs \"first\". Do not change or remove this line.\n        printFirst();\n        currentOrder= 2;\n        conditionVar.notify_all();\n    }\n\n    void second()\n    {\n        std::unique_lock<std::mutex> lock(mutexLock);\n        conditionVar.wait(lock, [&]()\n                          { return currentOrder == 2; });\n        // printSecond() outputs \"second\". Do not change or remove this line.\n        printSecond();\n        currentOrder= 3;\n        conditionVar.notify_all();\n    }\n\n    void third()\n    {\n        std::unique_lock<std::mutex> lock(mutexLock);\n        conditionVar.wait(lock, [&]()\n                          { return currentOrder == 3; });\n        // printThird() outputs \"third\". Do not change or remove this line.\n        printThird();\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> corpFlightBookings(vector<vector<int>> &flightBookings, int totalFlights)\n{\n    vector<int> bookingCount(totalFlights, 0);\n    for (int i = 0; i < flightBookings.size(); ++i)\n    {\n        const auto &booking = flightBookings[i];\n        bookingCount[booking[0] - 1] += booking[2];\n        if (booking[1] < totalFlights)\n        {\n            bookingCount[booking[1]] -= booking[2];\n        }\n    }\n    for (int index = 1; index < totalFlights; ++index)\n    {\n        bookingCount[index] += bookingCount[index - 1];\n    }\n    return bookingCount;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> corpFlightBookings(std::vector<std::vector<int>> &flightBookings, int totalFlights)\n{\n    std::vector<int> bookingCount(totalFlights, 0);\n    for(const auto &booking : flightBookings)\n    {\n        bookingCount[booking[0] - 1]+= booking[2];\n        if(booking[1] < totalFlights)\n        {\n            bookingCount[booking[1]]-= booking[2];\n        }\n    }\n    for(int index= 1; index < totalFlights; ++index)\n    {\n        bookingCount[index]+= bookingCount[index - 1];\n    }\n    return bookingCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nvector<TreeNode *> deleteNodes(TreeNode *rootNode, vector<int> &nodesToDelete)\n{\n    vector<TreeNode *> forest;\n    set<int> toDeleteSet(nodesToDelete.begin(), nodesToDelete.end());\n    helper(rootNode, true, toDeleteSet, forest);\n    return forest;\n}\n\nTreeNode *helper(TreeNode *currentNode, bool isRoot, set<int> &toDeleteSet, vector<TreeNode *> &forest)\n{\n    if(!currentNode)\n        return NULL;\n    bool isDeleted= toDeleteSet.count(currentNode->value);\n    if(isRoot && !isDeleted)\n        forest.push_back(currentNode);\n    currentNode->leftChild= helper(currentNode->leftChild, isDeleted, toDeleteSet, forest);\n    currentNode->rightChild= helper(currentNode->rightChild, isDeleted, toDeleteSet, forest);\n    return isDeleted ? NULL : currentNode;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nstd::vector<TreeNode *> deleteNodes(TreeNode *rootNode, std::vector<int> &nodesToDelete)\n{\n    std::vector<TreeNode *> forest;\n    std::set<int> toDeleteSet(nodesToDelete.begin(), nodesToDelete.end());\n    helper(rootNode, true, toDeleteSet, forest);\n    return forest;\n}\n\nTreeNode *helper(TreeNode *currentNode, bool isRoot, std::set<int> &toDeleteSet, std::vector<TreeNode *> &forest)\n{\n    if(!currentNode)\n        return NULL;\n    bool isDeleted= toDeleteSet.count(currentNode->value);\n    if(isRoot && !isDeleted)\n        forest.push_back(currentNode);\n    currentNode->leftChild= helper(currentNode->leftChild, isDeleted, toDeleteSet, forest);\n    currentNode->rightChild= helper(currentNode->rightChild, isDeleted, toDeleteSet, forest);\n    return isDeleted ? NULL : currentNode;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> splitString(const string &inputString)\n{\n    vector<int> resultVector(inputString.length());\n    int parenthesisCount= 0;\n\n    for(size_t index= 0; index < inputString.length(); ++index)\n    {\n        if(inputString[index] == '(')\n        {\n            resultVector[index]= parenthesisCount % 2;\n            parenthesisCount++;\n        }\n        else\n        {\n            parenthesisCount--;\n            resultVector[index]= parenthesisCount % 2;\n        }\n    }\n\n    return resultVector;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> splitString(const std::string &inputString)\n{\n    std::vector<int> resultVector(inputString.length());\n    int parenthesisCount= 0;\n\n    for(size_t index= 0; index < inputString.length(); ++index)\n    {\n        if(inputString[index] == '(')\n        {\n            resultVector[index]= parenthesisCount % 2;\n            parenthesisCount++;\n        }\n        else\n        {\n            parenthesisCount--;\n            resultVector[index]= parenthesisCount % 2;\n        }\n    }\n\n    return resultVector;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring removeDuplicates(string inputString, int threshold)\n{\n    vector<pair<char, int>> characterStack;\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentChar = inputString[i];\n        if (characterStack.empty() || characterStack.back().first != currentChar)\n        {\n            characterStack.push_back({currentChar, 1});\n        }\n        else if (++characterStack.back().second == threshold)\n        {\n            characterStack.pop_back();\n        }\n    }\n    string resultString;\n    for (int i = 0; i < characterStack.size(); ++i)\n    {\n        auto &characterPair = characterStack[i];\n        resultString.append(characterPair.second, characterPair.first);\n    }\n    return resultString;\n}",
    "output": "std::string removeDuplicates(std::string inputString, int threshold)\n{\n    std::vector<std::pair<char, int>> characterStack;\n    for(char currentChar : inputString)\n    {\n        if(characterStack.empty() || characterStack.back().first != currentChar)\n        {\n            characterStack.push_back({currentChar, 1});\n        }\n        else if(++characterStack.back().second == threshold)\n        {\n            characterStack.pop_back();\n        }\n    }\n    std::string resultString;\n    for(auto &characterPair : characterStack)\n    {\n        resultString.append(characterPair.second, characterPair.first);\n    }\n    return resultString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble trimmedMean(vector<int> &valueList)\n{\n    int totalElements = valueList.size();\n    int elementsToRemove = totalElements * 0.05;\n    sort(valueList.begin(), valueList.end());\n    double totalSum = 0.0;\n    for(int index = elementsToRemove; index < totalElements - elementsToRemove; index++)\n    {\n        totalSum += valueList[index];\n    }\n    return totalSum / (totalElements - 2 * elementsToRemove);\n}",
    "output": "#include <bits/stdc++.h>\ndouble trimmedMean(std::vector<int> &valueList)\n{\n    int totalElements= valueList.size();\n    int elementsToRemove= totalElements * 0.05;\n    std::sort(valueList.begin(), valueList.end());\n    double totalSum= 0.0;\n    for(int index= elementsToRemove; index < totalElements - elementsToRemove; index++)\n    {\n        totalSum+= valueList[index];\n    }\n    return totalSum / (totalElements - 2 * elementsToRemove);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> arraysIntersection(vector<int> &firstArray, vector<int> &secondArray, vector<int> &thirdArray)\n{\n    int firstIndex= 0, secondIndex= 0, thirdIndex= 0;\n    vector<int> intersectionResult;\n    while(firstIndex < firstArray.size() && secondIndex < secondArray.size() && thirdIndex < thirdArray.size())\n    {\n        if(firstArray[firstIndex] == secondArray[secondIndex] && secondArray[secondIndex] == thirdArray[thirdIndex])\n        {\n            intersectionResult.push_back(firstArray[firstIndex]);\n            firstIndex++;\n            secondIndex++;\n            thirdIndex++;\n        }\n        else\n        {\n            if(firstArray[firstIndex] <= secondArray[secondIndex] && firstArray[firstIndex] <= thirdArray[thirdIndex])\n                firstIndex++;\n            else if(secondArray[secondIndex] <= thirdArray[thirdIndex])\n                secondIndex++;\n            else\n                thirdIndex++;\n        }\n    }\n    return intersectionResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> arraysIntersection(std::vector<int> &firstArray, std::vector<int> &secondArray, std::vector<int> &thirdArray)\n{\n    int firstIndex= 0, secondIndex= 0, thirdIndex= 0;\n    std::vector<int> intersectionResult;\n    while(firstIndex < firstArray.size() && secondIndex < secondArray.size() && thirdIndex < thirdArray.size())\n    {\n        if(firstArray[firstIndex] == secondArray[secondIndex] && secondArray[secondIndex] == thirdArray[thirdIndex])\n        {\n            intersectionResult.push_back(firstArray[firstIndex]);\n            firstIndex++;\n            secondIndex++;\n            thirdIndex++;\n        }\n        else\n        {\n            if(firstArray[firstIndex] <= secondArray[secondIndex] && firstArray[firstIndex] <= thirdArray[thirdIndex])\n                firstIndex++;\n            else if(secondArray[secondIndex] <= thirdArray[thirdIndex])\n                secondIndex++;\n            else\n                thirdIndex++;\n        }\n    }\n    return intersectionResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nbool findPairWithSum(TreeNode *currentNode, int targetSum, unordered_set<int> &valueSet)\n{\n    if(!currentNode)\n        return false;\n    if(valueSet.count(targetSum - currentNode->value))\n        return true;\n    valueSet.insert(currentNode->value);\n    return findPairWithSum(currentNode->leftChild, targetSum, valueSet) || findPairWithSum(currentNode->rightChild, targetSum, valueSet);\n}\n\nbool twoSumInBSTs(TreeNode *firstTreeRoot, TreeNode *secondTreeRoot, int targetSum)\n{\n    unordered_set<int> valueSet;\n    findPairWithSum(firstTreeRoot, targetSum, valueSet);\n    return findPairWithSum(secondTreeRoot, targetSum, valueSet);\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nbool findPairWithSum(TreeNode *currentNode, int targetSum, std::unordered_set<int> &valueSet)\n{\n    if(!currentNode)\n        return false;\n    if(valueSet.count(targetSum - currentNode->value))\n        return true;\n    valueSet.insert(currentNode->value);\n    return findPairWithSum(currentNode->leftChild, targetSum, valueSet) || findPairWithSum(currentNode->rightChild, targetSum, valueSet);\n}\n\nbool twoSumInBSTs(TreeNode *firstTreeRoot, TreeNode *secondTreeRoot, int targetSum)\n{\n    std::unordered_set<int> valueSet;\n    findPairWithSum(firstTreeRoot, targetSum, valueSet);\n    return findPairWithSum(secondTreeRoot, targetSum, valueSet);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countSteppingNumbers(int lowerBound, int upperBound)\n{\n    vector<int> steppingNumbers;\n    for(int currentNumber= lowerBound; currentNumber <= upperBound; currentNumber++)\n    {\n        int previousDigit= -1;\n        int tempNumber= currentNumber;\n        bool isStepping= true;\n        while(tempNumber > 0)\n        {\n            int currentDigit= tempNumber % 10;\n            if(previousDigit != -1 && abs(previousDigit - currentDigit) != 1)\n            {\n                isStepping= false;\n                break;\n            }\n            previousDigit= currentDigit;\n            tempNumber/= 10;\n        }\n        if(isStepping)\n            steppingNumbers.push_back(currentNumber);\n    }\n    return steppingNumbers;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> countSteppingNumbers(int lowerBound, int upperBound)\n{\n    std::vector<int> steppingNumbers;\n    for(int currentNumber= lowerBound; currentNumber <= upperBound; currentNumber++)\n    {\n        int previousDigit= -1;\n        int tempNumber= currentNumber;\n        bool isStepping= true;\n        while(tempNumber > 0)\n        {\n            int currentDigit= tempNumber % 10;\n            if(previousDigit != -1 && std::abs(previousDigit - currentDigit) != 1)\n            {\n                isStepping= false;\n                break;\n            }\n            previousDigit= currentDigit;\n            tempNumber/= 10;\n        }\n        if(isStepping)\n            steppingNumbers.push_back(currentNumber);\n    }\n    return steppingNumbers;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass ZeroEvenOdd\n{\n  private:\n    int maxNumber;\n    int currentCount;\n    mutex mutexLock;\n    condition_variable conditionVar;\n\n  public:\n    ZeroEvenOdd(int maxNumber)\n    {\n        this->maxNumber = maxNumber;\n        currentCount = 1;\n    }\n\n    void zero(function<void(int)> printNumber)\n    {\n        for(int i = 1; i <= maxNumber; i++)\n        {\n            unique_lock<mutex> lock(mutexLock);\n            conditionVar.wait(lock, [this]()\n                              { return currentCount % 2 != 0; });\n            printNumber(0);\n            currentCount++;\n            conditionVar.notify_all();\n        }\n    }\n\n    void even(function<void(int)> printNumber)\n    {\n        for(int i = 2; i <= maxNumber; i += 2)\n        {\n            unique_lock<mutex> lock(mutexLock);\n            conditionVar.wait(lock, [this, i]()\n                              { return currentCount == 2 * i; });\n            printNumber(i);\n            currentCount++;\n            conditionVar.notify_all();\n        }\n    }\n\n    void odd(function<void(int)> printNumber)\n    {\n        for(int i = 1; i <= maxNumber; i += 2)\n        {\n            unique_lock<mutex> lock(mutexLock);\n            conditionVar.wait(lock, [this, i]()\n                              { return currentCount == 2 * i - 1; });\n            printNumber(i);\n            currentCount++;\n            conditionVar.notify_all();\n        }\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass ZeroEvenOdd\n{\n  private:\n    int maxNumber;\n    int currentCount;\n    std::mutex mutexLock;\n    std::condition_variable conditionVar;\n\n  public:\n    ZeroEvenOdd(int maxNumber)\n    {\n        this->maxNumber= maxNumber;\n        currentCount= 1;\n    }\n\n    void zero(function<void(int)> printNumber)\n    {\n        for(int i= 1; i <= maxNumber; i++)\n        {\n            unique_lock<mutex> lock(mutexLock);\n            conditionVar.wait(lock, [this]()\n                              { return currentCount % 2 != 0; });\n            printNumber(0);\n            currentCount++;\n            conditionVar.notify_all();\n        }\n    }\n\n    void even(function<void(int)> printNumber)\n    {\n        for(int i= 2; i <= maxNumber; i+= 2)\n        {\n            unique_lock<mutex> lock(mutexLock);\n            conditionVar.wait(lock, [this, i]()\n                              { return currentCount == 2 * i; });\n            printNumber(i);\n            currentCount++;\n            conditionVar.notify_all();\n        }\n    }\n\n    void odd(function<void(int)> printNumber)\n    {\n        for(int i= 1; i <= maxNumber; i+= 2)\n        {\n            unique_lock<mutex> lock(mutexLock);\n            conditionVar.wait(lock, [this, i]()\n                              { return currentCount == 2 * i - 1; });\n            printNumber(i);\n            currentCount++;\n            conditionVar.notify_all();\n        }\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid sortArray(vector<int> &sourceArray, vector<int> &orderArray)\n{\n    map<int, int> elementCounts;\n\n    for(int element : sourceArray)\n    {\n        elementCounts[element]++;\n    }\n    int currentIndex = 0;\n    for(int i = 0; i < orderArray.size(); ++i)\n    {\n        int element = orderArray[i];\n        while(elementCounts[element]--)\n        {\n            sourceArray[currentIndex++] = element;\n        }\n    }\n    for(auto &countPair : elementCounts)\n    {\n        while(countPair.second--)\n        {\n            sourceArray[currentIndex++] = countPair.first;\n        }\n    }\n}",
    "output": "#include <bits/stdc++.h>\nvoid sortArray(std::vector<int> &sourceArray, std::vector<int> &orderArray)\n{\n    std::map<int, int> elementCounts;\n\n    for(int element : sourceArray)\n    {\n        elementCounts[element]++;\n    }\n    int currentIndex= 0;\n    for(int element : orderArray)\n    {\n        while(elementCounts[element]--)\n        {\n            sourceArray[currentIndex++]= element;\n        }\n    }\n    for(auto &countPair : elementCounts)\n    {\n        while(countPair.second--)\n        {\n            sourceArray[currentIndex++]= countPair.first;\n        }\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For std::pair\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild, *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    pair<TreeNode *, int> depthFirstSearch(TreeNode *currentNode)\n    {\n        if(!currentNode)\n            return {NULL, 0};\n        auto leftResult = depthFirstSearch(currentNode->leftChild);\n        auto rightResult = depthFirstSearch(currentNode->rightChild);\n        if(leftResult.second > rightResult.second)\n        {\n            return {leftResult.first, leftResult.second + 1};\n        }\n        else if(leftResult.second < rightResult.second)\n        {\n            return {rightResult.first, rightResult.second + 1};\n        }\n        else\n        {\n            return {currentNode, leftResult.second + 1};\n        }\n    }\n\n    TreeNode *lowestCommonAncestorOfDeepestLeaves(TreeNode *root)\n    {\n        return depthFirstSearch(root).first;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild, *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    std::pair<TreeNode *, int> depthFirstSearch(TreeNode *currentNode)\n    {\n        if(!currentNode)\n            return {NULL, 0};\n        auto leftResult= depthFirstSearch(currentNode->leftChild);\n        auto rightResult= depthFirstSearch(currentNode->rightChild);\n        if(leftResult.second > rightResult.second)\n        {\n            return {leftResult.first, leftResult.second + 1};\n        }\n        else if(leftResult.second < rightResult.second)\n        {\n            return {rightResult.first, rightResult.second + 1};\n        }\n        else\n        {\n            return {currentNode, leftResult.second + 1};\n        }\n    }\n\n    TreeNode *lowestCommonAncestorOfDeepestLeaves(TreeNode *root)\n    {\n        return depthFirstSearch(root).first;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint longestWpi(vector<int> &workHours)\n{\n    int score = 0;\n    int maxLength = 0;\n    unordered_map<int, int> firstOccurrence;\n\n    for(int index = 0; index < workHours.size(); ++index)\n    {\n        score += workHours[index] > 8 ? 1 : -1;\n        if(score > 0)\n            maxLength = index + 1;\n        else\n        {\n            if(firstOccurrence.find(score) == firstOccurrence.end())\n                firstOccurrence[score] = index;\n            if(firstOccurrence.find(score - 1) != firstOccurrence.end())\n                maxLength = max(maxLength, index - firstOccurrence[score - 1]);\n        }\n    }\n    return maxLength;\n}",
    "output": "#include <bits/stdc++.h>\nint longestWpi(std::vector<int> &workHours)\n{\n    int score= 0;\n    int maxLength= 0;\n    std::unordered_map<int, int> firstOccurrence;\n\n    for(int index= 0; index < workHours.size(); ++index)\n    {\n        score+= workHours[index] > 8 ? 1 : -1;\n        if(score > 0)\n            maxLength= index + 1;\n        else\n        {\n            if(firstOccurrence.find(score) == firstOccurrence.end())\n                firstOccurrence[score]= index;\n            if(firstOccurrence.find(score - 1) != firstOccurrence.end())\n                maxLength= std::max(maxLength, index - firstOccurrence[score - 1]);\n        }\n    }\n    return maxLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> smallestSufficientTeam(vector<string> &requiredSkills, vector<vector<string>> &people)\n{\n    int skillCount = requiredSkills.size(), peopleCount = people.size();\n    vector<int> skillToIndex(128, -1);\n    vector<vector<int>> peopleSkillsIndex(peopleCount);\n    vector<int> result(skillCount);\n    int currentMin = skillCount + 1;\n\n    for(int i = 0; i < skillCount; ++i)\n        skillToIndex[requiredSkills[i].front()] = i;\n\n    for(int i = 0; i < peopleCount; ++i)\n        for(int j = 0; j < people[i].size(); ++j)\n            peopleSkillsIndex[i].push_back(skillToIndex[people[i][j].front()]);\n\n    function<void(bitset<26>, int, int)> depthFirstSearch = [&](bitset<26> skillSet, int personIndex, int teamCount)\n    {\n        if(teamCount >= currentMin)\n            return;\n        if(personIndex == peopleCount && (skillSet & ((1 << skillCount) - 1)) != (1 << skillCount) - 1)\n            return;\n        if(personIndex == peopleCount)\n        {\n            currentMin = teamCount;\n            int idx = 0;\n            for(int i = 0; i < peopleCount; ++i)\n                if(skillSet[26 - i - 1])\n                    result[idx++] = i;\n            return;\n        }\n        depthFirstSearch(skillSet | (skillSet >> peopleSkillsIndex[personIndex]) | (skillSet << skillCount << peopleSkillsIndex[personIndex]), personIndex + 1, teamCount + 1);\n        depthFirstSearch(skillSet, personIndex + 1, teamCount);\n    };\n\n    depthFirstSearch(0, 0, 0);\n    result.resize(currentMin);\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> smallestSufficientTeam(std::vector<std::string> &requiredSkills, std::vector<std::vector<std::string>> &people)\n{\n    int skillCount = requiredSkills.size(), peopleCount = people.size();\n    std::vector<int> skillToIndex(128, -1);\n    std::vector<std::vector<int>> peopleSkillsIndex(peopleCount);\n    std::vector<int> result(skillCount);\n    int currentMin = skillCount + 1;\n\n    for(int i = 0; i < skillCount; ++i)\n        skillToIndex[requiredSkills[i].front()] = i;\n\n    for(int i = 0; i < peopleCount; ++i)\n        for(const std::string &skill : people[i])\n            peopleSkillsIndex[i].push_back(skillToIndex[skill.front()]);\n\n    std::function<void(std::bitset<26>, int, int)> depthFirstSearch = [&](std::bitset<26> skillSet, int personIndex, int teamCount)\n    {\n        if(teamCount >= currentMin)\n            return;\n        if(personIndex == peopleCount && (skillSet & ((1 << skillCount) - 1)) != (1 << skillCount) - 1)\n            return;\n        if(personIndex == peopleCount)\n        {\n            currentMin = teamCount;\n            int idx = 0;\n            for(int i = 0; i < peopleCount; ++i)\n                if(skillSet[26 - i - 1])\n                    result[idx++] = i;\n            return;\n        }\n        depthFirstSearch(skillSet | (skillSet >> peopleSkillsIndex[personIndex]) | (skillSet << skillCount << peopleSkillsIndex[personIndex]), personIndex + 1, teamCount + 1);\n        depthFirstSearch(skillSet, personIndex + 1, teamCount);\n    };\n\n    depthFirstSearch(0, 0, 0);\n    result.resize(currentMin);\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findSpecialInteger(const vector<int> &sortedArray)\n{\n    int totalElements = sortedArray.size(), requiredCount = totalElements / 4;\n    for(int currentIndex = 0; currentIndex < totalElements; currentIndex++)\n    {\n        if(currentIndex + requiredCount < totalElements && sortedArray[currentIndex] == sortedArray[currentIndex + requiredCount])\n        {\n            return sortedArray[currentIndex];\n        }\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint findSpecialInteger(const std::vector<int> &sortedArray)\n{\n    int totalElements= sortedArray.size(), requiredCount= totalElements / 4;\n    for(int currentIndex= 0; currentIndex < totalElements; currentIndex++)\n    {\n        if(sortedArray[currentIndex] == sortedArray[currentIndex + requiredCount])\n        {\n            return sortedArray[currentIndex];\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint removeCoveredIntervals(vector<vector<int>> &intervalList)\n{\n    sort(intervalList.begin(), intervalList.end(), [](const vector<int> &firstInterval, const vector<int> &secondInterval)\n         {\n        if (firstInterval[0] == secondInterval[0]) return firstInterval[1] > secondInterval[1];\n        return firstInterval[0] < secondInterval[0]; });\n\n    int nonCoveredCount = 0, lastEnd = 0;\n    for (int i = 0; i < intervalList.size(); ++i)\n    {\n        const auto &currentInterval = intervalList[i];\n        if (currentInterval[1] > lastEnd)\n        {\n            nonCoveredCount++;\n            lastEnd = currentInterval[1];\n        }\n    }\n    return nonCoveredCount;\n}",
    "output": "#include <bits/stdc++.h>\nint removeCoveredIntervals(std::vector<std::vector<int>> &intervalList)\n{\n    std::sort(intervalList.begin(), intervalList.end(), [](const std::vector<int> &firstInterval, const std::vector<int> &secondInterval)\n         {\n        if (firstInterval[0] == secondInterval[0]) return firstInterval[1] > secondInterval[1];\n        return firstInterval[0] < secondInterval[0]; });\n\n    int nonCoveredCount= 0, lastEnd= 0;\n    for(const auto &currentInterval : intervalList)\n    {\n        if(currentInterval[1] > lastEnd)\n        {\n            nonCoveredCount++;\n            lastEnd= currentInterval[1];\n        }\n    }\n    return nonCoveredCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<bool> areConnected(int totalNodes, int connectionThreshold, vector<vector<int>> &connectionQueries)\n{\n    vector<bool> connectionResults(connectionQueries.size());\n    vector<int> nodeParent(totalNodes + 1), nodeRank(totalNodes + 1, 0);\n\n    for(int i= 1; i <= totalNodes; ++i)\n        nodeParent[i]= i;\n\n    function<int(int)> findParent= [&](int currentNode)\n    {\n        if(nodeParent[currentNode] != currentNode)\n            nodeParent[currentNode]= findParent(nodeParent[currentNode]);\n        return nodeParent[currentNode];\n    };\n\n    auto uniteNodes= [&](int nodeX, int nodeY)\n    {\n        int rootX= findParent(nodeX);\n        int rootY= findParent(nodeY);\n        if(rootX != rootY)\n        {\n            if(nodeRank[rootX] > nodeRank[rootY])\n                swap(rootX, rootY);\n            nodeParent[rootX]= rootY;\n            if(nodeRank[rootX] == nodeRank[rootY])\n                nodeRank[rootY]++;\n        }\n    };\n\n    for(int i= connectionThreshold + 1; i <= totalNodes; ++i)\n        for(int j= 2 * i; j <= totalNodes; j+= i)\n            uniteNodes(i, j);\n\n    for(int i= 0; i < connectionQueries.size(); ++i)\n        connectionResults[i]= findParent(connectionQueries[i][0]) == findParent(connectionQueries[i][1]);\n\n    return connectionResults;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<bool> areConnected(int totalNodes, int connectionThreshold, std::vector<std::vector<int>> &connectionQueries)\n{\n    std::vector<bool> connectionResults(connectionQueries.size());\n    std::vector<int> nodeParent(totalNodes + 1), nodeRank(totalNodes + 1, 0);\n\n    for(int i= 1; i <= totalNodes; ++i)\n        nodeParent[i]= i;\n\n    std::function<int(int)> findParent= [&](int currentNode)\n    {\n        if(nodeParent[currentNode] != currentNode)\n            nodeParent[currentNode]= findParent(nodeParent[currentNode]);\n        return nodeParent[currentNode];\n    };\n\n    auto uniteNodes= [&](int nodeX, int nodeY)\n    {\n        int rootX= findParent(nodeX);\n        int rootY= findParent(nodeY);\n        if(rootX != rootY)\n        {\n            if(nodeRank[rootX] > nodeRank[rootY])\n                std::swap(rootX, rootY);\n            nodeParent[rootX]= rootY;\n            if(nodeRank[rootX] == nodeRank[rootY])\n                nodeRank[rootY]++;\n        }\n    };\n\n    for(int i= connectionThreshold + 1; i <= totalNodes; ++i)\n        for(int j= 2 * i; j <= totalNodes; j+= i)\n            uniteNodes(i, j);\n\n    for(int i= 0; i < connectionQueries.size(); ++i)\n        connectionResults[i]= findParent(connectionQueries[i][0]) == findParent(connectionQueries[i][1]);\n\n    return connectionResults;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minFallingPathSum(vector<vector<int>> &grid)\n{\n    int gridSize= grid.size();\n    for(int row= 1; row < gridSize; ++row)\n    {\n        for(int col= 0; col < gridSize; ++col)\n        {\n            int minimumValue= INT_MAX;\n            for(int prevCol= 0; prevCol < gridSize; ++prevCol)\n            {\n                if(prevCol == col)\n                    continue;\n                minimumValue= min(minimumValue, grid[row - 1][prevCol]);\n            }\n            grid[row][col]+= minimumValue;\n        }\n    }\n    return *min_element(grid[gridSize - 1].begin(), grid[gridSize - 1].end());\n}",
    "output": "#include <bits/stdc++.h>\nint minFallingPathSum(std::vector<std::vector<int>> &grid)\n{\n    int gridSize = grid.size();\n    for(int row = 1; row < gridSize; ++row)\n    {\n        for(int col = 0; col < gridSize; ++col)\n        {\n            int minimumValue = INT_MAX;\n            for(int prevCol = 0; prevCol < gridSize; ++prevCol)\n            {\n                if(prevCol == col)\n                    continue;\n                minimumValue = std::min(minimumValue, grid[row - 1][prevCol]);\n            }\n            grid[row][col] += minimumValue;\n        }\n    }\n    return *std::min_element(grid[gridSize - 1].begin(), grid[gridSize - 1].end());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numEquivDominoPairs(vector<vector<int>> &dominoes)\n{\n    unordered_map<int, int> frequencyMap;\n    int totalPairs = 0;\n    for (int i = 0; i < dominoes.size(); ++i)\n    {\n        auto &domino = dominoes[i];\n        int key = (min(domino[0], domino[1]) << 4) | max(domino[0], domino[1]);\n        totalPairs += frequencyMap[key]++;\n    }\n    return totalPairs;\n}",
    "output": "#include <bits/stdc++.h>\nint numEquivDominoPairs(std::vector<std::vector<int>> &dominoes)\n{\n    std::unordered_map<int, int> frequencyMap;\n    int totalPairs= 0;\n    for(auto &domino : dominoes)\n    {\n        int key= (std::min(domino[0], domino[1]) << 4) | std::max(domino[0], domino[1]);\n        totalPairs+= frequencyMap[key]++;\n    }\n    return totalPairs;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumCostTreeFromLeafValues(vector<int> &leafValues)\n{\n    int numberOfLeaves= leafValues.size();\n    vector<vector<int>> costDP(numberOfLeaves, vector<int>(numberOfLeaves, 0));\n    vector<vector<int>> maxValues(numberOfLeaves, vector<int>(numberOfLeaves, 0));\n\n    for(int startIndex= 0; startIndex < numberOfLeaves; ++startIndex)\n    {\n        for(int endIndex= startIndex; endIndex < numberOfLeaves; ++endIndex)\n        {\n            maxValues[startIndex][endIndex]= *max_element(leafValues.begin() + startIndex, leafValues.begin() + endIndex + 1);\n        }\n    }\n\n    for(int length= 1; length < numberOfLeaves; ++length)\n    {\n        for(int startIndex= 0; startIndex + length < numberOfLeaves; ++startIndex)\n        {\n            int endIndex= startIndex + length;\n            costDP[startIndex][endIndex]= INT_MAX;\n            for(int partitionIndex= startIndex; partitionIndex < endIndex; ++partitionIndex)\n            {\n                costDP[startIndex][endIndex]= min(costDP[startIndex][endIndex], costDP[startIndex][partitionIndex] + costDP[partitionIndex + 1][endIndex] + maxValues[startIndex][partitionIndex] * maxValues[partitionIndex + 1][endIndex]);\n            }\n        }\n    }\n    return costDP[0][numberOfLeaves - 1];\n}",
    "output": "#include <bits/stdc++.h>\nint minimumCostTreeFromLeafValues(std::vector<int> &leafValues)\n{\n    int numberOfLeaves = leafValues.size();\n    std::vector<std::vector<int>> costDP(numberOfLeaves, std::vector<int>(numberOfLeaves, 0));\n    std::vector<std::vector<int>> maxValues(numberOfLeaves, std::vector<int>(numberOfLeaves, 0));\n\n    for(int startIndex = 0; startIndex < numberOfLeaves; ++startIndex)\n    {\n        for(int endIndex = startIndex; endIndex < numberOfLeaves; ++endIndex)\n        {\n            maxValues[startIndex][endIndex] = *std::max_element(leafValues.begin() + startIndex, leafValues.begin() + endIndex + 1);\n        }\n    }\n\n    for(int length = 1; length < numberOfLeaves; ++length)\n    {\n        for(int startIndex = 0; startIndex + length < numberOfLeaves; ++startIndex)\n        {\n            int endIndex = startIndex + length;\n            costDP[startIndex][endIndex] = std::numeric_limits<int>::max();\n            for(int partitionIndex = startIndex; partitionIndex < endIndex; ++partitionIndex)\n            {\n                costDP[startIndex][endIndex] = std::min(costDP[startIndex][endIndex], costDP[startIndex][partitionIndex] + costDP[partitionIndex + 1][endIndex] + maxValues[startIndex][partitionIndex] * maxValues[partitionIndex + 1][endIndex]);\n            }\n        }\n    }\n    return costDP[0][numberOfLeaves - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> shortestAlternatingPaths(int numberOfNodes, vector<vector<int>> &redEdges, vector<vector<int>> &blueEdges)\n{\n    vector<vector<vector<int>>> adjacencyList(numberOfNodes, vector<vector<int>>(2));\n\n    for (int i = 0; i < redEdges.size(); ++i)\n    {\n        adjacencyList[redEdges[i][0]][0].push_back(redEdges[i][1]);\n    }\n\n    for (int i = 0; i < blueEdges.size(); ++i)\n    {\n        adjacencyList[blueEdges[i][0]][1].push_back(blueEdges[i][1]);\n    }\n\n    vector<vector<int>> distance(numberOfNodes, vector<int>(2, -1));\n    distance[0] = {0, 0};\n\n    queue<pair<int, int>> bfsQueue;\n    bfsQueue.push({0, 0});\n    bfsQueue.push({0, 1});\n\n    while (!bfsQueue.empty())\n    {\n        int currentNode = bfsQueue.front().first, currentColor = bfsQueue.front().second;\n        bfsQueue.pop();\n        int nextColor = currentColor ^ 1;\n\n        for (int neighbor : adjacencyList[currentNode][nextColor])\n        {\n            if (distance[neighbor][nextColor] == -1)\n            {\n                distance[neighbor][nextColor] = distance[currentNode][currentColor] + 1;\n                bfsQueue.push({neighbor, nextColor});\n            }\n        }\n    }\n\n    vector<int> result(numberOfNodes);\n    for (int index = 0; index < numberOfNodes; ++index)\n    {\n        result[index] = min(distance[index][0], distance[index][1]);\n        if (distance[index][0] == -1 || distance[index][1] == -1)\n        {\n            result[index] = max(distance[index][0], distance[index][1]);\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> shortestAlternatingPaths(int numberOfNodes, std::vector<std::vector<int>> &redEdges, std::vector<std::vector<int>> &blueEdges)\n{\n    std::vector<std::vector<std::vector<int>>> adjacencyList(numberOfNodes, std::vector<std::vector<int>>(2));\n\n    for(const auto &redEdge : redEdges)\n    {\n        adjacencyList[redEdge[0]][0].push_back(redEdge[1]);\n    }\n\n    for(const auto &blueEdge : blueEdges)\n    {\n        adjacencyList[blueEdge[0]][1].push_back(blueEdge[1]);\n    }\n\n    std::vector<std::vector<int>> distance(numberOfNodes, std::vector<int>(2, -1));\n    distance[0]= {0, 0};\n\n    std::queue<std::pair<int, int>> bfsQueue;\n    bfsQueue.push({0, 0});\n    bfsQueue.push({0, 1});\n\n    while(!bfsQueue.empty())\n    {\n        int currentNode= bfsQueue.front().first, currentColor= bfsQueue.front().second;\n        bfsQueue.pop();\n        int nextColor= currentColor ^ 1;\n\n        for(int neighbor : adjacencyList[currentNode][nextColor])\n        {\n            if(distance[neighbor][nextColor] == -1)\n            {\n                distance[neighbor][nextColor]= distance[currentNode][currentColor] + 1;\n                bfsQueue.push({neighbor, nextColor});\n            }\n        }\n    }\n\n    std::vector<int> result(numberOfNodes);\n    for(int index= 0; index < numberOfNodes; ++index)\n    {\n        result[index]= std::min(distance[index][0], distance[index][1]);\n        if(distance[index][0] == -1 || distance[index][1] == -1)\n        {\n            result[index]= std::max(distance[index][0], distance[index][1]);\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxDifference(int firstArray[], int secondArray[], int arraySize)\n{\n    int maxDifference1= INT_MIN, maxDifference2= INT_MIN, maxDifference3= INT_MIN, maxDifference4= INT_MIN;\n    int minDifference1= INT_MAX, minDifference2= INT_MAX, minDifference3= INT_MAX, minDifference4= INT_MAX;\n\n    for(int index= 0; index < arraySize; index++)\n    {\n        maxDifference1= max(maxDifference1, firstArray[index] - secondArray[index] + index);\n        maxDifference2= max(maxDifference2, firstArray[index] + secondArray[index] + index);\n        maxDifference3= max(maxDifference3, -firstArray[index] + secondArray[index] + index);\n        maxDifference4= max(maxDifference4, -firstArray[index] - secondArray[index] + index);\n\n        minDifference1= min(minDifference1, firstArray[index] - secondArray[index] + index);\n        minDifference2= min(minDifference2, firstArray[index] + secondArray[index] + index);\n        minDifference3= min(minDifference3, -firstArray[index] + secondArray[index] + index);\n        minDifference4= min(minDifference4, -firstArray[index] - secondArray[index] + index);\n    }\n    return max({maxDifference1 - minDifference1, maxDifference2 - minDifference2, maxDifference3 - minDifference3, maxDifference4 - minDifference4});\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMaxDifference(int firstArray[], int secondArray[], int arraySize)\n{\n    int maxDifference1= INT_MIN, maxDifference2= INT_MIN, maxDifference3= INT_MIN, maxDifference4= INT_MIN;\n    int minDifference1= INT_MAX, minDifference2= INT_MAX, minDifference3= INT_MAX, minDifference4= INT_MAX;\n\n    for(int index= 0; index < arraySize; index++)\n    {\n        maxDifference1= std::max(maxDifference1, firstArray[index] - secondArray[index] + index);\n        maxDifference2= std::max(maxDifference2, firstArray[index] + secondArray[index] + index);\n        maxDifference3= std::max(maxDifference3, -firstArray[index] + secondArray[index] + index);\n        maxDifference4= std::max(maxDifference4, -firstArray[index] - secondArray[index] + index);\n\n        minDifference1= std::min(minDifference1, firstArray[index] - secondArray[index] + index);\n        minDifference2= std::min(minDifference2, firstArray[index] + secondArray[index] + index);\n        minDifference3= std::min(minDifference3, -firstArray[index] + secondArray[index] + index);\n        minDifference4= std::min(minDifference4, -firstArray[index] - secondArray[index] + index);\n    }\n    return std::max({maxDifference1 - minDifference1, maxDifference2 - minDifference2, maxDifference3 - minDifference3, maxDifference4 - minDifference4});\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> replaceElements(vector<int> &inputArray)\n{\n    int arraySize= inputArray.size();\n    int maximumElement= -1;\n    for(int index= arraySize - 1; index >= 0; index--)\n    {\n        int currentElement= inputArray[index];\n        inputArray[index]= maximumElement;\n        maximumElement= max(maximumElement, currentElement);\n    }\n    return inputArray;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> replaceElements(std::vector<int> &inputArray)\n{\n    int arraySize = inputArray.size();\n    int maximumElement = -1;\n    for(int index = arraySize - 1; index >= 0; index--)\n    {\n        int currentElement = inputArray[index];\n        inputArray[index] = maximumElement;\n        maximumElement = std::max(maximumElement, currentElement);\n    }\n    return inputArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findBestValue(vector<int> &array, int targetValue)\n{\n    int lowerBound = 0;\n    int upperBound = *max_element(array.begin(), array.end());\n    int bestVal, minimumDiff = INT_MAX;\n\n    while(lowerBound <= upperBound)\n    {\n        int midVal = lowerBound + (upperBound - lowerBound) / 2;\n        int totalSum = 0;\n        for(int i = 0; i < array.size(); ++i)\n        {\n            totalSum += min(array[i], midVal);\n        }\n        if(totalSum == targetValue)\n        {\n            return midVal;\n        }\n        else if(totalSum > targetValue)\n        {\n            upperBound = midVal - 1;\n        }\n        else\n        {\n            lowerBound = midVal + 1;\n        }\n        if(abs(targetValue - totalSum) < minimumDiff || (abs(targetValue - totalSum) == minimumDiff && midVal < bestVal))\n        {\n            minimumDiff = abs(targetValue - totalSum);\n            bestVal = midVal;\n        }\n    }\n    return bestVal;\n}",
    "output": "#include <bits/stdc++.h>\nint findBestValue(std::vector<int> &array, int targetValue)\n{\n    int lowerBound= 0;\n    int upperBound= *std::max_element(array.begin(), array.end());\n    int bestVal, minimumDiff= INT_MAX;\n\n    while(lowerBound <= upperBound)\n    {\n        int midVal= lowerBound + (upperBound - lowerBound) / 2;\n        int totalSum= 0;\n        for(int num : array)\n        {\n            totalSum+= std::min(num, midVal);\n        }\n        if(totalSum == targetValue)\n        {\n            return midVal;\n        }\n        else if(totalSum > targetValue)\n        {\n            upperBound= midVal - 1;\n        }\n        else\n        {\n            lowerBound= midVal + 1;\n        }\n        if(std::abs(targetValue - totalSum) < minimumDiff || (std::abs(targetValue - totalSum) == minimumDiff && midVal < bestVal))\n        {\n            minimumDiff= std::abs(targetValue - totalSum);\n            bestVal= midVal;\n        }\n    }\n    return bestVal;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> removeSubfolders(vector<string> &folders)\n{\n    vector<string> uniqueFolders;\n    sort(folders.begin(), folders.end());\n    string currentPrefix = \"/\";\n\n    for (int i = 0; i < folders.size(); ++i)\n    {\n        const auto &folderPath = folders[i];\n        if (folderPath.compare(0, currentPrefix.size(), currentPrefix) != 0)\n        {\n            uniqueFolders.push_back(folderPath);\n            currentPrefix = folderPath + \"/\";\n        }\n    }\n    return uniqueFolders;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> removeSubfolders(std::vector<std::string> &folders)\n{\n    std::vector<std::string> uniqueFolders;\n    std::sort(folders.begin(), folders.end());\n    std::string currentPrefix= \"/\";\n\n    for(const auto &folderPath : folders)\n    {\n        if(folderPath.compare(0, currentPrefix.size(), currentPrefix) != 0)\n        {\n            uniqueFolders.push_back(folderPath);\n            currentPrefix= folderPath + \"/\";\n        }\n    }\n    return uniqueFolders;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> getMaxSumAndCount(vector<string> &board)\n{\n    int modulus= 1000000007;\n    int boardSize= board.size();\n    vector<vector<pair<int, int>>> dynamicProgramming(boardSize, vector<pair<int, int>>(boardSize, {0, 0}));\n    dynamicProgramming[boardSize - 1][boardSize - 1]= {0, 1};\n\n    for(int rowIndex= boardSize - 1; rowIndex >= 0; rowIndex--)\n    {\n        for(int columnIndex= boardSize - 1; columnIndex >= 0; columnIndex--)\n        {\n            if(board[rowIndex][columnIndex] == 'X' || (rowIndex == boardSize - 1 && columnIndex == boardSize - 1))\n                continue;\n            int currentValue= board[rowIndex][columnIndex] == 'E' ? 0 : board[rowIndex][columnIndex] - '0';\n            pair<int, int> up= rowIndex > 0 ? dynamicProgramming[rowIndex - 1][columnIndex] : make_pair(-1, 0);\n            pair<int, int> left= columnIndex > 0 ? dynamicProgramming[rowIndex][columnIndex - 1] : make_pair(-1, 0);\n            pair<int, int> diagonal= rowIndex > 0 && columnIndex > 0 ? dynamicProgramming[rowIndex - 1][columnIndex - 1] : make_pair(-1, 0);\n\n            pair<int, int> maxPair= max({up, left, diagonal});\n            if(maxPair.first == -1)\n                continue;\n\n            dynamicProgramming[rowIndex][columnIndex].first= maxPair.first + currentValue;\n            if(up == maxPair)\n                dynamicProgramming[rowIndex][columnIndex].second= (dynamicProgramming[rowIndex][columnIndex].second + up.second % modulus) % modulus;\n            if(left == maxPair)\n                dynamicProgramming[rowIndex][columnIndex].second= (dynamicProgramming[rowIndex][columnIndex].second + left.second % modulus) % modulus;\n            if(diagonal == maxPair)\n                dynamicProgramming[rowIndex][columnIndex].second= (dynamicProgramming[rowIndex][columnIndex].second + diagonal.second % modulus) % modulus;\n        }\n    }\n    return {dynamicProgramming[0][0].first, dynamicProgramming[0][0].second};\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> getMaxSumAndCount(std::vector<std::string> &board)\n{\n    int modulus = 1000000007;\n    int boardSize = board.size();\n    std::vector<std::vector<std::pair<int, int>>> dynamicProgramming(boardSize, std::vector<std::pair<int, int>>(boardSize, {0, 0}));\n    dynamicProgramming[boardSize - 1][boardSize - 1] = {0, 1};\n\n    for(int rowIndex = boardSize - 1; rowIndex >= 0; rowIndex--)\n    {\n        for(int columnIndex = boardSize - 1; columnIndex >= 0; columnIndex--)\n        {\n            if(board[rowIndex][columnIndex] == 'X' || (rowIndex == boardSize - 1 && columnIndex == boardSize - 1))\n                continue;\n            int currentValue = board[rowIndex][columnIndex] == 'E' ? 0 : board[rowIndex][columnIndex] - '0';\n            std::pair<int, int> up = rowIndex > 0 ? dynamicProgramming[rowIndex - 1][columnIndex] : std::make_pair(-1, 0);\n            std::pair<int, int> left = columnIndex > 0 ? dynamicProgramming[rowIndex][columnIndex - 1] : std::make_pair(-1, 0);\n            std::pair<int, int> diagonal = rowIndex > 0 && columnIndex > 0 ? dynamicProgramming[rowIndex - 1][columnIndex - 1] : std::make_pair(-1, 0);\n\n            std::pair<int, int> maxPair = std::max({up, left, diagonal});\n            if(maxPair.first == -1)\n                continue;\n\n            dynamicProgramming[rowIndex][columnIndex].first = maxPair.first + currentValue;\n            if(up == maxPair)\n                dynamicProgramming[rowIndex][columnIndex].second = (dynamicProgramming[rowIndex][columnIndex].second + up.second % modulus) % modulus;\n            if(left == maxPair)\n                dynamicProgramming[rowIndex][columnIndex].second = (dynamicProgramming[rowIndex][columnIndex].second + left.second % modulus) % modulus;\n            if(diagonal == maxPair)\n                dynamicProgramming[rowIndex][columnIndex].second = (dynamicProgramming[rowIndex][columnIndex].second + diagonal.second % modulus) % modulus;\n        }\n    }\n    return {dynamicProgramming[0][0].first, dynamicProgramming[0][0].second};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint jobScheduling(vector<int> &startTime, vector<int> &endTime, vector<int> &profit)\n{\n    int jobCount = startTime.size();\n    vector<tuple<int, int, int>> jobs(jobCount);\n\n    for(int jobIndex = 0; jobIndex < jobCount; ++jobIndex)\n    {\n        jobs[jobIndex] = {endTime[jobIndex], startTime[jobIndex], profit[jobIndex]};\n    }\n\n    sort(jobs.begin(), jobs.end());\n\n    vector<int> maxProfit(jobCount);\n    maxProfit[0] = get<2>(jobs[0]);\n\n    for(int jobIndex = 1; jobIndex < jobCount; ++jobIndex)\n    {\n        int lastNonConflictJobIndex = -1;\n        for(int prevJobIndex = jobIndex - 1; prevJobIndex >= 0; --prevJobIndex)\n        {\n            if(get<1>(jobs[prevJobIndex]) >= get<0>(jobs[lastNonConflictJobIndex == -1 ? jobIndex : lastNonConflictJobIndex]))\n            {\n                lastNonConflictJobIndex = prevJobIndex;\n            }\n        }\n        maxProfit[jobIndex] = max(maxProfit[jobIndex - 1], (lastNonConflictJobIndex == -1 ? 0 : maxProfit[lastNonConflictJobIndex]) + get<2>(jobs[jobIndex]));\n    }\n\n    return maxProfit[jobCount - 1];\n}",
    "output": "#include <bits/stdc++.h>\nint jobScheduling(std::vector<int> &startTime, std::vector<int> &endTime, std::vector<int> &profit)\n{\n    int jobCount= startTime.size();\n    std::vector<std::tuple<int, int, int>> jobs(jobCount);\n\n    for(int jobIndex= 0; jobIndex < jobCount; ++jobIndex)\n    {\n        jobs[jobIndex]= {endTime[jobIndex], startTime[jobIndex], profit[jobIndex]};\n    }\n\n    std::sort(jobs.begin(), jobs.end());\n\n    std::vector<int> maxProfit(jobCount);\n    maxProfit[0]= std::get<2>(jobs[0]);\n\n    for(int jobIndex= 1; jobIndex < jobCount; ++jobIndex)\n    {\n        int lastNonConflictJobIndex= -1;\n        for(int prevJobIndex= jobIndex - 1; prevJobIndex >= 0; --prevJobIndex)\n        {\n            if(std::get<1>(jobs[prevJobIndex]) >= std::get<0>(jobs[lastNonConflictJobIndex == -1 ? jobIndex : lastNonConflictJobIndex]))\n            {\n                lastNonConflictJobIndex= prevJobIndex;\n            }\n        }\n        maxProfit[jobIndex]= std::max(maxProfit[jobIndex - 1], (lastNonConflictJobIndex == -1 ? 0 : maxProfit[lastNonConflictJobIndex]) + std::get<2>(jobs[jobIndex]));\n    }\n\n    return maxProfit[jobCount - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int tribonacci(int n)\n{\n    if(n == 0)\n        return 0;\n    if(n == 1 || n == 2)\n        return 1;\n    int previousValue1= 0, previousValue2= 1, previousValue3= 1, currentValue;\n    for(int index= 3; index <= n; ++index)\n    {\n        currentValue= previousValue1 + previousValue2 + previousValue3;\n        previousValue1= previousValue2;\n        previousValue2= previousValue3;\n        previousValue3= currentValue;\n    }\n    return previousValue3;\n}",
    "output": "int tribonacci(int n)\n{\n    if(n == 0)\n        return 0;\n    if(n == 1 || n == 2)\n        return 1;\n    int previousValue1= 0, previousValue2= 1, previousValue3= 1, currentValue;\n    for(int index= 3; index <= n; ++index)\n    {\n        currentValue= previousValue1 + previousValue2 + previousValue3;\n        previousValue1= previousValue2;\n        previousValue2= previousValue3;\n        previousValue3= currentValue;\n    }\n    return previousValue3;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n#include \"CustomFunction.h\"\n\nusing namespace std;\n\nvector<vector<int>> findSolution(CustomFunction &customFunction, int targetValue)\n{\n    vector<vector<int>> solutions;\n    for(int inputX= 1; inputX <= 1000; inputX++)\n    {\n        for(int inputY= 1; inputY <= 1000; inputY++)\n        {\n            if(customFunction.f(inputX, inputY) == targetValue)\n            {\n                solutions.push_back({inputX, inputY});\n            }\n            else if(customFunction.f(inputX, inputY) > targetValue)\n            {\n                break;\n            }\n        }\n    }\n    return solutions;\n}",
    "output": "#include <bits/stdc++.h>\n#include \"CustomFunction.h\"\n\n\nstd::vector<std::vector<int>> findSolution(CustomFunction &customFunction, int targetValue)\n{\n    std::vector<std::vector<int>> solutions;\n    for(int inputX= 1; inputX <= 1000; inputX++)\n    {\n        for(int inputY= 1; inputY <= 1000; inputY++)\n        {\n            if(customFunction.f(inputX, inputY) == targetValue)\n            {\n                solutions.push_back({inputX, inputY});\n            }\n            else if(customFunction.f(inputX, inputY) > targetValue)\n            {\n                break;\n            }\n        }\n    }\n    return solutions;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring alphabetBoardPath(const string &target)\n{\n    string result;\n    pair<int, int> currentPosition(0, 0);\n\n    for (int i = 0; i < target.size(); ++i)\n    {\n        char character = target[i];\n        int row = (character - 'a') / 5;\n        int column = (character - 'a') % 5;\n        while (currentPosition.first > row)\n        {\n            result.push_back('U');\n            --currentPosition.first;\n        }\n        while (currentPosition.second > column)\n        {\n            result.push_back('L');\n            --currentPosition.second;\n        }\n        while (currentPosition.first < row)\n        {\n            result.push_back('D');\n            ++currentPosition.first;\n        }\n        while (currentPosition.second < column)\n        {\n            result.push_back('R');\n            ++currentPosition.second;\n        }\n        result.push_back('!');\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string alphabetBoardPath(const std::string &target)\n{\n    std::string result;\n    std::pair<int, int> currentPosition(0, 0);\n\n    for(char character : target)\n    {\n        int row= (character - 'a') / 5;\n        int column= (character - 'a') % 5;\n        while(currentPosition.first > row)\n        {\n            result.push_back('U');\n            --currentPosition.first;\n        }\n        while(currentPosition.second > column)\n        {\n            result.push_back('L');\n            --currentPosition.second;\n        }\n        while(currentPosition.first < row)\n        {\n            result.push_back('D');\n            ++currentPosition.first;\n        }\n        while(currentPosition.second < column)\n        {\n            result.push_back('R');\n            ++currentPosition.second;\n        }\n        result.push_back('!');\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint largest1BorderedSquare(vector<vector<int>> &grid)\n{\n    int rowCount= grid.size();\n    int columnCount= grid[0].size();\n    vector<vector<int>> horizontalCount(rowCount, vector<int>(columnCount, 0));\n    vector<vector<int>> verticalCount(rowCount, vector<int>(columnCount, 0));\n\n    int maxSquareSize= 0;\n\n    for(int rowIndex= 0; rowIndex < rowCount; rowIndex++)\n    {\n        for(int columnIndex= 0; columnIndex < columnCount; columnIndex++)\n        {\n            if(grid[rowIndex][columnIndex] == 1)\n            {\n                horizontalCount[rowIndex][columnIndex]= (columnIndex == 0) ? 1 : horizontalCount[rowIndex][columnIndex - 1] + 1;\n                verticalCount[rowIndex][columnIndex]= (rowIndex == 0) ? 1 : verticalCount[rowIndex - 1][columnIndex] + 1;\n\n                int minSize= min(horizontalCount[rowIndex][columnIndex], verticalCount[rowIndex][columnIndex]);\n                while(minSize > maxSquareSize)\n                {\n                    if(horizontalCount[rowIndex - minSize + 1][columnIndex] >= minSize &&\n                       verticalCount[rowIndex][columnIndex - minSize + 1] >= minSize)\n                    {\n                        maxSquareSize= minSize;\n                    }\n                    minSize--;\n                }\n            }\n        }\n    }\n\n    return maxSquareSize * maxSquareSize;\n}",
    "output": "#include <bits/stdc++.h>\nint largest1BorderedSquare(std::vector<std::vector<int>> &grid)\n{\n    int rowCount= grid.size();\n    int columnCount= grid[0].size();\n    std::vector<std::vector<int>> horizontalCount(rowCount, std::vector<int>(columnCount, 0));\n    std::vector<std::vector<int>> verticalCount(rowCount, std::vector<int>(columnCount, 0));\n\n    int maxSquareSize= 0;\n\n    for(int rowIndex= 0; rowIndex < rowCount; rowIndex++)\n    {\n        for(int columnIndex= 0; columnIndex < columnCount; columnIndex++)\n        {\n            if(grid[rowIndex][columnIndex] == 1)\n            {\n                horizontalCount[rowIndex][columnIndex]= (columnIndex == 0) ? 1 : horizontalCount[rowIndex][columnIndex - 1] + 1;\n                verticalCount[rowIndex][columnIndex]= (rowIndex == 0) ? 1 : verticalCount[rowIndex - 1][columnIndex] + 1;\n\n                int minSize= std::min(horizontalCount[rowIndex][columnIndex], verticalCount[rowIndex][columnIndex]);\n                while(minSize > maxSquareSize)\n                {\n                    if(horizontalCount[rowIndex - minSize + 1][columnIndex] >= minSize &&\n                       verticalCount[rowIndex][columnIndex - minSize + 1] >= minSize)\n                    {\n                        maxSquareSize= minSize;\n                    }\n                    minSize--;\n                }\n            }\n        }\n    }\n\n    return maxSquareSize * maxSquareSize;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint stoneGameII(vector<int> &piles)\n{\n    int numberOfPiles = piles.size();\n    vector<vector<int>> memo(numberOfPiles, vector<int>(numberOfPiles + 1, 0));\n\n    for(int index = numberOfPiles - 2; index >= 0; --index)\n    {\n        piles[index] += piles[index + 1];\n    }\n\n    function<int(int, int)> search = [&](int currentIndex, int maxTake)\n    {\n        if(currentIndex + 2 * maxTake >= numberOfPiles)\n        {\n            return piles[currentIndex];\n        }\n        if(memo[currentIndex][maxTake] > 0)\n        {\n            return memo[currentIndex][maxTake];\n        }\n        memo[currentIndex][maxTake] = 0;\n        for(int take = 1; take <= 2 * maxTake; ++take)\n        {\n            memo[currentIndex][maxTake] = max(memo[currentIndex][maxTake], piles[currentIndex] - search(currentIndex + take, max(maxTake, take)));\n        }\n        return memo[currentIndex][maxTake];\n    };\n\n    return search(0, 1);\n}",
    "output": "#include <bits/stdc++.h>\nint stoneGameII(std::vector<int> &piles)\n{\n    int numberOfPiles= piles.size();\n    std::vector<std::vector<int>> memo(numberOfPiles, std::vector<int>(numberOfPiles + 1, 0));\n\n    for(int index= numberOfPiles - 2; index >= 0; --index)\n    {\n        piles[index]+= piles[index + 1];\n    }\n\n    function<int(int, int)> search= [&](int currentIndex, int maxTake)\n    {\n        if(currentIndex + 2 * maxTake >= numberOfPiles)\n        {\n            return piles[currentIndex];\n        }\n        if(memo[currentIndex][maxTake] > 0)\n        {\n            return memo[currentIndex][maxTake];\n        }\n        memo[currentIndex][maxTake]= 0;\n        for(int take= 1; take <= 2 * maxTake; ++take)\n        {\n            memo[currentIndex][maxTake]= std::max(memo[currentIndex][maxTake], piles[currentIndex] - search(currentIndex + take, std::max(maxTake, take)));\n        }\n        return memo[currentIndex][maxTake];\n    };\n\n    return search(0, 1);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int sumEvenGrandparent(TreeNode *currentNode, TreeNode *parentNode= NULL, TreeNode *grandparentNode= NULL)\n{\n    if(!currentNode)\n        return 0;\n    int totalSum= 0;\n    if(grandparentNode && grandparentNode->val % 2 == 0)\n    {\n        totalSum+= currentNode->val;\n    }\n    totalSum+= sumEvenGrandparent(currentNode->left, currentNode, parentNode) + sumEvenGrandparent(currentNode->right, currentNode, parentNode);\n    return totalSum;\n}",
    "output": "int sumEvenGrandparent(TreeNode *currentNode, TreeNode *parentNode= NULL, TreeNode *grandparentNode= NULL)\n{\n    if(!currentNode)\n        return 0;\n    int totalSum= 0;\n    if(grandparentNode && grandparentNode->val % 2 == 0)\n    {\n        totalSum+= currentNode->val;\n    }\n    totalSum+= sumEvenGrandparent(currentNode->left, currentNode, parentNode) + sumEvenGrandparent(currentNode->right, currentNode, parentNode);\n    return totalSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countDistinctRepeatedSubstrings(const string &inputString)\n{\n    unordered_set<string> uniqueSubstrings;\n    for(int substringLength= inputString.length() / 2; substringLength >= 1; substringLength--)\n    {\n        for(int startIndex= 0; startIndex <= inputString.length() - 2 * substringLength; startIndex++)\n        {\n            string currentSubstring= inputString.substr(startIndex, substringLength);\n            if(inputString.find(currentSubstring, startIndex + substringLength) != string::npos)\n                uniqueSubstrings.insert(currentSubstring);\n        }\n    }\n    return uniqueSubstrings.size();\n}",
    "output": "#include <bits/stdc++.h>\nint countDistinctRepeatedSubstrings(const std::string &inputString)\n{\n    std::unordered_set<std::string> uniqueSubstrings;\n    for(int substringLength= inputString.length() / 2; substringLength >= 1; substringLength--)\n    {\n        for(int startIndex= 0; startIndex <= inputString.length() - 2 * substringLength; startIndex++)\n        {\n            std::string currentSubstring= inputString.substr(startIndex, substringLength);\n            if(inputString.find(currentSubstring, startIndex + substringLength) != std::string::npos)\n                uniqueSubstrings.insert(currentSubstring);\n        }\n    }\n    return uniqueSubstrings.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint treeDiameter(vector<vector<int>> &edges)\n{\n    unordered_map<int, vector<int>> adjacencyList;\n    for (const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    queue<pair<int, int>> bfsQueue;\n    bfsQueue.push({0, 0});\n    int furthestNode = 0;\n    int maxDistance = 0;\n    while (!bfsQueue.empty())\n    {\n        int currentNode = bfsQueue.front().first;\n        int currentDistance = bfsQueue.front().second;\n        bfsQueue.pop();\n        if (currentDistance > maxDistance)\n        {\n            maxDistance = currentDistance;\n            furthestNode = currentNode;\n        }\n        for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n        {\n            int neighbor = adjacencyList[currentNode][i];\n            adjacencyList[neighbor].erase(remove(adjacencyList[neighbor].begin(), adjacencyList[neighbor].end(), currentNode), adjacencyList[neighbor].end());\n            bfsQueue.push({neighbor, currentDistance + 1});\n        }\n    }\n\n    bfsQueue.push({furthestNode, 0});\n    maxDistance = 0;\n    while (!bfsQueue.empty())\n    {\n        int currentNode = bfsQueue.front().first;\n        int currentDistance = bfsQueue.front().second;\n        bfsQueue.pop();\n        if (currentDistance > maxDistance)\n        {\n            maxDistance = currentDistance;\n        }\n        for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n        {\n            int neighbor = adjacencyList[currentNode][i];\n            adjacencyList[neighbor].erase(remove(adjacencyList[neighbor].begin(), adjacencyList[neighbor].end(), currentNode), adjacencyList[neighbor].end());\n            bfsQueue.push({neighbor, currentDistance + 1});\n        }\n    }\n\n    return maxDistance;\n}",
    "output": "#include <bits/stdc++.h>\nint treeDiameter(std::vector<std::vector<int>> &edges)\n{\n    std::unordered_map<int, std::vector<int>> adjacencyList;\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    std::queue<std::pair<int, int>> bfsQueue;\n    bfsQueue.push({0, 0});\n    int furthestNode= 0;\n    int maxDistance= 0;\n    while(!bfsQueue.empty())\n    {\n        int currentNode= bfsQueue.front().first;\n        int currentDistance= bfsQueue.front().second;\n        bfsQueue.pop();\n        if(currentDistance > maxDistance)\n        {\n            maxDistance= currentDistance;\n            furthestNode= currentNode;\n        }\n        for(int neighbor : adjacencyList[currentNode])\n        {\n            adjacencyList[neighbor].erase(std::remove(adjacencyList[neighbor].begin(), adjacencyList[neighbor].end(), currentNode), adjacencyList[neighbor].end());\n            bfsQueue.push({neighbor, currentDistance + 1});\n        }\n    }\n\n    bfsQueue.push({furthestNode, 0});\n    maxDistance= 0;\n    while(!bfsQueue.empty())\n    {\n        int currentNode= bfsQueue.front().first;\n        int currentDistance= bfsQueue.front().second;\n        bfsQueue.pop();\n        if(currentDistance > maxDistance)\n        {\n            maxDistance= currentDistance;\n        }\n        for(int neighbor : adjacencyList[currentNode])\n        {\n            adjacencyList[neighbor].erase(std::remove(adjacencyList[neighbor].begin(), adjacencyList[neighbor].end(), currentNode), adjacencyList[neighbor].end());\n            bfsQueue.push({neighbor, currentDistance + 1});\n        }\n    }\n\n    return maxDistance;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dynamicProgramming[101][101];\n\nbool isPalindrome(const vector<int> &inputArray, int startIndex, int endIndex)\n{\n    while(startIndex < endIndex)\n        if(inputArray[startIndex++] != inputArray[endIndex--])\n            return false;\n    return true;\n}\n\nint minRemovals(vector<int> &inputArray, int startIndex, int endIndex)\n{\n    if(startIndex > endIndex)\n        return 0;\n    if(startIndex == endIndex)\n        return 1;\n    if(dynamicProgramming[startIndex][endIndex] != -1)\n        return dynamicProgramming[startIndex][endIndex];\n\n    int result= minRemovals(inputArray, startIndex + 1, endIndex) + 1;\n    for(int k= startIndex + 1; k <= endIndex; k++)\n        if(inputArray[startIndex] == inputArray[k])\n            result= min(result, minRemovals(inputArray, startIndex + 1, k - 1) + minRemovals(inputArray, k + 1, endIndex));\n    return dynamicProgramming[startIndex][endIndex]= result;\n}\n\nint minimumMoves(vector<int> &inputArray)\n{\n    memset(dynamicProgramming, -1, sizeof(dynamicProgramming));\n    return minRemovals(inputArray, 0, inputArray.size() - 1);\n}",
    "output": "#include <bits/stdc++.h>\nint dynamicProgramming[101][101];\n\nbool isPalindrome(const std::vector<int> &inputArray, int startIndex, int endIndex)\n{\n    while(startIndex < endIndex)\n        if(inputArray[startIndex++] != inputArray[endIndex--])\n            return false;\n    return true;\n}\n\nint minRemovals(std::vector<int> &inputArray, int startIndex, int endIndex)\n{\n    if(startIndex > endIndex)\n        return 0;\n    if(startIndex == endIndex)\n        return 1;\n    if(dynamicProgramming[startIndex][endIndex] != -1)\n        return dynamicProgramming[startIndex][endIndex];\n\n    int result= minRemovals(inputArray, startIndex + 1, endIndex) + 1;\n    for(int k= startIndex + 1; k <= endIndex; k++)\n        if(inputArray[startIndex] == inputArray[k])\n            result= std::min(result, minRemovals(inputArray, startIndex + 1, k - 1) + minRemovals(inputArray, k + 1, endIndex));\n    return dynamicProgramming[startIndex][endIndex]= result;\n}\n\nint minimumMoves(std::vector<int> &inputArray)\n{\n    std::memset(dynamicProgramming, -1, sizeof(dynamicProgramming));\n    return minRemovals(inputArray, 0, inputArray.size() - 1);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint movesToMakeZigzag(vector<int> &numbers)\n{\n    int evenIndexMoves = 0, oddIndexMoves = 0;\n    for(int currentIndex = 0; currentIndex < numbers.size(); currentIndex++)\n    {\n        int leftNeighbor = currentIndex > 0 ? numbers[currentIndex - 1] : INT_MAX;\n        int rightNeighbor = currentIndex + 1 < numbers.size() ? numbers[currentIndex + 1] : INT_MAX;\n        int decrementForEven = numbers[currentIndex] - min(leftNeighbor, rightNeighbor) + 1;\n        int decrementForOdd = numbers[currentIndex] - min(leftNeighbor, rightNeighbor) + 1;\n        if(currentIndex % 2 == 0)\n        {\n            evenIndexMoves += max(0, decrementForEven);\n        }\n        else\n        {\n            oddIndexMoves += max(0, decrementForOdd);\n        }\n    }\n    return min(evenIndexMoves, oddIndexMoves);\n}",
    "output": "int movesToMakeZigzag(std::vector<int> &numbers)\n{\n    int evenIndexMoves= 0, oddIndexMoves= 0;\n    for(int currentIndex= 0; currentIndex < numbers.size(); currentIndex++)\n    {\n        int leftNeighbor= currentIndex > 0 ? numbers[currentIndex - 1] : INT_MAX;\n        int rightNeighbor= currentIndex + 1 < numbers.size() ? numbers[currentIndex + 1] : INT_MAX;\n        int decrementForEven= numbers[currentIndex] - std::min(leftNeighbor, rightNeighbor) + 1;\n        int decrementForOdd= numbers[currentIndex] - std::min(leftNeighbor, rightNeighbor) + 1;\n        if(currentIndex % 2 == 0)\n        {\n            evenIndexMoves+= std::max(0, decrementForEven);\n        }\n        else\n        {\n            oddIndexMoves+= std::max(0, decrementForOdd);\n        }\n    }\n    return std::min(evenIndexMoves, oddIndexMoves);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nbool canWin(TreeNode *rootNode, int targetValue)\n{\n    if(!rootNode)\n        return false;\n    if(rootNode->value == targetValue)\n    {\n        int leftNodeCount= 0, rightNodeCount= 0;\n        if(rootNode->leftChild)\n            leftNodeCount= 1 + canWin(rootNode->leftChild, targetValue);\n        if(rootNode->rightChild)\n            rightNodeCount= 1 + canWin(rootNode->rightChild, targetValue);\n        return leftNodeCount % 2 || rightNodeCount % 2;\n    }\n    return canWin(rootNode->leftChild, targetValue) || canWin(rootNode->rightChild, targetValue);\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nbool canWin(TreeNode *rootNode, int targetValue)\n{\n    if(!rootNode)\n        return false;\n    if(rootNode->value == targetValue)\n    {\n        int leftNodeCount= 0, rightNodeCount= 0;\n        if(rootNode->leftChild)\n            leftNodeCount= 1 + canWin(rootNode->leftChild, targetValue);\n        if(rootNode->rightChild)\n            rightNodeCount= 1 + canWin(rootNode->rightChild, targetValue);\n        return leftNodeCount % 2 || rightNodeCount % 2;\n    }\n    return canWin(rootNode->leftChild, targetValue) || canWin(rootNode->rightChild, targetValue);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int firstNumber, int secondNumber)\n{\n    return secondNumber == 0 ? firstNumber : gcd(secondNumber, firstNumber % secondNumber);\n}\n\nbool isGoodArray(vector<int> &numberArray)\n{\n    int greatestCommonDivisor = numberArray[0];\n    for (int i = 0; i < numberArray.size(); ++i)\n    {\n        int currentNumber = numberArray[i];\n        greatestCommonDivisor = gcd(greatestCommonDivisor, currentNumber);\n    }\n    return greatestCommonDivisor == 1;\n}",
    "output": "#include <bits/stdc++.h>\nint gcd(int firstNumber, int secondNumber)\n{\n    return secondNumber == 0 ? firstNumber : gcd(secondNumber, firstNumber % secondNumber);\n}\n\nbool isGoodArray(std::vector<int> &numberArray)\n{\n    int greatestCommonDivisor= numberArray[0];\n    for(int currentNumber : numberArray)\n    {\n        greatestCommonDivisor= gcd(greatestCommonDivisor, currentNumber);\n    }\n    return greatestCommonDivisor == 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring breakPalindrome(string palindromeString)\n{\n    int length = palindromeString.size();\n    if(length < 2)\n        return \"\";\n\n    for(int index = 0; index < length / 2; index++)\n    {\n        if(palindromeString[index] != 'a')\n        {\n            palindromeString[index] = 'a';\n            return palindromeString;\n        }\n    }\n\n    palindromeString[length - 1] = 'b';\n    return palindromeString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string breakPalindrome(std::string palindromeString)\n{\n    int length= palindromeString.size();\n    if(length < 2)\n        return \"\";\n\n    for(int index= 0; index < length / 2; index++)\n    {\n        if(palindromeString[index] != 'a')\n        {\n            palindromeString[index]= 'a';\n            return palindromeString;\n        }\n    }\n\n    palindromeString[length - 1]= 'b';\n    return palindromeString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> diagonalSort(vector<vector<int>> &matrix)\n{\n    int rowCount= matrix.size(), columnCount= matrix[0].size();\n    for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n    {\n        priority_queue<int, vector<int>, greater<>> minHeap;\n        int currentRow= rowIndex, currentCol= 0;\n        while(currentRow < rowCount && currentCol < columnCount)\n        {\n            minHeap.push(matrix[currentRow++][currentCol++]);\n        }\n        currentRow= rowIndex, currentCol= 0;\n        while(currentRow < rowCount && currentCol < columnCount)\n        {\n            matrix[currentRow++][currentCol++]= minHeap.top();\n            minHeap.pop();\n        }\n    }\n    for(int colIndex= 1; colIndex < columnCount; ++colIndex)\n    {\n        priority_queue<int, vector<int>, greater<>> minHeap;\n        int currentRow= 0, currentCol= colIndex;\n        while(currentRow < rowCount && currentCol < columnCount)\n        {\n            minHeap.push(matrix[currentRow++][currentCol++]);\n        }\n        currentRow= 0, currentCol= colIndex;\n        while(currentRow < rowCount && currentCol < columnCount)\n        {\n            matrix[currentRow++][currentCol++]= minHeap.top();\n            minHeap.pop();\n        }\n    }\n    return matrix;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> diagonalSort(std::vector<std::vector<int>> &matrix)\n{\n    int rowCount = matrix.size(), columnCount = matrix[0].size();\n    for(int rowIndex = 0; rowIndex < rowCount; ++rowIndex)\n    {\n        std::priority_queue<int, std::vector<int>, std::greater<>> minHeap;\n        int currentRow = rowIndex, currentCol = 0;\n        while(currentRow < rowCount && currentCol < columnCount)\n        {\n            minHeap.push(matrix[currentRow++][currentCol++]);\n        }\n        currentRow = rowIndex, currentCol = 0;\n        while(currentRow < rowCount && currentCol < columnCount)\n        {\n            matrix[currentRow++][currentCol++] = minHeap.top();\n            minHeap.pop();\n        }\n    }\n    for(int colIndex = 1; colIndex < columnCount; ++colIndex)\n    {\n        std::priority_queue<int, std::vector<int>, std::greater<>> minHeap;\n        int currentRow = 0, currentCol = colIndex;\n        while(currentRow < rowCount && currentCol < columnCount)\n        {\n            minHeap.push(matrix[currentRow++][currentCol++]);\n        }\n        currentRow = 0, currentCol = colIndex;\n        while(currentRow < rowCount && currentCol < columnCount)\n        {\n            matrix[currentRow++][currentCol++] = minHeap.top();\n            minHeap.pop();\n        }\n    }\n    return matrix;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool depthFirstSearch(vector<vector<int>> &grid, int row, int column)\n{\n    if(row < 0 || column < 0 || row >= grid.size() || column >= grid[0].size())\n    {\n        return false;\n    }\n\n    if(grid[row][column] == 1)\n    {\n        return true;\n    }\n\n    grid[row][column]= 1;\n\n    bool up= depthFirstSearch(grid, row - 1, column);\n    bool down= depthFirstSearch(grid, row + 1, column);\n    bool left= depthFirstSearch(grid, row, column - 1);\n    bool right= depthFirstSearch(grid, row, column + 1);\n\n    return up && down && left && right;\n}\n\nint countClosedIslands(vector<vector<int>> &grid)\n{\n    int closedIslandCount= 0;\n\n    for(int row= 0; row < grid.size(); ++row)\n    {\n        for(int column= 0; column < grid[0].size(); ++column)\n        {\n            if(grid[row][column] == 0 && depthFirstSearch(grid, row, column))\n            {\n                closedIslandCount++;\n            }\n        }\n    }\n\n    return closedIslandCount;\n}",
    "output": "#include <bits/stdc++.h>\nbool depthFirstSearch(std::vector<std::vector<int>> &grid, int row, int column)\n{\n    if(row < 0 || column < 0 || row >= grid.size() || column >= grid[0].size())\n    {\n        return false;\n    }\n\n    if(grid[row][column] == 1)\n    {\n        return true;\n    }\n\n    grid[row][column]= 1;\n\n    bool up= depthFirstSearch(grid, row - 1, column);\n    bool down= depthFirstSearch(grid, row + 1, column);\n    bool left= depthFirstSearch(grid, row, column - 1);\n    bool right= depthFirstSearch(grid, row, column + 1);\n\n    return up && down && left && right;\n}\n\nint countClosedIslands(std::vector<std::vector<int>> &grid)\n{\n    int closedIslandCount= 0;\n\n    for(int row= 0; row < grid.size(); ++row)\n    {\n        for(int column= 0; column < grid[0].size(); ++column)\n        {\n            if(grid[row][column] == 0 && depthFirstSearch(grid, row, column))\n            {\n                closedIslandCount++;\n            }\n        }\n    }\n\n    return closedIslandCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxValueAfterReverse(vector<int> &numbers)\n{\n    int totalDifference= 0, maxDifference= 0;\n    int minValue= INT_MAX, maxValue= INT_MIN;\n    for(int index= 0; index < numbers.size() - 1; ++index)\n    {\n        totalDifference+= abs(numbers[index] - numbers[index + 1]);\n        minValue= min(minValue, max(numbers[index], numbers[index + 1]));\n        maxValue= max(maxValue, min(numbers[index], numbers[index + 1]));\n        maxDifference= max(maxDifference, abs(numbers[index + 1] - numbers[0]) - abs(numbers[index + 1] - numbers[index]));\n        maxDifference= max(maxDifference, abs(numbers[index] - numbers[numbers.size() - 1]) - abs(numbers[index] - numbers[index + 1]));\n    }\n    return totalDifference + max(maxDifference, 2 * (maxValue - minValue));\n}",
    "output": "#include <bits/stdc++.h>\nint maxValueAfterReverse(std::vector<int> &numbers)\n{\n    int totalDifference= 0, maxDifference= 0;\n    int minValue= INT_MAX, maxValue= INT_MIN;\n    for(int index= 0; index < numbers.size() - 1; ++index)\n    {\n        totalDifference+= std::abs(numbers[index] - numbers[index + 1]);\n        minValue= std::min(minValue, std::max(numbers[index], numbers[index + 1]));\n        maxValue= std::max(maxValue, std::min(numbers[index], numbers[index + 1]));\n        maxDifference= std::max(maxDifference, std::abs(numbers[index + 1] - numbers[0]) - std::abs(numbers[index + 1] - numbers[index]));\n        maxDifference= std::max(maxDifference, std::abs(numbers[index] - numbers[numbers.size() - 1]) - std::abs(numbers[index] - numbers[index + 1]));\n    }\n    return totalDifference + std::max(maxDifference, 2 * (maxValue - minValue));\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> arrayRankTransform(vector<int> &inputArray)\n{\n    vector<int> sortedArray = inputArray;\n    sort(sortedArray.begin(), sortedArray.end());\n    unordered_map<int, int> rankMap;\n    int currentRank = 1;\n\n    for (int i = 0; i < sortedArray.size(); ++i)\n    {\n        int number = sortedArray[i];\n        if (rankMap.find(number) == rankMap.end())\n        {\n            rankMap[number] = currentRank++;\n        }\n    }\n\n    for (int index = 0; index < inputArray.size(); index++)\n    {\n        inputArray[index] = rankMap[inputArray[index]];\n    }\n\n    return inputArray;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> arrayRankTransform(std::vector<int> &inputArray)\n{\n    std::vector<int> sortedArray= inputArray;\n    std::sort(sortedArray.begin(), sortedArray.end());\n    std::unordered_map<int, int> rankMap;\n    int currentRank= 1;\n\n    for(int number : sortedArray)\n    {\n        if(rankMap.find(number) == rankMap.end())\n        {\n            rankMap[number]= currentRank++;\n        }\n    }\n\n    for(int index= 0; index < inputArray.size(); index++)\n    {\n        inputArray[index]= rankMap[inputArray[index]];\n    }\n\n    return inputArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> matrixRankTransform(vector<vector<int>> &inputMatrix)\n{\n    int rowCount = inputMatrix.size(), columnCount = inputMatrix[0].size();\n    vector<vector<int>> rankMatrix(rowCount, vector<int>(columnCount));\n    vector<int> sortedRowRanks(rowCount), sortedColumnRanks(columnCount);\n\n    auto getNeighbours = [&](int row, int col)\n    {\n        vector<pair<int, int>> neighboursList;\n        for (int i = 0; i < rowCount; ++i)\n            if (i != row)\n                neighboursList.push_back({i, col});\n        for (int i = 0; i < columnCount; ++i)\n            if (i != col)\n                neighboursList.push_back({row, i});\n        return neighboursList;\n    };\n\n    for (int currentBound = 0; currentBound <= 2e5; currentBound++)\n    {\n        queue<pair<int, int>> positionQueue;\n        for (int i = 0; i < rowCount; ++i)\n            for (int j = 0; j < columnCount; ++j)\n                if (inputMatrix[i][j] == currentBound && rankMatrix[i][j] == 0)\n                    positionQueue.push({i, j});\n\n        if (positionQueue.empty())\n            break;\n        for (int queueSize = positionQueue.size(); queueSize > 0; --queueSize)\n        {\n            pair<int, int> currentPosition = positionQueue.front();\n            positionQueue.pop();\n            auto [row, col] = currentPosition;\n            int potentialRank = sortedRowRanks[row] + 1;\n            for (auto [neighbourRow, neighbourCol] : getNeighbours(row, col))\n                if (inputMatrix[neighbourRow][neighbourCol] <= inputMatrix[row][col])\n                    potentialRank = max(potentialRank, rankMatrix[neighbourRow][neighbourCol] + (inputMatrix[neighbourRow][neighbourCol] < inputMatrix[row][col] ? 0 : 1));\n            if (potentialRank == sortedColumnRanks[col] + 1)\n            {\n                rankMatrix[row][col] = sortedRowRanks[row] = sortedColumnRanks[col] = potentialRank;\n            }\n            else\n            {\n                positionQueue.push(currentPosition);\n            }\n        }\n    }\n    return rankMatrix;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> matrixRankTransform(std::vector<std::vector<int>> &inputMatrix)\n{\n    int rowCount= inputMatrix.size(), columnCount= inputMatrix[0].size();\n    std::vector<std::vector<int>> rankMatrix(rowCount, std::vector<int>(columnCount));\n    std::vector<int> sortedRowRanks(rowCount), sortedColumnRanks(columnCount);\n\n    auto getNeighbours= [&](int row, int col)\n    {\n        std::vector<std::pair<int, int>> neighboursList;\n        for(int i= 0; i < rowCount; ++i)\n            if(i != row)\n                neighboursList.push_back({i, col});\n        for(int i= 0; i < columnCount; ++i)\n            if(i != col)\n                neighboursList.push_back({row, i});\n        return neighboursList;\n    };\n\n    for(int currentBound= 0; currentBound <= 2e5; currentBound++)\n    {\n        std::queue<std::pair<int, int>> positionQueue;\n        for(int i= 0; i < rowCount; ++i)\n            for(int j= 0; j < columnCount; ++j)\n                if(inputMatrix[i][j] == currentBound && rankMatrix[i][j] == 0)\n                    positionQueue.push({i, j});\n\n        if(positionQueue.empty())\n            break;\n        for(std::pair<int, int> currentPosition; !positionQueue.empty(); positionQueue.pop())\n        {\n            auto [row, col]= currentPosition= positionQueue.front();\n            int potentialRank= sortedRowRanks[row] + 1;\n            for(auto [neighbourRow, neighbourCol] : getNeighbours(row, col))\n                if(inputMatrix[neighbourRow][neighbourCol] <= inputMatrix[row][col])\n                    potentialRank= std::max(potentialRank, rankMatrix[neighbourRow][neighbourCol] + (inputMatrix[neighbourRow][neighbourCol] < inputMatrix[row][col] ? 0 : 1));\n            if(potentialRank == sortedColumnRanks[col] + 1)\n            {\n                rankMatrix[row][col]= sortedRowRanks[row]= sortedColumnRanks[col]= potentialRank;\n            }\n            else\n            {\n                positionQueue.push(currentPosition);\n            }\n        }\n    }\n    return rankMatrix;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generateSentencesHelper(int wordIndex, vector<string> &wordList, map<string, set<string>> &synonymMap, vector<string> &sentenceList, string currentSentence)\n{\n    if(wordIndex == wordList.size())\n    {\n        sentenceList.push_back(currentSentence);\n    }\n    else\n    {\n        set<string> &synonymsForWord = synonymMap[wordList[wordIndex]];\n        for(auto it = synonymsForWord.begin(); it != synonymsForWord.end(); ++it)\n        {\n            generateSentencesHelper(wordIndex + 1, wordList, synonymMap, sentenceList, currentSentence + (currentSentence.empty() ? \"\" : \" \") + *it);\n        }\n    }\n}\n\nvector<string> generateSentences(vector<vector<string>> &synonymPairs, string inputText)\n{\n    map<string, set<string>> synonymMap;\n\n    for(const auto &synonymPair : synonymPairs)\n    {\n        synonymMap[synonymPair[0]].insert(synonymPair[0]);\n        synonymMap[synonymPair[0]].insert(synonymPair[1]);\n        synonymMap[synonymPair[1]].insert(synonymPair[0]);\n        synonymMap[synonymPair[1]].insert(synonymPair[1]);\n    }\n\n    vector<string> wordList;\n    size_t start = 0, end = inputText.find(' ');\n\n    while(end != string::npos)\n    {\n        wordList.push_back(inputText.substr(start, end - start));\n        start = end + 1;\n        end = inputText.find(' ', start);\n    }\n\n    wordList.push_back(inputText.substr(start));\n\n    vector<string> sentenceList;\n    generateSentencesHelper(0, wordList, synonymMap, sentenceList, \"\");\n\n    return sentenceList;\n}",
    "output": "#include <bits/stdc++.h>\nvoid generateSentencesHelper(int wordIndex, std::vector<std::string> &wordList, std::map<std::string, std::set<std::string>> &synonymMap, std::vector<std::string> &sentenceList, std::string currentSentence)\n{\n    if(wordIndex == wordList.size())\n    {\n        sentenceList.push_back(currentSentence);\n    }\n    else\n    {\n        std::set<std::string> &synonymsForWord= synonymMap[wordList[wordIndex]];\n        for(const auto &synonym : synonymsForWord)\n        {\n            generateSentencesHelper(wordIndex + 1, wordList, synonymMap, sentenceList, currentSentence + (currentSentence.empty() ? \"\" : \" \") + synonym);\n        }\n    }\n}\n\nstd::vector<std::string> generateSentences(std::vector<std::vector<std::string>> &synonymPairs, std::string inputText)\n{\n    std::map<std::string, std::set<std::string>> synonymMap;\n\n    for(const auto &synonymPair : synonymPairs)\n    {\n        synonymMap[synonymPair[0]].insert(synonymPair[0]);\n        synonymMap[synonymPair[0]].insert(synonymPair[1]);\n        synonymMap[synonymPair[1]].insert(synonymPair[0]);\n        synonymMap[synonymPair[1]].insert(synonymPair[1]);\n    }\n\n    std::vector<std::string> wordList;\n    size_t start= 0, end= inputText.find(' ');\n\n    while(end != std::string::npos)\n    {\n        wordList.push_back(inputText.substr(start, end - start));\n        start= end + 1;\n        end= inputText.find(' ', start);\n    }\n\n    wordList.push_back(inputText.substr(start));\n\n    std::vector<std::string> sentenceList;\n    generateSentencesHelper(0, wordList, synonymMap, sentenceList, \"\");\n\n    return sentenceList;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateNumberOfWays(int totalPeople)\n{\n    const int modulo= 1000000007;\n    vector<int> dynamicProgramming(totalPeople / 2 + 1);\n    dynamicProgramming[0]= 1;\n    for(int halfIndex= 1; halfIndex <= totalPeople / 2; ++halfIndex)\n    {\n        for(int subIndex= 1; subIndex <= halfIndex; ++subIndex)\n        {\n            dynamicProgramming[halfIndex]= (dynamicProgramming[halfIndex] + ((long long)dynamicProgramming[halfIndex - subIndex] * dynamicProgramming[subIndex - 1]) % modulo) % modulo;\n        }\n    }\n    return dynamicProgramming[totalPeople / 2];\n}",
    "output": "#include <bits/stdc++.h>\nint calculateNumberOfWays(int totalPeople)\n{\n    const int modulo= 1000000007;\n    std::vector<int> dynamicProgramming(totalPeople / 2 + 1);\n    dynamicProgramming[0]= 1;\n    for(int halfIndex= 1; halfIndex <= totalPeople / 2; ++halfIndex)\n    {\n        for(int subIndex= 1; subIndex <= halfIndex; ++subIndex)\n        {\n            dynamicProgramming[halfIndex]= (dynamicProgramming[halfIndex] + ((long long)dynamicProgramming[halfIndex - subIndex] * dynamicProgramming[subIndex - 1]) % modulo) % modulo;\n        }\n    }\n    return dynamicProgramming[totalPeople / 2];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dayOfYear(string date)\n{\n    int year = stoi(date.substr(0, 4));\n    int month = stoi(date.substr(5, 2));\n    int day = stoi(date.substr(8, 2));\n\n    int daysInMonth[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    if(year % 4 == 0 && (year % 100 != 0 || year % 400 == 0))\n    {\n        daysInMonth[2] = 29;\n    }\n\n    int cumulativeDayOfYear = 0;\n    for(int i = 1; i < month; ++i)\n    {\n        cumulativeDayOfYear += daysInMonth[i];\n    }\n    cumulativeDayOfYear += day;\n\n    return cumulativeDayOfYear;\n}",
    "output": "int dayOfYear(std::string date)\n{\n    int year= stoi(date.substr(0, 4));\n    int month= stoi(date.substr(5, 2));\n    int day= stoi(date.substr(8, 2));\n\n    int daysInMonth[]= {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    if(year % 4 == 0 && (year % 100 != 0 || year % 400 == 0))\n    {\n        daysInMonth[2]= 29;\n    }\n\n    int cumulativeDayOfYear= 0;\n    for(int i= 1; i < month; ++i)\n    {\n        cumulativeDayOfYear+= daysInMonth[i];\n    }\n    cumulativeDayOfYear+= day;\n\n    return cumulativeDayOfYear;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nclass FindElements\n{\n  public:\n    FindElements(TreeNode *rootNode)\n    {\n        recoverTree(rootNode, 0);\n    }\n\n    bool find(int target)\n    {\n        return valuesSet.find(target) != valuesSet.end();\n    }\n\n  private:\n    void recoverTree(TreeNode *currentNode, int currentValue)\n    {\n        if(currentNode == NULL)\n            return;\n\n        currentNode->value = currentValue;\n        valuesSet.insert(currentValue);\n\n        recoverTree(currentNode->leftChild, currentValue * 2 + 1);\n        recoverTree(currentNode->rightChild, currentValue * 2 + 2);\n    }\n\n    set<int> valuesSet;\n};",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nclass FindElements\n{\n  public:\n    FindElements(TreeNode *rootNode)\n    {\n        recoverTree(rootNode, 0);\n    }\n\n    bool find(int target)\n    {\n        return valuesSet.find(target) != valuesSet.end();\n    }\n\n  private:\n    void recoverTree(TreeNode *currentNode, int currentValue)\n    {\n        if(currentNode == NULL)\n            return;\n\n        currentNode->value= currentValue;\n        valuesSet.insert(currentValue);\n\n        recoverTree(currentNode->leftChild, currentValue * 2 + 1);\n        recoverTree(currentNode->rightChild, currentValue * 2 + 2);\n    }\n\n    std::set<int> valuesSet;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For rand()\nusing namespace std;\n\nclass MajorityChecker\n{\n  public:\n    MajorityChecker(vector<int> &inputArray)\n    {\n        for(int index= 0; index < inputArray.size(); index++)\n        {\n            positions[inputArray[index]].push_back(index);\n        }\n    }\n\n    int query(int leftIndex, int rightIndex, int threshold)\n    {\n        for(int attempt= 0; attempt < 20; attempt++)\n        {\n            int randomIndex= rand() % (rightIndex - leftIndex + 1) + leftIndex;\n            int occurrences= positions[inputArray[randomIndex]].size();\n            if(occurrences >= threshold)\n            {\n                auto lowerBound= lower_bound(positions[inputArray[randomIndex]].begin(), positions[inputArray[randomIndex]].end(), leftIndex);\n                auto upperBound= upper_bound(positions[inputArray[randomIndex]].begin(), positions[inputArray[randomIndex]].end(), rightIndex);\n                if(upperBound - lowerBound >= threshold)\n                    return inputArray[randomIndex];\n            }\n        }\n        return -1;\n    }\n\n  private:\n    unordered_map<int, vector<int>> positions;\n};",
    "output": "#include <bits/stdc++.h>\n// for rand()\n\nclass MajorityChecker\n{\n  public:\n    MajorityChecker(std::vector<int> &inputArray)\n    {\n        for(int index= 0; index < inputArray.size(); index++)\n        {\n            positions[inputArray[index]].push_back(index);\n        }\n    }\n\n    int query(int leftIndex, int rightIndex, int threshold)\n    {\n        for(int attempt= 0; attempt < 20; attempt++)\n        {\n            int randomIndex= std::rand() % (rightIndex - leftIndex + 1) + leftIndex;\n            int occurrences= positions[inputArray[randomIndex]].size();\n            if(occurrences >= threshold)\n            {\n                auto lowerBound= std::lower_bound(positions[inputArray[randomIndex]].begin(), positions[inputArray[randomIndex]].end(), leftIndex);\n                auto upperBound= std::upper_bound(positions[inputArray[randomIndex]].begin(), positions[inputArray[randomIndex]].end(), rightIndex);\n                if(upperBound - lowerBound >= threshold)\n                    return inputArray[randomIndex];\n            }\n        }\n        return -1;\n    }\n\n  private:\n    std::unordered_map<int, std::vector<int>> positions;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numRollsToTarget(int numberOfDice, int sidesPerDie, int targetSum)\n{\n    const int modulo= 1e9 + 7;\n    vector<vector<int>> dynamicProgramming(numberOfDice + 1, vector<int>(targetSum + 1, 0));\n    dynamicProgramming[0][0]= 1;\n\n    for(int diceCount= 1; diceCount <= numberOfDice; ++diceCount)\n    {\n        for(int sum= 1; sum <= targetSum; ++sum)\n        {\n            for(int faceValue= 1; faceValue <= sidesPerDie; ++faceValue)\n            {\n                if(sum >= faceValue)\n                {\n                    dynamicProgramming[diceCount][sum]= (dynamicProgramming[diceCount][sum] + dynamicProgramming[diceCount - 1][sum - faceValue]) % modulo;\n                }\n            }\n        }\n    }\n    return dynamicProgramming[numberOfDice][targetSum];\n}",
    "output": "#include <bits/stdc++.h>\nint numRollsToTarget(int numberOfDice, int sidesPerDie, int targetSum)\n{\n    const int modulo= 1e9 + 7;\n    std::vector<std::vector<int>> dynamicProgramming(numberOfDice + 1, std::vector<int>(targetSum + 1, 0));\n    dynamicProgramming[0][0]= 1;\n\n    for(int diceCount= 1; diceCount <= numberOfDice; ++diceCount)\n    {\n        for(int sum= 1; sum <= targetSum; ++sum)\n        {\n            for(int faceValue= 1; faceValue <= sidesPerDie; ++faceValue)\n            {\n                if(sum >= faceValue)\n                {\n                    dynamicProgramming[diceCount][sum]= (dynamicProgramming[diceCount][sum] + dynamicProgramming[diceCount - 1][sum - faceValue]) % modulo;\n                }\n            }\n        }\n    }\n    return dynamicProgramming[numberOfDice][targetSum];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For standard I/O if needed\nusing namespace std;\n\n// Assuming ImmutableListNode is defined elsewhere\nvoid printLinkedListInReverse(ImmutableListNode *listHead)\n{\n    if(listHead != NULL)\n    {\n        printLinkedListInReverse(listHead->getNext());\n        listHead->printValue();\n    }\n}",
    "output": "void printLinkedListInReverse(ImmutableListNode *listHead)\n{\n    if(listHead != NULL)\n    {\n        printLinkedListInReverse(listHead->getNext());\n        listHead->printValue();\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeToVisitAllPoints(vector<vector<int>> &points)\n{\n    int totalTime= 0;\n    for(int currentIndex= 1; currentIndex < points.size(); currentIndex++)\n    {\n        int deltaX= abs(points[currentIndex][0] - points[currentIndex - 1][0]);\n        int deltaY= abs(points[currentIndex][1] - points[currentIndex - 1][1]);\n        totalTime+= max(deltaX, deltaY);\n    }\n    return totalTime;\n}",
    "output": "#include <bits/stdc++.h>\nint minTimeToVisitAllPoints(std::vector<std::vector<int>> &points)\n{\n    int totalTime= 0;\n    for(int currentIndex= 1; currentIndex < points.size(); currentIndex++)\n    {\n        int deltaX= std::abs(points[currentIndex][0] - points[currentIndex - 1][0]);\n        int deltaY= std::abs(points[currentIndex][1] - points[currentIndex - 1][1]);\n        totalTime+= std::max(deltaX, deltaY);\n    }\n    return totalTime;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode *removeZeroSumSublists(ListNode *head)\n{\n    ListNode dummyNode(0);\n    dummyNode.next = head;\n    ListNode *currentNode = &dummyNode;\n\n    while(currentNode)\n    {\n        int cumulativeSum = 0;\n        ListNode *tempNode = currentNode->next; // Use a temporary pointer to traverse the list\n        while(tempNode)\n        {\n            cumulativeSum += tempNode->val;\n            if(cumulativeSum == 0)\n            {\n                currentNode->next = tempNode->next; // Remove the sublist starting from currentNode->next\n            }\n            tempNode = tempNode->next;\n        }\n        currentNode = currentNode->next;\n        if(currentNode)\n        {\n            head = currentNode->next;\n        }\n    }\n\n    return dummyNode.next;\n}",
    "output": "ListNode *removeZeroSumSublists(ListNode *head)\n{\n    ListNode dummyNode(0);\n    dummyNode.next= head;\n    ListNode *currentNode= &dummyNode;\n\n    while(currentNode)\n    {\n        int cumulativeSum= 0;\n        while(head)\n        {\n            cumulativeSum+= head->val;\n            if(cumulativeSum == 0)\n            {\n                currentNode->next= head->next;\n            }\n            head= head->next;\n        }\n        currentNode= currentNode->next;\n        if(currentNode)\n        {\n            head= currentNode->next;\n        }\n    }\n\n    return dummyNode.next;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<string>> suggestedProducts(vector<string> &productList, string searchTerm)\n{\n    vector<vector<string>> suggestionResult;\n    sort(productList.begin(), productList.end());\n\n    for(int index = 0; index < searchTerm.size(); ++index)\n    {\n        vector<string> suggestions;\n        for(int j = 0; j < productList.size(); ++j)\n        {\n            const auto &product = productList[j];\n            if(product.size() > index && product[index] == searchTerm[index])\n            {\n                suggestions.push_back(product);\n                if(suggestions.size() == 3)\n                    break;\n            }\n        }\n        suggestionResult.push_back(suggestions);\n    }\n\n    return suggestionResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<std::string>> suggestedProducts(std::vector<std::string> &productList, std::string searchTerm)\n{\n    std::vector<std::vector<std::string>> suggestionResult;\n    std::sort(productList.begin(), productList.end());\n\n    for(int index= 0; index < searchTerm.size(); ++index)\n    {\n        std::vector<std::string> suggestions;\n        for(const auto &product : productList)\n        {\n            if(product.size() > index && product[index] == searchTerm[index])\n            {\n                suggestions.push_back(product);\n                if(suggestions.size() == 3)\n                    break;\n            }\n        }\n        suggestionResult.push_back(suggestions);\n    }\n\n    return suggestionResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulus = 1e9 + 7;\n\nint numOfWays(int totalSteps, int arrayLength)\n{\n    int maxPosition = min(totalSteps / 2, arrayLength - 1);\n    vector<vector<int>> dynamicProgramming(2, vector<int>(maxPosition + 1));\n    dynamicProgramming[0][0] = 1;\n\n    for(int step = 1; step <= totalSteps; ++step)\n    {\n        for(int position = 0; position <= maxPosition; ++position)\n        {\n            dynamicProgramming[step % 2][position] = dynamicProgramming[(step - 1) % 2][position];\n            if(position > 0)\n            {\n                dynamicProgramming[step % 2][position] += dynamicProgramming[(step - 1) % 2][position - 1];\n            }\n            if(position < maxPosition)\n            {\n                dynamicProgramming[step % 2][position] += dynamicProgramming[(step - 1) % 2][position + 1];\n            }\n            dynamicProgramming[step % 2][position] %= modulus;\n        }\n    }\n\n    return dynamicProgramming[totalSteps % 2][0];\n}",
    "output": "#include <bits/stdc++.h>\nconst int modulus = 1e9 + 7;\n\nint numOfWays(int totalSteps, int arrayLength)\n{\n    int maxPosition = std::min(totalSteps / 2, arrayLength - 1);\n    std::vector<std::vector<int>> dynamicProgramming(2, std::vector<int>(maxPosition + 1));\n    dynamicProgramming[0][0] = 1;\n\n    for(int step = 1; step <= totalSteps; ++step)\n    {\n        for(int position = 0; position <= maxPosition; ++position)\n        {\n            dynamicProgramming[step % 2][position] = dynamicProgramming[(step - 1) % 2][position];\n            if(position > 0)\n            {\n                dynamicProgramming[step % 2][position] += dynamicProgramming[(step - 1) % 2][position - 1];\n            }\n            if(position < maxPosition)\n            {\n                dynamicProgramming[step % 2][position] += dynamicProgramming[(step - 1) % 2][position + 1];\n            }\n            dynamicProgramming[step % 2][position] %= modulus;\n        }\n    }\n\n    return dynamicProgramming[totalSteps % 2][0];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring toHexspeak(string number)\n{\n    long decimalNumber = stol(number);\n    string hexRepresentation = \"\";\n    while(decimalNumber)\n    {\n        int remainder = decimalNumber % 16;\n        if(remainder == 1)\n            hexRepresentation = \"I\" + hexRepresentation;\n        else if(remainder == 0)\n            hexRepresentation = \"O\" + hexRepresentation;\n        else if(remainder > 9)\n            hexRepresentation = (char)(remainder - 10 + 'A') + hexRepresentation;\n        else\n            return \"ERROR\";\n        decimalNumber /= 16;\n    }\n    return hexRepresentation;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string toHexspeak(std::string number)\n{\n    long decimalNumber= std::stol(number);\n    std::string hexRepresentation= \"\";\n    while(decimalNumber)\n    {\n        int remainder= decimalNumber % 16;\n        if(remainder == 1)\n            hexRepresentation= \"I\" + hexRepresentation;\n        else if(remainder == 0)\n            hexRepresentation= \"O\" + hexRepresentation;\n        else if(remainder > 9)\n            hexRepresentation= (char)(remainder - 10 + 'A') + hexRepresentation;\n        else\n            return \"ERROR\";\n        decimalNumber/= 16;\n    }\n    return hexRepresentation;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> findInvalidTransactions(vector<string> &transactionRecords)\n{\n    unordered_map<string, vector<vector<string>>> transactionMap;\n\n    for (int i = 0; i < transactionRecords.size(); ++i)\n    {\n        const auto &record = transactionRecords[i];\n        stringstream stringStream(record);\n        vector<string> transactionDetails;\n        string detail;\n\n        while (getline(stringStream, detail, ','))\n            transactionDetails.push_back(detail);\n\n        transactionMap[transactionDetails[0]].push_back(transactionDetails);\n    }\n\n    vector<string> invalidTransactions;\n\n    for (int i = 0; i < transactionRecords.size(); ++i)\n    {\n        const auto &record = transactionRecords[i];\n        stringstream stringStream(record);\n        vector<string> transactionDetails;\n        string detail;\n\n        while (getline(stringStream, detail, ','))\n            transactionDetails.push_back(detail);\n\n        if (stoi(transactionDetails[2]) > 1000)\n        {\n            invalidTransactions.push_back(record);\n            continue;\n        }\n\n        for (int j = 0; j < transactionMap[transactionDetails[0]].size(); ++j)\n        {\n            const auto &otherTransaction = transactionMap[transactionDetails[0]][j];\n            if (otherTransaction[3] != transactionDetails[3] && abs(stoi(otherTransaction[1]) - stoi(transactionDetails[1])) <= 60)\n            {\n                invalidTransactions.push_back(record);\n                break;\n            }\n        }\n    }\n\n    return invalidTransactions;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> findInvalidTransactions(std::vector<std::string> &transactionRecords)\n{\n    std::unordered_map<std::string, std::vector<std::vector<std::string>>> transactionMap;\n\n    for(const auto &record : transactionRecords)\n    {\n        std::stringstream stringStream(record);\n        std::vector<std::string> transactionDetails;\n        std::string detail;\n\n        while(std::getline(stringStream, detail, ','))\n            transactionDetails.push_back(detail);\n\n        transactionMap[transactionDetails[0]].push_back(transactionDetails);\n    }\n\n    std::vector<std::string> invalidTransactions;\n\n    for(const auto &record : transactionRecords)\n    {\n        std::stringstream stringStream(record);\n        std::vector<std::string> transactionDetails;\n        std::string detail;\n\n        while(std::getline(stringStream, detail, ','))\n            transactionDetails.push_back(detail);\n\n        if(std::stoi(transactionDetails[2]) > 1000)\n        {\n            invalidTransactions.push_back(record);\n            continue;\n        }\n\n        for(const auto &otherTransaction : transactionMap[transactionDetails[0]])\n        {\n            if(otherTransaction[3] != transactionDetails[3] && std::abs(std::stoi(otherTransaction[1]) - std::stoi(transactionDetails[1])) <= 60)\n            {\n                invalidTransactions.push_back(record);\n                break;\n            }\n        }\n    }\n\n    return invalidTransactions;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countSmallerFrequencies(const vector<string> &words, const vector<string> &queries)\n{\n    vector<int> frequencyOfWords(words.size(), 0);\n\n    for(int wordIndex= 0; wordIndex < words.size(); ++wordIndex)\n    {\n        char minCharacter= *min_element(words[wordIndex].begin(), words[wordIndex].end());\n        frequencyOfWords[wordIndex]= count(words[wordIndex].begin(), words[wordIndex].end(), minCharacter);\n    }\n\n    vector<int> result(queries.size(), 0);\n    for(int queryIndex= 0; queryIndex < queries.size(); ++queryIndex)\n    {\n        char minCharacter= *min_element(queries[queryIndex].begin(), queries[queryIndex].end());\n        int frequencyOfQuery= count(queries[queryIndex].begin(), queries[queryIndex].end(), minCharacter);\n\n        result[queryIndex]= count_if(frequencyOfWords.begin(), frequencyOfWords.end(), [frequencyOfQuery](int frequency)\n                                     { return frequency > frequencyOfQuery; });\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> countSmallerFrequencies(const std::vector<std::string> &words, const std::vector<std::string> &queries)\n{\n    std::vector<int> frequencyOfWords(words.size(), 0);\n\n    for(int wordIndex= 0; wordIndex < words.size(); ++wordIndex)\n    {\n        char minCharacter= *min_element(words[wordIndex].begin(), words[wordIndex].end());\n        frequencyOfWords[wordIndex]= count(words[wordIndex].begin(), words[wordIndex].end(), minCharacter);\n    }\n\n    std::vector<int> result(queries.size(), 0);\n    for(int queryIndex= 0; queryIndex < queries.size(); ++queryIndex)\n    {\n        char minCharacter= *min_element(queries[queryIndex].begin(), queries[queryIndex].end());\n        int frequencyOfQuery= count(queries[queryIndex].begin(), queries[queryIndex].end(), minCharacter);\n\n        result[queryIndex]= count_if(frequencyOfWords.begin(), frequencyOfWords.end(), [frequencyOfQuery](int frequency)\n                                     { return frequency > frequencyOfQuery; });\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countDaysBetweenDates(const string &startDate, const string &endDate)\n{\n    tm startDateTime= {}, endDateTime= {};\n    istringstream startDateStream(startDate), endDateStream(endDate);\n    startDateStream >> get_time(&startDateTime, \"%Y-%m-%d\");\n    endDateStream >> get_time(&endDateTime, \"%Y-%m-%d\");\n\n    time_t startTime= mktime(&startDateTime);\n    time_t endTime= mktime(&endDateTime);\n    double dateDifference= difftime(endTime, startTime);\n    return dateDifference / 86400;\n}",
    "output": "#include <bits/stdc++.h>\nint countDaysBetweenDates(const std::string &startDate, const std::string &endDate)\n{\n    std::tm startDateTime= {}, endDateTime= {};\n    std::istringstream startDateStream(startDate), endDateStream(endDate);\n    startDateStream >> std::get_time(&startDateTime, \"%Y-%m-%d\");\n    endDateStream >> std::get_time(&endDateTime, \"%Y-%m-%d\");\n\n    std::time_t startTime= std::mktime(&startDateTime);\n    std::time_t endTime= std::mktime(&endDateTime);\n    double dateDifference= std::difftime(endTime, startTime);\n    return dateDifference / 86400;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool validateBinaryTreeNodes(int nodeCount, vector<int> &leftChildIndices, vector<int> &rightChildIndices)\n{\n    vector<int> parentIndices(nodeCount, -1);\n    for(int index= 0; index < nodeCount; ++index)\n    {\n        if(leftChildIndices[index] != -1)\n        {\n            if(parentIndices[leftChildIndices[index]] != -1)\n                return false;\n            parentIndices[leftChildIndices[index]]= index;\n        }\n        if(rightChildIndices[index] != -1)\n        {\n            if(parentIndices[rightChildIndices[index]] != -1)\n                return false;\n            parentIndices[rightChildIndices[index]]= index;\n        }\n    }\n    int rootIndex= -1;\n    for(int index= 0; index < nodeCount; ++index)\n    {\n        if(parentIndices[index] == -1)\n        {\n            if(rootIndex != -1)\n                return false;\n            rootIndex= index;\n        }\n    }\n    return rootIndex != -1;\n}",
    "output": "#include <bits/stdc++.h>\nbool validateBinaryTreeNodes(int nodeCount, std::vector<int> &leftChildIndices, std::vector<int> &rightChildIndices)\n{\n    std::vector<int> parentIndices(nodeCount, -1);\n    for(int index= 0; index < nodeCount; ++index)\n    {\n        if(leftChildIndices[index] != -1)\n        {\n            if(parentIndices[leftChildIndices[index]] != -1)\n                return false;\n            parentIndices[leftChildIndices[index]]= index;\n        }\n        if(rightChildIndices[index] != -1)\n        {\n            if(parentIndices[rightChildIndices[index]] != -1)\n                return false;\n            parentIndices[rightChildIndices[index]]= index;\n        }\n    }\n    int rootIndex= -1;\n    for(int index= 0; index < nodeCount; ++index)\n    {\n        if(parentIndices[index] == -1)\n        {\n            if(rootIndex != -1)\n                return false;\n            rootIndex= index;\n        }\n    }\n    return rootIndex != -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\npair<int, int> closestFactors(int targetNumber)\n{\n    int potentialFactor1 = sqrt(targetNumber + 2);\n    while(true)\n    {\n        int potentialFactor2 = (targetNumber + 2) / potentialFactor1;\n        if(potentialFactor1 * potentialFactor2 == targetNumber + 2)\n        {\n            return make_pair(potentialFactor1, potentialFactor2);\n        }\n        potentialFactor2 = (targetNumber + 1) / potentialFactor1;\n        if(potentialFactor1 * potentialFactor2 == targetNumber + 1)\n        {\n            return make_pair(potentialFactor1, potentialFactor2);\n        }\n        potentialFactor1--;\n    }\n}",
    "output": "std::pair<int, int> closestFactors(int targetNumber)\n{\n    int potentialFactor1= std::sqrt(targetNumber + 2);\n    while(true)\n    {\n        int potentialFactor2= (targetNumber + 2) / potentialFactor1;\n        if(potentialFactor1 * potentialFactor2 == targetNumber + 2)\n        {\n            return std::make_pair(potentialFactor1, potentialFactor2);\n        }\n        potentialFactor2= (targetNumber + 1) / potentialFactor1;\n        if(potentialFactor1 * potentialFactor2 == targetNumber + 1)\n        {\n            return std::make_pair(potentialFactor1, potentialFactor2);\n        }\n        potentialFactor1--;\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestMultipleOfThree(vector<int> &digitList)\n{\n    int totalSum = 0, remainderCount[3] = {0};\n\n    for(int digit : digitList)\n    {\n        totalSum += digit;\n        remainderCount[digit % 3]++;\n    }\n\n    if(totalSum % 3 == 1)\n    {\n        if(remainderCount[1] >= 1)\n            remainderCount[1]--;\n        else\n            remainderCount[2] -= 2;\n    }\n    else if(totalSum % 3 == 2)\n    {\n        if(remainderCount[2] >= 1)\n            remainderCount[2]--;\n        else\n            remainderCount[1] -= 2;\n    }\n\n    string result = \"\";\n    for(int i = 0; i <= 9; ++i)\n    {\n        int count = remainderCount[i % 3];\n        while(count--)\n            result += to_string(i);\n    }\n\n    if(!result.empty() && result.back() == '0')\n        return \"0\";\n    reverse(result.begin(), result.end());\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string largestMultipleOfThree(std::vector<int> &digitList)\n{\n    int totalSum= 0, remainderCount[3]= {0};\n\n    for(int digit : digitList)\n    {\n        totalSum+= digit;\n        remainderCount[digit % 3]++;\n    }\n\n    if(totalSum % 3 == 1)\n    {\n        if(remainderCount[1] >= 1)\n            remainderCount[1]--;\n        else\n            remainderCount[2]-= 2;\n    }\n    else if(totalSum % 3 == 2)\n    {\n        if(remainderCount[2] >= 1)\n            remainderCount[2]--;\n        else\n            remainderCount[1]-= 2;\n    }\n\n    std::string result= \"\";\n    for(int i= 0; i <= 9; ++i)\n    {\n        int count= remainderCount[i % 3];\n        while(count--)\n            result+= std::to_string(i);\n    }\n\n    if(!result.empty() && result.back() == '0')\n        return \"0\";\n    std::reverse(result.begin(), result.end());\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint palindromePartition(string inputString, int partitions)\n{\n    int stringLength= inputString.size();\n    vector<vector<int>> dpMatrix(stringLength, vector<int>(stringLength, 0));\n\n    for(int length= 2; length <= stringLength; ++length)\n    {\n        for(int startIndex= 0; startIndex <= stringLength - length; ++startIndex)\n        {\n            int endIndex= startIndex + length - 1;\n            dpMatrix[startIndex][endIndex]= dpMatrix[startIndex + 1][endIndex - 1] + (inputString[startIndex] != inputString[endIndex]);\n        }\n    }\n\n    vector<int> minCuts(stringLength, 1e9);\n    for(int i= 0; i < stringLength; ++i)\n    {\n        if(dpMatrix[0][i] == 0)\n        {\n            minCuts[i]= 0;\n        }\n        else\n        {\n            for(int j= 0; j < i; ++j)\n            {\n                minCuts[i]= min(minCuts[i], minCuts[j] + dpMatrix[j + 1][i]);\n            }\n        }\n    }\n\n    return minCuts.back() + partitions;\n}",
    "output": "#include <bits/stdc++.h>\nint palindromePartition(std::string inputString, int partitions)\n{\n    int stringLength= inputString.size();\n    std::vector<std::vector<int>> dpMatrix(stringLength, std::vector<int>(stringLength, 0));\n\n    for(int length= 2; length <= stringLength; ++length)\n    {\n        for(int startIndex= 0; startIndex <= stringLength - length; ++startIndex)\n        {\n            int endIndex= startIndex + length - 1;\n            dpMatrix[startIndex][endIndex]= dpMatrix[startIndex + 1][endIndex - 1] + (inputString[startIndex] != inputString[endIndex]);\n        }\n    }\n\n    std::vector<int> minCuts(stringLength, 1e9);\n    for(int i= 0; i < stringLength; ++i)\n    {\n        if(dpMatrix[0][i] == 0)\n        {\n            minCuts[i]= 0;\n        }\n        else\n        {\n            for(int j= 0; j < i; ++j)\n            {\n                minCuts[i]= std::min(minCuts[i], minCuts[j] + dpMatrix[j + 1][i]);\n            }\n        }\n    }\n\n    return minCuts.back() + partitions;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<bool> canMakePaliQueries(string inputString, vector<vector<int>> &queries)\n{\n    vector<bool> queryResults;\n    for (int q = 0; q < queries.size(); ++q)\n    {\n        auto &query = queries[q];\n        int leftIndex = query[0], rightIndex = query[1], allowedChanges = query[2];\n        int charCount[26] = {0};\n        for (int i = leftIndex; i <= rightIndex; i++)\n        {\n            charCount[inputString[i] - 'a']++;\n        }\n        int oddCharacterCount = 0;\n        for (int i = 0; i < 26; i++)\n        {\n            oddCharacterCount += charCount[i] % 2;\n        }\n        queryResults.push_back(oddCharacterCount / 2 <= allowedChanges);\n    }\n    return queryResults;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<bool> canMakePaliQueries(std::string inputString, std::vector<std::vector<int>> &queries)\n{\n    std::vector<bool> queryResults;\n    for(auto &query : queries)\n    {\n        int leftIndex= query[0], rightIndex= query[1], allowedChanges= query[2];\n        int charCount[26]= {0};\n        for(int i= leftIndex; i <= rightIndex; i++)\n        {\n            charCount[inputString[i] - 'a']++;\n        }\n        int oddCharacterCount= 0;\n        for(int i= 0; i < 26; i++)\n        {\n            oddCharacterCount+= charCount[i] % 2;\n        }\n        queryResults.push_back(oddCharacterCount / 2 <= allowedChanges);\n    }\n    return queryResults;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> groupThePeople(vector<int> &groupSizes)\n{\n    unordered_map<int, vector<int>> sizeToMembersMap;\n    vector<vector<int>> groupedResult;\n\n    for(int memberIndex= 0; memberIndex < groupSizes.size(); memberIndex++)\n    {\n        sizeToMembersMap[groupSizes[memberIndex]].push_back(memberIndex);\n        if(sizeToMembersMap[groupSizes[memberIndex]].size() == groupSizes[memberIndex])\n        {\n            groupedResult.push_back(sizeToMembersMap[groupSizes[memberIndex]]);\n            sizeToMembersMap[groupSizes[memberIndex]].clear();\n        }\n    }\n\n    return groupedResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> groupThePeople(std::vector<int> &groupSizes)\n{\n    std::unordered_map<int, std::vector<int>> sizeToMembersMap;\n    std::vector<std::vector<int>> groupedResult;\n\n    for(int memberIndex= 0; memberIndex < groupSizes.size(); memberIndex++)\n    {\n        sizeToMembersMap[groupSizes[memberIndex]].push_back(memberIndex);\n        if(sizeToMembersMap[groupSizes[memberIndex]].size() == groupSizes[memberIndex])\n        {\n            groupedResult.push_back(sizeToMembersMap[groupSizes[memberIndex]]);\n            sizeToMembersMap[groupSizes[memberIndex]].clear();\n        }\n    }\n\n    return groupedResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring formatDate(const string &inputDate)\n{\n    unordered_map<string, string> monthMapping= {\n        {\"Jan\", \"01\"},\n        {\"Feb\", \"02\"},\n        {\"Mar\", \"03\"},\n        {\"Apr\", \"04\"},\n        {\"May\", \"05\"},\n        {\"Jun\", \"06\"},\n        {\"Jul\", \"07\"},\n        {\"Aug\", \"08\"},\n        {\"Sep\", \"09\"},\n        {\"Oct\", \"10\"},\n        {\"Nov\", \"11\"},\n        {\"Dec\", \"12\"},\n    };\n\n    stringstream dateStream(inputDate);\n    string day, month, year;\n    dateStream >> day >> month >> year;\n    return year + \"-\" + monthMapping[month] + \"-\" + day;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string formatDate(const std::string &inputDate)\n{\n    std::unordered_map<std::string, std::string> monthMapping= {\n        {\"Jan\", \"01\"},\n        {\"Feb\", \"02\"},\n        {\"Mar\", \"03\"},\n        {\"Apr\", \"04\"},\n        {\"May\", \"05\"},\n        {\"Jun\", \"06\"},\n        {\"Jul\", \"07\"},\n        {\"Aug\", \"08\"},\n        {\"Sep\", \"09\"},\n        {\"Oct\", \"10\"},\n        {\"Nov\", \"11\"},\n        {\"Dec\", \"12\"},\n    };\n\n    std::stringstream dateStream(inputDate);\n    std::string day, month, year;\n    dateStream >> day >> month >> year;\n    return year + \"-\" + monthMapping[month] + \"-\" + day;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint sumOfDivisorsWithFourDivisors(const vector<int> &numbers)\n{\n    int totalSum = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        int divisorCount = 0;\n        int divisorSum = 0;\n\n        for (int j = 1; j * j <= currentNumber; ++j)\n        {\n            if (currentNumber % j == 0)\n            {\n                divisorSum += j;\n                ++divisorCount;\n\n                if (currentNumber / j != j)\n                {\n                    divisorSum += (currentNumber / j);\n                    ++divisorCount;\n                }\n            }\n\n            if (divisorCount > 4)\n            {\n                break;\n            }\n        }\n\n        if (divisorCount == 4)\n        {\n            totalSum += divisorSum;\n        }\n    }\n\n    return totalSum;\n}",
    "output": "int sumOfDivisorsWithFourDivisors(const std::vector<int> &numbers)\n{\n    int totalSum= 0;\n    for(int currentNumber : numbers)\n    {\n        int divisorCount= 0;\n        int divisorSum= 0;\n\n        for(int i= 1; i * i <= currentNumber; ++i)\n        {\n            if(currentNumber % i == 0)\n            {\n                divisorSum+= i;\n                ++divisorCount;\n\n                if(currentNumber / i != i)\n                {\n                    divisorSum+= (currentNumber / i);\n                    ++divisorCount;\n                }\n            }\n\n            if(divisorCount > 4)\n            {\n                break;\n            }\n        }\n\n        if(divisorCount == 4)\n        {\n            totalSum+= divisorSum;\n        }\n    }\n\n    return totalSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumSubsequence(vector<int> &numbers, int subsequenceLength)\n{\n    int totalElements= numbers.size();\n    vector<int> dynamicProgramming(totalElements, 0);\n    int maxResult= 0;\n\n    for(int currentIndex= 0; currentIndex < totalElements; ++currentIndex)\n    {\n        dynamicProgramming[currentIndex]= numbers[currentIndex];\n        for(int previousIndex= max(0, currentIndex - subsequenceLength); previousIndex < currentIndex; ++previousIndex)\n        {\n            dynamicProgramming[currentIndex]= max(dynamicProgramming[currentIndex], dynamicProgramming[previousIndex] + numbers[currentIndex]);\n        }\n        maxResult= max(maxResult, dynamicProgramming[currentIndex]);\n    }\n\n    return maxResult;\n}",
    "output": "#include <bits/stdc++.h>\nint maxSumSubsequence(std::vector<int> &numbers, int subsequenceLength)\n{\n    int totalElements= numbers.size();\n    std::vector<int> dynamicProgramming(totalElements, 0);\n    int maxResult= 0;\n\n    for(int currentIndex= 0; currentIndex < totalElements; ++currentIndex)\n    {\n        dynamicProgramming[currentIndex]= numbers[currentIndex];\n        for(int previousIndex= std::max(0, currentIndex - subsequenceLength); previousIndex < currentIndex; ++previousIndex)\n        {\n            dynamicProgramming[currentIndex]= std::max(dynamicProgramming[currentIndex], dynamicProgramming[previousIndex] + numbers[currentIndex]);\n        }\n        maxResult= std::max(maxResult, dynamicProgramming[currentIndex]);\n    }\n\n    return maxResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestDistance(vector<int> &distances, int startIndex, int destinationIndex)\n{\n    int totalDistance= 0, clockwiseDistance= 0;\n\n    for(int i= 0; i < distances.size(); ++i)\n    {\n        totalDistance+= distances[i];\n        if(i >= startIndex && i < destinationIndex)\n        {\n            clockwiseDistance+= distances[i];\n        }\n    }\n\n    return min(clockwiseDistance, totalDistance - clockwiseDistance);\n}",
    "output": "#include <bits/stdc++.h>\nint shortestDistance(std::vector<int> &distances, int startIndex, int destinationIndex)\n{\n    int totalDistance= 0, clockwiseDistance= 0;\n\n    for(int i= 0; i < distances.size(); ++i)\n    {\n        totalDistance+= distances[i];\n        if(i >= startIndex && i < destinationIndex)\n        {\n            clockwiseDistance+= distances[i];\n        }\n    }\n\n    return std::min(clockwiseDistance, totalDistance - clockwiseDistance);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maximumSum(vector<int> &array)\n{\n    int arraySize = array.size();\n    vector<int> sumWithoutDeletion(arraySize), sumWithDeletion(arraySize);\n    sumWithoutDeletion[0] = array[0];\n    sumWithDeletion[0] = 0;\n    int maxSum = array[0];\n\n    for (int index = 1; index < arraySize; index++)\n    {\n        sumWithoutDeletion[index] = max(array[index], sumWithoutDeletion[index - 1] + array[index]);\n        sumWithDeletion[index] = max(sumWithDeletion[index - 1] + array[index], sumWithoutDeletion[index - 1]);\n        maxSum = max(maxSum, max(sumWithoutDeletion[index], sumWithDeletion[index]));\n    }\n    return maxSum;\n}",
    "output": "#include <bits/stdc++.h>\nint maximumSum(std::vector<int> &array)\n{\n    int arraySize= array.size();\n    std::vector<int> sumWithoutDeletion(arraySize), sumWithDeletion(arraySize);\n    sumWithoutDeletion[0]= array[0];\n    sumWithDeletion[0]= 0;\n    int maxSum= array[0];\n\n    for(int index= 1; index < arraySize; index++)\n    {\n        sumWithoutDeletion[index]= std::max(array[index], sumWithoutDeletion[index - 1] + array[index]);\n        sumWithDeletion[index]= std::max(sumWithDeletion[index - 1] + array[index], sumWithoutDeletion[index - 1]);\n        maxSum= std::max(maxSum, std::max(sumWithoutDeletion[index], sumWithDeletion[index]));\n    }\n    return maxSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring getDayOfTheWeek(int day, int month, int year)\n{\n    array<string, 7> weekDays= {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n    if(month < 3)\n    {\n        month+= 12;\n        year-= 1;\n    }\n    int yearOfCentury= year % 100;\n    int century= year / 100;\n    int dayOfWeek= (day + 13 * (month + 1) / 5 + yearOfCentury + yearOfCentury / 4 + 5 * century + century / 4) % 7;\n    return weekDays[dayOfWeek];\n}",
    "output": "#include <bits/stdc++.h>\nstd::string getDayOfTheWeek(int day, int month, int year)\n{\n    std::array<std::string, 7> weekDays= {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n    if(month < 3)\n    {\n        month+= 12;\n        year-= 1;\n    }\n    int yearOfCentury= year % 100;\n    int century= year / 100;\n    int dayOfWeek= (day + 13 * (month + 1) / 5 + yearOfCentury + yearOfCentury / 4 + 5 * century + century / 4) % 7;\n    return weekDays[dayOfWeek];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &sourceArray, vector<int> &targetArray)\n{\n    int arraySize = sourceArray.size();\n    vector<int> operationsCount(arraySize, numeric_limits<int>::max());\n    for (int i = 0; i < targetArray.size(); ++i)\n    {\n        int targetElement = targetArray[i];\n        vector<int> newOperationsCount(arraySize, numeric_limits<int>::max());\n        int previousValue = 0;\n        for (int index = 0; index < arraySize; ++index)\n        {\n            if (targetElement < sourceArray[index])\n                newOperationsCount[index] = previousValue;\n            if (index > 0 && operationsCount[index - 1] < previousValue)\n                previousValue = operationsCount[index - 1];\n            if (index + 1 < arraySize && sourceArray[index] > sourceArray[index + 1])\n                return -1;\n        }\n        operationsCount.swap(newOperationsCount);\n    }\n    return operationsCount.back();\n}",
    "output": "#include <bits/stdc++.h>\nint minOperations(std::vector<int> &sourceArray, std::vector<int> &targetArray)\n{\n    int arraySize= sourceArray.size();\n    std::vector<int> operationsCount(arraySize, std::numeric_limits<int>::max());\n    for(int targetElement : targetArray)\n    {\n        std::vector<int> newOperationsCount(arraySize, std::numeric_limits<int>::max());\n        int previousValue= 0;\n        for(int index= 0; index < arraySize; ++index)\n        {\n            if(targetElement < sourceArray[index])\n                newOperationsCount[index]= previousValue;\n            if(index > 0 && operationsCount[index - 1] < previousValue)\n                previousValue= operationsCount[index - 1];\n            if(index + 1 < arraySize && sourceArray[index] > sourceArray[index + 1])\n                return -1;\n        }\n        operationsCount.swap(newOperationsCount);\n    }\n    return operationsCount.back();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> generateSequentialDigits(int lowerBound, int upperBound)\n{\n    vector<int> sequentialNumbers;\n    for(int startingDigit= 1; startingDigit <= 9; ++startingDigit)\n    {\n        int currentNumber= startingDigit;\n        for(int nextDigit= startingDigit + 1; nextDigit <= 9; ++nextDigit)\n        {\n            currentNumber= currentNumber * 10 + nextDigit;\n            if(currentNumber >= lowerBound && currentNumber <= upperBound)\n            {\n                sequentialNumbers.push_back(currentNumber);\n            }\n        }\n    }\n    sort(sequentialNumbers.begin(), sequentialNumbers.end());\n    return sequentialNumbers;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> generateSequentialDigits(int lowerBound, int upperBound)\n{\n    std::vector<int> sequentialNumbers;\n    for(int startingDigit= 1; startingDigit <= 9; ++startingDigit)\n    {\n        int currentNumber= startingDigit;\n        for(int nextDigit= startingDigit + 1; nextDigit <= 9; ++nextDigit)\n        {\n            currentNumber= currentNumber * 10 + nextDigit;\n            if(currentNumber >= lowerBound && currentNumber <= upperBound)\n            {\n                sequentialNumbers.push_back(currentNumber);\n            }\n        }\n    }\n    std::sort(sequentialNumbers.begin(), sequentialNumbers.end());\n    return sequentialNumbers;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSideLength(vector<vector<int>> &matrix, int threshold)\n{\n    int rows= matrix.size(), columns= matrix[0].size();\n    vector<vector<int>> prefixSum(rows + 1, vector<int>(columns + 1));\n    for(int row= 1; row <= rows; ++row)\n    {\n        for(int col= 1; col <= columns; ++col)\n        {\n            prefixSum[row][col]= matrix[row - 1][col - 1] + prefixSum[row - 1][col] + prefixSum[row][col - 1] - prefixSum[row - 1][col - 1];\n        }\n    }\n\n    int maxSide= 0;\n    for(int row= 1; row <= rows; ++row)\n    {\n        for(int col= 1; col <= columns; ++col)\n        {\n            for(int size= 1; size <= min(rows, columns); ++size)\n            {\n                int endX= row + size - 1, endY= col + size - 1;\n                if(endX <= rows && endY <= columns)\n                {\n                    int currentSum= prefixSum[endX][endY] - prefixSum[endX][col - 1] - prefixSum[row - 1][endY] + prefixSum[row - 1][col - 1];\n                    if(currentSum <= threshold)\n                    {\n                        maxSide= max(maxSide, size);\n                    }\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n    }\n    return maxSide;\n}",
    "output": "#include <bits/stdc++.h>\nint maxSideLength(std::vector<std::vector<int>> &matrix, int threshold)\n{\n    int rows= matrix.size(), columns= matrix[0].size();\n    std::vector<std::vector<int>> prefixSum(rows + 1, std::vector<int>(columns + 1));\n    for(int row= 1; row <= rows; ++row)\n    {\n        for(int col= 1; col <= columns; ++col)\n        {\n            prefixSum[row][col]= matrix[row - 1][col - 1] + prefixSum[row - 1][col] + prefixSum[row][col - 1] - prefixSum[row - 1][col - 1];\n        }\n    }\n\n    int maxSide= 0;\n    for(int row= 1; row <= rows; ++row)\n    {\n        for(int col= 1; col <= columns; ++col)\n        {\n            for(int size= 1; size <= std::min(rows, columns); ++size)\n            {\n                int endX= row + size - 1, endY= col + size - 1;\n                if(endX <= rows && endY <= columns)\n                {\n                    int currentSum= prefixSum[endX][endY] - prefixSum[endX][col - 1] - prefixSum[row - 1][endY] + prefixSum[row - 1][col - 1];\n                    if(currentSum <= threshold)\n                    {\n                        maxSide= std::max(maxSide, size);\n                    }\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n    }\n    return maxSide;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(vector<vector<int>> &grid, int maxK)\n{\n    int rows = grid.size();\n    int columns = grid[0].size();\n    vector<vector<vector<int>>> visited(rows, vector<vector<int>>(columns, vector<int>(maxK + 1, 0)));\n    queue<tuple<int, int, int, int>> queue;\n    int stepCount = 0;\n    int directionMoves[][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    queue.push({0, 0, 0, maxK});\n\n    while (!queue.empty())\n    {\n        int queueSize = queue.size();\n        for (int i = 0; i < queueSize; ++i)\n        {\n            int currentX, currentY, currentSteps, kRemaining;\n            tie(currentX, currentY, currentSteps, kRemaining) = queue.front();\n            queue.pop();\n            if (currentX == rows - 1 && currentY == columns - 1)\n                return currentSteps;\n\n            for (int j = 0; j < 4; ++j) // Traditional for loop instead of range-based for loop\n            {\n                int newX = currentX + directionMoves[j][0];\n                int newY = currentY + directionMoves[j][1];\n                if (newX >= 0 && newX < rows && newY >= 0 && newY < columns)\n                {\n                    int newKRemaining = kRemaining - grid[newX][newY];\n                    if (newKRemaining >= 0 && !visited[newX][newY][newKRemaining])\n                    {\n                        visited[newX][newY][newKRemaining] = 1;\n                        queue.push({newX, newY, currentSteps + 1, newKRemaining});\n                    }\n                }\n            }\n        }\n    }\n\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint shortestPath(std::vector<std::vector<int>> &grid, int maxK)\n{\n    int rows= grid.size();\n    int columns= grid[0].size();\n    std::vector<std::vector<std::vector<int>>> visited(rows, std::vector<std::vector<int>>(columns, std::vector<int>(maxK + 1, 0)));\n    std::queue<std::tuple<int, int, int, int>> queue;\n    int stepCount= 0;\n    int directionMoves[][2]= {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    queue.push({0, 0, 0, maxK});\n\n    while(!queue.empty())\n    {\n        int queueSize= queue.size();\n        for(int i= 0; i < queueSize; ++i)\n        {\n            int currentX, currentY, currentSteps, kRemaining;\n            std::tie(currentX, currentY, currentSteps, kRemaining)= queue.front();\n            queue.pop();\n            if(currentX == rows - 1 && currentY == columns - 1)\n                return currentSteps;\n\n            for(const auto &move : directionMoves)\n            {\n                int newX= currentX + move[0];\n                int newY= currentY + move[1];\n                if(newX >= 0 && newX < rows && newY >= 0 && newY < columns)\n                {\n                    int newKRemaining= kRemaining - grid[newX][newY];\n                    if(newKRemaining >= 0 && !visited[newX][newY][newKRemaining])\n                    {\n                        visited[newX][newY][newKRemaining]= 1;\n                        queue.push({newX, newY, currentSteps + 1, newKRemaining});\n                    }\n                }\n            }\n        }\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int minPerimeter(int requiredApples)\n{\n    int layer= 0;\n    int totalApples= 0;\n\n    while(totalApples < requiredApples)\n    {\n        layer++;\n        totalApples+= 12 * layer;\n    }\n\n    return 8 * layer;\n}",
    "output": "int minPerimeter(int requiredApples)\n{\n    int layer= 0;\n    int totalApples= 0;\n\n    while(totalApples < requiredApples)\n    {\n        layer++;\n        totalApples+= 12 * layer;\n    }\n\n    return 8 * layer;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TreeAncestor\n{\n  public:\n    vector<vector<int>> ancestorMatrix;\n\n    TreeAncestor(int nodeCount, vector<int> &parentArray)\n    {\n        ancestorMatrix.resize(nodeCount, vector<int>(20));\n        for(int index= 0; index < nodeCount; index++)\n            ancestorMatrix[index][0]= parentArray[index];\n        for(int power= 1; power < 20; power++)\n            for(int index= 0; index < nodeCount; index++)\n                ancestorMatrix[index][power]= ancestorMatrix[index][power - 1] == -1 ? -1 : ancestorMatrix[ancestorMatrix[index][power - 1]][power - 1];\n    }\n\n    int getKthAncestor(int currentNode, int k)\n    {\n        for(int i= 0; i < 20; i++)\n        {\n            if(k & (1 << i))\n            {\n                currentNode= ancestorMatrix[currentNode][i];\n                if(currentNode == -1)\n                    return -1;\n            }\n        }\n        return currentNode;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass TreeAncestor\n{\n  public:\n    std::vector<std::vector<int>> ancestorMatrix;\n\n    TreeAncestor(int nodeCount, std::vector<int> &parentArray)\n    {\n        ancestorMatrix.resize(nodeCount, std::vector<int>(20));\n        for(int index= 0; index < nodeCount; index++)\n            ancestorMatrix[index][0]= parentArray[index];\n        for(int power= 1; power < 20; power++)\n            for(int index= 0; index < nodeCount; index++)\n                ancestorMatrix[index][power]= ancestorMatrix[index][power - 1] == -1 ? -1 : ancestorMatrix[ancestorMatrix[index][power - 1]][power - 1];\n    }\n\n    int getKthAncestor(int currentNode, int k)\n    {\n        for(int i= 0; i < 20; i++)\n        {\n            if(k & (1 << i))\n            {\n                currentNode= ancestorMatrix[currentNode][i];\n                if(currentNode == -1)\n                    return -1;\n            }\n        }\n        return currentNode;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfBalloons(string text)\n{\n    int letterFrequency[26] = {0};\n    for (int i = 0; i < text.size(); ++i)\n    {\n        char character = text[i];\n        letterFrequency[character - 'a']++;\n    }\n    int balloonsCount[5] = {letterFrequency['b' - 'a'], letterFrequency['a' - 'a'], letterFrequency['l' - 'a'] / 2, letterFrequency['o' - 'a'] / 2, letterFrequency['n' - 'a']};\n    return *min_element(balloonsCount, balloonsCount + 5);\n}",
    "output": "#include <bits/stdc++.h>\nint maxNumberOfBalloons(std::string text)\n{\n    int letterFrequency[26]= {0};\n    for(char character : text)\n    {\n        letterFrequency[character - 'a']++;\n    }\n    int balloonsCount[5]= {letterFrequency['b' - 'a'], letterFrequency['a' - 'a'], letterFrequency['l' - 'a'] / 2, letterFrequency['o' - 'a'] / 2, letterFrequency['n' - 'a']};\n    return *std::min_element(balloonsCount, balloonsCount + 5);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring reverseParentheses(string inputString)\n{\n    stack<char> characterStack;\n    string reversedString = \"\";\n\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentChar = inputString[i];\n        if (currentChar != ')')\n        {\n            characterStack.push(currentChar);\n        }\n        else\n        {\n            string temporaryString = \"\";\n            while (!characterStack.empty() && characterStack.top() != '(')\n            {\n                temporaryString += characterStack.top();\n                characterStack.pop();\n            }\n            if (!characterStack.empty())\n                characterStack.pop(); // Remove '('\n            for (int j = 0; j < temporaryString.size(); ++j)\n            {\n                char tempChar = temporaryString[j];\n                characterStack.push(tempChar);\n            }\n        }\n    }\n\n    while (!characterStack.empty())\n    {\n        reversedString = characterStack.top() + reversedString;\n        characterStack.pop();\n    }\n\n    return reversedString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string reverseParentheses(std::string inputString)\n{\n    std::stack<char> characterStack;\n    std::string reversedString= \"\";\n\n    for(char currentChar : inputString)\n    {\n        if(currentChar != ')')\n        {\n            characterStack.push(currentChar);\n        }\n        else\n        {\n            std::string temporaryString= \"\";\n            while(!characterStack.empty() && characterStack.top() != '(')\n            {\n                temporaryString+= characterStack.top();\n                characterStack.pop();\n            }\n            if(!characterStack.empty())\n                characterStack.pop(); // Remove '('\n            for(char tempChar : temporaryString)\n            {\n                characterStack.push(tempChar);\n            }\n        }\n    }\n\n    while(!characterStack.empty())\n    {\n        reversedString= characterStack.top() + reversedString;\n        characterStack.pop();\n    }\n\n    return reversedString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint kConcatenationMaxSum(vector<int> &array, int concatenationCount)\n{\n    int modulus= 1e9 + 7;\n    long long totalSum= 0, maximumSum= 0, currentMax= 0;\n    for(int index= 0; index < array.size(); index++)\n    {\n        totalSum+= array[index];\n        currentMax= max(array[index], currentMax + array[index]);\n        maximumSum= max(maximumSum, currentMax);\n    }\n    if(concatenationCount == 1)\n        return maximumSum % modulus;\n    long long doubleConcatenation= 0, doubleConcatenationMax= 0;\n    for(int index= 0; index < 2 * array.size(); index++)\n    {\n        doubleConcatenation= max((long long)array[index % array.size()], doubleConcatenation + array[index % array.size()]);\n        doubleConcatenationMax= max(doubleConcatenationMax, doubleConcatenation);\n    }\n    return max({maximumSum, doubleConcatenationMax + (concatenationCount - 2) * max(0LL, totalSum)}) % modulus;\n}",
    "output": "#include <bits/stdc++.h>\nint kConcatenationMaxSum(std::vector<int> &array, int concatenationCount)\n{\n    int modulus= 1e9 + 7;\n    long long totalSum= 0, maximumSum= 0, currentMax= 0;\n    for(int index= 0; index < array.size(); index++)\n    {\n        totalSum+= array[index];\n        currentMax= std::max(array[index], currentMax + array[index]);\n        maximumSum= std::max(maximumSum, currentMax);\n    }\n    if(concatenationCount == 1)\n        return maximumSum % modulus;\n    long long doubleConcatenation= 0, doubleConcatenationMax= 0;\n    for(int index= 0; index < 2 * array.size(); index++)\n    {\n        doubleConcatenation= std::max((long long)array[index % array.size()], doubleConcatenation + array[index % array.size()]);\n        doubleConcatenationMax= std::max(doubleConcatenationMax, doubleConcatenation);\n    }\n    return std::max({maximumSum, doubleConcatenationMax + (concatenationCount - 2) * std::max(0LL, totalSum)}) % modulus;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> findCriticalConnections(int nodeCount, vector<vector<int>> &connections)\n{\n    vector<vector<int>> adjacencyList(nodeCount);\n    for (int i = 0; i < connections.size(); ++i)\n    {\n        const auto &connection = connections[i];\n        adjacencyList[connection[0]].push_back(connection[1]);\n        adjacencyList[connection[1]].push_back(connection[0]);\n    }\n\n    vector<vector<int>> criticalEdges;\n    vector<int> lowLink(nodeCount, -1), discoveryTime(nodeCount, -1);\n    int currentTime = 0;\n\n    function<void(int, int)> depthFirstSearch = [&](int currentNode, int parentNode)\n    {\n        lowLink[currentNode] = discoveryTime[currentNode] = currentTime++;\n        for (int j = 0; j < adjacencyList[currentNode].size(); ++j)\n        {\n            int neighbor = adjacencyList[currentNode][j];\n            if (neighbor == parentNode)\n                continue;\n            if (discoveryTime[neighbor] == -1)\n            {\n                depthFirstSearch(neighbor, currentNode);\n                lowLink[currentNode] = min(lowLink[currentNode], lowLink[neighbor]);\n                if (lowLink[neighbor] > discoveryTime[currentNode])\n                    criticalEdges.push_back({currentNode, neighbor});\n            }\n            else\n            {\n                lowLink[currentNode] = min(lowLink[currentNode], discoveryTime[neighbor]);\n            }\n        }\n    };\n\n    depthFirstSearch(0, -1);\n    return criticalEdges;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> findCriticalConnections(int nodeCount, std::vector<std::vector<int>> &connections)\n{\n    std::vector<std::vector<int>> adjacencyList(nodeCount);\n    for(const auto &connection : connections)\n    {\n        adjacencyList[connection[0]].push_back(connection[1]);\n        adjacencyList[connection[1]].push_back(connection[0]);\n    }\n\n    std::vector<std::vector<int>> criticalEdges;\n    std::vector<int> lowLink(nodeCount, -1), discoveryTime(nodeCount, -1);\n    int currentTime = 0;\n\n    std::function<void(int, int)> depthFirstSearch = [&](int currentNode, int parentNode)\n    {\n        lowLink[currentNode] = discoveryTime[currentNode] = currentTime++;\n        for(int neighbor : adjacencyList[currentNode])\n        {\n            if(neighbor == parentNode)\n                continue;\n            if(discoveryTime[neighbor] == -1)\n            {\n                depthFirstSearch(neighbor, currentNode);\n                lowLink[currentNode] = std::min(lowLink[currentNode], lowLink[neighbor]);\n                if(lowLink[neighbor] > discoveryTime[currentNode])\n                    criticalEdges.push_back({currentNode, neighbor});\n            }\n            else\n            {\n                lowLink[currentNode] = std::min(lowLink[currentNode], discoveryTime[neighbor]);\n            }\n        }\n    };\n\n    depthFirstSearch(0, -1);\n    return criticalEdges;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\n\nvector<int> pathsWithMaxScore(vector<string> &gameBoard)\n{\n    int boardSize = gameBoard.size();\n    vector<vector<int>> maxScoreDP(boardSize, vector<int>(boardSize, 0)), pathCount(boardSize, vector<int>(boardSize, 0));\n\n    gameBoard[0][0] = '0';\n    gameBoard[boardSize - 1][boardSize - 1] = '0';\n    pathCount[boardSize - 1][boardSize - 1] = 1;\n\n    for (int row = boardSize - 1; row >= 0; row--)\n    {\n        for (int col = boardSize - 1; col >= 0; col--)\n        {\n            if (gameBoard[row][col] != 'X')\n            {\n                vector<pair<int, int>> neighbors = {{row - 1, col}, {row, col - 1}, {row - 1, col - 1}};\n                for (int i = 0; i < neighbors.size(); i++)\n                {\n                    int neighborRow = neighbors[i].first, neighborCol = neighbors[i].second;\n                    if (neighborRow >= 0 && neighborCol >= 0)\n                    {\n                        if (maxScoreDP[row][col] < maxScoreDP[neighborRow][neighborCol] + gameBoard[row][col] - '0')\n                        {\n                            maxScoreDP[row][col] = maxScoreDP[neighborRow][neighborCol] + gameBoard[row][col] - '0';\n                            pathCount[row][col] = pathCount[neighborRow][neighborCol];\n                        }\n                        else if (maxScoreDP[row][col] == maxScoreDP[neighborRow][neighborCol] + gameBoard[row][col] - '0')\n                        {\n                            pathCount[row][col] = (pathCount[row][col] + pathCount[neighborRow][neighborCol]) % mod;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return {maxScoreDP[0][0], pathCount[0][0]};\n}",
    "output": "#include <bits/stdc++.h>\nconst int mod= 1000000007;\n\nstd::vector<int> pathsWithMaxScore(std::vector<std::string> &gameBoard)\n{\n    int boardSize= gameBoard.size();\n    std::vector<std::vector<int>> maxScoreDP(boardSize, std::vector<int>(boardSize, 0)), pathCount(boardSize, std::vector<int>(boardSize, 0));\n\n    gameBoard[0][0]= '0';\n    gameBoard[boardSize - 1][boardSize - 1]= '0';\n    pathCount[boardSize - 1][boardSize - 1]= 1;\n\n    for(int row= boardSize - 1; row >= 0; row--)\n    {\n        for(int col= boardSize - 1; col >= 0; col--)\n        {\n            if(gameBoard[row][col] != 'X')\n            {\n                std::vector<std::pair<int, int>> neighbors= {{row - 1, col}, {row, col - 1}, {row - 1, col - 1}};\n                for(auto neighbor : neighbors)\n                {\n                    int neighborRow= neighbor.first, neighborCol= neighbor.second;\n                    if(neighborRow >= 0 && neighborCol >= 0)\n                    {\n                        if(maxScoreDP[row][col] < maxScoreDP[neighborRow][neighborCol] + gameBoard[row][col] - '0')\n                        {\n                            maxScoreDP[row][col]= maxScoreDP[neighborRow][neighborCol] + gameBoard[row][col] - '0';\n                            pathCount[row][col]= pathCount[neighborRow][neighborCol];\n                        }\n                        else if(maxScoreDP[row][col] == maxScoreDP[neighborRow][neighborCol] + gameBoard[row][col] - '0')\n                        {\n                            pathCount[row][col]= (pathCount[row][col] + pathCount[neighborRow][neighborCol]) % mod;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return {maxScoreDP[0][0], pathCount[0][0]};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring makeFancyString(const string &inputString)\n{\n    string fancyString;\n    int consecutiveCount = 1;\n\n    for(size_t index = 1; index < inputString.size(); ++index)\n    {\n        if(inputString[index] == inputString[index - 1])\n        {\n            ++consecutiveCount;\n        }\n        else\n        {\n            consecutiveCount = 1;\n        }\n        if(consecutiveCount < 3)\n        {\n            fancyString += inputString[index];\n        }\n    }\n\n    return fancyString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string makeFancyString(const std::string &inputString)\n{\n    std::string fancyString;\n    int consecutiveCount= 1;\n\n    for(size_t index= 1; index < inputString.size(); ++index)\n    {\n        if(inputString[index] == inputString[index - 1])\n        {\n            ++consecutiveCount;\n        }\n        else\n        {\n            consecutiveCount= 1;\n        }\n        if(consecutiveCount < 3)\n        {\n            fancyString+= inputString[index];\n        }\n    }\n\n    return fancyString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring longestHappyString(int countA, int countB, int countC)\n{\n    string result;\n    using charCountPair = pair<int, char>;\n    priority_queue<charCountPair> priorityQueue;\n\n    if (countA)\n        priorityQueue.push({countA, 'a'});\n    if (countB)\n        priorityQueue.push({countB, 'b'});\n    if (countC)\n        priorityQueue.push({countC, 'c'});\n\n    while (!priorityQueue.empty())\n    {\n        auto currentCharCount = priorityQueue.top();\n        priorityQueue.pop();\n        if (result.size() >= 2 && result[result.size() - 1] == currentCharCount.second && result[result.size() - 2] == currentCharCount.second)\n        {\n            if (priorityQueue.empty())\n                break;\n            auto nextCharCount = priorityQueue.top();\n            priorityQueue.pop();\n            result += nextCharCount.second;\n            if (--nextCharCount.first > 0)\n                priorityQueue.push(nextCharCount);\n            priorityQueue.push(currentCharCount);\n        }\n        else\n        {\n            result += currentCharCount.second;\n            if (--currentCharCount.first > 0)\n                priorityQueue.push(currentCharCount);\n        }\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string longestHappyString(int countA, int countB, int countC)\n{\n    std::string result;\n    using charCountPair= std::pair<int, char>;\n    std::priority_queue<charCountPair> priorityQueue;\n\n    if(countA)\n        priorityQueue.push({countA, 'a'});\n    if(countB)\n        priorityQueue.push({countB, 'b'});\n    if(countC)\n        priorityQueue.push({countC, 'c'});\n\n    while(!priorityQueue.empty())\n    {\n        auto currentCharCount= priorityQueue.top();\n        priorityQueue.pop();\n        if(result.size() >= 2 && result[result.size() - 1] == currentCharCount.second && result[result.size() - 2] == currentCharCount.second)\n        {\n            if(priorityQueue.empty())\n                break;\n            auto nextCharCount= priorityQueue.top();\n            priorityQueue.pop();\n            result+= nextCharCount.second;\n            if(--nextCharCount.first > 0)\n                priorityQueue.push(nextCharCount);\n            priorityQueue.push(currentCharCount);\n        }\n        else\n        {\n            result+= currentCharCount.second;\n            if(--currentCharCount.first > 0)\n                priorityQueue.push(currentCharCount);\n        }\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> peopleCanSee(vector<int> &heights)\n{\n    int totalPeople = heights.size();\n    vector<int> visibleCount(totalPeople, 0);\n    stack<int> indexStack;\n\n    for(int currentIndex = totalPeople - 1; currentIndex >= 0; --currentIndex)\n    {\n        while(!indexStack.empty() && heights[indexStack.top()] < heights[currentIndex])\n        {\n            int topIndex = indexStack.top();\n            indexStack.pop();\n            visibleCount[currentIndex]++;\n            visibleCount[currentIndex] += visibleCount[topIndex];\n        }\n        indexStack.push(currentIndex);\n    }\n\n    return visibleCount;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> peopleCanSee(std::vector<int> &heights)\n{\n    int totalPeople= heights.size();\n    std::vector<int> visibleCount(totalPeople, 0);\n    std::stack<int> indexStack;\n\n    for(int currentIndex= totalPeople - 1; currentIndex >= 0; --currentIndex)\n    {\n        while(!indexStack.empty() && heights[indexStack.top()] < heights[currentIndex])\n        {\n            int topIndex= indexStack.top();\n            indexStack.pop();\n            visibleCount[currentIndex]++;\n            visibleCount[currentIndex]+= visibleCount[topIndex];\n        }\n        indexStack.push(currentIndex);\n    }\n\n    return visibleCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> minimumAbsDifference(vector<int> &sortedArray)\n{\n    sort(sortedArray.begin(), sortedArray.end());\n    int minimumDifference= INT_MAX;\n    vector<vector<int>> pairsWithMinimumDifference;\n\n    for(int index= 1; index < sortedArray.size(); ++index)\n    {\n        int currentDifference= sortedArray[index] - sortedArray[index - 1];\n        if(currentDifference < minimumDifference)\n        {\n            minimumDifference= currentDifference;\n            pairsWithMinimumDifference.clear();\n            pairsWithMinimumDifference.push_back({sortedArray[index - 1], sortedArray[index]});\n        }\n        else if(currentDifference == minimumDifference)\n        {\n            pairsWithMinimumDifference.push_back({sortedArray[index - 1], sortedArray[index]});\n        }\n    }\n\n    return pairsWithMinimumDifference;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> minimumAbsDifference(std::vector<int> &sortedArray)\n{\n    std::sort(sortedArray.begin(), sortedArray.end());\n    int minimumDifference = INT_MAX;\n    std::vector<std::vector<int>> pairsWithMinimumDifference;\n\n    for(int index = 1; index < sortedArray.size(); ++index)\n    {\n        int currentDifference = sortedArray[index] - sortedArray[index - 1];\n        if(currentDifference < minimumDifference)\n        {\n            minimumDifference = currentDifference;\n            pairsWithMinimumDifference.clear();\n            pairsWithMinimumDifference.push_back({sortedArray[index - 1], sortedArray[index]});\n        }\n        else if(currentDifference == minimumDifference)\n        {\n            pairsWithMinimumDifference.push_back({sortedArray[index - 1], sortedArray[index]});\n        }\n    }\n\n    return pairsWithMinimumDifference;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint nthUglyNumber(int n, int factorA, int factorB, int factorC)\n{\n    long long firstFactor= factorA, secondFactor= factorB, thirdFactor= factorC;\n    long long abLeastCommonMultiple= firstFactor * secondFactor / gcd(firstFactor, secondFactor);\n    long long acLeastCommonMultiple= firstFactor * thirdFactor / gcd(firstFactor, thirdFactor);\n    long long bcLeastCommonMultiple= secondFactor * thirdFactor / gcd(secondFactor, thirdFactor);\n    long long abcLeastCommonMultiple= firstFactor * bcLeastCommonMultiple / gcd(firstFactor, bcLeastCommonMultiple);\n\n    long long leftBoundary= 0, rightBoundary= 2e9;\n    while(leftBoundary < rightBoundary)\n    {\n        long long midPoint= leftBoundary + (rightBoundary - leftBoundary) / 2;\n        long long count= midPoint / firstFactor + midPoint / secondFactor + midPoint / thirdFactor - midPoint / abLeastCommonMultiple - midPoint / acLeastCommonMultiple - midPoint / bcLeastCommonMultiple + midPoint / abcLeastCommonMultiple;\n        if(count < n)\n        {\n            leftBoundary= midPoint + 1;\n        }\n        else\n        {\n            rightBoundary= midPoint;\n        }\n    }\n    return leftBoundary;\n}",
    "output": "#include <bits/stdc++.h>\nint nthUglyNumber(int n, int factorA, int factorB, int factorC)\n{\n    long long firstFactor= factorA, secondFactor= factorB, thirdFactor= factorC;\n    long long abLeastCommonMultiple= firstFactor * secondFactor / std::__gcd(firstFactor, secondFactor);\n    long long acLeastCommonMultiple= firstFactor * thirdFactor / std::__gcd(firstFactor, thirdFactor);\n    long long bcLeastCommonMultiple= secondFactor * thirdFactor / std::__gcd(secondFactor, thirdFactor);\n    long long abcLeastCommonMultiple= firstFactor * bcLeastCommonMultiple / std::__gcd(firstFactor, bcLeastCommonMultiple);\n\n    long long leftBoundary= 0, rightBoundary= 2e9;\n    while(leftBoundary < rightBoundary)\n    {\n        long long midPoint= leftBoundary + (rightBoundary - leftBoundary) / 2;\n        long long count= midPoint / firstFactor + midPoint / secondFactor + midPoint / thirdFactor - midPoint / abLeastCommonMultiple - midPoint / acLeastCommonMultiple - midPoint / bcLeastCommonMultiple + midPoint / abcLeastCommonMultiple;\n        if(count < n)\n        {\n            leftBoundary= midPoint + 1;\n        }\n        else\n        {\n            rightBoundary= midPoint;\n        }\n    }\n    return leftBoundary;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> sortItems(int itemCount, int groupCount, vector<int> &groupAssignments, vector<vector<int>> &dependencies)\n{\n    // Calculate outdegrees and dependencies for groups and items\n    vector<int> groupOutdegree(groupCount, 0);\n    vector<vector<int>> groupEdges(groupCount);\n    vector<int> itemOutdegree(itemCount, 0);\n    vector<vector<int>> itemEdges(itemCount);\n\n    for(int index = 0; index < groupAssignments.size(); ++index)\n    {\n        for(int dependencyIndex = 0; dependencyIndex < dependencies[index].size(); ++dependencyIndex)\n        {\n            int dependency = dependencies[index][dependencyIndex];\n            int currentGroup = groupAssignments[index], dependencyGroup = groupAssignments[dependency];\n            if(currentGroup != -1 && currentGroup != dependencyGroup && !groupEdges[dependencyGroup].empty() && groupEdges[dependencyGroup].back() == currentGroup)\n            {\n                groupEdges[dependencyGroup].push_back(currentGroup);\n                ++groupOutdegree[currentGroup];\n            }\n            if(currentGroup != dependencyGroup)\n            {\n                itemEdges[dependency].push_back(index);\n                ++itemOutdegree[index];\n            }\n        }\n    }\n\n    // Topological sort\n    auto topologicalSort = [](const vector<int> &outdegree, const vector<vector<int>> &edges)\n    {\n        vector<int> sortedList, queue;\n        for(int index = 0; index < outdegree.size(); ++index)\n            if(outdegree[index] == 0)\n                queue.push_back(index);\n\n        while(!queue.empty())\n        {\n            int currentNode = queue.back();\n            queue.pop_back();\n            sortedList.push_back(currentNode);\n\n            for(int neighborIndex = 0; neighborIndex < edges[currentNode].size(); ++neighborIndex)\n            {\n                int neighbor = edges[currentNode][neighborIndex];\n                if(--const_cast<int &>(outdegree[neighbor]) == 0)\n                    queue.push_back(neighbor);\n            }\n        }\n        return sortedList;\n    };\n\n    vector<int> groupOrder = topologicalSort(groupOutdegree, groupEdges);\n    if(groupOrder.size() < groupCount)\n        return {};\n\n    vector<int> itemOrder = topologicalSort(itemOutdegree, itemEdges);\n    if(itemOrder.size() < itemCount)\n        return {};\n\n    // Combine orders\n    vector<int> result;\n    for(int groupIndex = 0; groupIndex < groupOrder.size(); ++groupIndex)\n    {\n        for(int itemIndex = 0; itemIndex < itemOrder.size(); ++itemIndex)\n        {\n            if(groupAssignments[itemOrder[itemIndex]] == groupOrder[groupIndex])\n                result.push_back(itemOrder[itemIndex]);\n        }\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> sortItems(int itemCount, int groupCount, std::vector<int> &groupAssignments, std::vector<std::vector<int>> &dependencies)\n{\n    // Calculate outdegrees and dependencies for groups and items\n    std::vector<int> groupOutdegree(groupCount, 0);\n    std::vector<std::vector<int>> groupEdges(groupCount);\n    std::vector<int> itemOutdegree(itemCount, 0);\n    std::vector<std::vector<int>> itemEdges(itemCount);\n\n    for(int index= 0; index < groupAssignments.size(); ++index)\n    {\n        for(const int dependency : dependencies[index])\n        {\n            int currentGroup= groupAssignments[index], dependencyGroup= groupAssignments[dependency];\n            if(currentGroup != -1 && currentGroup != dependencyGroup && !groupEdges[dependencyGroup].empty() && groupEdges[dependencyGroup].back() == currentGroup)\n            {\n                groupEdges[dependencyGroup].push_back(currentGroup);\n                ++groupOutdegree[currentGroup];\n            }\n            if(currentGroup != dependencyGroup)\n            {\n                itemEdges[dependency].push_back(index);\n                ++itemOutdegree[index];\n            }\n        }\n    }\n\n    // Topological sort\n    auto topologicalSort= [](const std::vector<int> &outdegree, const std::vector<std::vector<int>> &edges)\n    {\n        std::vector<int> sortedList, queue;\n        for(int index= 0; index < outdegree.size(); ++index)\n            if(outdegree[index] == 0)\n                queue.push_back(index);\n\n        while(!queue.empty())\n        {\n            int currentNode= queue.back();\n            queue.pop_back();\n            sortedList.push_back(currentNode);\n\n            for(const int neighbor : edges[currentNode])\n                if(--const_cast<int &>(outdegree[neighbor]) == 0)\n                    queue.push_back(neighbor);\n        }\n        return sortedList;\n    };\n\n    std::vector<int> groupOrder= topologicalSort(groupOutdegree, groupEdges);\n    if(groupOrder.size() < groupCount)\n        return {};\n\n    std::vector<int> itemOrder= topologicalSort(itemOutdegree, itemEdges);\n    if(itemOrder.size() < itemCount)\n        return {};\n\n    // Combine orders\n    std::vector<int> result;\n    for(const int groupIndex : groupOrder)\n        for(const int itemIndex : itemOrder)\n            if(groupAssignments[itemIndex] == groupIndex)\n                result.push_back(itemIndex);\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint waterPlants(vector<int> &plantWaterNeeds, int wateringCanCapacity)\n{\n    int totalSteps= 0;\n    int waterLeft= 0;\n    for(int plantIndex= 0; plantIndex < plantWaterNeeds.size(); ++plantIndex)\n    {\n        if(waterLeft < plantWaterNeeds[plantIndex])\n        {\n            totalSteps+= 2 * plantIndex + 1; // Refill the watering can\n            waterLeft= wateringCanCapacity;\n        }\n        waterLeft-= plantWaterNeeds[plantIndex];\n        totalSteps++; // Move to the next plant\n    }\n    return totalSteps;\n}",
    "output": "#include <bits/stdc++.h>\nint waterPlants(std::vector<int> &plantWaterNeeds, int wateringCanCapacity)\n{\n    int totalSteps= 0;\n    int waterLeft= 0;\n    for(int plantIndex= 0; plantIndex < plantWaterNeeds.size(); ++plantIndex)\n    {\n        if(waterLeft < plantWaterNeeds[plantIndex])\n        {\n            totalSteps+= 2 * plantIndex + 1; // Refill the watering can\n            waterLeft= wateringCanCapacity;\n        }\n        waterLeft-= plantWaterNeeds[plantIndex];\n        totalSteps++; // Move to the next plant\n    }\n    return totalSteps;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// for std::min\nusing namespace std;\n\nint findLargestMagicSquare(vector<vector<int>> &grid)\n{\n    int rows= grid.size(), columns= grid[0].size();\n    vector<vector<int>> rowSums(rows, vector<int>(columns + 1, 0));\n    vector<vector<int>> columnSums(rows + 1, vector<int>(columns, 0));\n\n    for(int rowIndex= 0; rowIndex < rows; ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex < columns; ++colIndex)\n        {\n            rowSums[rowIndex][colIndex + 1]= rowSums[rowIndex][colIndex] + grid[rowIndex][colIndex];\n            columnSums[rowIndex + 1][colIndex]= columnSums[rowIndex][colIndex] + grid[rowIndex][colIndex];\n        }\n    }\n\n    for(int squareSize= min(rows, columns); squareSize > 1; --squareSize)\n    {\n        for(int rowIndex= 0; rowIndex + squareSize - 1 < rows; ++rowIndex)\n        {\n            for(int colIndex= 0; colIndex + squareSize - 1 < columns; ++colIndex)\n            {\n                int sum= rowSums[rowIndex][colIndex + squareSize] - rowSums[rowIndex][colIndex];\n                bool isMagicSquare= true;\n                for(int checkIndex= 1; checkIndex < squareSize; ++checkIndex)\n                {\n                    if(rowSums[rowIndex + checkIndex][colIndex + squareSize] - rowSums[rowIndex + checkIndex][colIndex] != sum)\n                    {\n                        isMagicSquare= false;\n                        break;\n                    }\n                    if(columnSums[rowIndex + squareSize][colIndex + checkIndex] - columnSums[rowIndex][colIndex + checkIndex] != sum)\n                    {\n                        isMagicSquare= false;\n                        break;\n                    }\n                }\n                if(!isMagicSquare)\n                    continue;\n\n                int diagonal1Sum= 0, diagonal2Sum= 0;\n                for(int diagonalIndex= 0; diagonalIndex < squareSize; ++diagonalIndex)\n                {\n                    diagonal1Sum+= grid[rowIndex + diagonalIndex][colIndex + diagonalIndex];\n                    diagonal2Sum+= grid[rowIndex + diagonalIndex][colIndex + squareSize - 1 - diagonalIndex];\n                }\n                if(diagonal1Sum == sum && diagonal2Sum == sum)\n                    return squareSize;\n            }\n        }\n    }\n\n    return 1;\n}",
    "output": "#include <bits/stdc++.h>\nint findLargestMagicSquare(std::vector<std::vector<int>> &grid)\n{\n    int rows= grid.size(), columns= grid[0].size();\n    std::vector<std::vector<int>> rowSums(rows, std::vector<int>(columns + 1, 0));\n    std::vector<std::vector<int>> columnSums(rows + 1, std::vector<int>(columns, 0));\n\n    for(int rowIndex= 0; rowIndex < rows; ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex < columns; ++colIndex)\n        {\n            rowSums[rowIndex][colIndex + 1]= rowSums[rowIndex][colIndex] + grid[rowIndex][colIndex];\n            columnSums[rowIndex + 1][colIndex]= columnSums[rowIndex][colIndex] + grid[rowIndex][colIndex];\n        }\n    }\n\n    for(int squareSize= std::min(rows, columns); squareSize > 1; --squareSize)\n    {\n        for(int rowIndex= 0; rowIndex + squareSize - 1 < rows; ++rowIndex)\n        {\n            for(int colIndex= 0; colIndex + squareSize - 1 < columns; ++colIndex)\n            {\n                int sum= rowSums[rowIndex][colIndex + squareSize] - rowSums[rowIndex][colIndex];\n                bool isMagicSquare= true;\n                for(int checkIndex= 1; checkIndex < squareSize; ++checkIndex)\n                {\n                    if(rowSums[rowIndex + checkIndex][colIndex + squareSize] - rowSums[rowIndex + checkIndex][colIndex] != sum)\n                    {\n                        isMagicSquare= false;\n                        break;\n                    }\n                    if(columnSums[rowIndex + squareSize][colIndex + checkIndex] - columnSums[rowIndex][colIndex + checkIndex] != sum)\n                    {\n                        isMagicSquare= false;\n                        break;\n                    }\n                }\n                if(!isMagicSquare)\n                    continue;\n\n                int diagonal1Sum= 0, diagonal2Sum= 0;\n                for(int diagonalIndex= 0; diagonalIndex < squareSize; ++diagonalIndex)\n                {\n                    diagonal1Sum+= grid[rowIndex + diagonalIndex][colIndex + diagonalIndex];\n                    diagonal2Sum+= grid[rowIndex + diagonalIndex][colIndex + squareSize - 1 - diagonalIndex];\n                }\n                if(diagonal1Sum == sum && diagonal2Sum == sum)\n                    return squareSize;\n            }\n        }\n    }\n\n    return 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint extractArtifacts(int gridSize, vector<vector<int>> &artifactRegions, vector<vector<int>> &digSites)\n{\n    unordered_map<int, set<pair<int, int>>> artifactCells;\n    unordered_map<int, int> artifactCounts;\n    \n    for(int regionIndex = 0; regionIndex < artifactRegions.size(); regionIndex++)\n    {\n        for(int row = artifactRegions[regionIndex][0]; row <= artifactRegions[regionIndex][2]; row++)\n        {\n            for(int col = artifactRegions[regionIndex][1]; col <= artifactRegions[regionIndex][3]; col++)\n            {\n                artifactCells[row * gridSize + col].insert({regionIndex, row * gridSize + col});\n                artifactCounts[regionIndex]++;\n            }\n        }\n    }\n\n    int totalArtifactsFound = 0;\n    for(int i = 0; i < digSites.size(); i++)\n    {\n        const auto &digSite = digSites[i];\n        int cellIndex = digSite[0] * gridSize + digSite[1];\n        for(auto it = artifactCells[cellIndex].begin(); it != artifactCells[cellIndex].end();)\n        {\n            artifactCounts[it->first]--;\n            if(artifactCounts[it->first] == 0)\n            {\n                totalArtifactsFound++;\n            }\n            it = artifactCells[cellIndex].erase(it); // Erase and get the next iterator\n        }\n    }\n    return totalArtifactsFound;\n}",
    "output": "#include <bits/stdc++.h>\nint extractArtifacts(int gridSize, std::vector<std::vector<int>> &artifactRegions, std::vector<std::vector<int>> &digSites)\n{\n    std::unordered_map<int, std::set<std::pair<int, int>>> artifactCells;\n    std::unordered_map<int, int> artifactCounts;\n    for(int regionIndex= 0; regionIndex < artifactRegions.size(); regionIndex++)\n    {\n        for(int row= artifactRegions[regionIndex][0]; row <= artifactRegions[regionIndex][2]; row++)\n        {\n            for(int col= artifactRegions[regionIndex][1]; col <= artifactRegions[regionIndex][3]; col++)\n            {\n                artifactCells[row * gridSize + col].insert({regionIndex, row * gridSize + col});\n                artifactCounts[regionIndex]++;\n            }\n        }\n    }\n\n    int totalArtifactsFound= 0;\n    for(const auto &digSite : digSites)\n    {\n        int cellIndex= digSite[0] * gridSize + digSite[1];\n        for(const auto &artifact : artifactCells[cellIndex])\n        {\n            artifactCounts[artifact.first]--;\n            if(artifactCounts[artifact.first] == 0)\n                totalArtifactsFound++;\n        }\n        artifactCells.erase(cellIndex);\n    }\n    return totalArtifactsFound;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint addRooms(int roomIndex, const vector<vector<int>> &childRooms, vector<int> &roomMemo)\n{\n    if (childRooms[roomIndex].empty())\n        return 1;\n\n    if (roomMemo[roomIndex] != -1)\n        return roomMemo[roomIndex];\n\n    long long result = 1;\n    int childCount = 0;\n    for (int i = 0; i < childRooms[roomIndex].size(); i++)\n    {\n        int child = childRooms[roomIndex][i];\n        childCount++;\n        result = (result * addRooms(child, childRooms, roomMemo)) % mod;\n    }\n\n    for (int i = 2; i <= childCount; i++)\n    {\n        result = (result * i) % mod;\n    }\n\n    return roomMemo[roomIndex] = result;\n}\n\nint numOfWays(vector<int> &previousRoom)\n{\n    int roomCount = previousRoom.size();\n    vector<vector<int>> childRooms(roomCount);\n    for (int i = 1; i < roomCount; i++)\n    {\n        childRooms[previousRoom[i]].push_back(i);\n    }\n\n    vector<int> roomMemo(roomCount, -1);\n    return addRooms(0, childRooms, roomMemo);\n}",
    "output": "#include <bits/stdc++.h>\nconst int mod= 1e9 + 7;\n\nint addRooms(int roomIndex, const std::vector<std::vector<int>> &childRooms, std::vector<int> &roomMemo)\n{\n    if(childRooms[roomIndex].empty())\n        return 1;\n\n    if(roomMemo[roomIndex] != -1)\n        return roomMemo[roomIndex];\n\n    long long result= 1;\n    int childCount= 0;\n    for(int child : childRooms[roomIndex])\n    {\n        childCount++;\n        result= (result * addRooms(child, childRooms, roomMemo)) % mod;\n    }\n\n    for(int i= 2; i <= childCount; i++)\n    {\n        result= (result * i) % mod;\n    }\n\n    return roomMemo[roomIndex]= result;\n}\n\nint numOfWays(std::vector<int> &previousRoom)\n{\n    int roomCount= previousRoom.size();\n    std::vector<std::vector<int>> childRooms(roomCount);\n    for(int i= 1; i < roomCount; i++)\n    {\n        childRooms[previousRoom[i]].push_back(i);\n    }\n\n    std::vector<int> roomMemo(roomCount, -1);\n    return addRooms(0, childRooms, roomMemo);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> matrixBlockSum(vector<vector<int>> &inputMatrix, int blockSize)\n{\n    int rowCount= inputMatrix.size();\n    int colCount= inputMatrix[0].size();\n    vector<vector<int>> blockSumResult(rowCount, vector<int>(colCount, 0));\n\n    for(int currentRow= 0; currentRow < rowCount; ++currentRow)\n    {\n        for(int currentCol= 0; currentCol < colCount; ++currentCol)\n        {\n            for(int r= max(0, currentRow - blockSize); r <= min(rowCount - 1, currentRow + blockSize); ++r)\n            {\n                for(int c= max(0, currentCol - blockSize); c <= min(colCount - 1, currentCol + blockSize); ++c)\n                {\n                    blockSumResult[currentRow][currentCol]+= inputMatrix[r][c];\n                }\n            }\n        }\n    }\n\n    return blockSumResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> matrixBlockSum(std::vector<std::vector<int>> &inputMatrix, int blockSize)\n{\n    int rowCount = inputMatrix.size();\n    int colCount = inputMatrix[0].size();\n    std::vector<std::vector<int>> blockSumResult(rowCount, std::vector<int>(colCount, 0));\n\n    for(int currentRow = 0; currentRow < rowCount; ++currentRow)\n    {\n        for(int currentCol = 0; currentCol < colCount; ++currentCol)\n        {\n            for(int r = std::max(0, currentRow - blockSize); r <= std::min(rowCount - 1, currentRow + blockSize); ++r)\n            {\n                for(int c = std::max(0, currentCol - blockSize); c <= std::min(colCount - 1, currentCol + blockSize); ++c)\n                {\n                    blockSumResult[currentRow][currentCol] += inputMatrix[r][c];\n                }\n            }\n        }\n    }\n\n    return blockSumResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nint sumEvenGrandparent(TreeNode *currentNode, TreeNode *parentNode= NULL, TreeNode *grandparentNode= NULL)\n{\n    if(currentNode == NULL)\n        return 0;\n    int sum= ((grandparentNode != NULL) && (grandparentNode->value % 2 == 0)) ? currentNode->value : 0;\n    return sum + sumEvenGrandparent(currentNode->leftChild, currentNode, parentNode) + sumEvenGrandparent(currentNode->rightChild, currentNode, parentNode);\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nint sumEvenGrandparent(TreeNode *currentNode, TreeNode *parentNode= NULL, TreeNode *grandparentNode= NULL)\n{\n    if(currentNode == NULL)\n        return 0;\n    int sum= ((grandparentNode != NULL) && (grandparentNode->value % 2 == 0)) ? currentNode->value : 0;\n    return sum + sumEvenGrandparent(currentNode->leftChild, currentNode, parentNode) + sumEvenGrandparent(currentNode->rightChild, currentNode, parentNode);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> noZeroIntegers(int targetSum)\n{\n    for(int firstInteger= 1; firstInteger < targetSum; ++firstInteger)\n    {\n        if(to_string(firstInteger).find('0') == string::npos &&\n           to_string(targetSum - firstInteger).find('0') == string::npos)\n        {\n            return {firstInteger, targetSum - firstInteger};\n        }\n    }\n    return {0, 0}; // never gets here\n}",
    "output": "std::vector<int> noZeroIntegers(int targetSum)\n{\n    for(int firstInteger= 1; firstInteger < targetSum; ++firstInteger)\n    {\n        if(std::to_string(firstInteger).find('0') == std::string::npos &&\n           std::to_string(targetSum - firstInteger).find('0') == std::string::npos)\n        {\n            return {firstInteger, targetSum - firstInteger};\n        }\n    }\n    return {0, 0}; // never gets here\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int minFlips(int sourceA, int sourceB, int targetC)\n{\n    int flipCount= 0;\n    for(int bitPosition= 0; bitPosition < 32; ++bitPosition)\n    {\n        int bitA= (sourceA >> bitPosition) & 1;\n        int bitB= (sourceB >> bitPosition) & 1;\n        int bitC= (targetC >> bitPosition) & 1;\n        if(bitC == 0)\n        {\n            flipCount+= bitA + bitB;\n        }\n        else\n        {\n            flipCount+= 1 - (bitA | bitB);\n        }\n    }\n    return flipCount;\n}",
    "output": "int minFlips(int sourceA, int sourceB, int targetC)\n{\n    int flipCount= 0;\n    for(int bitPosition= 0; bitPosition < 32; ++bitPosition)\n    {\n        int bitA= (sourceA >> bitPosition) & 1;\n        int bitB= (sourceB >> bitPosition) & 1;\n        int bitC= (targetC >> bitPosition) & 1;\n        if(bitC == 0)\n        {\n            flipCount+= bitA + bitB;\n        }\n        else\n        {\n            flipCount+= 1 - (bitA | bitB);\n        }\n    }\n    return flipCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool uniqueOccurrences(vector<int> &inputArray)\n{\n    map<int, int> occurrenceCounts;\n    for (int i = 0; i < inputArray.size(); ++i)\n    {\n        int number = inputArray[i];\n        occurrenceCounts[number]++;\n    }\n\n    unordered_set<int> uniqueCounts;\n    for (auto it = occurrenceCounts.begin(); it != occurrenceCounts.end(); ++it)\n    {\n        if (uniqueCounts.count(it->second) > 0)\n        {\n            return false;\n        }\n        uniqueCounts.insert(it->second);\n    }\n\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool uniqueOccurrences(std::vector<int> &inputArray)\n{\n    std::map<int, int> occurrenceCounts;\n    for(int number : inputArray)\n    {\n        occurrenceCounts[number]++;\n    }\n\n    std::unordered_set<int> uniqueCounts;\n    for(auto &count : occurrenceCounts)\n    {\n        if(uniqueCounts.count(count.second) > 0)\n        {\n            return false;\n        }\n        uniqueCounts.insert(count.second);\n    }\n\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring removeDuplicates(string inputString, int repeatCount)\n{\n    stack<pair<char, int>> characterStack;\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentCharacter = inputString[i];\n        if (!characterStack.empty() && characterStack.top().first == currentCharacter)\n        {\n            characterStack.top().second++;\n            if (characterStack.top().second == repeatCount)\n                characterStack.pop();\n        }\n        else\n        {\n            characterStack.push({currentCharacter, 1});\n        }\n    }\n    string resultString = \"\";\n    while (!characterStack.empty())\n    {\n        resultString = string(characterStack.top().second, characterStack.top().first) + resultString;\n        characterStack.pop();\n    }\n    return resultString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string removeDuplicates(std::string inputString, int repeatCount)\n{\n    std::stack<std::pair<char, int>> characterStack;\n    for(char currentCharacter : inputString)\n    {\n        if(!characterStack.empty() && characterStack.top().first == currentCharacter)\n        {\n            characterStack.top().second++;\n            if(characterStack.top().second == repeatCount)\n                characterStack.pop();\n        }\n        else\n        {\n            characterStack.push({currentCharacter, 1});\n        }\n    }\n    std::string resultString= \"\";\n    while(!characterStack.empty())\n    {\n        resultString= std::string(characterStack.top().second, characterStack.top().first) + resultString;\n        characterStack.pop();\n    }\n    return resultString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maximum69Number(int originalNumber)\n{\n    string numberString = to_string(originalNumber);\n    for (int i = 0; i < numberString.size(); ++i)\n    {\n        if (numberString[i] == '6')\n        {\n            numberString[i] = '9';\n            break;\n        }\n    }\n    return stoi(numberString);\n}",
    "output": "#include <bits/stdc++.h>\nint maximum69Number(int originalNumber)\n{\n    std::string numberString = std::to_string(originalNumber);\n    for(char &digit : numberString)\n    {\n        if(digit == '6')\n        {\n            digit = '9';\n            break;\n        }\n    }\n    return std::stoi(numberString);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findBall(vector<vector<int>> &grid)\n{\n    int totalRows= grid.size();\n    int totalColumns= grid[0].size();\n    vector<int> ballPositions(totalColumns, -1);\n\n    for(int columnIndex= 0; columnIndex < totalColumns; columnIndex++)\n    {\n        int currentRowIndex= 0, currentColumnIndex= columnIndex;\n\n        while(currentRowIndex < totalRows)\n        {\n            int nextRowIndex= currentRowIndex + 1, nextColumnIndex= currentColumnIndex + grid[currentRowIndex][currentColumnIndex];\n            if(nextColumnIndex < 0 || nextColumnIndex >= totalColumns || grid[currentRowIndex][nextColumnIndex] != grid[currentRowIndex][currentColumnIndex])\n                break;\n            currentRowIndex= nextRowIndex;\n            currentColumnIndex= nextColumnIndex;\n        }\n\n        if(currentRowIndex == totalRows)\n        {\n            ballPositions[columnIndex]= currentColumnIndex;\n        }\n    }\n\n    return ballPositions;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findBall(std::vector<std::vector<int>> &grid)\n{\n    int totalRows= grid.size();\n    int totalColumns= grid[0].size();\n    std::vector<int> ballPositions(totalColumns, -1);\n\n    for(int columnIndex= 0; columnIndex < totalColumns; columnIndex++)\n    {\n        int currentRowIndex= 0, currentColumnIndex= columnIndex;\n\n        while(currentRowIndex < totalRows)\n        {\n            int nextRowIndex= currentRowIndex + 1, nextColumnIndex= currentColumnIndex + grid[currentRowIndex][currentColumnIndex];\n            if(nextColumnIndex < 0 || nextColumnIndex >= totalColumns || grid[currentRowIndex][nextColumnIndex] != grid[currentRowIndex][currentColumnIndex])\n                break;\n            currentRowIndex= nextRowIndex;\n            currentColumnIndex= nextColumnIndex;\n        }\n\n        if(currentRowIndex == totalRows)\n        {\n            ballPositions[columnIndex]= currentColumnIndex;\n        }\n    }\n\n    return ballPositions;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble maxProbability(int nodeCount, vector<vector<int>> &edges, vector<double> &successProbabilities, int startNode, int endNode)\n{\n    vector<vector<pair<int, double>>> adjacencyList(nodeCount);\n    for(int index = 0; index < edges.size(); ++index)\n    {\n        adjacencyList[edges[index][0]].emplace_back(edges[index][1], successProbabilities[index]);\n        adjacencyList[edges[index][1]].emplace_back(edges[index][0], successProbabilities[index]);\n    }\n\n    vector<double> maximumProbabilities(nodeCount, 0);\n    maximumProbabilities[startNode] = 1;\n\n    priority_queue<pair<double, int>> priorityQueue;\n    priorityQueue.emplace(1, startNode);\n\n    while(!priorityQueue.empty())\n    {\n        double currentProbability = priorityQueue.top().first;\n        int currentNode = priorityQueue.top().second;\n        priorityQueue.pop();\n\n        if(currentNode == endNode)\n        {\n            return currentProbability;\n        }\n\n        if(currentProbability < maximumProbabilities[currentNode])\n        {\n            continue;\n        }\n\n        for(int i = 0; i < adjacencyList[currentNode].size(); ++i)\n        {\n            auto &edge = adjacencyList[currentNode][i];\n            double newProbability = currentProbability * edge.second;\n            if(newProbability > maximumProbabilities[edge.first])\n            {\n                maximumProbabilities[edge.first] = newProbability;\n                priorityQueue.emplace(newProbability, edge.first);\n            }\n        }\n    }\n\n    return 0;\n}",
    "output": "#include <bits/stdc++.h>\ndouble maxProbability(int nodeCount, std::vector<std::vector<int>> &edges, std::vector<double> &successProbabilities, int startNode, int endNode)\n{\n    std::vector<std::vector<std::pair<int, double>>> adjacencyList(nodeCount);\n    for(int index= 0; index < edges.size(); ++index)\n    {\n        adjacencyList[edges[index][0]].emplace_back(edges[index][1], successProbabilities[index]);\n        adjacencyList[edges[index][1]].emplace_back(edges[index][0], successProbabilities[index]);\n    }\n\n    std::vector<double> maximumProbabilities(nodeCount, 0);\n    maximumProbabilities[startNode]= 1;\n\n    std::priority_queue<std::pair<double, int>> priorityQueue;\n    priorityQueue.emplace(1, startNode);\n\n    while(!priorityQueue.empty())\n    {\n        double currentProbability= priorityQueue.top().first;\n        int currentNode= priorityQueue.top().second;\n        priorityQueue.pop();\n\n        if(currentNode == endNode)\n        {\n            return currentProbability;\n        }\n\n        if(currentProbability < maximumProbabilities[currentNode])\n        {\n            continue;\n        }\n\n        for(auto &edge : adjacencyList[currentNode])\n        {\n            double newProbability= currentProbability * edge.second;\n            if(newProbability > maximumProbabilities[edge.first])\n            {\n                maximumProbabilities[edge.first]= newProbability;\n                priorityQueue.emplace(newProbability, edge.first);\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint sumOfFlooredPairs(vector<int> &numbers)\n{\n    int modulus = 1e9 + 7;\n    int maxValue = *max_element(numbers.begin(), numbers.end());\n    vector<int> count(maxValue + 1, 0);\n    vector<long long> prefixSum(maxValue + 1, 0);\n\n    for(int i = 0; i < numbers.size(); i++)\n    {\n        count[numbers[i]]++;\n    }\n\n    for(int i = 1; i <= maxValue; i++)\n    {\n        prefixSum[i] = (prefixSum[i - 1] + count[i]) % modulus;\n    }\n\n    long long result = 0;\n    for(int currentValue = 1; currentValue <= maxValue; currentValue++)\n    {\n        for(int multiplier = 1, nextValue = currentValue; nextValue <= maxValue; multiplier++, nextValue += currentValue)\n        {\n            result = (result + ((prefixSum[nextValue] - prefixSum[nextValue - currentValue] + modulus) % modulus) * multiplier % modulus * count[currentValue] % modulus) % modulus;\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nint sumOfFlooredPairs(std::vector<int> &numbers)\n{\n    int modulus= 1e9 + 7;\n    int maxValue= *max_element(numbers.begin(), numbers.end());\n    std::vector<int> count(maxValue + 1, 0);\n    std::vector<long long> prefixSum(maxValue + 1, 0);\n\n    for(int number : numbers)\n    {\n        count[number]++;\n    }\n\n    for(int i= 1; i <= maxValue; i++)\n    {\n        prefixSum[i]= (prefixSum[i - 1] + count[i]) % modulus;\n    }\n\n    long long result= 0;\n    for(int currentValue= 1; currentValue <= maxValue; currentValue++)\n    {\n        for(int multiplier= 1, nextValue= currentValue; nextValue <= maxValue; multiplier++, nextValue+= currentValue)\n        {\n            result= (result + ((prefixSum[nextValue] - prefixSum[nextValue - currentValue] + modulus) % modulus) * multiplier % modulus * count[currentValue] % modulus) % modulus;\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring breakPalindrome(string palindrome)\n{\n    int length = palindrome.length();\n    if(length == 1)\n        return \"\";\n\n    for(int index = 0; index < length / 2; index++)\n    {\n        if(palindrome[index] != 'a')\n        {\n            palindrome[index] = 'a';\n            return palindrome;\n        }\n    }\n\n    palindrome[length - 1] = 'b';\n    return palindrome;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string breakPalindrome(std::string palindrome)\n{\n    int length= palindrome.length();\n    if(length == 1)\n        return \"\";\n\n    for(int index= 0; index < length / 2; index++)\n    {\n        if(palindrome[index] != 'a')\n        {\n            palindrome[index]= 'a';\n            return palindrome;\n        }\n    }\n\n    palindrome[length - 1]= 'b';\n    return palindrome;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minCostToMoveChips(vector<int> &chipPositions)\n{\n    int evenChipCount = 0, oddChipCount = 0;\n    for (int i = 0; i < chipPositions.size(); ++i)\n    {\n        int position = chipPositions[i];\n        if (position % 2 == 0)\n            evenChipCount++;\n        else\n            oddChipCount++;\n    }\n    return min(evenChipCount, oddChipCount);\n}",
    "output": "#include <bits/stdc++.h>\nint minCostToMoveChips(std::vector<int> &chipPositions)\n{\n    int evenChipCount= 0, oddChipCount= 0;\n    for(int position : chipPositions)\n    {\n        if(position % 2 == 0)\n            evenChipCount++;\n        else\n            oddChipCount++;\n    }\n    return std::min(evenChipCount, oddChipCount);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint longestSubsequence(vector<int> &inputArray, int difference)\n{\n    unordered_map<int, int> lengthMap;\n    int maxLength = 0;\n    for (int i = 0; i < inputArray.size(); ++i)\n    {\n        int currentNumber = inputArray[i];\n        lengthMap[currentNumber] = lengthMap[currentNumber - difference] + 1;\n        maxLength = max(maxLength, lengthMap[currentNumber]);\n    }\n    return maxLength;\n}",
    "output": "#include <bits/stdc++.h>\nint longestSubsequence(std::vector<int> &inputArray, int difference)\n{\n    std::unordered_map<int, int> lengthMap;\n    int maxLength= 0;\n    for(int currentNumber : inputArray)\n    {\n        lengthMap[currentNumber]= lengthMap[currentNumber - difference] + 1;\n        maxLength= std::max(maxLength, lengthMap[currentNumber]);\n    }\n    return maxLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaximumGoldHelper(vector<vector<int>> &goldGrid, int currentRow, int currentCol, int rows, int columns)\n{\n    if(currentRow < 0 || currentRow >= rows || currentCol < 0 || currentCol >= columns || goldGrid[currentRow][currentCol] == 0)\n        return 0;\n\n    int originalGold= goldGrid[currentRow][currentCol];\n    goldGrid[currentRow][currentCol]= 0;\n\n    int maxGold= 0;\n    maxGold= max(maxGold, getMaximumGoldHelper(goldGrid, currentRow + 1, currentCol, rows, columns));\n    maxGold= max(maxGold, getMaximumGoldHelper(goldGrid, currentRow - 1, currentCol, rows, columns));\n    maxGold= max(maxGold, getMaximumGoldHelper(goldGrid, currentRow, currentCol + 1, rows, columns));\n    maxGold= max(maxGold, getMaximumGoldHelper(goldGrid, currentRow, currentCol - 1, rows, columns));\n\n    goldGrid[currentRow][currentCol]= originalGold;\n    return maxGold + originalGold;\n}\n\nint getMaximumGold(vector<vector<int>> &goldGrid)\n{\n    int rows= goldGrid.size(), columns= goldGrid[0].size(), maxGold= 0;\n    for(int rowIndex= 0; rowIndex < rows; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < columns; colIndex++)\n        {\n            if(goldGrid[rowIndex][colIndex] != 0)\n            {\n                maxGold= max(maxGold, getMaximumGoldHelper(goldGrid, rowIndex, colIndex, rows, columns));\n            }\n        }\n    }\n    return maxGold;\n}",
    "output": "#include <bits/stdc++.h>\nint getMaximumGoldHelper(std::vector<std::vector<int>> &goldGrid, int currentRow, int currentCol, int rows, int columns)\n{\n    if(currentRow < 0 || currentRow >= rows || currentCol < 0 || currentCol >= columns || goldGrid[currentRow][currentCol] == 0)\n        return 0;\n\n    int originalGold= goldGrid[currentRow][currentCol];\n    goldGrid[currentRow][currentCol]= 0;\n\n    int maxGold= 0;\n    maxGold= std::max(maxGold, getMaximumGoldHelper(goldGrid, currentRow + 1, currentCol, rows, columns));\n    maxGold= std::max(maxGold, getMaximumGoldHelper(goldGrid, currentRow - 1, currentCol, rows, columns));\n    maxGold= std::max(maxGold, getMaximumGoldHelper(goldGrid, currentRow, currentCol + 1, rows, columns));\n    maxGold= std::max(maxGold, getMaximumGoldHelper(goldGrid, currentRow, currentCol - 1, rows, columns));\n\n    goldGrid[currentRow][currentCol]= originalGold;\n    return maxGold + originalGold;\n}\n\nint getMaximumGold(std::vector<std::vector<int>> &goldGrid)\n{\n    int rows= goldGrid.size(), columns= goldGrid[0].size(), maxGold= 0;\n    for(int rowIndex= 0; rowIndex < rows; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < columns; colIndex++)\n        {\n            if(goldGrid[rowIndex][colIndex] != 0)\n            {\n                maxGold= std::max(maxGold, getMaximumGoldHelper(goldGrid, rowIndex, colIndex, rows, columns));\n            }\n        }\n    }\n    return maxGold;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int countStrings(int length)\n{\n    const int modulus= 1e9 + 7;\n    long long twoPower= 1, threePower= 1;\n    for(int i= 0; i < length; ++i)\n    {\n        twoPower= (twoPower * 2) % modulus;\n        threePower= (threePower * 3) % modulus;\n    }\n    return (threePower - twoPower + modulus) % modulus;\n}",
    "output": "int countStrings(int length)\n{\n    const int modulus= 1e9 + 7;\n    long long twoPower= 1, threePower= 1;\n    for(int i= 0; i < length; ++i)\n    {\n        twoPower= (twoPower * 2) % modulus;\n        threePower= (threePower * 3) % modulus;\n    }\n    return (threePower - twoPower + modulus) % modulus;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> sortBasedOnMapping(vector<int> &mapping, vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), [&](int firstNumber, int secondNumber)\n          {\n        string firstNumberStr = to_string(firstNumber);\n        string secondNumberStr = to_string(secondNumber);\n        for (int i = 0; i < firstNumberStr.size(); ++i) \n            firstNumberStr[i] = '0' + mapping[firstNumberStr[i] - '0'];\n        for (int i = 0; i < secondNumberStr.size(); ++i) \n            secondNumberStr[i] = '0' + mapping[secondNumberStr[i] - '0'];\n        return firstNumberStr < secondNumberStr; });\n    return numbers;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> sortBasedOnMapping(std::vector<int> &mapping, std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), [&](int firstNumber, int secondNumber)\n              {\n        std::string firstNumberStr = std::to_string(firstNumber);\n        std::string secondNumberStr = std::to_string(secondNumber);\n        for (char &character : firstNumberStr) character = '0' + mapping[character - '0'];\n        for (char &character : secondNumberStr) character = '0' + mapping[character - '0'];\n        return firstNumberStr < secondNumberStr; });\n    return numbers;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findTheCity(int cityCount, vector<vector<int>> &cityEdges, int distanceThreshold)\n{\n    vector<vector<int>> distance(cityCount, vector<int>(cityCount, 1e5));\n    for (int i = 0; i < cityEdges.size(); i++)\n    {\n        const auto &edge = cityEdges[i];\n        distance[edge[0]][edge[1]] = edge[2];\n        distance[edge[1]][edge[0]] = edge[2];\n    }\n\n    for (int i = 0; i < cityCount; i++)\n        distance[i][i] = 0;\n\n    for (int k = 0; k < cityCount; k++)\n    {\n        for (int i = 0; i < cityCount; i++)\n        {\n            for (int j = 0; j < cityCount; j++)\n            {\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j]);\n            }\n        }\n    }\n\n    int resultCity = 0, minReachableCities = cityCount;\n    for (int i = 0; i < cityCount; i++)\n    {\n        int reachableCities = 0;\n        for (int j = 0; j < cityCount; j++)\n        {\n            if (distance[i][j] <= distanceThreshold)\n                reachableCities++;\n        }\n        if (reachableCities <= minReachableCities)\n        {\n            minReachableCities = reachableCities;\n            resultCity = i;\n        }\n    }\n    return resultCity;\n}",
    "output": "#include <bits/stdc++.h>\nint findTheCity(int cityCount, std::vector<std::vector<int>> &cityEdges, int distanceThreshold)\n{\n    std::vector<std::vector<int>> distance(cityCount, std::vector<int>(cityCount, 1e5));\n    for(const auto &edge : cityEdges)\n    {\n        distance[edge[0]][edge[1]]= edge[2];\n        distance[edge[1]][edge[0]]= edge[2];\n    }\n\n    for(int i= 0; i < cityCount; i++)\n        distance[i][i]= 0;\n\n    for(int k= 0; k < cityCount; k++)\n    {\n        for(int i= 0; i < cityCount; i++)\n        {\n            for(int j= 0; j < cityCount; j++)\n            {\n                distance[i][j]= std::min(distance[i][j], distance[i][k] + distance[k][j]);\n            }\n        }\n    }\n\n    int resultCity= 0, minReachableCities= cityCount;\n    for(int i= 0; i < cityCount; i++)\n    {\n        int reachableCities= 0;\n        for(int j= 0; j < cityCount; j++)\n        {\n            if(distance[i][j] <= distanceThreshold)\n                reachableCities++;\n        }\n        if(reachableCities <= minReachableCities)\n        {\n            minReachableCities= reachableCities;\n            resultCity= i;\n        }\n    }\n    return resultCity;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxCandies(const vector<int> &candyCounts, int numberOfFriends)\n{\n    int minimumCandies = 1;\n    int maximumCandies = *max_element(candyCounts.begin(), candyCounts.end());\n\n    while (minimumCandies <= maximumCandies)\n    {\n        int midCandies = minimumCandies + (maximumCandies - minimumCandies) / 2;\n        int totalCount = 0;\n        for (int i = 0; i < candyCounts.size(); ++i)\n        {\n            totalCount += candyCounts[i] / midCandies;\n        }\n        if (totalCount >= numberOfFriends)\n        {\n            minimumCandies = midCandies + 1;\n        }\n        else\n        {\n            maximumCandies = midCandies - 1;\n        }\n    }\n    return maximumCandies;\n}",
    "output": "#include <bits/stdc++.h>\nint maxCandies(const std::vector<int> &candyCounts, int numberOfFriends)\n{\n    int minimumCandies= 1;\n    int maximumCandies= *std::max_element(candyCounts.begin(), candyCounts.end());\n\n    while(minimumCandies <= maximumCandies)\n    {\n        int midCandies= minimumCandies + (maximumCandies - minimumCandies) / 2;\n        int totalCount= 0;\n        for(int candyCount : candyCounts)\n        {\n            totalCount+= candyCount / midCandies;\n        }\n        if(totalCount >= numberOfFriends)\n        {\n            minimumCandies= midCandies + 1;\n        }\n        else\n        {\n            maximumCandies= midCandies - 1;\n        }\n    }\n    return maximumCandies;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> kWeakestRows(vector<vector<int>> &militaryMatrix, int numberOfWeakestRows)\n{\n    vector<pair<int, int>> soldiersCount;\n\n    for(int rowIndex= 0; rowIndex < militaryMatrix.size(); ++rowIndex)\n    {\n        int soldierCount= count(militaryMatrix[rowIndex].begin(), militaryMatrix[rowIndex].end(), 1);\n        soldiersCount.push_back({soldierCount, rowIndex});\n    }\n\n    sort(soldiersCount.begin(), soldiersCount.end());\n    vector<int> weakestRowsIndices(numberOfWeakestRows);\n    for(int index= 0; index < numberOfWeakestRows; ++index)\n    {\n        weakestRowsIndices[index]= soldiersCount[index].second;\n    }\n    return weakestRowsIndices;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> kWeakestRows(std::vector<std::vector<int>> &militaryMatrix, int numberOfWeakestRows)\n{\n    std::vector<std::pair<int, int>> soldiersCount;\n\n    for(int rowIndex= 0; rowIndex < militaryMatrix.size(); ++rowIndex)\n    {\n        int soldierCount= std::count(militaryMatrix[rowIndex].begin(), militaryMatrix[rowIndex].end(), 1);\n        soldiersCount.push_back({soldierCount, rowIndex});\n    }\n\n    std::sort(soldiersCount.begin(), soldiersCount.end());\n    std::vector<int> weakestRowsIndices(numberOfWeakestRows);\n    for(int index= 0; index < numberOfWeakestRows; ++index)\n    {\n        weakestRowsIndices[index]= soldiersCount[index].second;\n    }\n    return weakestRowsIndices;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minSetSize(vector<int> &inputArray)\n{\n    unordered_map<int, int> frequencyMap;\n    priority_queue<int> maxHeap;\n    for (int element : inputArray)\n        frequencyMap[element]++;\n    for (auto it = frequencyMap.begin(); it != frequencyMap.end(); ++it)\n        maxHeap.push(it->second);\n    int halfSize = inputArray.size() / 2;\n    int setCount = 0;\n    int currentSize = 0;\n    while (currentSize < halfSize)\n    {\n        currentSize += maxHeap.top();\n        maxHeap.pop();\n        setCount++;\n    }\n    return setCount;\n}",
    "output": "#include <bits/stdc++.h>\nint minSetSize(std::vector<int> &inputArray)\n{\n    std::unordered_map<int, int> frequencyMap;\n    std::priority_queue<int> maxHeap;\n    for(int element : inputArray)\n        frequencyMap[element]++;\n    for(auto &[_, count] : frequencyMap)\n        maxHeap.push(count);\n    int halfSize = inputArray.size() / 2;\n    int setCount = 0;\n    int currentSize = 0;\n    while(currentSize < halfSize)\n    {\n        currentSize += maxHeap.top();\n        maxHeap.pop();\n        setCount++;\n    }\n    return setCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nclass Solution\n{\n    int calculateSubtreeSums(TreeNode *currentNode, vector<int> &subtreeSums)\n    {\n        if(!currentNode)\n            return 0;\n        int subtreeSum = currentNode->value + calculateSubtreeSums(currentNode->leftChild, subtreeSums) + calculateSubtreeSums(currentNode->rightChild, subtreeSums);\n        subtreeSums.push_back(subtreeSum);\n        return subtreeSum;\n    }\n\n  public:\n    int maxProduct(TreeNode *root)\n    {\n        vector<int> subtreeSums;\n        long long totalSum = calculateSubtreeSums(root, subtreeSums);\n        long long maxProductValue = 0;\n\n        for (size_t i = 0; i < subtreeSums.size(); ++i)\n        {\n            long long subtreeSum = subtreeSums[i];\n            maxProductValue = max(maxProductValue, subtreeSum * (totalSum - subtreeSum));\n        }\n\n        return maxProductValue % 1000000007;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nclass Solution\n{\n    int calculateSubtreeSums(TreeNode *currentNode, std::vector<int> &subtreeSums)\n    {\n        if(!currentNode)\n            return 0;\n        int subtreeSum= currentNode->value + calculateSubtreeSums(currentNode->leftChild, subtreeSums) + calculateSubtreeSums(currentNode->rightChild, subtreeSums);\n        subtreeSums.push_back(subtreeSum);\n        return subtreeSum;\n    }\n\n  public:\n    int maxProduct(TreeNode *root)\n    {\n        std::vector<int> subtreeSums;\n        long long totalSum= calculateSubtreeSums(root, subtreeSums);\n        long long maxProductValue= 0;\n\n        for(long long subtreeSum : subtreeSums)\n        {\n            maxProductValue= std::max(maxProductValue, subtreeSum * (totalSum - subtreeSum));\n        }\n\n        return maxProductValue % 1000000007;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass DiningPhilosophers\n{\n    mutex forks[5];\n    condition_variable notBusy[5];\n\n  public:\n    void wantsToEat(int philosopher,\n                    function<void()> pickLeftFork,\n                    function<void()> pickRightFork,\n                    function<void()> eat,\n                    function<void()> putLeftFork,\n                    function<void()> putRightFork)\n    {\n        int leftFork = philosopher;\n        int rightFork = (philosopher + 1) % 5;\n\n        {\n            unique_lock<mutex> lock(forks[leftFork]);\n            notBusy[leftFork].wait(lock, [&]\n                                   { return !forks[rightFork].try_lock(); });\n            pickLeftFork();\n\n            unique_lock<mutex> rightLock(forks[rightFork], adopt_lock);\n            pickRightFork();\n            eat();\n\n            putRightFork();\n            rightLock.unlock();\n            notBusy[rightFork].notify_all();\n        }\n\n        putLeftFork();\n        notBusy[leftFork].notify_all();\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass DiningPhilosophers\n{\n    std::mutex forks[5];\n    std::condition_variable notBusy[5];\n\n  public:\n    void wantsToEat(int philosopher,\n                    std::function<void()> pickLeftFork,\n                    std::function<void()> pickRightFork,\n                    std::function<void()> eat,\n                    std::function<void()> putLeftFork,\n                    std::function<void()> putRightFork)\n    {\n        int leftFork= philosopher;\n        int rightFork= (philosopher + 1) % 5;\n\n        {\n            std::unique_lock<std::mutex> lock(forks[leftFork]);\n            notBusy[leftFork].wait(lock, [&]\n                                   { return !forks[rightFork].try_lock(); });\n            pickLeftFork();\n\n            std::unique_lock<std::mutex> rightLock(forks[rightFork], std::adopt_lock);\n            pickRightFork();\n            eat();\n\n            putRightFork();\n            rightLock.unlock();\n            notBusy[rightFork].notify_all();\n        }\n\n        putLeftFork();\n        notBusy[leftFork].notify_all();\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> queensAttackTheKing(vector<vector<int>> &queens, vector<int> &kingPosition)\n{\n    vector<vector<int>> attackingQueens;\n    for(int directionX = -1; directionX <= 1; directionX++)\n    {\n        for(int directionY = -1; directionY <= 1; directionY++)\n        {\n            if(directionX == 0 && directionY == 0)\n                continue;\n            int currentX = kingPosition[0] + directionX;\n            int currentY = kingPosition[1] + directionY;\n            while(currentX >= 0 && currentY >= 0 && currentX < 8 && currentY < 8)\n            {\n                for(int i = 0; i < queens.size(); ++i)\n                {\n                    vector<int> &queenPosition = queens[i];\n                    if(currentX == queenPosition[0] && currentY == queenPosition[1])\n                    {\n                        attackingQueens.push_back({queenPosition[0], queenPosition[1]});\n                        break;\n                    }\n                }\n                currentX += directionX;\n                currentY += directionY;\n            }\n        }\n    }\n    return attackingQueens;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> queensAttackTheKing(std::vector<std::vector<int>> &queens, std::vector<int> &kingPosition)\n{\n    std::vector<std::vector<int>> attackingQueens;\n    for(int directionX= -1; directionX <= 1; directionX++)\n    {\n        for(int directionY= -1; directionY <= 1; directionY++)\n        {\n            if(directionX == 0 && directionY == 0)\n                continue;\n            int currentX= kingPosition[0] + directionX;\n            int currentY= kingPosition[1] + directionY;\n            while(currentX >= 0 && currentY >= 0 && currentX < 8 && currentY < 8)\n            {\n                for(std::vector<int> &queenPosition : queens)\n                {\n                    if(currentX == queenPosition[0] && currentY == queenPosition[1])\n                    {\n                        attackingQueens.push_back({queenPosition[0], queenPosition[1]});\n                        break;\n                    }\n                }\n                currentX+= directionX;\n                currentY+= directionY;\n            }\n        }\n    }\n    return attackingQueens;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulus = 1000000007;\n\nint dieSimulator(int totalRolls, vector<int> &maxRolls)\n{\n    vector<vector<int>> dynamicProgramming(6, vector<int>(totalRolls + 1, 0));\n    vector<int> sum(totalRolls + 1, 0);\n\n    for(int face = 0; face < 6; face++)\n        dynamicProgramming[face][1] = 1;\n    sum[1] = 6;\n\n    for(int rolls = 2; rolls <= totalRolls; rolls++)\n    {\n        int currentSum = 0;\n        for(int face = 0; face < 6; face++)\n        {\n            dynamicProgramming[face][rolls] = sum[rolls - 1];\n            if(rolls - maxRolls[face] - 1 >= 0)\n            {\n                dynamicProgramming[face][rolls] = (dynamicProgramming[face][rolls] - sum[rolls - maxRolls[face] - 1] + modulus) % modulus;\n                if(rolls - maxRolls[face] - 1 >= 1)\n                {\n                    dynamicProgramming[face][rolls] = (dynamicProgramming[face][rolls] + dynamicProgramming[face][rolls - maxRolls[face] - 1]) % modulus;\n                }\n            }\n            currentSum = (currentSum + dynamicProgramming[face][rolls]) % modulus;\n        }\n        sum[rolls] = currentSum;\n    }\n\n    return sum[totalRolls];\n}",
    "output": "#include <bits/stdc++.h>\nconst int modulus= 1000000007;\n\nint dieSimulator(int totalRolls, std::vector<int> &maxRolls)\n{\n    std::vector<std::vector<int>> dynamicProgramming(6, std::vector<int>(totalRolls + 1, 0));\n    std::vector<int> sum(totalRolls + 1, 0);\n\n    for(int face= 0; face < 6; face++)\n        dynamicProgramming[face][1]= 1;\n    sum[1]= 6;\n\n    for(int rolls= 2; rolls <= totalRolls; rolls++)\n    {\n        int currentSum= 0;\n        for(int face= 0; face < 6; face++)\n        {\n            dynamicProgramming[face][rolls]= sum[rolls - 1];\n            if(rolls - maxRolls[face] - 1 >= 0)\n            {\n                dynamicProgramming[face][rolls]= (dynamicProgramming[face][rolls] - sum[rolls - maxRolls[face] - 1] + modulus) % modulus;\n                if(rolls - maxRolls[face] - 1 >= 1)\n                {\n                    dynamicProgramming[face][rolls]= (dynamicProgramming[face][rolls] + dynamicProgramming[face][rolls - maxRolls[face] - 1]) % modulus;\n                }\n            }\n            currentSum= (currentSum + dynamicProgramming[face][rolls]) % modulus;\n        }\n        sum[rolls]= currentSum;\n    }\n\n    return sum[totalRolls];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxEqualFrequency(vector<int> &numbers)\n{\n    unordered_map<int, int> countMap, frequencyMap;\n    int maxLength= 0, maxFrequency= 0;\n    for(int index= 0; index < numbers.size(); index++)\n    {\n        countMap[numbers[index]]++;\n        frequencyMap[countMap[numbers[index]] - 1]--;\n        frequencyMap[countMap[numbers[index]]]++;\n\n        maxFrequency= max(maxFrequency, countMap[numbers[index]]);\n        if(maxFrequency * (index + 1) == index ||\n           maxFrequency * (frequencyMap[maxFrequency - 1] + 1) +\n                   (maxFrequency - 1) * frequencyMap[maxFrequency - 1] ==\n               index)\n        {\n            maxLength= index + 1;\n        }\n    }\n    return maxLength;\n}",
    "output": "#include <bits/stdc++.h>\nint getMaxEqualFrequency(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> countMap, frequencyMap;\n    int maxLength= 0, maxFrequency= 0;\n    \n    for(int index= 0; index < numbers.size(); index++)\n    {\n        countMap[numbers[index]]++;\n        frequencyMap[countMap[numbers[index]] - 1]--;\n        frequencyMap[countMap[numbers[index]]]++;\n\n        maxFrequency= std::max(maxFrequency, countMap[numbers[index]]);\n        \n        if(maxFrequency * (index + 1) == index ||\n           maxFrequency * (frequencyMap[maxFrequency - 1] + 1) +\n                   (maxFrequency - 1) * frequencyMap[maxFrequency - 1] ==\n               index)\n        {\n            maxLength= index + 1;\n        }\n    }\n    return maxLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minJumps(vector<int> &array)\n{\n    int arraySize = array.size();\n    if(arraySize <= 1)\n        return 0;\n\n    unordered_map<int, vector<int>> valueIndices;\n    for(int i = 0; i < arraySize; ++i)\n    {\n        valueIndices[array[i]].push_back(i);\n    }\n\n    queue<int> indexQueue;\n    vector<bool> visited(arraySize, false);\n\n    indexQueue.push(0);\n    visited[0] = true;\n    int steps = 0;\n\n    while(!indexQueue.empty())\n    {\n        int queueSize = indexQueue.size();\n\n        for(int i = 0; i < queueSize; ++i)\n        {\n            int currentIndex = indexQueue.front();\n            indexQueue.pop();\n\n            if(currentIndex == arraySize - 1)\n                return steps;\n\n            if(currentIndex > 0 && !visited[currentIndex - 1])\n            {\n                indexQueue.push(currentIndex - 1);\n                visited[currentIndex - 1] = true;\n            }\n\n            if(currentIndex < arraySize - 1 && !visited[currentIndex + 1])\n            {\n                indexQueue.push(currentIndex + 1);\n                visited[currentIndex + 1] = true;\n            }\n\n            // Traditional for loop replacing the range-based for loop\n            for (size_t j = 0; j < valueIndices[array[currentIndex]].size(); ++j)\n            {\n                int neighborIndex = valueIndices[array[currentIndex]][j];\n                if(!visited[neighborIndex])\n                {\n                    indexQueue.push(neighborIndex);\n                    visited[neighborIndex] = true;\n                }\n            }\n\n            valueIndices[array[currentIndex]].clear();\n        }\n\n        ++steps;\n    }\n\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint minJumps(std::vector<int> &array)\n{\n    int arraySize= array.size();\n    if(arraySize <= 1)\n        return 0;\n\n    std::unordered_map<int, std::vector<int>> valueIndices;\n    for(int i= 0; i < arraySize; ++i)\n    {\n        valueIndices[array[i]].push_back(i);\n    }\n\n    std::queue<int> indexQueue;\n    std::vector<bool> visited(arraySize, false);\n\n    indexQueue.push(0);\n    visited[0]= true;\n    int steps= 0;\n\n    while(!indexQueue.empty())\n    {\n        int queueSize= indexQueue.size();\n\n        for(int i= 0; i < queueSize; ++i)\n        {\n            int currentIndex= indexQueue.front();\n            indexQueue.pop();\n\n            if(currentIndex == arraySize - 1)\n                return steps;\n\n            if(currentIndex > 0 && !visited[currentIndex - 1])\n            {\n                indexQueue.push(currentIndex - 1);\n                visited[currentIndex - 1]= true;\n            }\n\n            if(currentIndex < arraySize - 1 && !visited[currentIndex + 1])\n            {\n                indexQueue.push(currentIndex + 1);\n                visited[currentIndex + 1]= true;\n            }\n\n            for(int neighborIndex : valueIndices[array[currentIndex]])\n            {\n                if(!visited[neighborIndex])\n                {\n                    indexQueue.push(neighborIndex);\n                    visited[neighborIndex]= true;\n                }\n            }\n\n            valueIndices[array[currentIndex]].clear();\n        }\n\n        ++steps;\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For INT_MIN\nusing namespace std;\n\nint maxValueInStack(vector<int> &numbers, int limit)\n{\n    int totalElements= numbers.size();\n    if(limit >= totalElements)\n        return -1;\n\n    int maximumValue= INT_MIN;\n    for(int index= 0; index <= limit; ++index)\n    {\n        maximumValue= max(maximumValue, numbers[index]);\n    }\n    return maximumValue;\n}",
    "output": "#include <bits/stdc++.h>\n// for INT_MIN\n // for std::max\n\nint maxValueInStack(std::vector<int> &numbers, int limit)\n{\n    int totalElements = numbers.size();\n    if (limit >= totalElements)\n        return -1;\n\n    int maximumValue = INT_MIN;\n    for (int index = 0; index <= limit; ++index)\n    {\n        maximumValue = std::max(maximumValue, numbers[index]);\n    }\n    return maximumValue;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For abs function\nusing namespace std;\n\nint calculateMinimumSteps(string sourceString, string targetString)\n{\n    vector<int> sourceCharacterCount(26, 0);\n    vector<int> targetCharacterCount(26, 0);\n    for (int i = 0; i < sourceString.size(); ++i)\n        sourceCharacterCount[sourceString[i] - 'a']++;\n    for (int i = 0; i < targetString.size(); ++i)\n        targetCharacterCount[targetString[i] - 'a']++;\n    int minimumSteps = 0;\n    for (int index = 0; index < 26; index++)\n    {\n        minimumSteps += abs(sourceCharacterCount[index] - targetCharacterCount[index]);\n    }\n    return minimumSteps / 2;\n}",
    "output": "#include <bits/stdc++.h>\n// for abs\n\nint calculateMinimumSteps(std::string sourceString, std::string targetString)\n{\n    std::vector<int> sourceCharacterCount(26, 0);\n    std::vector<int> targetCharacterCount(26, 0);\n    for(char character : sourceString)\n        sourceCharacterCount[character - 'a']++;\n    for(char character : targetString)\n        targetCharacterCount[character - 'a']++;\n    int minimumSteps= 0;\n    for(int index= 0; index < 26; index++)\n    {\n        minimumSteps+= std::abs(sourceCharacterCount[index] - targetCharacterCount[index]);\n    }\n    return minimumSteps / 2;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TweetCounts\n{\n  public:\n    TweetCounts() {}\n\n    void recordTweet(string tweetName, int timestamp)\n    {\n        tweetData[tweetName][timestamp]++;\n    }\n\n    vector<int> getTweetCountsPerFrequency(string frequency, string tweetName, int startTime, int endTime)\n    {\n        int timeStep = (frequency == \"minute\") ? 60 : (frequency == \"hour\") ? 3600 : 86400;\n        vector<int> countChunks((endTime - startTime) / timeStep + 1, 0);\n\n        if(tweetData.count(tweetName))\n        {\n            for(auto timeCountPair : tweetData[tweetName])\n            {\n                int chunkIndex = (timeCountPair.first - startTime) / timeStep;\n                if(chunkIndex >= 0 && chunkIndex < countChunks.size())\n                {\n                    countChunks[chunkIndex] += timeCountPair.second;\n                }\n            }\n        }\n\n        return countChunks;\n    }\n\n  private:\n    unordered_map<string, map<int, int>> tweetData;\n};",
    "output": "#include <bits/stdc++.h>\nclass TweetCounts\n{\n  public:\n    TweetCounts() {}\n\n    void recordTweet(std::string tweetName, int timestamp)\n    {\n        tweetData[tweetName][timestamp]++;\n    }\n\n    std::vector<int> getTweetCountsPerFrequency(std::string frequency, std::string tweetName, int startTime, int endTime)\n    {\n        int timeStep= (frequency == \"minute\") ? 60 : (frequency == \"hour\") ? 3600\n                                                                           : 86400;\n        std::vector<int> countChunks((endTime - startTime) / timeStep + 1, 0);\n\n        if(tweetData.count(tweetName))\n        {\n            for(auto timeCountPair : tweetData[tweetName])\n            {\n                int chunkIndex= (timeCountPair.first - startTime) / timeStep;\n                if(chunkIndex >= 0 && chunkIndex < countChunks.size())\n                {\n                    countChunks[chunkIndex]+= timeCountPair.second;\n                }\n            }\n        }\n\n        return countChunks;\n    }\n\n  private:\n    std::unordered_map<std::string, std::map<int, int>> tweetData;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool checkStraightLine(vector<vector<int>> &pointCoordinates)\n{\n    int deltaX= pointCoordinates[1][0] - pointCoordinates[0][0];\n    int deltaY= pointCoordinates[1][1] - pointCoordinates[0][1];\n\n    for(int index= 2; index < pointCoordinates.size(); ++index)\n    {\n        int relativeX= pointCoordinates[index][0] - pointCoordinates[0][0];\n        int relativeY= pointCoordinates[index][1] - pointCoordinates[0][1];\n        if(deltaX * relativeY != deltaY * relativeX)\n            return false;\n    }\n\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool checkStraightLine(std::vector<std::vector<int>> &pointCoordinates)\n{\n    int deltaX = pointCoordinates[1][0] - pointCoordinates[0][0];\n    int deltaY = pointCoordinates[1][1] - pointCoordinates[0][1];\n\n    for(int index = 2; index < pointCoordinates.size(); ++index)\n    {\n        int relativeX = pointCoordinates[index][0] - pointCoordinates[0][0];\n        int relativeY = pointCoordinates[index][1] - pointCoordinates[0][1];\n        if(deltaX * relativeY != deltaY * relativeX)\n            return false;\n    }\n\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint balancedString(string inputString)\n{\n    int stringLength = inputString.size();\n    unordered_map<char, int> characterFrequencyMap;\n    for (char character : inputString)\n        characterFrequencyMap[character]++;\n\n    int startIndex = 0, minimumLength = stringLength;\n    for (int endIndex = 0; endIndex < stringLength; endIndex++)\n    {\n        characterFrequencyMap[inputString[endIndex]]--;\n        while (startIndex < stringLength && characterFrequencyMap['Q'] <= stringLength / 4 && characterFrequencyMap['W'] <= stringLength / 4 && characterFrequencyMap['E'] <= stringLength / 4 && characterFrequencyMap['R'] <= stringLength / 4)\n        {\n            minimumLength = min(minimumLength, endIndex - startIndex + 1);\n            characterFrequencyMap[inputString[startIndex]]++;\n            startIndex++;\n        }\n    }\n    return minimumLength;\n}",
    "output": "#include <bits/stdc++.h>\nint balancedString(std::string inputString)\n{\n    int stringLength= inputString.size();\n    std::unordered_map<char, int> characterFrequencyMap;\n    for(char character : inputString)\n        characterFrequencyMap[character]++;\n\n    int startIndex= 0, minimumLength= stringLength;\n    for(int endIndex= 0; endIndex < stringLength; endIndex++)\n    {\n        characterFrequencyMap[inputString[endIndex]]--;\n        while(startIndex < stringLength && characterFrequencyMap['Q'] <= stringLength / 4 && characterFrequencyMap['W'] <= stringLength / 4 && characterFrequencyMap['E'] <= stringLength / 4 && characterFrequencyMap['R'] <= stringLength / 4)\n        {\n            minimumLength= std::min(minimumLength, endIndex - startIndex + 1);\n            characterFrequencyMap[inputString[startIndex]]++;\n            startIndex++;\n        }\n    }\n    return minimumLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Job\n{\n    int startTime;\n    int endTime;\n    int profit;\n};\n\nint findNextJob(vector<Job> &jobs, int currentIndex)\n{\n    for(int nextIndex= currentIndex + 1; nextIndex < jobs.size(); nextIndex++)\n    {\n        if(jobs[nextIndex].startTime >= jobs[currentIndex].endTime)\n        {\n            return nextIndex;\n        }\n    }\n    return -1;\n}\n\nint maxProfitHelper(vector<Job> &jobs, vector<int> &memoization, int currentIndex)\n{\n    if(currentIndex == -1)\n        return 0;\n    if(memoization[currentIndex] != -1)\n        return memoization[currentIndex];\n\n    int nextJobIndex= findNextJob(jobs, currentIndex);\n    int includeCurrentJobProfit= jobs[currentIndex].profit + maxProfitHelper(jobs, memoization, nextJobIndex);\n    int excludeCurrentJobProfit= maxProfitHelper(jobs, memoization, currentIndex - 1);\n\n    memoization[currentIndex]= max(includeCurrentJobProfit, excludeCurrentJobProfit);\n    return memoization[currentIndex];\n}\n\nint maxProfit(vector<int> &startTimes, vector<int> &endTimes, vector<int> &profits)\n{\n    int jobCount= startTimes.size();\n    vector<Job> jobs(jobCount);\n\n    for(int i= 0; i < jobCount; i++)\n    {\n        jobs[i]= {startTimes[i], endTimes[i], profits[i]};\n    }\n\n    sort(jobs.begin(), jobs.end(), [](const Job &a, const Job &b)\n         { return a.endTime < b.endTime; });\n\n    vector<int> memoization(jobCount, -1);\n    return maxProfitHelper(jobs, memoization, jobCount - 1);\n}",
    "output": "#include <bits/stdc++.h>\nstruct Job\n{\n    int startTime;\n    int endTime;\n    int profit;\n};\n\nint findNextJob(std::vector<Job> &jobs, int currentIndex)\n{\n    for(int nextIndex= currentIndex + 1; nextIndex < jobs.size(); nextIndex++)\n    {\n        if(jobs[nextIndex].startTime >= jobs[currentIndex].endTime)\n        {\n            return nextIndex;\n        }\n    }\n    return -1;\n}\n\nint maxProfitHelper(std::vector<Job> &jobs, std::vector<int> &memoization, int currentIndex)\n{\n    if(currentIndex == -1)\n        return 0;\n    if(memoization[currentIndex] != -1)\n        return memoization[currentIndex];\n\n    int nextJobIndex= findNextJob(jobs, currentIndex);\n    int includeCurrentJobProfit= jobs[currentIndex].profit + maxProfitHelper(jobs, memoization, nextJobIndex);\n    int excludeCurrentJobProfit= maxProfitHelper(jobs, memoization, currentIndex - 1);\n\n    memoization[currentIndex]= std::max(includeCurrentJobProfit, excludeCurrentJobProfit);\n    return memoization[currentIndex];\n}\n\nint maxProfit(std::vector<int> &startTimes, std::vector<int> &endTimes, std::vector<int> &profits)\n{\n    int jobCount= startTimes.size();\n    std::vector<Job> jobs(jobCount);\n\n    for(int i= 0; i < jobCount; i++)\n    {\n        jobs[i]= {startTimes[i], endTimes[i], profits[i]};\n    }\n\n    std::sort(jobs.begin(), jobs.end(), [](const Job &a, const Job &b)\n         { return a.endTime < b.endTime; });\n\n    std::vector<int> memoization(jobCount, -1);\n    return maxProfitHelper(jobs, memoization, jobCount - 1);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool compareEvents(const vector<int> &event1, const vector<int> &event2)\n{\n    return event1[0] < event2[0];\n}\n\nint maxEvents(vector<vector<int>> &eventList)\n{\n    sort(eventList.begin(), eventList.end(), compareEvents);\n    priority_queue<int, vector<int>, greater<int>> minHeap;\n    int totalEventCount = 0, currentDay = 0;\n\n    for (int i = 0; i < eventList.size(); ++i)\n    {\n        auto &event = eventList[i];\n        while (!minHeap.empty() && minHeap.top() < event[0])\n        {\n            minHeap.pop();\n        }\n        minHeap.push(event[1]);\n        totalEventCount++;\n        currentDay++;\n    }\n\n    return totalEventCount;\n}",
    "output": "#include <bits/stdc++.h>\nbool compareEvents(const std::vector<int> &event1, const std::vector<int> &event2)\n{\n    return event1[0] < event2[0];\n}\n\nint maxEvents(std::vector<std::vector<int>> &eventList)\n{\n    std::sort(eventList.begin(), eventList.end(), compareEvents);\n    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;\n    int totalEventCount = 0, currentDay = 0;\n\n    for(auto &event : eventList)\n    {\n        while(!minHeap.empty() && minHeap.top() < event[0])\n        {\n            minHeap.pop();\n        }\n        minHeap.push(event[1]);\n        totalEventCount++;\n        currentDay++;\n    }\n\n    return totalEventCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> getWinnersAndLosers(vector<vector<int>> &matchResults)\n{\n    set<int> winnerSet, loserSet;\n    for (int i = 0; i < matchResults.size(); ++i)\n    {\n        vector<int> &match = matchResults[i];\n        winnerSet.insert(match[0]);\n        loserSet.insert(match[1]);\n    }\n    return {vector<int>(winnerSet.begin(), winnerSet.end()), vector<int>(loserSet.begin(), loserSet.end())};\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> getWinnersAndLosers(std::vector<std::vector<int>> &matchResults)\n{\n    std::set<int> winnerSet, loserSet;\n    for(std::vector<int> &match : matchResults)\n    {\n        winnerSet.insert(match[0]);\n        loserSet.insert(match[1]);\n    }\n    return {std::vector<int>(winnerSet.begin(), winnerSet.end()), std::vector<int>(loserSet.begin(), loserSet.end())};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minMovesToPalindrome(string inputString)\n{\n    int moveCount= 0;\n    int leftIndex= 0, rightIndex= inputString.length() - 1;\n\n    while(leftIndex < rightIndex)\n    {\n        if(inputString[leftIndex] != inputString[rightIndex])\n        {\n            int tempRightIndex= rightIndex;\n\n            while(inputString[leftIndex] != inputString[tempRightIndex])\n            {\n                tempRightIndex--;\n            }\n            inputString.erase(inputString.begin() + tempRightIndex);\n            inputString.insert(inputString.begin() + rightIndex, inputString[leftIndex]);\n            moveCount+= rightIndex - tempRightIndex;\n        }\n        leftIndex++;\n        rightIndex--;\n    }\n\n    return moveCount;\n}",
    "output": "#include <bits/stdc++.h>\nint minMovesToPalindrome(std::string inputString)\n{\n    int moveCount= 0;\n    int leftIndex= 0, rightIndex= inputString.length() - 1;\n\n    while(leftIndex < rightIndex)\n    {\n        if(inputString[leftIndex] != inputString[rightIndex])\n        {\n            int tempRightIndex= rightIndex;\n\n            while(inputString[leftIndex] != inputString[tempRightIndex])\n            {\n                tempRightIndex--;\n            }\n            inputString.erase(inputString.begin() + tempRightIndex);\n            inputString.insert(inputString.begin() + rightIndex, inputString[leftIndex]);\n            moveCount+= rightIndex - tempRightIndex;\n        }\n        leftIndex++;\n        rightIndex--;\n    }\n\n    return moveCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Cashier\n{\n    int numberOfCustomers;\n    int discountPercentage;\n    int customerCount;\n    map<int, int> pricesMap;\n\n  public:\n    Cashier(int numberOfCustomers, int discountPercentage, vector<int> &products, vector<int> &prices)\n    {\n        this->numberOfCustomers= numberOfCustomers;\n        this->discountPercentage= discountPercentage;\n        customerCount= 0;\n        for(int index= 0; index < products.size(); ++index)\n        {\n            pricesMap[products[index]]= prices[index];\n        }\n    }\n\n    double getBill(vector<int> productIds, vector<int> quantities)\n    {\n        customerCount++;\n        double totalAmount= 0;\n        for(int index= 0; index < productIds.size(); ++index)\n        {\n            totalAmount+= pricesMap[productIds[index]] * quantities[index];\n        }\n        if(customerCount % numberOfCustomers == 0)\n        {\n            totalAmount*= (100 - discountPercentage) / 100.0;\n        }\n        return totalAmount;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Cashier\n{\n    int numberOfCustomers;\n    int discountPercentage;\n    int customerCount;\n    std::map<int, int> pricesMap;\n\n  public:\n    Cashier(int numberOfCustomers, int discountPercentage, std::vector<int> &products, std::vector<int> &prices)\n    {\n        this->numberOfCustomers= numberOfCustomers;\n        this->discountPercentage= discountPercentage;\n        customerCount= 0;\n        for(int index= 0; index < products.size(); ++index)\n        {\n            pricesMap[products[index]]= prices[index];\n        }\n    }\n\n    double getBill(std::vector<int> productIds, std::vector<int> quantities)\n    {\n        customerCount++;\n        double totalAmount= 0;\n        for(int index= 0; index < productIds.size(); ++index)\n        {\n            totalAmount+= pricesMap[productIds[index]] * quantities[index];\n        }\n        if(customerCount % numberOfCustomers == 0)\n        {\n            totalAmount*= (100 - discountPercentage) / 100.0;\n        }\n        return totalAmount;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int, int>> findPairs(int targetSum)\n{\n    vector<pair<int, int>> foundPairs;\n\n    int calculateSum(int firstNum, int secondNum)\n    {\n        return firstNum + secondNum;\n    }\n\n    for(int firstNum = 1; firstNum <= targetSum; firstNum++)\n    {\n        for(int secondNum = 1; secondNum <= targetSum; secondNum++)\n        {\n            if(calculateSum(firstNum, secondNum) == targetSum)\n            {\n                foundPairs.push_back(make_pair(firstNum, secondNum));\n            }\n        }\n    }\n    return foundPairs;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::pair<int, int>> findPairs(int targetSum)\n{\n    std::vector<std::pair<int, int>> foundPairs;\n\n    int calculateSum(int firstNum, int secondNum)\n    {\n        return firstNum + secondNum;\n    }\n\n    for(int firstNum= 1; firstNum <= targetSum; firstNum++)\n    {\n        for(int secondNum= 1; secondNum <= targetSum; secondNum++)\n        {\n            if(calculateSum(firstNum, secondNum) == targetSum)\n            {\n                foundPairs.push_back(std::make_pair(firstNum, secondNum));\n            }\n        }\n    }\n    return foundPairs;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> circularPermutation(int numBits, int startValue)\n{\n    vector<int> permutationResult(1 << numBits);\n    for(int index= 0; index < (1 << numBits); ++index)\n    {\n        permutationResult[index]= startValue ^ (index ^ (index >> 1));\n    }\n    return permutationResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> circularPermutation(int numBits, int startValue)\n{\n    std::vector<int> permutationResult(1 << numBits);\n    for(int index= 0; index < (1 << numBits); ++index)\n    {\n        permutationResult[index]= startValue ^ (index ^ (index >> 1));\n    }\n    return permutationResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// Make sure to include this header for unordered_set\n\nusing namespace std;\n\nint maxLength(vector<string> &stringArray)\n{\n    vector<string> uniqueCombinations = {\"\"};\n\n    int maximumLength = 0;\n    for (int i = 0; i < stringArray.size(); ++i)\n    {\n        string currentString = stringArray[i];\n        if (unordered_set<char>(currentString.begin(), currentString.end()).size() < currentString.size())\n            continue;\n        for (int index = uniqueCombinations.size() - 1; index >= 0; --index)\n        {\n            string combinedString = uniqueCombinations[index] + currentString;\n            if (unordered_set<char>(combinedString.begin(), combinedString.end()).size() == combinedString.size())\n            {\n                uniqueCombinations.push_back(combinedString);\n                maximumLength = max(maximumLength, (int)combinedString.size());\n            }\n        }\n    }\n\n    return maximumLength;\n}",
    "output": "#include <bits/stdc++.h>\nint maxLength(std::vector<std::string> &stringArray)\n{\n    std::vector<std::string> uniqueCombinations= {\"\"};\n\n    int maximumLength= 0;\n    for(std::string currentString : stringArray)\n    {\n        if(std::unordered_set<char>(currentString.begin(), currentString.end()).size() < currentString.size())\n            continue;\n        for(int index= uniqueCombinations.size() - 1; index >= 0; --index)\n        {\n            std::string combinedString= uniqueCombinations[index] + currentString;\n            if(std::unordered_set<char>(combinedString.begin(), combinedString.end()).size() == combinedString.size())\n            {\n                uniqueCombinations.push_back(combinedString);\n                maximumLength= std::max(maximumLength, (int)combinedString.size());\n            }\n        }\n    }\n\n    return maximumLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint tilingRectangle(int width, int height)\n{\n    if(width > height)\n        swap(width, height);\n    if(width == 1)\n        return height;\n    if(width == height)\n        return 1;\n\n    int minimumTiles = INT_MAX;\n    for(int halfWidth = 1; halfWidth <= width / 2; ++halfWidth)\n    {\n        minimumTiles = min(minimumTiles, tilingRectangle(halfWidth, height) + tilingRectangle(width - halfWidth, height));\n    }\n    for(int halfHeight = 1; halfHeight <= height / 2; ++halfHeight)\n    {\n        minimumTiles = min(minimumTiles, tilingRectangle(width, halfHeight) + tilingRectangle(width, height - halfHeight));\n    }\n    return minimumTiles;\n}",
    "output": "int tilingRectangle(int width, int height)\n{\n    if(width > height)\n        std::swap(width, height);\n    if(width == 1)\n        return height;\n    if(width == height)\n        return 1;\n\n    int minimumTiles= INT_MAX;\n    for(int halfWidth= 1; halfWidth <= width / 2; ++halfWidth)\n    {\n        minimumTiles= std::min(minimumTiles, tilingRectangle(halfWidth, height) + tilingRectangle(width - halfWidth, height));\n    }\n    for(int halfHeight= 1; halfHeight <= height / 2; ++halfHeight)\n    {\n        minimumTiles= std::min(minimumTiles, tilingRectangle(width, halfHeight) + tilingRectangle(width, height - halfHeight));\n    }\n    return minimumTiles;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findClosestDivisors(int inputNumber)\n{\n    for(int divisor= int(sqrt(inputNumber + 2)); divisor >= 1; divisor--)\n    {\n        if((inputNumber + 1) % divisor == 0)\n            return {divisor, (inputNumber + 1) / divisor};\n        if((inputNumber + 2) % divisor == 0)\n            return {divisor, (inputNumber + 2) / divisor};\n    }\n    return {};\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findClosestDivisors(int inputNumber)\n{\n    for(int divisor= int(std::sqrt(inputNumber + 2)); divisor >= 1; divisor--)\n    {\n        if((inputNumber + 1) % divisor == 0)\n            return {divisor, (inputNumber + 1) / divisor};\n        if((inputNumber + 2) % divisor == 0)\n            return {divisor, (inputNumber + 2) / divisor};\n    }\n    return {};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestMultipleOfThree(vector<int> &digits)\n{\n    sort(digits.rbegin(), digits.rend());\n    int totalSum = 0;\n    for (int digit : digits)\n    {\n        totalSum += digit;\n    }\n\n    if (totalSum % 3 == 0)\n    {\n        if (digits.back() == 0)\n            return \"0\";\n        string result(digits.begin(), digits.end());\n        return result;\n    }\n\n    vector<int> moduloGroups[3];\n    for (int digit : digits)\n    {\n        moduloGroups[digit % 3].push_back(digit);\n    }\n\n    if (totalSum % 3 == 1)\n    {\n        if (!moduloGroups[1].empty())\n        {\n            moduloGroups[1].pop_back();\n        }\n        else\n        {\n            moduloGroups[2].pop_back();\n            moduloGroups[2].pop_back();\n        }\n    }\n    else\n    {\n        if (!moduloGroups[2].empty())\n        {\n            moduloGroups[2].pop_back();\n        }\n        else\n        {\n            moduloGroups[1].pop_back();\n            moduloGroups[1].pop_back();\n        }\n    }\n\n    string result;\n    for (int i = 0; i < 3; ++i)\n    {\n        for (int j = 0; j < moduloGroups[i].size(); ++j)\n        {\n            int digit = moduloGroups[i][j];\n            result += to_string(digit);\n        }\n    }\n\n    sort(result.rbegin(), result.rend());\n    if (result.empty() || result[0] == '0')\n    {\n        return \"0\";\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string largestMultipleOfThree(std::vector<int> &digits)\n{\n    std::sort(digits.rbegin(), digits.rend());\n    int totalSum= 0;\n    for(int digit : digits)\n    {\n        totalSum+= digit;\n    }\n\n    if(totalSum % 3 == 0)\n    {\n        if(digits.back() == 0)\n            return \"0\";\n        std::string result(digits.begin(), digits.end());\n        return result;\n    }\n\n    std::vector<int> moduloGroups[3];\n    for(int digit : digits)\n    {\n        moduloGroups[digit % 3].push_back(digit);\n    }\n\n    if(totalSum % 3 == 1)\n    {\n        if(!moduloGroups[1].empty())\n        {\n            moduloGroups[1].pop_back();\n        }\n        else\n        {\n            moduloGroups[2].pop_back();\n            moduloGroups[2].pop_back();\n        }\n    }\n    else\n    {\n        if(!moduloGroups[2].empty())\n        {\n            moduloGroups[2].pop_back();\n        }\n        else\n        {\n            moduloGroups[1].pop_back();\n            moduloGroups[1].pop_back();\n        }\n    }\n\n    std::string result;\n    for(int i= 0; i < 3; ++i)\n    {\n        for(int digit : moduloGroups[i])\n        {\n            result+= std::to_string(digit);\n        }\n    }\n\n    std::sort(result.rbegin(), result.rend());\n    if(result.empty() || result[0] == '0')\n    {\n        return \"0\";\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> smallerNumbersThanCurrent(vector<int> &inputNumbers)\n{\n    vector<int> result(inputNumbers.size());\n    for(int currentIndex= 0; currentIndex < inputNumbers.size(); currentIndex++)\n    {\n        int smallerCount= 0;\n        for(int comparisonIndex= 0; comparisonIndex < inputNumbers.size(); comparisonIndex++)\n        {\n            if(currentIndex != comparisonIndex && inputNumbers[comparisonIndex] < inputNumbers[currentIndex])\n            {\n                smallerCount++;\n            }\n        }\n        result[currentIndex]= smallerCount;\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> smallerNumbersThanCurrent(std::vector<int> &inputNumbers)\n{\n    std::vector<int> result(inputNumbers.size());\n    for(int currentIndex= 0; currentIndex < inputNumbers.size(); currentIndex++)\n    {\n        int smallerCount= 0;\n        for(int comparisonIndex= 0; comparisonIndex < inputNumbers.size(); comparisonIndex++)\n        {\n            if(currentIndex != comparisonIndex && inputNumbers[comparisonIndex] < inputNumbers[currentIndex])\n            {\n                smallerCount++;\n            }\n        }\n        result[currentIndex]= smallerCount;\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring rankTeams(vector<string> &votes)\n{\n    int numberOfVotes= votes.size(), numberOfTeams= votes[0].size();\n    vector<vector<int>> teamVoteCount(26, vector<int>(numberOfTeams, 0));\n    string rankedTeams= votes[0];\n    for(int voteIndex= 0; voteIndex < numberOfVotes; voteIndex++)\n    {\n        for(int teamIndex= 0; teamIndex < numberOfTeams; teamIndex++)\n        {\n            teamVoteCount[votes[voteIndex][teamIndex] - 'A'][teamIndex]++;\n        }\n    }\n    sort(rankedTeams.begin(), rankedTeams.end(), [&](char teamA, char teamB)\n              {\n        for (int teamIndex = 0; teamIndex < numberOfTeams; teamIndex++) {\n            if (teamVoteCount[teamA - 'A'][teamIndex] != teamVoteCount[teamB - 'A'][teamIndex]) {\n                return teamVoteCount[teamA - 'A'][teamIndex] > teamVoteCount[teamB - 'A'][teamIndex];\n            }\n        }\n        return teamA < teamB; });\n\n    return rankedTeams;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string rankTeams(std::vector<std::string> &votes)\n{\n    int numberOfVotes= votes.size(), numberOfTeams= votes[0].size();\n    std::vector<std::vector<int>> teamVoteCount(26, std::vector<int>(numberOfTeams, 0));\n    std::string rankedTeams= votes[0];\n    for(int voteIndex= 0; voteIndex < numberOfVotes; voteIndex++)\n    {\n        for(int teamIndex= 0; teamIndex < numberOfTeams; teamIndex++)\n        {\n            teamVoteCount[votes[voteIndex][teamIndex] - 'A'][teamIndex]++;\n        }\n    }\n    std::sort(rankedTeams.begin(), rankedTeams.end(), [&](char teamA, char teamB)\n              {\n        for (int teamIndex = 0; teamIndex < numberOfTeams; teamIndex++) {\n            if (teamVoteCount[teamA - 'A'][teamIndex] != teamVoteCount[teamB - 'A'][teamIndex]) {\n                return teamVoteCount[teamA - 'A'][teamIndex] > teamVoteCount[teamB - 'A'][teamIndex];\n            }\n        }\n        return teamA < teamB; });\n\n    return rankedTeams;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxHeight(vector<vector<int>> &cuboids)\n{\n    for (auto &cuboid : cuboids)\n        sort(cuboid.begin(), cuboid.end());\n\n    sort(cuboids.begin(), cuboids.end());\n\n    int numberOfCuboids = cuboids.size();\n    vector<int> heightDP(numberOfCuboids);\n    int maximumHeight = 0;\n\n    for (int currentCuboidIndex = 0; currentCuboidIndex < numberOfCuboids; currentCuboidIndex++)\n    {\n        heightDP[currentCuboidIndex] = cuboids[currentCuboidIndex][2];\n        for (int previousCuboidIndex = 0; previousCuboidIndex < currentCuboidIndex; previousCuboidIndex++)\n        {\n            if (cuboids[previousCuboidIndex][0] <= cuboids[currentCuboidIndex][0] &&\n                cuboids[previousCuboidIndex][1] <= cuboids[currentCuboidIndex][1] &&\n                cuboids[previousCuboidIndex][2] <= cuboids[currentCuboidIndex][2])\n            {\n                heightDP[currentCuboidIndex] = max(heightDP[currentCuboidIndex], heightDP[previousCuboidIndex] + cuboids[currentCuboidIndex][2]);\n            }\n        }\n        maximumHeight = max(maximumHeight, heightDP[currentCuboidIndex]);\n    }\n    return maximumHeight;\n}",
    "output": "#include <bits/stdc++.h>\nint maxHeight(std::vector<std::vector<int>> &cuboids)\n{\n    for(auto &cuboid : cuboids)\n        std::sort(cuboid.begin(), cuboid.end());\n\n    std::sort(cuboids.begin(), cuboids.end());\n\n    int numberOfCuboids= cuboids.size();\n    std::vector<int> heightDP(numberOfCuboids);\n    int maximumHeight= 0;\n\n    for(int currentCuboidIndex= 0; currentCuboidIndex < numberOfCuboids; currentCuboidIndex++)\n    {\n        heightDP[currentCuboidIndex]= cuboids[currentCuboidIndex][2];\n        for(int previousCuboidIndex= 0; previousCuboidIndex < currentCuboidIndex; previousCuboidIndex++)\n        {\n            if(cuboids[previousCuboidIndex][0] <= cuboids[currentCuboidIndex][0] &&\n               cuboids[previousCuboidIndex][1] <= cuboids[currentCuboidIndex][1] &&\n               cuboids[previousCuboidIndex][2] <= cuboids[currentCuboidIndex][2])\n            {\n                heightDP[currentCuboidIndex]= std::max(heightDP[currentCuboidIndex], heightDP[previousCuboidIndex] + cuboids[currentCuboidIndex][2]);\n            }\n        }\n        maximumHeight= std::max(maximumHeight, heightDP[currentCuboidIndex]);\n    }\n    return maximumHeight;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minCost(vector<vector<int>> &grid)\n{\n    int rowCount= grid.size(), columnCount= grid[0].size(), totalCost= 0;\n\n    vector<vector<int>> visitedCost(rowCount, vector<int>(columnCount, 1000000));\n    queue<pair<int, int>> positionQueue;\n    positionQueue.push({0, 0});\n    visitedCost[0][0]= 0;\n\n    while(!positionQueue.empty())\n    {\n        pair<int, int> currentPosition= positionQueue.front();\n        positionQueue.pop();\n        int currentRow= currentPosition.first, currentColumn= currentPosition.second;\n        if(currentRow == rowCount - 1 && currentColumn == columnCount - 1)\n        {\n            totalCost= visitedCost[currentRow][currentColumn];\n            break;\n        }\n\n        int deltaX[4]= {1, 0, -1, 0};\n        int deltaY[4]= {0, 1, 0, -1};\n\n        for(int direction= 0; direction < 4; ++direction)\n        {\n            int newRow= currentRow + deltaY[direction], newColumn= currentColumn + deltaX[direction];\n            if(0 <= newRow && newRow < rowCount && 0 <= newColumn && newColumn < columnCount)\n            {\n                int newCost= visitedCost[currentRow][currentColumn] + (direction + 1 != grid[currentRow][currentColumn]);\n                if(newCost < visitedCost[newRow][newColumn])\n                {\n                    visitedCost[newRow][newColumn]= newCost;\n                    positionQueue.push({newRow, newColumn});\n                }\n            }\n        }\n    }\n    return totalCost;\n}",
    "output": "#include <bits/stdc++.h>\nint minCost(std::vector<std::vector<int>> &grid)\n{\n    int rowCount = grid.size(), columnCount = grid[0].size(), totalCost = 0;\n\n    std::vector<std::vector<int>> visitedCost(rowCount, std::vector<int>(columnCount, 1000000));\n    std::queue<std::pair<int, int>> positionQueue;\n    positionQueue.push({0, 0});\n    visitedCost[0][0] = 0;\n\n    while (!positionQueue.empty())\n    {\n        std::pair<int, int> currentPosition = positionQueue.front();\n        positionQueue.pop();\n        int currentRow = currentPosition.first, currentColumn = currentPosition.second;\n        if (currentRow == rowCount - 1 && currentColumn == columnCount - 1)\n        {\n            totalCost = visitedCost[currentRow][currentColumn];\n            break;\n        }\n\n        int deltaX[4] = {1, 0, -1, 0};\n        int deltaY[4] = {0, 1, 0, -1};\n\n        for (int direction = 0; direction < 4; ++direction)\n        {\n            int newRow = currentRow + deltaY[direction], newColumn = currentColumn + deltaX[direction];\n            if (0 <= newRow && newRow < rowCount && 0 <= newColumn && newColumn < columnCount)\n            {\n                int newCost = visitedCost[currentRow][currentColumn] + (direction + 1 != grid[currentRow][currentColumn]);\n                if (newCost < visitedCost[newRow][newColumn])\n                {\n                    visitedCost[newRow][newColumn] = newCost;\n                    positionQueue.push({newRow, newColumn});\n                }\n            }\n        }\n    }\n    return totalCost;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countOfSubarrays(vector<int> &numbers, int targetOddCount)\n{\n    int arraySize= numbers.size(), subarrayCount= 0, oddCount= 0;\n    vector<int> oddCountPrefix(arraySize + 1, 0);\n\n    oddCountPrefix[0]= 1;\n    for(int index= 0; index < arraySize; index++)\n    {\n        oddCount+= numbers[index] % 2;\n        if(oddCount >= targetOddCount)\n            subarrayCount+= oddCountPrefix[oddCount - targetOddCount];\n        oddCountPrefix[oddCount]++;\n    }\n\n    return subarrayCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countOfSubarrays(std::vector<int> &numbers, int targetOddCount)\n{\n    int arraySize = numbers.size(), subarrayCount = 0, oddCount = 0;\n    std::vector<int> oddCountPrefix(arraySize + 1, 0);\n\n    oddCountPrefix[0] = 1;\n    for(int index = 0; index < arraySize; index++)\n    {\n        oddCount += numbers[index] % 2;\n        if(oddCount >= targetOddCount)\n            subarrayCount += oddCountPrefix[oddCount - targetOddCount];\n        oddCountPrefix[oddCount]++;\n    }\n\n    return subarrayCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring minRemoveToMakeValid(const string &inputString)\n{\n    stack<int> indexStack;\n    string resultString = inputString;\n\n    for(int currentIndex = 0; currentIndex < inputString.size(); currentIndex++)\n    {\n        if(inputString[currentIndex] == '(')\n        {\n            indexStack.push(currentIndex);\n        }\n        else if(inputString[currentIndex] == ')')\n        {\n            if(!indexStack.empty())\n            {\n                indexStack.pop();\n            }\n            else\n            {\n                resultString[currentIndex] = '-';\n            }\n        }\n    }\n\n    while(!indexStack.empty())\n    {\n        resultString[indexStack.top()] = '-';\n        indexStack.pop();\n    }\n\n    resultString.erase(remove(resultString.begin(), resultString.end(), '-'), resultString.end());\n    return resultString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string minRemoveToMakeValid(const std::string &inputString)\n{\n    std::stack<int> indexStack;\n    std::string resultString= inputString;\n\n    for(int currentIndex= 0; currentIndex < inputString.size(); currentIndex++)\n    {\n        if(inputString[currentIndex] == '(')\n        {\n            indexStack.push(currentIndex);\n        }\n        else if(inputString[currentIndex] == ')')\n        {\n            if(!indexStack.empty())\n            {\n                indexStack.pop();\n            }\n            else\n            {\n                resultString[currentIndex]= '-';\n            }\n        }\n    }\n\n    while(!indexStack.empty())\n    {\n        resultString[indexStack.top()]= '-';\n        indexStack.pop();\n    }\n\n    resultString.erase(std::remove(resultString.begin(), resultString.end(), '-'), resultString.end());\n    return resultString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isGoodArray(vector<int> &numbers)\n{\n    int greatestCommonDivisor = numbers[0];\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        greatestCommonDivisor = __gcd(greatestCommonDivisor, number);\n        if (greatestCommonDivisor == 1)\n        {\n            return true;\n        }\n    }\n    return greatestCommonDivisor == 1;\n}",
    "output": "#include <bits/stdc++.h>\n// Include this for std::gcd\n\nbool isGoodArray(std::vector<int> &numbers)\n{\n    int greatestCommonDivisor = numbers[0];\n    for(int number : numbers)\n    {\n        greatestCommonDivisor = std::gcd(greatestCommonDivisor, number);\n        if(greatestCommonDivisor == 1)\n        {\n            return true;\n        }\n    }\n    return greatestCommonDivisor == 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    int maxSumBST(TreeNode *rootNode)\n    {\n        int maximumSum= 0;\n        depthFirstSearch(rootNode, maximumSum);\n        return maximumSum;\n    }\n\n  private:\n    array<int, 4> depthFirstSearch(TreeNode *currentNode, int &maximumSum)\n    {\n        if(!currentNode)\n            return {1, 0, 1e5, -1e5};\n\n        auto leftResult= depthFirstSearch(currentNode->leftChild, maximumSum);\n        auto rightResult= depthFirstSearch(currentNode->rightChild, maximumSum);\n\n        if(leftResult[0] == 0 || rightResult[0] == 0 || currentNode->value <= leftResult[3] || currentNode->value >= rightResult[2])\n            return {0, 0, 0, 0};\n\n        int currentSum= currentNode->value + leftResult[1] + rightResult[1];\n        maximumSum= max(maximumSum, currentSum);\n\n        return {1, currentSum, min(currentNode->value, leftResult[2]), max(currentNode->value, rightResult[3])};\n    }\n};",
    "output": "#include <bits/stdc++.h>\n// For std::array\n // For std::max and std::min\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    int maxSumBST(TreeNode *rootNode)\n    {\n        int maximumSum= 0;\n        depthFirstSearch(rootNode, maximumSum);\n        return maximumSum;\n    }\n\n  private:\n    std::array<int, 4> depthFirstSearch(TreeNode *currentNode, int &maximumSum)\n    {\n        if(!currentNode)\n            return {1, 0, 1e5, -1e5};\n\n        auto leftResult= depthFirstSearch(currentNode->leftChild, maximumSum);\n        auto rightResult= depthFirstSearch(currentNode->rightChild, maximumSum);\n\n        if(leftResult[0] == 0 || rightResult[0] == 0 || currentNode->value <= leftResult[3] || currentNode->value >= rightResult[2])\n            return {0, 0, 0, 0};\n\n        int currentSum= currentNode->value + leftResult[1] + rightResult[1];\n        maximumSum= std::max(maximumSum, currentSum);\n\n        return {1, currentSum, std::min(currentNode->value, leftResult[2]), std::max(currentNode->value, rightResult[3])};\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring generateTheString(int length)\n{\n    string result(length, 'a');\n    if(length % 2 == 0)\n        result[length - 1]= 'b';\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string generateTheString(int length)\n{\n    std::string result(length, 'a');\n    if(length % 2 == 0)\n        result[length - 1]= 'b';\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// Include cmath for pow function\nusing namespace std;\n\nint findKthPalindrome(int k, int palindromeLength)\n{\n    int mid = (palindromeLength + 1) / 2;\n    int limit = pow(10, mid) - 1;\n\n    for(int i = 0; i <= limit; i++)\n    {\n        string numberString = to_string(i);\n        string reversedString(numberString.rbegin(), numberString.rend());\n        if(palindromeLength % 2 != 0)\n            reversedString = reversedString.substr(1);\n        numberString += reversedString;\n        int palindromeNumber = stoi(numberString);\n        if(palindromeNumber > 0)\n            k--;\n        if(k == 0)\n            return palindromeNumber;\n    }\n    return -1;\n}\n\nvector<int> palindromeQueries(vector<int> queryList, int palindromeLength)\n{\n    vector<int> resultList;\n    for (int i = 0; i < queryList.size(); ++i)\n    {\n        int query = queryList[i];\n        resultList.push_back(findKthPalindrome(query, palindromeLength));\n    }\n    return resultList;\n}",
    "output": "#include <bits/stdc++.h>\nint findKthPalindrome(int k, int palindromeLength)\n{\n    int mid= (palindromeLength + 1) / 2;\n    int limit= pow(10, mid) - 1;\n\n    for(int i= 0; i <= limit; i++)\n    {\n        std::string numberString= std::to_string(i);\n        std::string reversedString(numberString.rbegin(), numberString.rend());\n        if(palindromeLength % 2 != 0)\n            reversedString= reversedString.substr(1);\n        numberString+= reversedString;\n        int palindromeNumber= stoi(numberString);\n        if(palindromeNumber > 0)\n            k--;\n        if(k == 0)\n            return palindromeNumber;\n    }\n    return -1;\n}\n\nstd::vector<int> palindromeQueries(std::vector<int> queryList, int palindromeLength)\n{\n    std::vector<int> resultList;\n    for(int query : queryList)\n    {\n        resultList.push_back(findKthPalindrome(query, palindromeLength));\n    }\n    return resultList;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateTotalMinutes(int totalEmployees, int headEmployeeId, vector<int> &managerList, vector<int> &informDuration)\n{\n    vector<vector<int>> employeeSubordinates(totalEmployees);\n    for(int i = 0; i < totalEmployees; ++i)\n    {\n        if(managerList[i] != -1)\n        {\n            employeeSubordinates[managerList[i]].push_back(i);\n        }\n    }\n    return depthFirstSearch(headEmployeeId, employeeSubordinates, informDuration);\n}\n\nint depthFirstSearch(int employee, vector<vector<int>> &subordinates, vector<int> &informTime)\n{\n    if(informTime[employee] == 0)\n    {\n        return 0;\n    }\n    int maxInformTime = 0;\n    for(int i = 0; i < subordinates[employee].size(); ++i)\n    {\n        int subordinate = subordinates[employee][i];\n        maxInformTime = max(maxInformTime, depthFirstSearch(subordinate, subordinates, informTime));\n    }\n    return maxInformTime + informTime[employee];\n}",
    "output": "#include <bits/stdc++.h>\nint calculateTotalMinutes(int totalEmployees, int headEmployeeId, std::vector<int> &managerList, std::vector<int> &informDuration)\n{\n    std::vector<std::vector<int>> employeeSubordinates(totalEmployees);\n    for(int i= 0; i < totalEmployees; ++i)\n    {\n        if(managerList[i] != -1)\n        {\n            employeeSubordinates[managerList[i]].push_back(i);\n        }\n    }\n    return depthFirstSearch(headEmployeeId, employeeSubordinates, informDuration);\n}\n\nint depthFirstSearch(int employee, std::vector<std::vector<int>> &subordinates, std::vector<int> &informTime)\n{\n    if(informTime[employee] == 0)\n    {\n        return 0;\n    }\n    int maxInformTime= 0;\n    for(int subordinate : subordinates[employee])\n    {\n        maxInformTime= std::max(maxInformTime, depthFirstSearch(subordinate, subordinates, informTime));\n    }\n    return maxInformTime + informTime[employee];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(int currentNode, int parentNode, int timeRemaining, int targetNode, vector<vector<int>> &graph, double probability, vector<double> &result)\n{\n    if(timeRemaining == 0)\n    {\n        if(currentNode == targetNode)\n            result[0]+= probability;\n        return;\n    }\n\n    bool hasChild= false;\n    for(int i= 0; i < graph[currentNode].size(); ++i)\n    {\n        if(graph[currentNode][i] != parentNode)\n        {\n            hasChild= true;\n            depthFirstSearch(graph[currentNode][i], currentNode, timeRemaining - 1, targetNode, graph, probability / (graph[currentNode].size() - (currentNode != 1)), result);\n        }\n    }\n\n    if(!hasChild && currentNode == targetNode)\n        result[0]+= probability;\n}\n\ndouble frogPosition(int nodeCount, vector<vector<int>> &edges, int timeLimit, int targetNode)\n{\n    vector<vector<int>> graph(nodeCount + 1);\n    for(int i= 0; i < nodeCount - 1; ++i)\n    {\n        int firstNode= edges[i][0], secondNode= edges[i][1];\n        graph[firstNode].push_back(secondNode);\n        graph[secondNode].push_back(firstNode);\n    }\n\n    vector<double> result(1, 0.0);\n    depthFirstSearch(1, -1, timeLimit, targetNode, graph, 1.0, result);\n    return result[0];\n}",
    "output": "#include <bits/stdc++.h>\nvoid depthFirstSearch(int currentNode, int parentNode, int timeRemaining, int targetNode, std::vector<std::vector<int>> &graph, double probability, std::vector<double> &result)\n{\n    if(timeRemaining == 0)\n    {\n        if(currentNode == targetNode)\n            result[0] += probability;\n        return;\n    }\n\n    bool hasChild = false;\n    for(int i = 0; i < graph[currentNode].size(); ++i)\n    {\n        if(graph[currentNode][i] != parentNode)\n        {\n            hasChild = true;\n            depthFirstSearch(graph[currentNode][i], currentNode, timeRemaining - 1, targetNode, graph, probability / (graph[currentNode].size() - (currentNode != 1)), result);\n        }\n    }\n\n    if(!hasChild && currentNode == targetNode)\n        result[0] += probability;\n}\n\ndouble frogPosition(int nodeCount, std::vector<std::vector<int>> &edges, int timeLimit, int targetNode)\n{\n    std::vector<std::vector<int>> graph(nodeCount + 1);\n    for(int i = 0; i < nodeCount - 1; ++i)\n    {\n        int firstNode = edges[i][0], secondNode = edges[i][1];\n        graph[firstNode].push_back(secondNode);\n        graph[secondNode].push_back(firstNode);\n    }\n\n    std::vector<double> result(1, 0.0);\n    depthFirstSearch(1, -1, timeLimit, targetNode, graph, 1.0, result);\n    return result[0];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> reconstructMatrix(int upperLimit, int lowerLimit, vector<int> &columnSum)\n{\n    vector<vector<int>> result(2, vector<int>(columnSum.size(), 0));\n\n    for(int i= 0; i < columnSum.size(); i++)\n    {\n        if(columnSum[i] == 2)\n        {\n            result[0][i]= 1;\n            result[1][i]= 1;\n            upperLimit--;\n            lowerLimit--;\n        }\n        else if(columnSum[i] == 1)\n        {\n            if(upperLimit > lowerLimit)\n            {\n                result[0][i]= 1;\n                upperLimit--;\n            }\n            else\n            {\n                result[1][i]= 1;\n                lowerLimit--;\n            }\n        }\n\n        if(upperLimit < 0 || lowerLimit < 0)\n        {\n            return {};\n        }\n    }\n\n    if(upperLimit > 0 || lowerLimit > 0)\n    {\n        return {};\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> reconstructMatrix(int upperLimit, int lowerLimit, std::vector<int> &columnSum)\n{\n    std::vector<std::vector<int>> result(2, std::vector<int>(columnSum.size(), 0));\n\n    for(int i= 0; i < columnSum.size(); i++)\n    {\n        if(columnSum[i] == 2)\n        {\n            result[0][i]= 1;\n            result[1][i]= 1;\n            upperLimit--;\n            lowerLimit--;\n        }\n        else if(columnSum[i] == 1)\n        {\n            if(upperLimit > lowerLimit)\n            {\n                result[0][i]= 1;\n                upperLimit--;\n            }\n            else\n            {\n                result[1][i]= 1;\n                lowerLimit--;\n            }\n        }\n\n        if(upperLimit < 0 || lowerLimit < 0)\n        {\n            return {};\n        }\n    }\n\n    if(upperLimit > 0 || lowerLimit > 0)\n    {\n        return {};\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint directionX[]= {-1, 1, 0, 0};\nint directionY[]= {0, 0, -1, 1};\n\nvoid depthFirstSearch(vector<vector<int>> &grid, int currentX, int currentY)\n{\n    int rowCount= grid.size(), columnCount= grid[0].size();\n    grid[currentX][currentY]= 1;\n    for(int index= 0; index < 4; index++)\n    {\n        int nextX= currentX + directionX[index], nextY= currentY + directionY[index];\n        if(nextX >= 0 && nextX < rowCount && nextY >= 0 && nextY < columnCount && grid[nextX][nextY] == 0)\n        {\n            depthFirstSearch(grid, nextX, nextY);\n        }\n    }\n}\n\nint countClosedIslands(vector<vector<int>> &grid)\n{\n    int rowCount= grid.size(), columnCount= grid[0].size();\n    for(int row= 0; row < rowCount; row++)\n    {\n        for(int col= 0; col < columnCount; col++)\n        {\n            if(row == 0 || row == rowCount - 1 || col == 0 || col == columnCount - 1)\n            {\n                if(grid[row][col] == 0)\n                {\n                    depthFirstSearch(grid, row, col);\n                }\n            }\n        }\n    }\n    int closedIslandCount= 0;\n    for(int row= 1; row < rowCount - 1; row++)\n    {\n        for(int col= 1; col < columnCount - 1; col++)\n        {\n            if(grid[row][col] == 0)\n            {\n                depthFirstSearch(grid, row, col);\n                closedIslandCount++;\n            }\n        }\n    }\n    return closedIslandCount;\n}",
    "output": "#include <bits/stdc++.h>\nint directionX[]= {-1, 1, 0, 0};\nint directionY[]= {0, 0, -1, 1};\n\nvoid depthFirstSearch(std::vector<std::vector<int>> &grid, int currentX, int currentY)\n{\n    int rowCount= grid.size(), columnCount= grid[0].size();\n    grid[currentX][currentY]= 1;\n    for(int index= 0; index < 4; index++)\n    {\n        int nextX= currentX + directionX[index], nextY= currentY + directionY[index];\n        if(nextX >= 0 && nextX < rowCount && nextY >= 0 && nextY < columnCount && grid[nextX][nextY] == 0)\n        {\n            depthFirstSearch(grid, nextX, nextY);\n        }\n    }\n}\n\nint countClosedIslands(std::vector<std::vector<int>> &grid)\n{\n    int rowCount= grid.size(), columnCount= grid[0].size();\n    for(int row= 0; row < rowCount; row++)\n    {\n        for(int col= 0; col < columnCount; col++)\n        {\n            if(row == 0 || row == rowCount - 1 || col == 0 || col == columnCount - 1)\n            {\n                if(grid[row][col] == 0)\n                {\n                    depthFirstSearch(grid, row, col);\n                }\n            }\n        }\n    }\n    int closedIslandCount= 0;\n    for(int row= 1; row < rowCount - 1; row++)\n    {\n        for(int col= 1; col < columnCount - 1; col++)\n        {\n            if(grid[row][col] == 0)\n            {\n                depthFirstSearch(grid, row, col);\n                closedIslandCount++;\n            }\n        }\n    }\n    return closedIslandCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxScore(const string &word, const vector<int> &score)\n{\n    int totalScore = 0;\n    for (int i = 0; i < word.size(); ++i)\n    {\n        char character = word[i];\n        totalScore += score[character - 'a'];\n    }\n    return totalScore;\n}\n\nint getMaxScoreHelper(const vector<string> &words, const vector<int> &score,\n                      string availableLetters, int index)\n{\n    if (index == words.size())\n    {\n        return 0;\n    }\n    int withoutCurrentWordScore = getMaxScoreHelper(words, score, availableLetters, index + 1);\n    \n    // Check if we can use the current word's letters\n    bool canUseCurrentWord = true;\n    for (int i = 0; i < words[index].size(); ++i)\n    {\n        char character = words[index][i];\n        if (--availableLetters[character - 'a'] < 0)\n        {\n            canUseCurrentWord = false;\n            break;\n        }\n    }\n    \n    int withCurrentWordScore = 0;\n    if (canUseCurrentWord)\n    {\n        withCurrentWordScore = getMaxScore(words[index], score) + getMaxScoreHelper(words, score, availableLetters, index + 1);\n    }\n\n    return max(withCurrentWordScore, withoutCurrentWordScore);\n}\n\nint maxScoreWords(vector<string> &words, string availableLetters,\n                  vector<int> &score)\n{\n    return getMaxScoreHelper(words, score, availableLetters, 0);\n}",
    "output": "#include <bits/stdc++.h>\nint getMaxScore(const std::string &word, const std::vector<int> &score)\n{\n    int totalScore= 0;\n    for(char character : word)\n    {\n        totalScore+= score[character - 'a'];\n    }\n    return totalScore;\n}\n\nint getMaxScoreHelper(const std::vector<std::string> &words, const std::vector<int> &score,\n                      std::string availableLetters, int index)\n{\n    if(index == words.size())\n    {\n        return 0;\n    }\n    int withoutCurrentWordScore= getMaxScoreHelper(words, score, availableLetters, index + 1);\n    for(char character : words[index])\n    {\n        if(--availableLetters[character - 'a'] < 0)\n        {\n            break;\n        }\n    }\n    int withCurrentWordScore= getMaxScore(words[index], score) + getMaxScoreHelper(words, score, availableLetters, index + 1);\n    return std::max(withCurrentWordScore, withoutCurrentWordScore);\n}\n\nint maxScoreWords(std::vector<std::string> &words, std::string availableLetters,\n                  std::vector<int> &score)\n{\n    return getMaxScoreHelper(words, score, availableLetters, 0);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nclass Solution\n{\n  public:\n    TreeNode *balanceBST(TreeNode *root)\n    {\n        vector<TreeNode *> sortedNodes;\n        inorderTraversal(root, sortedNodes);\n        return sortedArrayToBST(sortedNodes, 0, sortedNodes.size() - 1);\n    }\n\n    void inorderTraversal(TreeNode *node, vector<TreeNode *> &sortedNodes)\n    {\n        if(node == NULL)\n            return;\n        inorderTraversal(node->leftChild, sortedNodes);\n        sortedNodes.push_back(node);\n        inorderTraversal(node->rightChild, sortedNodes);\n    }\n\n    TreeNode *sortedArrayToBST(vector<TreeNode *> &sortedNodes, int start, int end)\n    {\n        if(start > end)\n            return NULL;\n        int mid= start + (end - start) / 2;\n        TreeNode *newNode= sortedNodes[mid];\n        newNode->leftChild= sortedArrayToBST(sortedNodes, start, mid - 1);\n        newNode->rightChild= sortedArrayToBST(sortedNodes, mid + 1, end);\n        return newNode;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nclass Solution\n{\n  public:\n    TreeNode *balanceBST(TreeNode *root)\n    {\n        std::vector<TreeNode *> sortedNodes;\n        inorderTraversal(root, sortedNodes);\n        return sortedArrayToBST(sortedNodes, 0, sortedNodes.size() - 1);\n    }\n\n    void inorderTraversal(TreeNode *node, std::vector<TreeNode *> &sortedNodes)\n    {\n        if(node == NULL)\n            return;\n        inorderTraversal(node->leftChild, sortedNodes);\n        sortedNodes.push_back(node);\n        inorderTraversal(node->rightChild, sortedNodes);\n    }\n\n    TreeNode *sortedArrayToBST(std::vector<TreeNode *> &sortedNodes, int start, int end)\n    {\n        if(start > end)\n            return NULL;\n        int mid= start + (end - start) / 2;\n        TreeNode *newNode= sortedNodes[mid];\n        newNode->leftChild= sortedArrayToBST(sortedNodes, start, mid - 1);\n        newNode->rightChild= sortedArrayToBST(sortedNodes, mid + 1, end);\n        return newNode;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPerformance(int numberOfEngineers, int maxEngineers, vector<int> &speeds, vector<int> &efficiencies)\n{\n    vector<pair<int, int>> engineerPairs(numberOfEngineers);\n    for(int index= 0; index < numberOfEngineers; ++index)\n    {\n        engineerPairs[index]= {efficiencies[index], speeds[index]};\n    }\n\n    sort(engineerPairs.rbegin(), engineerPairs.rend());\n\n    priority_queue<int, vector<int>, greater<int>> minHeap;\n\n    long long totalSpeed= 0;\n    long long maximumPerformance= 0;\n\n    for (int i = 0; i < engineerPairs.size(); ++i)\n    {\n        auto &engineer = engineerPairs[i];\n        totalSpeed += engineer.second;\n        minHeap.push(engineer.second);\n\n        if(minHeap.size() > maxEngineers)\n        {\n            totalSpeed -= minHeap.top();\n            minHeap.pop();\n        }\n\n        maximumPerformance = max(maximumPerformance, totalSpeed * engineer.first);\n    }\n\n    return maximumPerformance % 1000000007;\n}",
    "output": "#include <bits/stdc++.h>\nint maxPerformance(int numberOfEngineers, int maxEngineers, std::vector<int> &speeds, std::vector<int> &efficiencies)\n{\n    std::vector<std::pair<int, int>> engineerPairs(numberOfEngineers);\n    for(int index= 0; index < numberOfEngineers; ++index)\n    {\n        engineerPairs[index]= {efficiencies[index], speeds[index]};\n    }\n\n    std::sort(engineerPairs.rbegin(), engineerPairs.rend());\n\n    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;\n\n    long long totalSpeed= 0;\n    long long maximumPerformance= 0;\n\n    for(auto &engineer : engineerPairs)\n    {\n        totalSpeed+= engineer.second;\n        minHeap.push(engineer.second);\n\n        if(minHeap.size() > maxEngineers)\n        {\n            totalSpeed-= minHeap.top();\n            minHeap.pop();\n        }\n\n        maximumPerformance= std::max(maximumPerformance, totalSpeed * engineer.first);\n    }\n\n    return maximumPerformance % 1000000007;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For abs\nusing namespace std;\n\nint findTheDistanceValue(vector<int> &firstArray, vector<int> &secondArray, int distanceThreshold)\n{\n    int validCount = 0;\n    for (int i = 0; i < firstArray.size(); ++i)\n    {\n        int elementA = firstArray[i];\n        bool isValid = true;\n        for (int j = 0; j < secondArray.size(); ++j)\n        {\n            int elementB = secondArray[j];\n            if (abs(elementA - elementB) <= distanceThreshold)\n            {\n                isValid = false;\n                break;\n            }\n        }\n        if (isValid)\n            validCount++;\n    }\n    return validCount;\n}",
    "output": "#include <bits/stdc++.h>\n// For std::abs\n\nint findTheDistanceValue(std::vector<int> &firstArray, std::vector<int> &secondArray, int distanceThreshold)\n{\n    int validCount= 0;\n    for(int elementA : firstArray)\n    {\n        bool isValid= true;\n        for(int elementB : secondArray)\n        {\n            if(std::abs(elementA - elementB) <= distanceThreshold)\n            {\n                isValid= false;\n                break;\n            }\n        }\n        if(isValid)\n            validCount++;\n    }\n    return validCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> shiftGrid(vector<vector<int>> &inputGrid, int shiftCount)\n{\n    int rowCount= inputGrid.size(), columnCount= inputGrid[0].size();\n    shiftCount%= (rowCount * columnCount);\n    vector<vector<int>> shiftedGrid(rowCount, vector<int>(columnCount));\n    for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n    {\n        for(int columnIndex= 0; columnIndex < columnCount; ++columnIndex)\n        {\n            int newIndex= (rowIndex * columnCount + columnIndex + shiftCount) % (rowCount * columnCount);\n            shiftedGrid[newIndex / columnCount][newIndex % columnCount]= inputGrid[rowIndex][columnIndex];\n        }\n    }\n    return shiftedGrid;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> shiftGrid(std::vector<std::vector<int>> &inputGrid, int shiftCount)\n{\n    int rowCount= inputGrid.size(), columnCount= inputGrid[0].size();\n    shiftCount%= (rowCount * columnCount);\n    std::vector<std::vector<int>> shiftedGrid(rowCount, std::vector<int>(columnCount));\n    for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n    {\n        for(int columnIndex= 0; columnIndex < columnCount; ++columnIndex)\n        {\n            int newIndex= (rowIndex * columnCount + columnIndex + shiftCount) % (rowCount * columnCount);\n            shiftedGrid[newIndex / columnCount][newIndex % columnCount]= inputGrid[rowIndex][columnIndex];\n        }\n    }\n    return shiftedGrid;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumDivThree(vector<int> &numbers)\n{\n    vector<int> remainderSums(3, 0);\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        vector<int> tempSums(remainderSums);\n        for (int j = 0; j < tempSums.size(); ++j)\n        {\n            int sum = tempSums[j];\n            remainderSums[(sum + number) % 3] = max(remainderSums[(sum + number) % 3], sum + number);\n        }\n    }\n    return remainderSums[0];\n}",
    "output": "#include <bits/stdc++.h>\nint maxSumDivThree(std::vector<int> &numbers)\n{\n    std::vector<int> remainderSums(3, 0);\n    for(int number : numbers)\n    {\n        std::vector<int> tempSums(remainderSums);\n        for(int sum : tempSums)\n        {\n            remainderSums[(sum + number) % 3] = std::max(remainderSums[(sum + number) % 3], sum + number);\n        }\n    }\n    return remainderSums[0];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint sumOfFourDivisors(vector<int> &numbers)\n{\n    int totalSum = 0;\n    for (int j = 0; j < numbers.size(); ++j)\n    {\n        int currentNumber = numbers[j];\n        int divisorCount = 0;\n        int divisorSum = 0;\n        for (int i = 1; i * i <= currentNumber; ++i)\n        {\n            if (currentNumber % i == 0)\n            {\n                divisorCount += (i * i == currentNumber) ? 1 : 2;\n                divisorSum += i + (currentNumber / i);\n                if (divisorCount > 4)\n                    break;\n            }\n        }\n        if (divisorCount == 4)\n            totalSum += divisorSum;\n    }\n    return totalSum;\n}",
    "output": "int sumOfFourDivisors(std::vector<int> &numbers)\n{\n    int totalSum= 0;\n    for(int currentNumber : numbers)\n    {\n        int divisorCount= 0;\n        int divisorSum= 0;\n        for(int i= 1; i * i <= currentNumber; ++i)\n        {\n            if(currentNumber % i == 0)\n            {\n                divisorCount+= (i * i == currentNumber) ? 1 : 2;\n                divisorSum+= i + (currentNumber / i);\n                if(divisorCount > 4)\n                    break;\n            }\n        }\n        if(divisorCount == 4)\n            totalSum+= divisorSum;\n    }\n    return totalSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// for std::find\nusing namespace std;\n\nbool hasValidPath(vector<vector<int>> &grid)\n{\n    int rowCount = grid.size();\n    int columnCount = grid[0].size();\n\n    vector<vector<int>> movementDirections = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n    vector<vector<int>> allowedDirections = {{}, {0, 2}, {1, 3}, {0, 1}, {0, 3}, {1, 2}, {1, 0}};\n\n    vector<vector<bool>> visitedCells(rowCount, vector<bool>(columnCount, false));\n\n    function<bool(int, int)> depthFirstSearch = [&](int currentRow, int currentColumn) -> bool\n    {\n        if (currentRow == rowCount - 1 && currentColumn == columnCount - 1)\n            return true;\n        visitedCells[currentRow][currentColumn] = true;\n        \n        // Replace range-based for loop with traditional for loop\n        for (int i = 0; i < allowedDirections[grid[currentRow][currentColumn]].size(); ++i)\n        {\n            int direction = allowedDirections[grid[currentRow][currentColumn]][i];\n            int nextRow = currentRow + movementDirections[direction][0];\n            int nextColumn = currentColumn + movementDirections[direction][1];\n            if (nextRow >= 0 && nextColumn >= 0 && nextRow < rowCount && nextColumn < columnCount && !visitedCells[nextRow][nextColumn] && find(allowedDirections[grid[nextRow][nextColumn]].begin(), allowedDirections[grid[nextRow][nextColumn]].end(), (direction + 2) % 4) != allowedDirections[grid[nextRow][nextColumn]].end())\n            {\n                if (depthFirstSearch(nextRow, nextColumn))\n                    return true;\n            }\n        }\n        return false;\n    };\n\n    return depthFirstSearch(0, 0);\n}",
    "output": "#include <bits/stdc++.h>\nbool hasValidPath(std::vector<std::vector<int>> &grid)\n{\n    int rowCount = grid.size();\n    int columnCount = grid[0].size();\n\n    std::vector<std::vector<int>> movementDirections = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n    std::vector<std::vector<int>> allowedDirections = {{}, {0, 2}, {1, 3}, {0, 1}, {0, 3}, {1, 2}, {1, 0}};\n\n    std::vector<std::vector<bool>> visitedCells(rowCount, std::vector<bool>(columnCount, false));\n\n    std::function<bool(int, int)> depthFirstSearch = [&](int currentRow, int currentColumn) -> bool\n    {\n        if(currentRow == rowCount - 1 && currentColumn == columnCount - 1)\n            return true;\n        visitedCells[currentRow][currentColumn] = true;\n        for(int direction : allowedDirections[grid[currentRow][currentColumn]])\n        {\n            int nextRow = currentRow + movementDirections[direction][0];\n            int nextColumn = currentColumn + movementDirections[direction][1];\n            if(nextRow >= 0 && nextColumn >= 0 && nextRow < rowCount && nextColumn < columnCount && !visitedCells[nextRow][nextColumn] && std::find(allowedDirections[grid[nextRow][nextColumn]].begin(), allowedDirections[grid[nextRow][nextColumn]].end(), (direction + 2) % 4) != allowedDirections[grid[nextRow][nextColumn]].end())\n            {\n                if(depthFirstSearch(nextRow, nextColumn))\n                    return true;\n            }\n        }\n        return false;\n    };\n\n    return depthFirstSearch(0, 0);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findLucky(vector<int> &numbersArray)\n{\n    unordered_map<int, int> frequencyMap;\n    for(int number : numbersArray)\n    {\n        frequencyMap[number]++;\n    }\n    int maxLuckyNumber = -1;\n    for(auto it = frequencyMap.begin(); it != frequencyMap.end(); ++it)\n    {\n        if(it->first == it->second)\n        {\n            maxLuckyNumber = max(maxLuckyNumber, it->first);\n        }\n    }\n    return maxLuckyNumber;\n}",
    "output": "#include <bits/stdc++.h>\nint findLucky(std::vector<int> &numbersArray)\n{\n    std::unordered_map<int, int> frequencyMap;\n    for(int number : numbersArray)\n    {\n        frequencyMap[number]++;\n    }\n    int maxLuckyNumber= -1;\n    for(auto &frequencyPair : frequencyMap)\n    {\n        if(frequencyPair.first == frequencyPair.second)\n        {\n            maxLuckyNumber= std::max(maxLuckyNumber, frequencyPair.first);\n        }\n    }\n    return maxLuckyNumber;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeToVisitAllPoints(vector<vector<int>> &points)\n{\n    int totalTime = 0;\n    for(int currentIndex = 1; currentIndex < points.size(); ++currentIndex)\n    {\n        int deltaX = abs(points[currentIndex][0] - points[currentIndex - 1][0]);\n        int deltaY = abs(points[currentIndex][1] - points[currentIndex - 1][1]);\n        totalTime += max(deltaX, deltaY);\n    }\n    return totalTime;\n}",
    "output": "#include <bits/stdc++.h>\nint minTimeToVisitAllPoints(std::vector<std::vector<int>> &points)\n{\n    int totalTime= 0;\n    for(int currentIndex= 1; currentIndex < points.size(); ++currentIndex)\n    {\n        int deltaX= abs(points[currentIndex][0] - points[currentIndex - 1][0]);\n        int deltaY= abs(points[currentIndex][1] - points[currentIndex - 1][1]);\n        totalTime+= std::max(deltaX, deltaY);\n    }\n    return totalTime;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UndergroundSystem\n{\n  public:\n    unordered_map<int, pair<string, int>> checkInInfo;\n    unordered_map<string, pair<int, int>> journeyData;\n\n    void checkIn(int customerId, string stationName, int time)\n    {\n        checkInInfo[customerId]= {stationName, time};\n    }\n\n    void checkOut(int customerId, string stationName, int time)\n    {\n        auto &startInfo= checkInInfo[customerId];\n        string route= startInfo.first + \"_\" + stationName;\n        int duration= time - startInfo.second;\n        journeyData[route].first+= duration;\n        journeyData[route].second++;\n    }\n\n    double getAverageTime(string startStation, string endStation)\n    {\n        string route= startStation + \"_\" + endStation;\n        auto &data= journeyData[route];\n        return (double)data.first / data.second;\n    }\n};",
    "output": "#include <bits/stdc++.h>\n// for std::pair\n\nclass UndergroundSystem\n{\n  public:\n    std::unordered_map<int, std::pair<std::string, int>> checkInInfo;\n    std::unordered_map<std::string, std::pair<int, int>> journeyData;\n\n    void checkIn(int customerId, std::string stationName, int time)\n    {\n        checkInInfo[customerId]= {stationName, time};\n    }\n\n    void checkOut(int customerId, std::string stationName, int time)\n    {\n        auto &startInfo= checkInInfo[customerId];\n        std::string route= startInfo.first + \"_\" + stationName;\n        int duration= time - startInfo.second;\n        journeyData[route].first+= duration;\n        journeyData[route].second++;\n    }\n\n    double getAverageTime(std::string startStation, std::string endStation)\n    {\n        std::string route= startStation + \"_\" + endStation;\n        auto &data= journeyData[route];\n        return (double)data.first / data.second;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<string>> suggestedProducts(vector<string> &productList, string searchTerm)\n{\n    sort(productList.begin(), productList.end());\n\n    vector<vector<string>> suggestions;\n    string currentPrefix;\n\n    for (int i = 0; i < searchTerm.size(); ++i)\n    {\n        char letter = searchTerm[i];\n        currentPrefix += letter;\n\n        auto iterator = lower_bound(productList.begin(), productList.end(), currentPrefix);\n        vector<string> currentSuggestions;\n\n        for (int index = 0; index < 3 && iterator != productList.end() && iterator->substr(0, currentPrefix.size()) == currentPrefix; ++index)\n        {\n            currentSuggestions.push_back(*iterator);\n            ++iterator;\n        }\n\n        suggestions.push_back(currentSuggestions);\n    }\n\n    return suggestions;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<std::string>> suggestedProducts(std::vector<std::string> &productList, std::string searchTerm)\n{\n    std::sort(productList.begin(), productList.end());\n\n    std::vector<std::vector<std::string>> suggestions;\n    std::string currentPrefix;\n\n    for(char letter : searchTerm)\n    {\n        currentPrefix+= letter;\n\n        auto iterator= std::lower_bound(productList.begin(), productList.end(), currentPrefix);\n        std::vector<std::string> currentSuggestions;\n\n        for(int index= 0; index < 3 && iterator != productList.end() && iterator->substr(0, currentPrefix.size()) == currentPrefix; ++index)\n        {\n            currentSuggestions.push_back(*iterator);\n            ++iterator;\n        }\n\n        suggestions.push_back(currentSuggestions);\n    }\n\n    return suggestions;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countLargestGroup(int totalNumber)\n{\n    vector<int> groupSizes(37, 0);\n    int largestGroupSize = 0;\n    int largestGroupCount = 0;\n\n    for(int currentNumber = 1; currentNumber <= totalNumber; currentNumber++)\n    {\n        int digitSum = 0, remainingNumber = currentNumber;\n        while(remainingNumber)\n        {\n            digitSum += remainingNumber % 10;\n            remainingNumber /= 10;\n        }\n        groupSizes[digitSum]++;\n        if(groupSizes[digitSum] > largestGroupSize)\n        {\n            largestGroupSize = groupSizes[digitSum];\n            largestGroupCount = 1;\n        }\n        else if(groupSizes[digitSum] == largestGroupSize)\n        {\n            largestGroupCount++;\n        }\n    }\n    return largestGroupCount;\n}",
    "output": "int countLargestGroup(int totalNumber)\n{\n    std::vector<int> groupSizes(37, 0);\n    int largestGroupSize= 0;\n    int largestGroupCount= 0;\n\n    for(int currentNumber= 1; currentNumber <= totalNumber; currentNumber++)\n    {\n        int digitSum= 0, remainingNumber= currentNumber;\n        while(remainingNumber)\n        {\n            digitSum+= remainingNumber % 10;\n            remainingNumber/= 10;\n        }\n        groupSizes[digitSum]++;\n        if(groupSizes[digitSum] > largestGroupSize)\n        {\n            largestGroupSize= groupSizes[digitSum];\n            largestGroupCount= 1;\n        }\n        else if(groupSizes[digitSum] == largestGroupSize)\n        {\n            largestGroupCount++;\n        }\n    }\n    return largestGroupCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring ticTacToe(vector<vector<int>> &playerMoves)\n{\n    int gameGrid[3][3] = {0};\n    int currentPlayer = 1;\n    for (int i = 0; i < playerMoves.size(); ++i)\n    {\n        const auto &move = playerMoves[i];\n        gameGrid[move[0]][move[1]] = currentPlayer;\n        if ((gameGrid[0][move[1]] == currentPlayer && gameGrid[1][move[1]] == currentPlayer && gameGrid[2][move[1]] == currentPlayer) ||\n            (gameGrid[move[0]][0] == currentPlayer && gameGrid[move[0]][1] == currentPlayer && gameGrid[move[0]][2] == currentPlayer) ||\n            (move[0] == move[1] && gameGrid[0][0] == currentPlayer && gameGrid[1][1] == currentPlayer && gameGrid[2][2] == currentPlayer) ||\n            (move[0] + move[1] == 2 && gameGrid[0][2] == currentPlayer && gameGrid[1][1] == currentPlayer && gameGrid[2][0] == currentPlayer))\n        {\n            return currentPlayer == 1 ? \"A\" : \"B\";\n        }\n        currentPlayer = 3 - currentPlayer;\n    }\n    return playerMoves.size() == 9 ? \"Draw\" : \"Pending\";\n}",
    "output": "#include <bits/stdc++.h>\nstd::string ticTacToe(std::vector<std::vector<int>> &playerMoves)\n{\n    int gameGrid[3][3]= {0};\n    int currentPlayer= 1;\n    for(const auto &move : playerMoves)\n    {\n        gameGrid[move[0]][move[1]]= currentPlayer;\n        if((gameGrid[0][move[1]] == currentPlayer && gameGrid[1][move[1]] == currentPlayer && gameGrid[2][move[1]] == currentPlayer) ||\n           (gameGrid[move[0]][0] == currentPlayer && gameGrid[move[0]][1] == currentPlayer && gameGrid[move[0]][2] == currentPlayer) ||\n           (move[0] == move[1] && gameGrid[0][0] == currentPlayer && gameGrid[1][1] == currentPlayer && gameGrid[2][2] == currentPlayer) ||\n           (move[0] + move[1] == 2 && gameGrid[0][2] == currentPlayer && gameGrid[1][1] == currentPlayer && gameGrid[2][0] == currentPlayer))\n        {\n            return currentPlayer == 1 ? \"A\" : \"B\";\n        }\n        currentPlayer= 3 - currentPlayer;\n    }\n    return playerMoves.size() == 9 ? \"Draw\" : \"Pending\";\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "using namespace std;\n\nbool checkOverlap(int circleRadius, int circleXCenter, int circleYCenter, int rectangleX1, int rectangleY1, int rectangleX2, int rectangleY2)\n{\n    int closestX = max(rectangleX1, min(circleXCenter, rectangleX2));\n    int closestY = max(rectangleY1, min(circleYCenter, rectangleY2));\n    return (circleXCenter - closestX) * (circleXCenter - closestX) + (circleYCenter - closestY) * (circleYCenter - closestY) <= circleRadius * circleRadius;\n}",
    "output": "bool checkOverlap(int circleRadius, int circleXCenter, int circleYCenter, int rectangleX1, int rectangleY1, int rectangleX2, int rectangleY2)\n{\n    int closestX= std::max(rectangleX1, std::min(circleXCenter, rectangleX2));\n    int closestY= std::max(rectangleY1, std::min(circleYCenter, rectangleY2));\n    return (circleXCenter - closestX) * (circleXCenter - closestX) + (circleYCenter - closestY) * (circleYCenter - closestY) <= circleRadius * circleRadius;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countSquares(vector<vector<int>> &inputMatrix)\n{\n    int rowCount= inputMatrix.size(), columnCount= inputMatrix[0].size(), totalSquares= 0;\n    vector<vector<int>> dynamicProgrammingTable(rowCount, vector<int>(columnCount, 0));\n    for(int currentRow= 0; currentRow < rowCount; currentRow++)\n    {\n        for(int currentColumn= 0; currentColumn < columnCount; currentColumn++)\n        {\n            if(currentRow == 0 || currentColumn == 0)\n                dynamicProgrammingTable[currentRow][currentColumn]= inputMatrix[currentRow][currentColumn];\n            else if(inputMatrix[currentRow][currentColumn])\n                dynamicProgrammingTable[currentRow][currentColumn]= min(dynamicProgrammingTable[currentRow - 1][currentColumn - 1], min(dynamicProgrammingTable[currentRow - 1][currentColumn], dynamicProgrammingTable[currentRow][currentColumn - 1])) + 1;\n            totalSquares+= dynamicProgrammingTable[currentRow][currentColumn];\n        }\n    }\n    return totalSquares;\n}",
    "output": "#include <bits/stdc++.h>\nint countSquares(std::vector<std::vector<int>> &inputMatrix)\n{\n    int rowCount = inputMatrix.size(), columnCount = inputMatrix[0].size(), totalSquares = 0;\n    std::vector<std::vector<int>> dynamicProgrammingTable(rowCount, std::vector<int>(columnCount, 0));\n    for(int currentRow = 0; currentRow < rowCount; currentRow++)\n    {\n        for(int currentColumn = 0; currentColumn < columnCount; currentColumn++)\n        {\n            if(currentRow == 0 || currentColumn == 0)\n                dynamicProgrammingTable[currentRow][currentColumn] = inputMatrix[currentRow][currentColumn];\n            else if(inputMatrix[currentRow][currentColumn])\n                dynamicProgrammingTable[currentRow][currentColumn] = std::min(dynamicProgrammingTable[currentRow - 1][currentColumn - 1], std::min(dynamicProgrammingTable[currentRow - 1][currentColumn], dynamicProgrammingTable[currentRow][currentColumn - 1])) + 1;\n            totalSquares += dynamicProgrammingTable[currentRow][currentColumn];\n        }\n    }\n    return totalSquares;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minChangesToDivideString(const string &inputString, int chunkSize)\n{\n    int stringLength = inputString.length();\n    if (stringLength % chunkSize != 0)\n        return -1;\n    int chunkCount = stringLength / chunkSize;\n    int result = 0;\n\n    for (int i = 0; i < chunkSize; ++i)\n    {\n        int characterCounts[26] = {0};\n        for (int j = i; j < stringLength; j += chunkSize)\n        {\n            ++characterCounts[inputString[j] - 'a'];\n        }\n        int maxCount = *max_element(characterCounts, characterCounts + 26);\n        result += chunkCount - maxCount;\n    }\n    return result;\n}",
    "output": "int minChangesToDivideString(const std::string &inputString, int chunkSize)\n{\n    int stringLength= inputString.length();\n    if(stringLength % chunkSize != 0)\n        return -1;\n    int chunkCount= stringLength / chunkSize;\n    int result= 0;\n\n    for(int i= 0; i < chunkSize; ++i)\n    {\n        int characterCounts[26]= {0};\n        for(int j= i; j < stringLength; j+= chunkSize)\n        {\n            ++characterCounts[inputString[j] - 'a'];\n        }\n        int maxCount= *std::max_element(characterCounts, characterCounts + 26);\n        result+= chunkCount - maxCount;\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "using namespace std;\n\nint calculateSteps(const string &binaryString)\n{\n    int totalSteps = 0, carryFlag = 0;\n    for(int index = binaryString.length() - 1; index > 0; --index)\n    {\n        int currentBit = binaryString[index] - '0';\n        if(currentBit && carryFlag)\n        {\n            carryFlag = 1;\n            totalSteps += 2;\n        }\n        else if(currentBit || carryFlag)\n        {\n            carryFlag ^= 1;\n            totalSteps += 2;\n        }\n        else\n        {\n            totalSteps++;\n        }\n    }\n\n    return totalSteps + carryFlag;\n}",
    "output": "int calculateSteps(const std::string &binaryString)\n{\n    int totalSteps= 0, carryFlag= 0;\n    for(int index= binaryString.length() - 1; index > 0; --index)\n    {\n        int currentBit= binaryString[index] - '0';\n        if(currentBit && carryFlag)\n        {\n            carryFlag= 1;\n            totalSteps+= 2;\n        }\n        else if(currentBit || carryFlag)\n        {\n            carryFlag^= 1;\n            totalSteps+= 2;\n        }\n        else\n        {\n            totalSteps++;\n        }\n    }\n\n    return totalSteps + carryFlag;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring longestDiverseString(int countA, int countB, int countC)\n{\n    string resultString= \"\";\n    using charCountPair= pair<int, char>;\n    priority_queue<charCountPair> maxHeap;\n    if(countA)\n        maxHeap.push({countA, 'a'});\n    if(countB)\n        maxHeap.push({countB, 'b'});\n    if(countC)\n        maxHeap.push({countC, 'c'});\n\n    while(!maxHeap.empty())\n    {\n        charCountPair mostFrequent= maxHeap.top();\n        maxHeap.pop();\n        if(!resultString.empty() && resultString.back() == mostFrequent.second)\n        {\n            if(maxHeap.empty())\n                break;\n            charCountPair secondMostFrequent= maxHeap.top();\n            maxHeap.pop();\n            resultString+= secondMostFrequent.second;\n            secondMostFrequent.first--;\n            if(secondMostFrequent.first)\n                maxHeap.push(secondMostFrequent);\n            maxHeap.push(mostFrequent);\n        }\n        else\n        {\n            resultString+= mostFrequent.second;\n            mostFrequent.first--;\n            if(mostFrequent.first)\n                maxHeap.push(mostFrequent);\n        }\n    }\n    return resultString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string longestDiverseString(int countA, int countB, int countC)\n{\n    std::string resultString= \"\";\n    using charCountPair= std::pair<int, char>;\n    std::priority_queue<charCountPair> maxHeap;\n    if(countA)\n        maxHeap.push({countA, 'a'});\n    if(countB)\n        maxHeap.push({countB, 'b'});\n    if(countC)\n        maxHeap.push({countC, 'c'});\n\n    while(!maxHeap.empty())\n    {\n        charCountPair mostFrequent= maxHeap.top();\n        maxHeap.pop();\n        if(!resultString.empty() && resultString.back() == mostFrequent.second)\n        {\n            if(maxHeap.empty())\n                break;\n            charCountPair secondMostFrequent= maxHeap.top();\n            maxHeap.pop();\n            resultString+= secondMostFrequent.second;\n            secondMostFrequent.first--;\n            if(secondMostFrequent.first)\n                maxHeap.push(secondMostFrequent);\n            maxHeap.push(mostFrequent);\n        }\n        else\n        {\n            resultString+= mostFrequent.second;\n            mostFrequent.first--;\n            if(mostFrequent.first)\n                maxHeap.push(mostFrequent);\n        }\n    }\n    return resultString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring stoneGameIII(vector<int> &stoneValues)\n{\n    int totalStones= stoneValues.size();\n    vector<int> dynamicProgramming(totalStones + 1, INT_MIN);\n    dynamicProgramming[totalStones]= 0;\n\n    for(int currentIndex= totalStones - 1; currentIndex >= 0; --currentIndex)\n    {\n        int currentSum= 0;\n        for(int moveCount= 0; moveCount < 3 && currentIndex + moveCount < totalStones; ++moveCount)\n        {\n            currentSum+= stoneValues[currentIndex + moveCount];\n            dynamicProgramming[currentIndex]= max(dynamicProgramming[currentIndex], currentSum - dynamicProgramming[currentIndex + moveCount + 1]);\n        }\n    }\n\n    return dynamicProgramming[0] == 0 ? \"Tie \" : dynamicProgramming[0] > 0 ? \"Alice \"\n                                                                           : \"Bob \";\n}",
    "output": "#include <bits/stdc++.h>\nstd::string stoneGameIII(std::vector<int> &stoneValues)\n{\n    int totalStones = stoneValues.size();\n    std::vector<int> dynamicProgramming(totalStones + 1, std::numeric_limits<int>::min());\n    dynamicProgramming[totalStones] = 0;\n\n    for(int currentIndex = totalStones - 1; currentIndex >= 0; --currentIndex)\n    {\n        int currentSum = 0;\n        for(int moveCount = 0; moveCount < 3 && currentIndex + moveCount < totalStones; ++moveCount)\n        {\n            currentSum += stoneValues[currentIndex + moveCount];\n            dynamicProgramming[currentIndex] = std::max(dynamicProgramming[currentIndex], currentSum - dynamicProgramming[currentIndex + moveCount + 1]);\n        }\n    }\n\n    return dynamicProgramming[0] == 0 ? \"Tie \" : dynamicProgramming[0] > 0 ? \"Alice \"\n                                                                           : \"Bob \";\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint smallestDivisor(vector<int> &numbers, int threshold)\n{\n    int left = 1, right = 1e6;\n    while(left < right)\n    {\n        int mid = (left + right) / 2;\n        int totalSum = 0;\n        for(int i = 0; i < numbers.size(); ++i)\n        {\n            int number = numbers[i];\n            totalSum += ceil(1.0 * number / mid);\n        }\n        if(totalSum > threshold)\n        {\n            left = mid + 1;\n        }\n        else\n        {\n            right = mid;\n        }\n    }\n    return left;\n}",
    "output": "#include <bits/stdc++.h>\nint smallestDivisor(std::vector<int> &numbers, int threshold)\n{\n    int left= 1, right= 1e6;\n    while(left < right)\n    {\n        int mid= (left + right) / 2;\n        int totalSum= 0;\n        for(int number : numbers)\n        {\n            totalSum+= std::ceil(1.0 * number / mid);\n        }\n        if(totalSum > threshold)\n        {\n            left= mid + 1;\n        }\n        else\n        {\n            right= mid;\n        }\n    }\n    return left;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfFlips(vector<vector<int>> &matrix)\n{\n    int rowCount = matrix.size(), colCount = matrix[0].size();\n    int totalFlips = 0;\n    int directions[][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}, {0, 0}};\n\n    auto encodePosition = [&](int row, int col)\n    { return row * colCount + col; };\n\n    while (true)\n    {\n        int flippedCount = 0;\n        queue<int> positionQueue;\n\n        for (int rowIndex = 0; rowIndex < rowCount; ++rowIndex)\n        {\n            for (int colIndex = 0; colIndex < colCount; ++colIndex)\n            {\n                if (matrix[rowIndex][colIndex] == 1)\n                {\n                    positionQueue.push(encodePosition(rowIndex, colIndex));\n                }\n            }\n        }\n\n        while (!positionQueue.empty())\n        {\n            int currentPosition = positionQueue.front(), currentRow = currentPosition / colCount, currentCol = currentPosition % colCount;\n            positionQueue.pop();\n\n            for (int i = 0; i < 5; ++i) // Using traditional for loop for the directions\n            {\n                int newRow = currentRow + directions[i][0], newCol = currentCol + directions[i][1];\n                if (newRow >= 0 && newRow < rowCount && newCol >= 0 && newCol < colCount)\n                {\n                    matrix[newRow][newCol] ^= 1;\n                    ++flippedCount;\n                }\n            }\n        }\n\n        if (flippedCount == 0)\n        {\n            break;\n        }\n        totalFlips += flippedCount;\n    }\n\n    for (int rowIndex = 0; rowIndex < rowCount; ++rowIndex)\n    {\n        for (int colIndex = 0; colIndex < colCount; ++colIndex)\n        {\n            if (matrix[rowIndex][colIndex] == 1)\n            {\n                return -1;\n            }\n        }\n    }\n\n    return totalFlips;\n}",
    "output": "#include <bits/stdc++.h>\nint minNumberOfFlips(std::vector<std::vector<int>> &matrix)\n{\n    int rowCount= matrix.size(), colCount= matrix[0].size();\n    int totalFlips= 0;\n    int directions[][2]= {{0, 1}, {0, -1}, {1, 0}, {-1, 0}, {0, 0}};\n\n    auto encodePosition= [&](int row, int col)\n    { return row * colCount + col; };\n\n    while(true)\n    {\n        int flippedCount= 0;\n        std::queue<int> positionQueue;\n\n        for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n        {\n            for(int colIndex= 0; colIndex < colCount; ++colIndex)\n            {\n                if(matrix[rowIndex][colIndex] == 1)\n                {\n                    positionQueue.push(encodePosition(rowIndex, colIndex));\n                }\n            }\n        }\n\n        while(!positionQueue.empty())\n        {\n            int currentPosition= positionQueue.front(), currentRow= currentPosition / colCount, currentCol= currentPosition % colCount;\n            positionQueue.pop();\n\n            for(auto direction : directions)\n            {\n                int newRow= currentRow + direction[0], newCol= currentCol + direction[1];\n                if(newRow >= 0 && newRow < rowCount && newCol >= 0 && newCol < colCount)\n                {\n                    matrix[newRow][newCol]^= 1;\n                    ++flippedCount;\n                }\n            }\n        }\n\n        if(flippedCount == 0)\n        {\n            break;\n        }\n        totalFlips+= flippedCount;\n    }\n\n    for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex < colCount; ++colIndex)\n        {\n            if(matrix[rowIndex][colIndex] == 1)\n            {\n                return -1;\n            }\n        }\n    }\n\n    return totalFlips;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring entityParser(string inputText)\n{\n    unordered_map<string, string> htmlEntities = {\n        {\"&quot;\", \"\\\"\"},\n        {\"&apos;\", \"'\"},\n        {\"&amp;\", \"&\"},\n        {\"&gt;\", \">\"},\n        {\"&lt;\", \"<\"},\n        {\"&frasl;\", \"/\"},\n    };\n\n    string parsedResult;\n    string currentEntity;\n    bool isInEntity = false;\n\n    for (int i = 0; i < inputText.size(); ++i)\n    {\n        char currentChar = inputText[i];\n        if (isInEntity)\n        {\n            currentEntity.push_back(currentChar);\n            if (currentChar == ';')\n            {\n                if (htmlEntities.find(currentEntity) != htmlEntities.end())\n                {\n                    parsedResult += htmlEntities[currentEntity];\n                }\n                else\n                {\n                    parsedResult += currentEntity;\n                }\n                isInEntity = false;\n                currentEntity.clear();\n            }\n        }\n        else\n        {\n            if (currentChar == '&')\n            {\n                isInEntity = true;\n                currentEntity.push_back(currentChar);\n            }\n            else\n            {\n                parsedResult.push_back(currentChar);\n            }\n        }\n    }\n\n    return parsedResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string entityParser(std::string inputText)\n{\n    std::unordered_map<std::string, std::string> htmlEntities= {\n        {\"&quot;\", \"\\\"\"},\n        {\"&apos;\", \"'\"},\n        {\"&amp;\", \"&\"},\n        {\"&gt;\", \">\"},\n        {\"&lt;\", \"<\"},\n        {\"&frasl;\", \"/\"},\n    };\n\n    std::string parsedResult;\n    std::string currentEntity;\n    bool isInEntity= false;\n\n    for(char currentChar : inputText)\n    {\n        if(isInEntity)\n        {\n            currentEntity.push_back(currentChar);\n            if(currentChar == ';')\n            {\n                if(htmlEntities.find(currentEntity) != htmlEntities.end())\n                {\n                    parsedResult+= htmlEntities[currentEntity];\n                }\n                else\n                {\n                    parsedResult+= currentEntity;\n                }\n                isInEntity= false;\n                currentEntity.clear();\n            }\n        }\n        else\n        {\n            if(currentChar == '&')\n            {\n                isInEntity= true;\n                currentEntity.push_back(currentChar);\n            }\n            else\n            {\n                parsedResult.push_back(currentChar);\n            }\n        }\n    }\n\n    return parsedResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nint getDecimalValue(ListNode *head)\n{\n    int decimalNumber= 0;\n    while(head)\n    {\n        decimalNumber= (decimalNumber << 1) | head->value;\n        head= head->next;\n    }\n    return decimalNumber;\n}",
    "output": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nint getDecimalValue(ListNode *head)\n{\n    int decimalNumber= 0;\n    while(head)\n    {\n        decimalNumber= (decimalNumber << 1) | head->value;\n        head= head->next;\n    }\n    return decimalNumber;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSquareSideLength(vector<vector<int>> &matrix, int valueThreshold)\n{\n    int rowCount= matrix.size();\n    int colCount= matrix[0].size();\n    vector<vector<int>> dynamicProgramming(rowCount + 1, vector<int>(colCount + 1, 0));\n    int maxLength= 0;\n\n    for(int row= 1; row <= rowCount; row++)\n    {\n        for(int col= 1; col <= colCount; col++)\n        {\n            dynamicProgramming[row][col]= matrix[row - 1][col - 1] + dynamicProgramming[row][col - 1] + dynamicProgramming[row - 1][col] - dynamicProgramming[row - 1][col - 1];\n            int squareSize= maxLength + 1;\n            if(row >= squareSize && col >= squareSize && dynamicProgramming[row][col] - dynamicProgramming[row][col - squareSize] - dynamicProgramming[row - squareSize][col] + dynamicProgramming[row - squareSize][col - squareSize] <= valueThreshold)\n            {\n                maxLength++;\n            }\n        }\n    }\n    return maxLength;\n}",
    "output": "#include <bits/stdc++.h>\nint maxSquareSideLength(std::vector<std::vector<int>> &matrix, int valueThreshold)\n{\n    int rowCount= matrix.size();\n    int colCount= matrix[0].size();\n    std::vector<std::vector<int>> dynamicProgramming(rowCount + 1, std::vector<int>(colCount + 1, 0));\n    int maxLength= 0;\n\n    for(int row= 1; row <= rowCount; row++)\n    {\n        for(int col= 1; col <= colCount; col++)\n        {\n            dynamicProgramming[row][col]= matrix[row - 1][col - 1] + dynamicProgramming[row][col - 1] + dynamicProgramming[row - 1][col] - dynamicProgramming[row - 1][col - 1];\n            int squareSize= maxLength + 1;\n            if(row >= squareSize && col >= squareSize && dynamicProgramming[row][col] - dynamicProgramming[row][col - squareSize] - dynamicProgramming[row - squareSize][col] + dynamicProgramming[row - squareSize][col - squareSize] <= valueThreshold)\n            {\n                maxLength++;\n            }\n        }\n    }\n    return maxLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(vector<vector<int>> &grid, int maxRemovals)\n{\n    int rows = grid.size();\n    int columns = grid[0].size();\n    queue<tuple<int, int, int, int>> queue;\n    queue.push({0, 0, 0, maxRemovals});\n    vector<vector<vector<int>>> visited(rows, vector<vector<int>>(columns, vector<int>(maxRemovals + 1, false)));\n\n    while (!queue.empty())\n    {\n        auto [currentX, currentY, steps, remainingK] = queue.front();\n        queue.pop();\n\n        if (currentX == rows - 1 && currentY == columns - 1)\n            return steps;\n        if (visited[currentX][currentY][remainingK])\n            continue;\n        visited[currentX][currentY][remainingK] = true;\n\n        vector<vector<int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n        for (int i = 0; i < directions.size(); ++i)\n        {\n            int nextX = currentX + directions[i][0];\n            int nextY = currentY + directions[i][1];\n\n            if (nextX >= 0 && nextX < rows && nextY >= 0 && nextY < columns)\n            {\n                if (grid[nextX][nextY] == 1 && remainingK > 0)\n                {\n                    queue.push({nextX, nextY, steps + 1, remainingK - 1});\n                }\n                else if (grid[nextX][nextY] == 0)\n                {\n                    queue.push({nextX, nextY, steps + 1, remainingK});\n                }\n            }\n        }\n    }\n\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint shortestPath(std::vector<std::vector<int>> &grid, int maxRemovals)\n{\n    int rows= grid.size();\n    int columns= grid[0].size();\n    std::queue<std::tuple<int, int, int, int>> queue;\n    queue.push({0, 0, 0, maxRemovals});\n    std::vector<std::vector<std::vector<int>>> visited(rows, std::vector<std::vector<int>>(columns, std::vector<int>(maxRemovals + 1, false)));\n\n    while(!queue.empty())\n    {\n        auto [currentX, currentY, steps, remainingK]= queue.front();\n        queue.pop();\n\n        if(currentX == rows - 1 && currentY == columns - 1)\n            return steps;\n        if(visited[currentX][currentY][remainingK])\n            continue;\n        visited[currentX][currentY][remainingK]= true;\n\n        std::vector<std::vector<int>> directions= {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n        for(const auto &direction : directions)\n        {\n            int nextX= currentX + direction[0];\n            int nextY= currentY + direction[1];\n\n            if(nextX >= 0 && nextX < rows && nextY >= 0 && nextY < columns)\n            {\n                if(grid[nextX][nextY] == 1 && remainingK > 0)\n                {\n                    queue.push({nextX, nextY, steps + 1, remainingK - 1});\n                }\n                else if(grid[nextX][nextY] == 0)\n                {\n                    queue.push({nextX, nextY, steps + 1, remainingK});\n                }\n            }\n        }\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution\n{\n  public:\n    void generateStrings(int remainingCharacters, string &currentString, vector<string> &happyStrings)\n    {\n        if(remainingCharacters == 0)\n        {\n            happyStrings.push_back(currentString);\n            return;\n        }\n        for(char character= 'a'; character <= 'c'; ++character)\n        {\n            if(currentString.empty() || currentString.back() != character)\n            {\n                currentString.push_back(character);\n                generateStrings(remainingCharacters - 1, currentString, happyStrings);\n                currentString.pop_back();\n            }\n        }\n    }\n\n    string getHappyString(int length, int index)\n    {\n        vector<string> happyStrings;\n        string currentString= \"\";\n        generateStrings(length, currentString, happyStrings);\n        return index <= happyStrings.size() ? happyStrings[index - 1] : \"\";\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Solution\n{\n  public:\n    void generateStrings(int remainingCharacters, std::string &currentString, std::vector<std::string> &happyStrings)\n    {\n        if(remainingCharacters == 0)\n        {\n            happyStrings.push_back(currentString);\n            return;\n        }\n        for(char character= 'a'; character <= 'c'; ++character)\n        {\n            if(currentString.empty() || currentString.back() != character)\n            {\n                currentString.push_back(character);\n                generateStrings(remainingCharacters - 1, currentString, happyStrings);\n                currentString.pop_back();\n            }\n        }\n    }\n\n    std::string getHappyString(int length, int index)\n    {\n        std::vector<std::string> happyStrings;\n        std::string currentString= \"\";\n        generateStrings(length, currentString, happyStrings);\n        return index <= happyStrings.size() ? happyStrings[index - 1] : \"\";\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo= 1e9 + 7;\n\nint numDecodings(string encodedString, int maxValue)\n{\n    int stringLength= encodedString.size();\n    vector<int> decodingWays(stringLength + 1, 0);\n    decodingWays[stringLength]= 1;\n\n    for(int currentIndex= stringLength - 1; currentIndex >= 0; currentIndex--)\n    {\n        long decodedNumber= 0;\n        for(int nextIndex= currentIndex; nextIndex < stringLength && decodedNumber <= maxValue; nextIndex++)\n        {\n            decodedNumber= decodedNumber * 10 + encodedString[nextIndex] - '0';\n            if(decodedNumber >= 1 && decodedNumber <= maxValue)\n            {\n                decodingWays[currentIndex]= (decodingWays[currentIndex] + decodingWays[nextIndex + 1]) % modulo;\n            }\n        }\n    }\n    return decodingWays[0];\n}",
    "output": "#include <bits/stdc++.h>\nconst int modulo= 1e9 + 7;\n\nint numDecodings(std::string encodedString, int maxValue)\n{\n    int stringLength= encodedString.size();\n    std::vector<int> decodingWays(stringLength + 1, 0);\n    decodingWays[stringLength]= 1;\n\n    for(int currentIndex= stringLength - 1; currentIndex >= 0; currentIndex--)\n    {\n        long decodedNumber= 0;\n        for(int nextIndex= currentIndex; nextIndex < stringLength && decodedNumber <= maxValue; nextIndex++)\n        {\n            decodedNumber= decodedNumber * 10 + encodedString[nextIndex] - '0';\n            if(decodedNumber >= 1 && decodedNumber <= maxValue)\n            {\n                decodingWays[currentIndex]= (decodingWays[currentIndex] + decodingWays[nextIndex + 1]) % modulo;\n            }\n        }\n    }\n    return decodingWays[0];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring reformatString(string inputString)\n{\n    queue<char> letterQueue, digitQueue;\n\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char character = inputString[i];\n        if (isalpha(character))\n            letterQueue.push(character);\n        else\n            digitQueue.push(character);\n    }\n\n    if (abs((int)(letterQueue.size() - digitQueue.size())) > 1)\n        return \"\";\n\n    string reformattedString = \"\";\n    bool useLetter = letterQueue.size() > digitQueue.size();\n\n    while (!letterQueue.empty() || !digitQueue.empty())\n    {\n        if (useLetter)\n        {\n            reformattedString += letterQueue.front();\n            letterQueue.pop();\n        }\n        else\n        {\n            reformattedString += digitQueue.front();\n            digitQueue.pop();\n        }\n        useLetter = !useLetter;\n    }\n\n    return reformattedString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string reformatString(std::string inputString)\n{\n    std::queue<char> letterQueue, digitQueue;\n\n    for(char character : inputString)\n    {\n        if(isalpha(character))\n            letterQueue.push(character);\n        else\n            digitQueue.push(character);\n    }\n\n    if(abs((int)(letterQueue.size() - digitQueue.size())) > 1)\n        return \"\";\n\n    std::string reformattedString= \"\";\n    bool useLetter= letterQueue.size() > digitQueue.size();\n\n    while(!letterQueue.empty() || !digitQueue.empty())\n    {\n        if(useLetter)\n        {\n            reformattedString+= letterQueue.front();\n            letterQueue.pop();\n        }\n        else\n        {\n            reformattedString+= digitQueue.front();\n            digitQueue.pop();\n        }\n        useLetter= !useLetter;\n    }\n\n    return reformattedString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<string>> displayTable(vector<vector<string>> &orders)\n{\n    map<int, map<string, int>> tableOrders;\n    set<string> foodItemsSet;\n\n    for (int i = 0; i < orders.size(); ++i)\n    {\n        auto &order = orders[i];\n        int tableNumber = stoi(order[1]);\n        string foodItem = order[2];\n        tableOrders[tableNumber][foodItem]++;\n        foodItemsSet.insert(foodItem);\n    }\n\n    vector<vector<string>> result;\n    vector<string> header = {\"Table\"};\n    header.insert(header.end(), foodItemsSet.begin(), foodItemsSet.end());\n    result.push_back(header);\n\n    for (auto it = tableOrders.begin(); it != tableOrders.end(); ++it)\n    {\n        vector<string> row = {to_string(it->first)};\n        for (auto foodItemIt = foodItemsSet.begin(); foodItemIt != foodItemsSet.end(); ++foodItemIt)\n        {\n            row.push_back(to_string(it->second.at(*foodItemIt))); // using at() for safety\n        }\n        result.push_back(row);\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<std::string>> displayTable(std::vector<std::vector<std::string>> &orders)\n{\n    std::map<int, std::map<std::string, int>> tableOrders;\n    std::set<std::string> foodItemsSet;\n\n    for(auto &order : orders)\n    {\n        int tableNumber= std::stoi(order[1]);\n        std::string foodItem= order[2];\n        tableOrders[tableNumber][foodItem]++;\n        foodItemsSet.insert(foodItem);\n    }\n\n    std::vector<std::vector<std::string>> result;\n    std::vector<std::string> header= {\"Table\"};\n    header.insert(header.end(), foodItemsSet.begin(), foodItemsSet.end());\n    result.push_back(header);\n\n    for(auto &table : tableOrders)\n    {\n        std::vector<std::string> row= {std::to_string(table.first)};\n        for(const auto &foodItem : foodItemsSet)\n        {\n            row.push_back(std::to_string(table.second[foodItem]));\n        }\n        result.push_back(row);\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfFrogs(string croakOfFrogs)\n{\n    int croakCounter[5] = {0};\n    int currentFrogs = 0, maxFrogs = 0;\n    for (int i = 0; i < croakOfFrogs.size(); ++i)\n    {\n        char croakChar = croakOfFrogs[i];\n        int index = string(\"croak\").find(croakChar);\n        croakCounter[index]++;\n        if (index == 0)\n        {\n            maxFrogs = max(maxFrogs, ++currentFrogs);\n        }\n        else if (--croakCounter[index - 1] < 0)\n        {\n            return -1;\n        }\n        else if (index == 4)\n        {\n            currentFrogs--;\n        }\n    }\n    return (croakCounter[0] == croakCounter[1] && croakCounter[1] == croakCounter[2] && croakCounter[2] == croakCounter[3] && croakCounter[3] == croakCounter[4]) ? maxFrogs : -1;\n}",
    "output": "#include <bits/stdc++.h>\nint minNumberOfFrogs(std::string croakOfFrogs)\n{\n    int croakCounter[5]= {0};\n    int currentFrogs= 0, maxFrogs= 0;\n    for(char croakChar : croakOfFrogs)\n    {\n        int index= std::string(\"croak\").find(croakChar);\n        croakCounter[index]++;\n        if(index == 0)\n        {\n            maxFrogs= std::max(maxFrogs, ++currentFrogs);\n        }\n        else if(--croakCounter[index - 1] < 0)\n        {\n            return -1;\n        }\n        else if(index == 4)\n        {\n            currentFrogs--;\n        }\n    }\n    return (croakCounter[0] == croakCounter[1] && croakCounter[1] == croakCounter[2] && croakCounter[2] == croakCounter[3] && croakCounter[3] == croakCounter[4]) ? maxFrogs : -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint waysToBuildArray(int arrayLength, int maxValue, int targetSum)\n{\n    const int modulus= 1e9 + 7;\n    vector<vector<int>> dynamicProgramming(arrayLength + 1, vector<int>(targetSum + 1, 0));\n    dynamicProgramming[0][0]= 1;\n    for(int currentLength= 1; currentLength <= arrayLength; ++currentLength)\n    {\n        for(int currentSum= 0; currentSum <= targetSum; ++currentSum)\n        {\n            for(int currentValue= 1; currentValue <= maxValue; ++currentValue)\n            {\n                if(currentSum < currentLength * (currentValue - 1))\n                {\n                    dynamicProgramming[currentLength][currentSum]= (dynamicProgramming[currentLength][currentSum] + dynamicProgramming[currentLength - 1][currentSum - (currentLength - 1) * (currentValue - 1)]) % modulus;\n                }\n            }\n        }\n    }\n    return dynamicProgramming[arrayLength][targetSum];\n}",
    "output": "#include <bits/stdc++.h>\nint waysToBuildArray(int arrayLength, int maxValue, int targetSum)\n{\n    const int modulus = 1e9 + 7;\n    std::vector<std::vector<int>> dynamicProgramming(arrayLength + 1, std::vector<int>(targetSum + 1, 0));\n    dynamicProgramming[0][0] = 1;\n    for(int currentLength = 1; currentLength <= arrayLength; ++currentLength)\n    {\n        for(int currentSum = 0; currentSum <= targetSum; ++currentSum)\n        {\n            for(int currentValue = 1; currentValue <= maxValue; ++currentValue)\n            {\n                if(currentSum < currentLength * (currentValue - 1))\n                {\n                    dynamicProgramming[currentLength][currentSum] = (dynamicProgramming[currentLength][currentSum] + dynamicProgramming[currentLength - 1][currentSum - (currentLength - 1) * (currentValue - 1)]) % modulus;\n                }\n            }\n        }\n    }\n    return dynamicProgramming[arrayLength][targetSum];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPossibleDivide(vector<int> &numberList, int groupSize)\n{\n    map<int, int> numberCounts;\n    for(int number : numberList)\n        numberCounts[number]++;\n\n    for(auto iterator = numberCounts.begin(); iterator != numberCounts.end(); ++iterator)\n    {\n        if(iterator->second > 0)\n        {\n            for(int index = groupSize - 1; index >= 0; --index)\n            {\n                if((numberCounts[iterator->first + index] -= iterator->second) < 0)\n                    return false;\n            }\n        }\n    }\n\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isPossibleDivide(std::vector<int> &numberList, int groupSize)\n{\n    std::map<int, int> numberCounts;\n    for(int number : numberList)\n        numberCounts[number]++;\n\n    for(auto iterator= numberCounts.begin(); iterator != numberCounts.end(); ++iterator)\n    {\n        if(iterator->second > 0)\n        {\n            for(int index= groupSize - 1; index >= 0; --index)\n            {\n                if((numberCounts[iterator->first + index]-= iterator->second) < 0)\n                    return false;\n            }\n        }\n    }\n\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSubstringOccurrences(const string &inputString, int maxUniqueChars)\n{\n    int stringLength= inputString.length(), maxOccurrences= 0;\n    unordered_map<char, int> characterFrequency;\n    for(int index= 0; index < stringLength; ++index)\n    {\n        characterFrequency[inputString[index]]++;\n        if(characterFrequency.size() <= maxUniqueChars)\n        {\n            maxOccurrences= max(maxOccurrences, characterFrequency[inputString[index]]);\n        }\n    }\n    return (characterFrequency.size() > maxUniqueChars) ? 0 : maxOccurrences;\n}",
    "output": "#include <bits/stdc++.h>\nint maxSubstringOccurrences(const std::string &inputString, int maxUniqueChars)\n{\n    int stringLength= inputString.length(), maxOccurrences= 0;\n    std::unordered_map<char, int> characterFrequency;\n    for(int index= 0; index < stringLength; ++index)\n    {\n        characterFrequency[inputString[index]]++;\n        if(characterFrequency.size() <= maxUniqueChars)\n        {\n            maxOccurrences= std::max(maxOccurrences, characterFrequency[inputString[index]]);\n        }\n    }\n    return (characterFrequency.size() > maxUniqueChars) ? 0 : maxOccurrences;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxCandies(vector<int> &boxStatus, vector<int> &boxCandies, vector<vector<int>> &boxKeys, vector<vector<int>> &containedBoxes, vector<int> &initialBoxes)\n{\n    int totalCandies = 0;\n    unordered_set<int> visitedBoxes;\n    queue<int> boxesToProcess;\n\n    for (int i = 0; i < initialBoxes.size(); ++i)\n    {\n        int box = initialBoxes[i];\n        boxesToProcess.push(box);\n    }\n\n    while (!boxesToProcess.empty())\n    {\n        int currentBox = boxesToProcess.front();\n        boxesToProcess.pop();\n\n        if (visitedBoxes.count(currentBox))\n        {\n            continue;\n        }\n\n        visitedBoxes.insert(currentBox);\n\n        if (boxStatus[currentBox] == 1)\n        {\n            totalCandies += boxCandies[currentBox];\n            for (int j = 0; j < boxKeys[currentBox].size(); ++j)\n            {\n                int key = boxKeys[currentBox][j];\n                boxStatus[key] = 1;\n                if (visitedBoxes.count(key))\n                {\n                    boxesToProcess.push(key);\n                }\n            }\n            for (int j = 0; j < containedBoxes[currentBox].size(); ++j)\n            {\n                int contained = containedBoxes[currentBox][j];\n                boxesToProcess.push(contained);\n            }\n        }\n        else\n        {\n            boxesToProcess.push(currentBox);\n        }\n    }\n\n    return totalCandies;\n}",
    "output": "#include <bits/stdc++.h>\nint maxCandies(std::vector<int> &boxStatus, std::vector<int> &boxCandies, std::vector<std::vector<int>> &boxKeys, std::vector<std::vector<int>> &containedBoxes, std::vector<int> &initialBoxes)\n{\n    int totalCandies= 0;\n    std::unordered_set<int> visitedBoxes;\n    std::queue<int> boxesToProcess;\n\n    for(int box : initialBoxes)\n    {\n        boxesToProcess.push(box);\n    }\n\n    while(!boxesToProcess.empty())\n    {\n        int currentBox= boxesToProcess.front();\n        boxesToProcess.pop();\n\n        if(visitedBoxes.count(currentBox))\n        {\n            continue;\n        }\n\n        visitedBoxes.insert(currentBox);\n\n        if(boxStatus[currentBox] == 1)\n        {\n            totalCandies+= boxCandies[currentBox];\n            for(int key : boxKeys[currentBox])\n            {\n                boxStatus[key]= 1;\n                if(visitedBoxes.count(key))\n                {\n                    boxesToProcess.push(key);\n                }\n            }\n            for(int contained : containedBoxes[currentBox])\n            {\n                boxesToProcess.push(contained);\n            }\n        }\n        else\n        {\n            boxesToProcess.push(currentBox);\n        }\n    }\n\n    return totalCandies;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxSum(vector<int> &numberArray, int subarraySize)\n{\n    int arraySize= numberArray.size();\n    priority_queue<int> maxHeap;\n    vector<long long> dynamicProgramming(arraySize + 1, 0);\n    long long maximumSum= 0;\n\n    for(int index= 0; index < arraySize; ++index)\n    {\n        if(index >= subarraySize)\n            maxHeap.pop(); // Maintain the maximum size of k\n        maxHeap.push(dynamicProgramming[index] - numberArray[index]);\n        dynamicProgramming[index + 1]= max(dynamicProgramming[index], numberArray[index] + maxHeap.top());\n        maximumSum= max(maximumSum, dynamicProgramming[index + 1]);\n    }\n\n    return maximumSum;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMaxSum(std::vector<int> &numberArray, int subarraySize)\n{\n    int arraySize= numberArray.size();\n    std::priority_queue<int> maxHeap;\n    std::vector<long long> dynamicProgramming(arraySize + 1, 0);\n    long long maximumSum= 0;\n\n    for(int index= 0; index < arraySize; ++index)\n    {\n        if(index >= subarraySize)\n            maxHeap.pop(); // Maintain the maximum size of k\n        maxHeap.push(dynamicProgramming[index] - numberArray[index]);\n        dynamicProgramming[index + 1]= std::max(dynamicProgramming[index], numberArray[index] + maxHeap.top());\n        maximumSum= std::max(maximumSum, dynamicProgramming[index + 1]);\n    }\n\n    return maximumSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> sumZero(int count)\n{\n    vector<int> result;\n    for(int index= 1; index <= count / 2; index++)\n    {\n        result.push_back(index);\n        result.push_back(-index);\n    }\n    if(count % 2 != 0)\n    {\n        result.push_back(0);\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> sumZero(int count)\n{\n    std::vector<int> result;\n    for(int index= 1; index <= count / 2; index++)\n    {\n        result.push_back(index);\n        result.push_back(-index);\n    }\n    if(count % 2 != 0)\n    {\n        result.push_back(0);\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int v) : value(v), leftChild(NULL), rightChild(NULL) {}\n};\n\nvoid inorderTraversal(TreeNode *rootNode, vector<int> &output)\n{\n    stack<TreeNode *> nodeStack;\n    TreeNode *currentNode= rootNode;\n\n    while(currentNode || !nodeStack.empty())\n    {\n        while(currentNode)\n        {\n            nodeStack.push(currentNode);\n            currentNode= currentNode->leftChild;\n        }\n        currentNode= nodeStack.top();\n        nodeStack.pop();\n        output.push_back(currentNode->value);\n        currentNode= currentNode->rightChild;\n    }\n}\n\nvector<int> getAllElements(TreeNode *treeRoot1, TreeNode *treeRoot2)\n{\n    vector<int> tree1Elements, tree2Elements;\n    inorderTraversal(treeRoot1, tree1Elements);\n    inorderTraversal(treeRoot2, tree2Elements);\n\n    vector<int> mergedResult;\n    int index1= 0, index2= 0;\n    while(index1 < tree1Elements.size() || index2 < tree2Elements.size())\n    {\n        if(index1 < tree1Elements.size() && (index2 >= tree2Elements.size() || tree1Elements[index1] <= tree2Elements[index2]))\n        {\n            mergedResult.push_back(tree1Elements[index1++]);\n        }\n        else\n        {\n            mergedResult.push_back(tree2Elements[index2++]);\n        }\n    }\n\n    return mergedResult;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int v) : value(v), leftChild(NULL), rightChild(NULL) {}\n};\n\nvoid inorderTraversal(TreeNode *rootNode, std::vector<int> &output)\n{\n    std::stack<TreeNode *> nodeStack;\n    TreeNode *currentNode = rootNode;\n\n    while(currentNode || !nodeStack.empty())\n    {\n        while(currentNode)\n        {\n            nodeStack.push(currentNode);\n            currentNode = currentNode->leftChild;\n        }\n        currentNode = nodeStack.top();\n        nodeStack.pop();\n        output.push_back(currentNode->value);\n        currentNode = currentNode->rightChild;\n    }\n}\n\nstd::vector<int> getAllElements(TreeNode *treeRoot1, TreeNode *treeRoot2)\n{\n    std::vector<int> tree1Elements, tree2Elements;\n    inorderTraversal(treeRoot1, tree1Elements);\n    inorderTraversal(treeRoot2, tree2Elements);\n\n    std::vector<int> mergedResult;\n    int index1 = 0, index2 = 0;\n    while(index1 < tree1Elements.size() || index2 < tree2Elements.size())\n    {\n        if(index1 < tree1Elements.size() && (index2 >= tree2Elements.size() || tree1Elements[index1] <= tree2Elements[index2]))\n        {\n            mergedResult.push_back(tree1Elements[index1++]);\n        }\n        else\n        {\n            mergedResult.push_back(tree2Elements[index2++]);\n        }\n    }\n\n    return mergedResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canReach(vector<int> &numbers, int startIndex)\n{\n    if(startIndex >= 0 && startIndex < numbers.size() && numbers[startIndex] >= 0)\n    {\n        if(numbers[startIndex] == 0)\n            return true;\n\n        numbers[startIndex]= -numbers[startIndex];\n        return canReach(numbers, startIndex + numbers[startIndex]) || canReach(numbers, startIndex - numbers[startIndex]);\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool canReach(std::vector<int> &numbers, int startIndex)\n{\n    if(startIndex >= 0 && startIndex < numbers.size() && numbers[startIndex] >= 0)\n    {\n        if(numbers[startIndex] == 0)\n            return true;\n\n        numbers[startIndex]= -numbers[startIndex];\n        return canReach(numbers, startIndex + numbers[startIndex]) || canReach(numbers, startIndex - numbers[startIndex]);\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isSolvable(map<char, int> characterValues, int targetResult)\n{\n    int totalSum = 0;\n    for (auto const &characterValuePair : characterValues)\n    {\n        totalSum += characterValuePair.second;\n    }\n    return totalSum % 10 == targetResult % 10;\n}",
    "output": "#include <bits/stdc++.h>\nbool isSolvable(std::map<char, int> characterValues, int targetResult)\n{\n    int totalSum= 0;\n    for(auto const &characterValuePair : characterValues)\n    {\n        totalSum+= characterValuePair.second;\n    }\n    return totalSum % 10 == targetResult % 10;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nbool isValidSequence(TreeNode *rootNode, vector<int> &sequenceArray, int currentIndex= 0)\n{\n    if(rootNode == NULL || currentIndex >= sequenceArray.size() || sequenceArray[currentIndex] != rootNode->value)\n    {\n        return false;\n    }\n    if(rootNode->leftChild == NULL && rootNode->rightChild == NULL)\n    {\n        return currentIndex == sequenceArray.size() - 1;\n    }\n    return isValidSequence(rootNode->leftChild, sequenceArray, currentIndex + 1) || isValidSequence(rootNode->rightChild, sequenceArray, currentIndex + 1);\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nbool isValidSequence(TreeNode *rootNode, std::vector<int> &sequenceArray, int currentIndex = 0)\n{\n    if(rootNode == NULL || currentIndex >= sequenceArray.size() || sequenceArray[currentIndex] != rootNode->value)\n    {\n        return false;\n    }\n    if(rootNode->leftChild == NULL && rootNode->rightChild == NULL)\n    {\n        return currentIndex == sequenceArray.size() - 1;\n    }\n    return isValidSequence(rootNode->leftChild, sequenceArray, currentIndex + 1) || isValidSequence(rootNode->rightChild, sequenceArray, currentIndex + 1);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid findAncestors(int currentNode, vector<vector<int>> &adjacencyList, vector<bool> &visitedNodes, vector<int> &ancestors)\n{\n    if(visitedNodes[currentNode])\n        return;\n    visitedNodes[currentNode] = true;\n    for(int i = 0; i < adjacencyList[currentNode].size(); ++i)\n    {\n        int ancestor = adjacencyList[currentNode][i];\n        ancestors.push_back(ancestor);\n        findAncestors(ancestor, adjacencyList, visitedNodes, ancestors);\n    }\n}\n\nvector<vector<int>> findAncestorsInDAG(int nodeCount, vector<vector<int>> &edgeList)\n{\n    vector<vector<int>> adjacencyList(nodeCount), ancestorsList(nodeCount);\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        vector<bool> visitedNodes(nodeCount, false);\n        findAncestors(i, adjacencyList, visitedNodes, ancestorsList[i]);\n        sort(ancestorsList[i].begin(), ancestorsList[i].end());\n    }\n    return ancestorsList;\n}",
    "output": "#include <bits/stdc++.h>\nvoid findAncestors(int currentNode, std::vector<std::vector<int>> &adjacencyList, std::vector<bool> &visitedNodes, std::vector<int> &ancestors)\n{\n    if(visitedNodes[currentNode])\n        return;\n    visitedNodes[currentNode]= true;\n    for(int ancestor : adjacencyList[currentNode])\n    {\n        ancestors.push_back(ancestor);\n        findAncestors(ancestor, adjacencyList, visitedNodes, ancestors);\n    }\n}\n\nstd::vector<std::vector<int>> findAncestorsInDAG(int nodeCount, std::vector<std::vector<int>> &edgeList)\n{\n    std::vector<std::vector<int>> adjacencyList(nodeCount), ancestorsList(nodeCount);\n    for(std::vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        std::vector<bool> visitedNodes(nodeCount, false);\n        findAncestors(i, adjacencyList, visitedNodes, ancestorsList[i]);\n        std::sort(ancestorsList[i].begin(), ancestorsList[i].end());\n    }\n    return ancestorsList;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxDifference(int number)\n{\n    int firstDigit = -1, secondDigit = -1;\n    string numberString = to_string(number);\n    for (int i = 0; i < numberString.size(); ++i)\n    {\n        char currentChar = numberString[i];\n        if (firstDigit == -1 && currentChar != '9')\n        {\n            firstDigit = currentChar - '0';\n        }\n        if (secondDigit == -1 && currentChar > '1')\n        {\n            secondDigit = currentChar - '0';\n        }\n        if (firstDigit != -1 && secondDigit != -1)\n        {\n            break;\n        }\n    }\n    for (int i = 0; i < numberString.size(); ++i)\n    {\n        char &currentChar = numberString[i];\n        if (currentChar - '0' == firstDigit)\n        {\n            currentChar = '9';\n        }\n        else if (currentChar - '0' == secondDigit)\n        {\n            currentChar = (numberString.front() == currentChar) ? '1' : '0';\n        }\n    }\n    return stoi(numberString) - number;\n}",
    "output": "#include <bits/stdc++.h>\nint maxDifference(int number)\n{\n    int firstDigit= -1, secondDigit= -1;\n    std::string numberString= std::to_string(number);\n    for(char currentChar : numberString)\n    {\n        if(firstDigit == -1 && currentChar != '9')\n        {\n            firstDigit= currentChar - '0';\n        }\n        if(secondDigit == -1 && currentChar > '1')\n        {\n            secondDigit= currentChar - '0';\n        }\n        if(firstDigit != -1 && secondDigit != -1)\n        {\n            break;\n        }\n    }\n    for(char &currentChar : numberString)\n    {\n        if(currentChar - '0' == firstDigit)\n        {\n            currentChar= '9';\n        }\n        else if(currentChar - '0' == secondDigit)\n        {\n            currentChar= (numberString.front() == currentChar) ? '1' : '0';\n        }\n    }\n    return std::stoi(numberString) - number;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Encrypter\n{\n  public:\n    Encrypter(vector<char> keySet, vector<string> valueSet, vector<string> wordDictionary)\n    {\n        for(int i= 0; i < keySet.size(); i++)\n        {\n            encryptMap[keySet[i]]= valueSet[i];\n            decryptMap[valueSet[i]]= keySet[i];\n        }\n        for(int i = 0; i < wordDictionary.size(); i++)\n        {\n            this->dictionary.insert(wordDictionary[i]);\n        }\n    }\n\n    string encrypt(const string &originalString)\n    {\n        string encryptedString= \"\";\n        for(int i = 0; i < originalString.size(); i++)\n        {\n            char character = originalString[i];\n            if(encryptMap.find(character) == encryptMap.end())\n            {\n                return \"\";\n            }\n            encryptedString+= encryptMap[character];\n        }\n        return encryptedString;\n    }\n\n    string decrypt(const string &encryptedString)\n    {\n        string decryptedString= \"\";\n        for(int i= 0; i < encryptedString.size(); i+= 2)\n        {\n            string tempSubstring= encryptedString.substr(i, 2);\n            if(decryptMap.find(tempSubstring) == decryptMap.end())\n            {\n                return \"\";\n            }\n            decryptedString+= decryptMap[tempSubstring];\n        }\n        if(dictionary.find(decryptedString) == dictionary.end())\n        {\n            return \"\";\n        }\n        return decryptedString;\n    }\n\n  private:\n    unordered_map<char, string> encryptMap;\n    unordered_map<string, char> decryptMap;\n    unordered_set<string> dictionary;\n};",
    "output": "#include <bits/stdc++.h>\nclass Encrypter\n{\n  public:\n    Encrypter(std::vector<char> keySet, std::vector<std::string> valueSet, std::vector<std::string> wordDictionary)\n    {\n        for(int i= 0; i < keySet.size(); i++)\n        {\n            encryptMap[keySet[i]]= valueSet[i];\n            decryptMap[valueSet[i]]= keySet[i];\n        }\n        for(const auto &word : wordDictionary)\n        {\n            this->dictionary.insert(word);\n        }\n    }\n\n    std::string encrypt(const std::string &originalString)\n    {\n        std::string encryptedString= \"\";\n        for(char character : originalString)\n        {\n            if(encryptMap.find(character) == encryptMap.end())\n            {\n                return \"\";\n            }\n            encryptedString+= encryptMap[character];\n        }\n        return encryptedString;\n    }\n\n    std::string decrypt(const std::string &encryptedString)\n    {\n        std::string decryptedString= \"\";\n        for(int i= 0; i < encryptedString.size(); i+= 2)\n        {\n            std::string tempSubstring= encryptedString.substr(i, 2);\n            if(decryptMap.find(tempSubstring) == decryptMap.end())\n            {\n                return \"\";\n            }\n            decryptedString+= decryptMap[tempSubstring];\n        }\n        if(dictionary.find(decryptedString) == dictionary.end())\n        {\n            return \"\";\n        }\n        return decryptedString;\n    }\n\n  private:\n    std::unordered_map<char, std::string> encryptMap;\n    std::unordered_map<std::string, char> decryptMap;\n    std::unordered_set<std::string> dictionary;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring decodeString(string encodedString)\n{\n    string decodedResult= \"\";\n    for(int currentIndex= 0; currentIndex < encodedString.length(); currentIndex++)\n    {\n        if(currentIndex + 2 < encodedString.length() && encodedString[currentIndex + 2] == '#')\n        {\n            decodedResult+= ('a' + (encodedString[currentIndex] - '0') * 10 + (encodedString[currentIndex + 1] - '0') - 10);\n            currentIndex+= 2;\n        }\n        else\n        {\n            decodedResult+= ('a' + encodedString[currentIndex] - '1');\n        }\n    }\n    return decodedResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string decodeString(std::string encodedString)\n{\n    std::string decodedResult= \"\";\n    for(int currentIndex= 0; currentIndex < encodedString.length(); currentIndex++)\n    {\n        if(currentIndex + 2 < encodedString.length() && encodedString[currentIndex + 2] == '#')\n        {\n            decodedResult+= ('a' + (encodedString[currentIndex] - '0') * 10 + (encodedString[currentIndex + 1] - '0') - 10);\n            currentIndex+= 2;\n        }\n        else\n        {\n            decodedResult+= ('a' + encodedString[currentIndex] - '1');\n        }\n    }\n    return decodedResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> watchedVideosByFriends(vector<vector<string>> &watchedVideos, vector<vector<int>> &friends, int userId, int targetLevel)\n{\n    unordered_set<int> visitedUsers;\n    queue<pair<int, int>> userQueue;\n    unordered_map<string, int> videoFrequency;\n\n    userQueue.push({userId, 0});\n    visitedUsers.insert(userId);\n\n    while(!userQueue.empty())\n    {\n        int currentUserId = userQueue.front().first;\n        int currentLevel = userQueue.front().second;\n        userQueue.pop();\n\n        if(currentLevel == targetLevel)\n        {\n            for(int i = 0; i < watchedVideos[currentUserId].size(); ++i)\n            {\n                const string &video = watchedVideos[currentUserId][i];\n                videoFrequency[video]++;\n            }\n        }\n        else if(currentLevel < targetLevel)\n        {\n            for(int j = 0; j < friends[currentUserId].size(); ++j)\n            {\n                int friendId = friends[currentUserId][j];\n                if(visitedUsers.find(friendId) == visitedUsers.end())\n                {\n                    visitedUsers.insert(friendId);\n                    userQueue.push({friendId, currentLevel + 1});\n                }\n            }\n        }\n    }\n\n    vector<string> result;\n    for(const auto &pair : videoFrequency)\n    {\n        result.push_back(pair.first);\n    }\n\n    sort(result.begin(), result.end(), [&videoFrequency](const string &a, const string &b)\n         {\n        if (videoFrequency[a] == videoFrequency[b]) {\n            return a < b;\n        } else {\n            return videoFrequency[a] < videoFrequency[b];\n        } });\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> watchedVideosByFriends(std::vector<std::vector<std::string>> &watchedVideos, std::vector<std::vector<int>> &friends, int userId, int targetLevel)\n{\n    std::unordered_set<int> visitedUsers;\n    std::queue<std::pair<int, int>> userQueue;\n    std::unordered_map<std::string, int> videoFrequency;\n\n    userQueue.push({userId, 0});\n    visitedUsers.insert(userId);\n\n    while(!userQueue.empty())\n    {\n        int currentUserId= userQueue.front().first;\n        int currentLevel= userQueue.front().second;\n        userQueue.pop();\n\n        if(currentLevel == targetLevel)\n        {\n            for(const std::string &video : watchedVideos[currentUserId])\n            {\n                videoFrequency[video]++;\n            }\n        }\n        else if(currentLevel < targetLevel)\n        {\n            for(int friendId : friends[currentUserId])\n            {\n                if(visitedUsers.find(friendId) == visitedUsers.end())\n                {\n                    visitedUsers.insert(friendId);\n                    userQueue.push({friendId, currentLevel + 1});\n                }\n            }\n        }\n    }\n\n    std::vector<std::string> result;\n    for(const auto &pair : videoFrequency)\n    {\n        result.push_back(pair.first);\n    }\n\n    std::sort(result.begin(), result.end(), [&videoFrequency](const std::string &a, const std::string &b)\n         {\n        if (videoFrequency[a] == videoFrequency[b]) {\n            return a < b;\n        } else {\n            return videoFrequency[a] < videoFrequency[b];\n        } });\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minStepsToMakePalindrome(string inputString)\n{\n    int stringLength = inputString.size();\n    vector<vector<int>> dpTable(stringLength, vector<int>(stringLength, 0));\n\n    for(int startIndex = stringLength - 2; startIndex >= 0; startIndex--)\n    {\n        for(int endIndex = startIndex + 1; endIndex < stringLength; endIndex++)\n        {\n            if(inputString[startIndex] == inputString[endIndex])\n            {\n                dpTable[startIndex][endIndex] = dpTable[startIndex + 1][endIndex - 1];\n            }\n            else\n            {\n                dpTable[startIndex][endIndex] = 1 + min(dpTable[startIndex + 1][endIndex], dpTable[startIndex][endIndex - 1]);\n            }\n        }\n    }\n\n    return dpTable[0][stringLength - 1];\n}",
    "output": "int minStepsToMakePalindrome(std::string inputString)\n{\n    int stringLength= inputString.size();\n    std::vector<std::vector<int>> dpTable(stringLength, std::vector<int>(stringLength, 0));\n\n    for(int startIndex= stringLength - 2; startIndex >= 0; startIndex--)\n    {\n        for(int endIndex= startIndex + 1; endIndex < stringLength; endIndex++)\n        {\n            if(inputString[startIndex] == inputString[endIndex])\n            {\n                dpTable[startIndex][endIndex]= dpTable[startIndex + 1][endIndex - 1];\n            }\n            else\n            {\n                dpTable[startIndex][endIndex]= 1 + std::min(dpTable[startIndex + 1][endIndex], dpTable[startIndex][endIndex - 1]);\n            }\n        }\n    }\n\n    return dpTable[0][stringLength - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For std::max\nusing namespace std;\n\nint longestSubarray(vector<int> &inputNumbers, int valueLimit)\n{\n    deque<int> maxDeque, minDeque;\n    int leftIndex= 0, rightIndex= 0, longestLength= 0;\n    while(rightIndex < inputNumbers.size())\n    {\n        while(!maxDeque.empty() && inputNumbers[rightIndex] > maxDeque.back())\n            maxDeque.pop_back();\n        while(!minDeque.empty() && inputNumbers[rightIndex] < minDeque.back())\n            minDeque.pop_back();\n\n        maxDeque.push_back(inputNumbers[rightIndex]);\n        minDeque.push_back(inputNumbers[rightIndex]);\n\n        while(maxDeque.front() - minDeque.front() > valueLimit)\n        {\n            if(maxDeque.front() == inputNumbers[leftIndex])\n                maxDeque.pop_front();\n            if(minDeque.front() == inputNumbers[leftIndex])\n                minDeque.pop_front();\n            leftIndex++;\n        }\n\n        longestLength= max(longestLength, rightIndex - leftIndex + 1);\n        rightIndex++;\n    }\n    return longestLength;\n}",
    "output": "#include <bits/stdc++.h>\nint longestSubarray(std::vector<int> &inputNumbers, int valueLimit)\n{\n    std::deque<int> maxDeque, minDeque;\n    int leftIndex= 0, rightIndex= 0, longestLength= 0;\n    while(rightIndex < inputNumbers.size())\n    {\n        while(!maxDeque.empty() && inputNumbers[rightIndex] > maxDeque.back())\n            maxDeque.pop_back();\n        while(!minDeque.empty() && inputNumbers[rightIndex] < minDeque.back())\n            minDeque.pop_back();\n\n        maxDeque.push_back(inputNumbers[rightIndex]);\n        minDeque.push_back(inputNumbers[rightIndex]);\n\n        while(maxDeque.front() - minDeque.front() > valueLimit)\n        {\n            if(maxDeque.front() == inputNumbers[leftIndex])\n                maxDeque.pop_front();\n            if(minDeque.front() == inputNumbers[leftIndex])\n                minDeque.pop_front();\n            leftIndex++;\n        }\n\n        longestLength= std::max(longestLength, rightIndex - leftIndex + 1);\n        rightIndex++;\n    }\n    return longestLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint kthSmallestSum(vector<vector<int>> &matrix, int k)\n{\n    int rowCount= matrix.size(), colCount= matrix[0].size();\n    priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> minHeap;\n    minHeap.push({matrix[0][0], 0, 0});\n\n    vector<vector<bool>> visited(rowCount, vector<bool>(colCount, false));\n    visited[0][0]= true;\n    int elementCount= 0;\n\n    while(!minHeap.empty())\n    {\n        auto current= minHeap.top();\n        minHeap.pop();\n        int currentSum= current[0], currentRow= current[1], currentCol= current[2];\n\n        elementCount++;\n        if(elementCount == k)\n        {\n            return currentSum;\n        }\n\n        if(currentRow + 1 < rowCount && !visited[currentRow + 1][currentCol])\n        {\n            visited[currentRow + 1][currentCol]= true;\n            minHeap.push({currentSum - matrix[currentRow][currentCol] + matrix[currentRow + 1][currentCol], currentRow + 1, currentCol});\n        }\n\n        if(currentCol + 1 < colCount && !visited[currentRow][currentCol + 1])\n        {\n            visited[currentRow][currentCol + 1]= true;\n            minHeap.push({currentSum - matrix[currentRow][currentCol] + matrix[currentRow][currentCol + 1], currentRow, currentCol + 1});\n        }\n    }\n\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint kthSmallestSum(std::vector<std::vector<int>> &matrix, int k)\n{\n    int rowCount = matrix.size(), colCount = matrix[0].size();\n    std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, std::greater<std::vector<int>>> minHeap;\n    minHeap.push({matrix[0][0], 0, 0});\n\n    std::vector<std::vector<bool>> visited(rowCount, std::vector<bool>(colCount, false));\n    visited[0][0] = true;\n    int elementCount = 0;\n\n    while(!minHeap.empty())\n    {\n        auto current = minHeap.top();\n        minHeap.pop();\n        int currentSum = current[0], currentRow = current[1], currentCol = current[2];\n\n        elementCount++;\n        if(elementCount == k)\n        {\n            return currentSum;\n        }\n\n        if(currentRow + 1 < rowCount && !visited[currentRow + 1][currentCol])\n        {\n            visited[currentRow + 1][currentCol] = true;\n            minHeap.push({currentSum - matrix[currentRow][currentCol] + matrix[currentRow + 1][currentCol], currentRow + 1, currentCol});\n        }\n\n        if(currentCol + 1 < colCount && !visited[currentRow][currentCol + 1])\n        {\n            visited[currentRow][currentCol + 1] = true;\n            minHeap.push({currentSum - matrix[currentRow][currentCol] + matrix[currentRow][currentCol + 1], currentRow, currentCol + 1});\n        }\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> buildArray(vector<int> &target, int size)\n{\n    vector<string> result;\n    int currentNumber = 1;\n    for (int i = 0; i < target.size(); ++i)\n    {\n        int number = target[i];\n        while (currentNumber < number)\n        {\n            result.push_back(\"Push \");\n            result.push_back(\"Pop \");\n            currentNumber++;\n        }\n        result.push_back(\"Push \");\n        currentNumber++;\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> buildArray(std::vector<int> &target, int size)\n{\n    std::vector<std::string> result;\n    int currentNumber= 1;\n    for(int number : target)\n    {\n        while(currentNumber < number)\n        {\n            result.push_back(\"Push \");\n            result.push_back(\"Pop \");\n            currentNumber++;\n        }\n        result.push_back(\"Push \");\n        currentNumber++;\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint makeConnected(int totalComputers, vector<vector<int>> &connections)\n{\n    vector<vector<int>> adjacencyList(totalComputers);\n    vector<bool> visited(totalComputers, false);\n    int connectedComponents = 0, extraEdges = 0;\n\n    for (int i = 0; i < connections.size(); ++i)\n    {\n        adjacencyList[connections[i][0]].push_back(connections[i][1]);\n        adjacencyList[connections[i][1]].push_back(connections[i][0]);\n    }\n\n    for (int computer = 0; computer < totalComputers; ++computer)\n    {\n        if (!visited[computer])\n        {\n            connectedComponents++;\n            vector<int> stack = {computer};\n\n            while (!stack.empty())\n            {\n                int currentComputer = stack.back();\n                stack.pop_back();\n\n                if (!visited[currentComputer])\n                {\n                    visited[currentComputer] = true;\n                    for (int j = 0; j < adjacencyList[currentComputer].size(); ++j)\n                    {\n                        int neighbor = adjacencyList[currentComputer][j];\n                        if (!visited[neighbor])\n                        {\n                            stack.push_back(neighbor);\n                        }\n                        else\n                        {\n                            extraEdges++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    int extraNeeded = connectedComponents - 1;\n\n    if (extraEdges >= extraNeeded)\n    {\n        return extraNeeded;\n    }\n\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint makeConnected(int totalComputers, std::vector<std::vector<int>> &connections)\n{\n    std::vector<std::vector<int>> adjacencyList(totalComputers);\n    std::vector<bool> visited(totalComputers, false);\n    int connectedComponents= 0, extraEdges= 0;\n\n    for(auto &connection : connections)\n    {\n        adjacencyList[connection[0]].push_back(connection[1]);\n        adjacencyList[connection[1]].push_back(connection[0]);\n    }\n\n    for(int computer= 0; computer < totalComputers; ++computer)\n    {\n        if(!visited[computer])\n        {\n            connectedComponents++;\n            std::vector<int> stack= {computer};\n\n            while(!stack.empty())\n            {\n                int currentComputer= stack.back();\n                stack.pop_back();\n\n                if(!visited[currentComputer])\n                {\n                    visited[currentComputer]= true;\n                    for(int neighbor : adjacencyList[currentComputer])\n                    {\n                        if(!visited[neighbor])\n                        {\n                            stack.push_back(neighbor);\n                        }\n                        else\n                        {\n                            extraEdges++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    int extraNeeded= connectedComponents - 1;\n\n    if(extraEdges >= extraNeeded)\n    {\n        return extraNeeded;\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumDistance(int firstIndex, int secondIndex, int currentPosition, const string &word)\n{\n    if(currentPosition == word.size())\n        return 0;\n\n    int minimumAnswer = 1e9;\n    for(int index = 0; index < 2; ++index) // Replacing range-based for loop\n    {\n        int currentIndex = (index == 0) ? firstIndex : secondIndex; // Get the appropriate index\n        if(currentIndex != -1)\n        {\n            int deltaX = abs(word[currentPosition] - word[currentIndex]) % 6, deltaY = abs(word[currentPosition] - word[currentIndex]) / 6;\n            minimumAnswer = min(minimumAnswer, min(deltaX, deltaY) * 2 + max(deltaX, deltaY));\n        }\n    }\n    minimumAnswer += calculateMinimumDistance(firstIndex, secondIndex, currentPosition + 1, word);\n\n    if(firstIndex == -1 || secondIndex == -1)\n    {\n        minimumAnswer = min(minimumAnswer, calculateMinimumDistance(firstIndex == -1 ? currentPosition : firstIndex, word[currentPosition], currentPosition + 1, word));\n    }\n\n    return minimumAnswer;\n}\n\nint minimumDistance(const string &word)\n{\n    return calculateMinimumDistance(-1, -1, 0, word);\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMinimumDistance(int firstIndex, int secondIndex, int currentPosition, const std::string &word)\n{\n    if(currentPosition == word.size())\n        return 0;\n\n    int minimumAnswer= 1e9;\n    for(int index : {firstIndex, secondIndex})\n    {\n        if(index != -1)\n        {\n            int deltaX= abs(word[currentPosition] - word[index]) % 6, deltaY= abs(word[currentPosition] - word[index]) / 6;\n            minimumAnswer= std::min(minimumAnswer, min(deltaX, deltaY) * 2 + max(deltaX, deltaY));\n        }\n    }\n    minimumAnswer+= calculateMinimumDistance(firstIndex, secondIndex, currentPosition + 1, word);\n\n    if(firstIndex == -1 || secondIndex == -1)\n    {\n        minimumAnswer= std::min(minimumAnswer, calculateMinimumDistance(firstIndex == -1 ? currentPosition : firstIndex, word[currentPosition], currentPosition + 1, word));\n    }\n\n    return minimumAnswer;\n}\n\nint minimumDistance(const std::string &word)\n{\n    return calculateMinimumDistance(-1, -1, 0, word);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int calculateNumberOfSteps(int inputNumber)\n{\n    int stepCount= 0;\n    while(inputNumber)\n    {\n        stepCount+= (inputNumber % 2 == 0) ? 1 : 2;\n        inputNumber>>= 1;\n    }\n    return stepCount - 1;\n}",
    "output": "int calculateNumberOfSteps(int inputNumber)\n{\n    int stepCount= 0;\n    while(inputNumber)\n    {\n        stepCount+= (inputNumber % 2 == 0) ? 1 : 2;\n        inputNumber>>= 1;\n    }\n    return stepCount - 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "double calculateClockAngle(int hour, int minutes)\n{\n    double minuteAngle= 6 * minutes;\n    double hourAngle= 30 * hour + 0.5 * minutes;\n    double angleDifference= abs(hourAngle - minuteAngle);\n    return min(angleDifference, 360 - angleDifference);\n}",
    "output": "double calculateClockAngle(int hour, int minutes)\n{\n    double minuteAngle= 6 * minutes;\n    double hourAngle= 30 * hour + 0.5 * minutes;\n    double angleDifference= abs(hourAngle - minuteAngle);\n    return min(angleDifference, 360 - angleDifference);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minJumps(vector<int> &jumpArray)\n{\n    int arraySize= jumpArray.size();\n    int maxReachable= jumpArray[0];\n    int stepsRemaining= jumpArray[0];\n    int totalJumps= 1;\n\n    if(arraySize == 1)\n        return 0;\n\n    for(int currentIndex= 1; currentIndex < arraySize; currentIndex++)\n    {\n        if(currentIndex == arraySize - 1)\n            return totalJumps;\n\n        maxReachable= max(maxReachable, currentIndex + jumpArray[currentIndex]);\n\n        stepsRemaining--;\n\n        if(stepsRemaining == 0)\n        {\n            totalJumps++;\n            stepsRemaining= maxReachable - currentIndex;\n        }\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint minJumps(std::vector<int> &jumpArray)\n{\n    int arraySize= jumpArray.size();\n    int maxReachable= jumpArray[0];\n    int stepsRemaining= jumpArray[0];\n    int totalJumps= 1;\n\n    if(arraySize == 1)\n        return 0;\n\n    for(int currentIndex= 1; currentIndex < arraySize; currentIndex++)\n    {\n        if(currentIndex == arraySize - 1)\n            return totalJumps;\n\n        maxReachable= std::max(maxReachable, currentIndex + jumpArray[currentIndex]);\n\n        stepsRemaining--;\n\n        if(stepsRemaining == 0)\n        {\n            totalJumps++;\n            stepsRemaining= maxReachable - currentIndex;\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maximum69Number(int originalNumber)\n{\n    string numberString = to_string(originalNumber);\n    for (int i = 0; i < numberString.size(); ++i)\n    {\n        if (numberString[i] == '6')\n        {\n            numberString[i] = '9';\n            break;\n        }\n    }\n    return stoi(numberString);\n}",
    "output": "#include <bits/stdc++.h>\nint maximum69Number(int originalNumber)\n{\n    std::string numberString= std::to_string(originalNumber);\n    for(char &digit : numberString)\n    {\n        if(digit == '6')\n        {\n            digit= '9';\n            break;\n        }\n    }\n    return std::stoi(numberString);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring getLargestNumber(vector<int> &digitCost, int target)\n{\n    vector<string> dynamicProgramming(target + 1, \"\");\n\n    for(int digitIndex= 0; digitIndex < 9; ++digitIndex)\n    {\n        for(int currentTarget= digitCost[digitIndex]; currentTarget <= target; ++currentTarget)\n        {\n            if(dynamicProgramming[currentTarget - digitCost[digitIndex]].size() < currentTarget - digitCost[digitIndex] && dynamicProgramming[currentTarget - digitCost[digitIndex]].size() + 1 > dynamicProgramming[currentTarget].size())\n            {\n                dynamicProgramming[currentTarget]= dynamicProgramming[currentTarget - digitCost[digitIndex]] + to_string(digitIndex + 1);\n            }\n        }\n    }\n\n    return dynamicProgramming[target].empty() ? \"0\" : dynamicProgramming[target];\n}",
    "output": "#include <bits/stdc++.h>\nstd::string getLargestNumber(std::vector<int> &digitCost, int target)\n{\n    std::vector<std::string> dynamicProgramming(target + 1, \"\");\n\n    for(int digitIndex= 0; digitIndex < 9; ++digitIndex)\n    {\n        for(int currentTarget= digitCost[digitIndex]; currentTarget <= target; ++currentTarget)\n        {\n            if(dynamicProgramming[currentTarget - digitCost[digitIndex]].size() < currentTarget - digitCost[digitIndex] && dynamicProgramming[currentTarget - digitCost[digitIndex]].size() + 1 > dynamicProgramming[currentTarget].size())\n            {\n                dynamicProgramming[currentTarget]= dynamicProgramming[currentTarget - digitCost[digitIndex]] + std::to_string(digitIndex + 1);\n            }\n        }\n    }\n\n    return dynamicProgramming[target].empty() ? \"0\" : dynamicProgramming[target];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "TreeNode *removeLeafNodes(TreeNode *currentNode, int targetValue)\n{\n    if(!currentNode)\n        return NULL;\n    currentNode->left= removeLeafNodes(currentNode->left, targetValue);\n    currentNode->right= removeLeafNodes(currentNode->right, targetValue);\n    if(!currentNode->left && !currentNode->right && currentNode->val == targetValue)\n    {\n        return NULL;\n    }\n    return currentNode;\n}",
    "output": "TreeNode *removeLeafNodes(TreeNode *currentNode, int targetValue)\n{\n    if(!currentNode)\n        return NULL;\n    currentNode->left= removeLeafNodes(currentNode->left, targetValue);\n    currentNode->right= removeLeafNodes(currentNode->right, targetValue);\n    if(!currentNode->left && !currentNode->right && currentNode->val == targetValue)\n    {\n        return NULL;\n    }\n    return currentNode;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minTaps(int totalLength, vector<int> &ranges)\n{\n    vector<int> intervals(totalLength + 1, 0);\n    for(int tapIndex= 0; tapIndex <= totalLength; ++tapIndex)\n    {\n        int leftEndpoint= max(0, tapIndex - ranges[tapIndex]);\n        int rightEndpoint= min(totalLength, tapIndex + ranges[tapIndex]);\n        intervals[leftEndpoint]= max(intervals[leftEndpoint], rightEndpoint - leftEndpoint);\n    }\n\n    int currentPosition= 0, totalTaps= 0, maxReach= 0;\n    while(currentPosition < totalLength)\n    {\n        maxReach= max(maxReach, currentPosition + intervals[currentPosition]);\n        if(maxReach == currentPosition)\n            return -1;\n        currentPosition= maxReach;\n        ++totalTaps;\n    }\n    return totalTaps;\n}",
    "output": "#include <bits/stdc++.h>\nint minTaps(int totalLength, std::vector<int> &ranges)\n{\n    std::vector<int> intervals(totalLength + 1, 0);\n    for(int tapIndex= 0; tapIndex <= totalLength; ++tapIndex)\n    {\n        int leftEndpoint= std::max(0, tapIndex - ranges[tapIndex]);\n        int rightEndpoint= std::min(totalLength, tapIndex + ranges[tapIndex]);\n        intervals[leftEndpoint]= std::max(intervals[leftEndpoint], rightEndpoint - leftEndpoint);\n    }\n\n    int currentPosition= 0, totalTaps= 0, maxReach= 0;\n    while(currentPosition < totalLength)\n    {\n        maxReach= std::max(maxReach, currentPosition + intervals[currentPosition]);\n        if(maxReach == currentPosition)\n            return -1;\n        currentPosition= maxReach;\n        ++totalTaps;\n    }\n    return totalTaps;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> peopleIndexes(vector<vector<string>> &favoriteCompanies)\n{\n    vector<int> result;\n    vector<set<string>> companySets;\n\n    for (int i = 0; i < favoriteCompanies.size(); ++i)\n    {\n        const auto &companies = favoriteCompanies[i];\n        companySets.push_back(set<string>(companies.begin(), companies.end()));\n    }\n\n    for (int personIndex = 0; personIndex < companySets.size(); ++personIndex)\n    {\n        bool isSubset = false;\n        for (int otherIndex = 0; otherIndex < companySets.size(); ++otherIndex)\n        {\n            if (personIndex != otherIndex && includes(companySets[otherIndex].begin(), companySets[otherIndex].end(),\n                                                     companySets[personIndex].begin(), companySets[personIndex].end()))\n            {\n                isSubset = true;\n                break;\n            }\n        }\n        if (!isSubset)\n            result.push_back(personIndex);\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> peopleIndexes(std::vector<std::vector<std::string>> &favoriteCompanies)\n{\n    std::vector<int> result;\n    std::vector<std::set<std::string>> companySets;\n\n    for(const auto &companies : favoriteCompanies)\n    {\n        companySets.push_back(std::set<std::string>(companies.begin(), companies.end()));\n    }\n\n    for(int personIndex= 0; personIndex < companySets.size(); ++personIndex)\n    {\n        bool isSubset= false;\n        for(int otherIndex= 0; otherIndex < companySets.size(); ++otherIndex)\n        {\n            if(personIndex != otherIndex && std::includes(companySets[otherIndex].begin(), companySets[otherIndex].end(),\n                                                     companySets[personIndex].begin(), companySets[personIndex].end()))\n            {\n                isSubset= true;\n                break;\n            }\n        }\n        if(!isSubset)\n            result.push_back(personIndex);\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numPoints(vector<vector<int>> &darts, int radius)\n{\n    int totalDarts = darts.size();\n    int maxPoints = 1;\n\n    for(int i = 0; i < totalDarts; ++i)\n    {\n        for(int j = 0; j < totalDarts; ++j)\n        {\n            int pointsInRange = 0;\n            for(int k = 0; k < totalDarts; ++k)\n            {\n                int deltaX = darts[i][0] - darts[k][0];\n                int deltaY = darts[i][1] - darts[k][1];\n                if(sqrt(deltaX * deltaX + deltaY * deltaY) <= radius)\n                    pointsInRange++;\n            }\n\n            if(pointsInRange > maxPoints)\n                maxPoints = pointsInRange;\n        }\n    }\n    return maxPoints;\n}",
    "output": "#include <bits/stdc++.h>\nint numPoints(std::vector<std::vector<int>> &darts, int radius)\n{\n    int totalDarts= darts.size();\n    int maxPoints= 1;\n\n    for(int i= 0; i < totalDarts; ++i)\n    {\n        for(int j= 0; j < totalDarts; ++j)\n        {\n            int pointsInRange= 0;\n            for(int k= 0; k < totalDarts; ++k)\n            {\n                int deltaX= darts[i][0] - darts[k][0];\n                int deltaY= darts[i][1] - darts[k][1];\n                if(sqrt(deltaX * deltaX + deltaY * deltaY) <= radius)\n                    pointsInRange++;\n            }\n\n            if(pointsInRange > maxPoints)\n                maxPoints= pointsInRange;\n        }\n    }\n    return maxPoints;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool customCompare(vector<int> &restaurantA, vector<int> &restaurantB)\n{\n    if(restaurantA[1] == restaurantB[1])\n        return restaurantA[0] > restaurantB[0];\n    return restaurantA[1] > restaurantB[1];\n}\n\nvector<int> filterRestaurants(vector<vector<int>> &restaurants, int isVeganFriendly, int maxPrice, int maxDistance)\n{\n    vector<vector<int>> filteredRestaurants;\n    for (int i = 0; i < restaurants.size(); ++i)\n    {\n        auto &restaurant = restaurants[i];\n        if ((isVeganFriendly == 0 || restaurant[2] == isVeganFriendly) && restaurant[3] <= maxPrice && restaurant[4] <= maxDistance)\n        {\n            filteredRestaurants.push_back(restaurant);\n        }\n    }\n    sort(filteredRestaurants.begin(), filteredRestaurants.end(), customCompare);\n    vector<int> restaurantIds;\n    for (int i = 0; i < filteredRestaurants.size(); ++i)\n    {\n        restaurantIds.push_back(filteredRestaurants[i][0]);\n    }\n    return restaurantIds;\n}",
    "output": "#include <bits/stdc++.h>\nbool customCompare(std::vector<int> &restaurantA, std::vector<int> &restaurantB)\n{\n    if(restaurantA[1] == restaurantB[1])\n        return restaurantA[0] > restaurantB[0];\n    return restaurantA[1] > restaurantB[1];\n}\n\nstd::vector<int> filterRestaurants(std::vector<std::vector<int>> &restaurants, int isVeganFriendly, int maxPrice, int maxDistance)\n{\n    std::vector<std::vector<int>> filteredRestaurants;\n    for(auto &restaurant : restaurants)\n    {\n        if((isVeganFriendly == 0 || restaurant[2] == isVeganFriendly) && restaurant[3] <= maxPrice && restaurant[4] <= maxDistance)\n        {\n            filteredRestaurants.push_back(restaurant);\n        }\n    }\n    std::sort(filteredRestaurants.begin(), filteredRestaurants.end(), customCompare);\n    std::vector<int> restaurantIds;\n    for(auto &restaurant : filteredRestaurants)\n    {\n        restaurantIds.push_back(restaurant[0]);\n    }\n    return restaurantIds;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findTheCity(int cityCount, vector<vector<int>> &cityEdges, int distanceThreshold)\n{\n    const int infinity = numeric_limits<int>::max();\n    vector<vector<int>> distanceMatrix(cityCount, vector<int>(cityCount, infinity));\n\n    for(int cityIndex = 0; cityIndex < cityCount; ++cityIndex)\n        distanceMatrix[cityIndex][cityIndex] = 0;\n\n    for(const auto &edge : cityEdges)\n    {\n        distanceMatrix[edge[0]][edge[1]] = distanceMatrix[edge[1]][edge[0]] = edge[2];\n    }\n\n    for(int intermediateCity = 0; intermediateCity < cityCount; ++intermediateCity)\n    {\n        for(int startCity = 0; startCity < cityCount; ++startCity)\n        {\n            for(int endCity = 0; endCity < cityCount; ++endCity)\n            {\n                distanceMatrix[startCity][endCity] = min(distanceMatrix[startCity][endCity], distanceMatrix[startCity][intermediateCity] + distanceMatrix[intermediateCity][endCity]);\n            }\n        }\n    }\n\n    int resultCity = -1, minReachableCities = cityCount + 1;\n    for(int cityIndex = 0; cityIndex < cityCount; ++cityIndex)\n    {\n        int reachableCount = 0;\n        for(int j = 0; j < distanceMatrix[cityIndex].size(); ++j)\n        {\n            if(distanceMatrix[cityIndex][j] <= distanceThreshold)\n                ++reachableCount;\n        }\n        if(reachableCount <= minReachableCities)\n        {\n            minReachableCities = reachableCount;\n            resultCity = cityIndex;\n        }\n    }\n    return resultCity;\n}",
    "output": "#include <bits/stdc++.h>\nint findTheCity(int cityCount, std::vector<std::vector<int>> &cityEdges, int distanceThreshold)\n{\n    const int infinity= std::numeric_limits<int>::max();\n    std::vector<std::vector<int>> distanceMatrix(cityCount, std::vector<int>(cityCount, infinity));\n\n    for(int cityIndex= 0; cityIndex < cityCount; ++cityIndex)\n        distanceMatrix[cityIndex][cityIndex]= 0;\n\n    for(const auto &edge : cityEdges)\n    {\n        distanceMatrix[edge[0]][edge[1]]= distanceMatrix[edge[1]][edge[0]]= edge[2];\n    }\n\n    for(int intermediateCity= 0; intermediateCity < cityCount; ++intermediateCity)\n    {\n        for(int startCity= 0; startCity < cityCount; ++startCity)\n        {\n            for(int endCity= 0; endCity < cityCount; ++endCity)\n            {\n                distanceMatrix[startCity][endCity]= std::min(distanceMatrix[startCity][endCity], distanceMatrix[startCity][intermediateCity] + distanceMatrix[intermediateCity][endCity]);\n            }\n        }\n    }\n\n    int resultCity= -1, minReachableCities= cityCount + 1;\n    for(int cityIndex= 0; cityIndex < cityCount; ++cityIndex)\n    {\n        int reachableCount= 0;\n        for(const auto &distance : distanceMatrix[cityIndex])\n        {\n            if(distance <= distanceThreshold)\n                ++reachableCount;\n        }\n        if(reachableCount <= minReachableCities)\n        {\n            minReachableCities= reachableCount;\n            resultCity= cityIndex;\n        }\n    }\n    return resultCity;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minDifficulty(vector<int> &jobDifficulty, int days)\n{\n    int jobCount= jobDifficulty.size();\n    if(jobCount < days)\n        return -1;\n    vector<vector<int>> difficultyDP(days, vector<int>(jobCount, INT_MAX));\n\n    difficultyDP[0][0]= jobDifficulty[0];\n    for(int currentJob= 1; currentJob < jobCount; ++currentJob)\n    {\n        difficultyDP[0][currentJob]= max(difficultyDP[0][currentJob - 1], jobDifficulty[currentJob]);\n    }\n\n    for(int currentDay= 1; currentDay < days; ++currentDay)\n    {\n        for(int jobIndex= currentDay; jobIndex < jobCount; ++jobIndex)\n        {\n            int maxDifficulty= jobDifficulty[jobIndex];\n            for(int previousJobIndex= jobIndex; previousJobIndex >= currentDay; --previousJobIndex)\n            {\n                maxDifficulty= max(maxDifficulty, jobDifficulty[previousJobIndex]);\n                difficultyDP[currentDay][jobIndex]= min(difficultyDP[currentDay][jobIndex], difficultyDP[currentDay - 1][previousJobIndex - 1] + maxDifficulty);\n            }\n        }\n    }\n    return difficultyDP[days - 1][jobCount - 1];\n}",
    "output": "#include <bits/stdc++.h>\nint minDifficulty(std::vector<int> &jobDifficulty, int days)\n{\n    int jobCount= jobDifficulty.size();\n    if(jobCount < days)\n        return -1;\n    std::vector<std::vector<int>> difficultyDP(days, std::vector<int>(jobCount, INT_MAX));\n\n    difficultyDP[0][0]= jobDifficulty[0];\n    for(int currentJob= 1; currentJob < jobCount; ++currentJob)\n    {\n        difficultyDP[0][currentJob]= std::max(difficultyDP[0][currentJob - 1], jobDifficulty[currentJob]);\n    }\n\n    for(int currentDay= 1; currentDay < days; ++currentDay)\n    {\n        for(int jobIndex= currentDay; jobIndex < jobCount; ++jobIndex)\n        {\n            int maxDifficulty= jobDifficulty[jobIndex];\n            for(int previousJobIndex= jobIndex; previousJobIndex >= currentDay; --previousJobIndex)\n            {\n                maxDifficulty= std::max(maxDifficulty, jobDifficulty[previousJobIndex]);\n                difficultyDP[currentDay][jobIndex]= std::min(difficultyDP[currentDay][jobIndex], difficultyDP[currentDay - 1][previousJobIndex - 1] + maxDifficulty);\n            }\n        }\n    }\n    return difficultyDP[days - 1][jobCount - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool compare(int firstNumber, int secondNumber)\n{\n    int bitCountFirst= __builtin_popcount(firstNumber);\n    int bitCountSecond= __builtin_popcount(secondNumber);\n\n    if(bitCountFirst == bitCountSecond)\n    {\n        return firstNumber < secondNumber;\n    }\n    return bitCountFirst < bitCountSecond;\n}\n\nvector<int> sortByBits(vector<int> &inputArray)\n{\n    sort(inputArray.begin(), inputArray.end(), compare);\n    return inputArray;\n}",
    "output": "#include <bits/stdc++.h>\nbool compare(int firstNumber, int secondNumber)\n{\n    int bitCountFirst= __builtin_popcount(firstNumber);\n    int bitCountSecond= __builtin_popcount(secondNumber);\n\n    if(bitCountFirst == bitCountSecond)\n    {\n        return firstNumber < secondNumber;\n    }\n    return bitCountFirst < bitCountSecond;\n}\n\nstd::vector<int> sortByBits(std::vector<int> &inputArray)\n{\n    std::sort(inputArray.begin(), inputArray.end(), compare);\n    return inputArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countOfValidSubstrings(string inputString)\n{\n    int totalCount= 0, startIndex= 0;\n    vector<int> characterCount(3, 0);\n\n    for(int endIndex= 0; endIndex < inputString.length(); endIndex++)\n    {\n        characterCount[inputString[endIndex] - 'a']++;\n\n        while(characterCount[0] > 0 && characterCount[1] > 0 && characterCount[2] > 0)\n        {\n            characterCount[inputString[startIndex++] - 'a']--;\n        }\n\n        totalCount+= startIndex;\n    }\n\n    return totalCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countOfValidSubstrings(std::string inputString)\n{\n    int totalCount= 0, startIndex= 0;\n    std::vector<int> characterCount(3, 0);\n\n    for(int endIndex= 0; endIndex < inputString.length(); endIndex++)\n    {\n        characterCount[inputString[endIndex] - 'a']++;\n\n        while(characterCount[0] > 0 && characterCount[1] > 0 && characterCount[2] > 0)\n        {\n            characterCount[inputString[startIndex++] - 'a']--;\n        }\n\n        totalCount+= startIndex;\n    }\n\n    return totalCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int countOrders(int numberOfOrders)\n{\n    long long modulus= 1e9 + 7;\n    long long totalWays= 1;\n    for(int currentOrder= 1; currentOrder <= numberOfOrders; ++currentOrder)\n    {\n        totalWays= totalWays * (2 * currentOrder - 1) * currentOrder % modulus;\n    }\n    return totalWays;\n}",
    "output": "int countOrders(int numberOfOrders)\n{\n    long long modulus= 1e9 + 7;\n    long long totalWays= 1;\n    for(int currentOrder= 1; currentOrder <= numberOfOrders; ++currentOrder)\n    {\n        totalWays= totalWays * (2 * currentOrder - 1) * currentOrder % modulus;\n    }\n    return totalWays;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<bool> checkIfPrerequisite(int totalCourses, vector<vector<int>> &prerequisites, vector<vector<int>> &queries)\n{\n    vector<vector<bool>> adjacencyMatrix(totalCourses, vector<bool>(totalCourses, false));\n    for (const auto &pre : prerequisites)\n    {\n        adjacencyMatrix[pre[0]][pre[1]] = true;\n    }\n\n    for (int intermediate = 0; intermediate < totalCourses; ++intermediate)\n    {\n        for (int source = 0; source < totalCourses; ++source)\n        {\n            for (int destination = 0; destination < totalCourses; ++destination)\n            {\n                adjacencyMatrix[source][destination] = adjacencyMatrix[source][destination] || (adjacencyMatrix[source][intermediate] && adjacencyMatrix[intermediate][destination]);\n            }\n        }\n    }\n\n    vector<bool> result;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        const auto &query = queries[i];\n        result.push_back(adjacencyMatrix[query[0]][query[1]]);\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<bool> checkIfPrerequisite(int totalCourses, std::vector<std::vector<int>> &prerequisites, std::vector<std::vector<int>> &queries)\n{\n    std::vector<std::vector<bool>> adjacencyMatrix(totalCourses, std::vector<bool>(totalCourses, false));\n    for(const auto &pre : prerequisites)\n    {\n        adjacencyMatrix[pre[0]][pre[1]]= true;\n    }\n\n    for(int intermediate= 0; intermediate < totalCourses; ++intermediate)\n    {\n        for(int source= 0; source < totalCourses; ++source)\n        {\n            for(int destination= 0; destination < totalCourses; ++destination)\n            {\n                adjacencyMatrix[source][destination]= adjacencyMatrix[source][destination] || (adjacencyMatrix[source][intermediate] && adjacencyMatrix[intermediate][destination]);\n            }\n        }\n    }\n\n    std::vector<bool> result;\n    for(const auto &query : queries)\n    {\n        result.push_back(adjacencyMatrix[query[0]][query[1]]);\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> kWeakestRows(vector<vector<int>> &matrix, int k)\n{\n    vector<pair<int, int>> soldierRowCount;\n    for(int rowIndex= 0; rowIndex < matrix.size(); ++rowIndex)\n    {\n        int soldierCount= count(matrix[rowIndex].begin(), matrix[rowIndex].end(), 1);\n        soldierRowCount.push_back({soldierCount, rowIndex});\n    }\n\n    sort(soldierRowCount.begin(), soldierRowCount.end());\n\n    vector<int> weakestRowIndices;\n    for(int index= 0; index < k; ++index)\n    {\n        weakestRowIndices.push_back(soldierRowCount[index].second);\n    }\n    return weakestRowIndices;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> kWeakestRows(std::vector<std::vector<int>> &matrix, int k)\n{\n    std::vector<std::pair<int, int>> soldierRowCount;\n    for(int rowIndex = 0; rowIndex < matrix.size(); ++rowIndex)\n    {\n        int soldierCount = std::count(matrix[rowIndex].begin(), matrix[rowIndex].end(), 1);\n        soldierRowCount.push_back({soldierCount, rowIndex});\n    }\n\n    std::sort(soldierRowCount.begin(), soldierRowCount.end());\n\n    std::vector<int> weakestRowIndices;\n    for(int index = 0; index < k; ++index)\n    {\n        weakestRowIndices.push_back(soldierRowCount[index].second);\n    }\n    return weakestRowIndices;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minSetSize(vector<int> &inputArray)\n{\n    unordered_map<int, int> frequencyCount;\n    for(auto element : inputArray)\n        frequencyCount[element]++;\n\n    vector<int> frequencies;\n    for(auto &entry : frequencyCount)\n        frequencies.push_back(entry.second);\n\n    sort(frequencies.rbegin(), frequencies.rend());\n\n    int totalRemoved = 0, minimalSetSize = 0;\n    for (int i = 0; i < frequencies.size(); ++i)\n    {\n        int freq = frequencies[i];\n        totalRemoved += freq;\n        minimalSetSize++;\n        if(totalRemoved * 2 >= inputArray.size())\n            return minimalSetSize;\n    }\n\n    return 0;\n}",
    "output": "#include <bits/stdc++.h>\nint minSetSize(std::vector<int> &inputArray)\n{\n    std::unordered_map<int, int> frequencyCount;\n    for(auto element : inputArray)\n        frequencyCount[element]++;\n\n    std::vector<int> frequencies;\n    for(auto &entry : frequencyCount)\n        frequencies.push_back(entry.second);\n\n    std::sort(frequencies.rbegin(), frequencies.rend());\n\n    int totalRemoved= 0, minimalSetSize= 0;\n    for(auto freq : frequencies)\n    {\n        totalRemoved+= freq;\n        minimalSetSize++;\n        if(totalRemoved * 2 >= inputArray.size())\n            return minimalSetSize;\n    }\n\n    return 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    int maxProduct(TreeNode *rootNode)\n    {\n        long totalSum= calculateTotal(rootNode), result= 0;\n        calculateMaxProduct(rootNode, totalSum / 2, result, totalSum);\n        return result % 1000000007;\n    }\n\n    int calculateTotal(TreeNode *rootNode)\n    {\n        if(!rootNode)\n            return 0;\n        return rootNode->value + calculateTotal(rootNode->leftChild) + calculateTotal(rootNode->rightChild);\n    }\n\n    int calculateMaxProduct(TreeNode *rootNode, double halfSum, long &result, long totalSum)\n    {\n        if(!rootNode)\n            return 0;\n        int currentSum= rootNode->value + calculateMaxProduct(rootNode->leftChild, halfSum, result, totalSum) + calculateMaxProduct(rootNode->rightChild, halfSum, result, totalSum);\n        result= max(result, (totalSum - currentSum) * currentSum);\n        return currentSum;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    int maxProduct(TreeNode *rootNode)\n    {\n        long totalSum = calculateTotal(rootNode), result = 0;\n        calculateMaxProduct(rootNode, totalSum / 2, result, totalSum);\n        return result % 1000000007;\n    }\n\n    int calculateTotal(TreeNode *rootNode)\n    {\n        if(!rootNode)\n            return 0;\n        return rootNode->value + calculateTotal(rootNode->leftChild) + calculateTotal(rootNode->rightChild);\n    }\n\n    int calculateMaxProduct(TreeNode *rootNode, double halfSum, long &result, long totalSum)\n    {\n        if(!rootNode)\n            return 0;\n        int currentSum = rootNode->value + calculateMaxProduct(rootNode->leftChild, halfSum, result, totalSum) + calculateMaxProduct(rootNode->rightChild, halfSum, result, totalSum);\n        result = std::max(result, (totalSum - currentSum) * currentSum);\n        return currentSum;\n    }\n};\n"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxJumps(vector<int> &heightArray, int maxDistance)\n{\n    int arraySize= heightArray.size();\n    vector<int> jumpCount(arraySize, 1);\n\n    auto jumpHelper= [&](auto &&self, int currentIndex) -> int\n    {\n        if(jumpCount[currentIndex] > 1)\n            return jumpCount[currentIndex];\n        int maximumJumps= 1;\n        for(int step= 1; step <= maxDistance; step++)\n        {\n            if(currentIndex + step < arraySize && heightArray[currentIndex] <= heightArray[currentIndex + step])\n                break;\n            if(currentIndex + step < arraySize)\n                maximumJumps= max(maximumJumps, 1 + self(self, currentIndex + step));\n\n            if(currentIndex - step >= 0 && heightArray[currentIndex] <= heightArray[currentIndex - step])\n                break;\n            if(currentIndex - step >= 0)\n                maximumJumps= max(maximumJumps, 1 + self(self, currentIndex - step));\n        }\n        return jumpCount[currentIndex]= maximumJumps;\n    };\n\n    for(int i= 0; i < arraySize; i++)\n        jumpHelper(jumpHelper, i);\n\n    return *max_element(jumpCount.begin(), jumpCount.end());\n}",
    "output": "#include <bits/stdc++.h>\nint maxJumps(std::vector<int> &heightArray, int maxDistance)\n{\n    int arraySize= heightArray.size();\n    std::vector<int> jumpCount(arraySize, 1);\n\n    auto jumpHelper= [&](auto &&self, int currentIndex) -> int\n    {\n        if(jumpCount[currentIndex] > 1)\n            return jumpCount[currentIndex];\n        int maximumJumps= 1;\n        for(int step= 1; step <= maxDistance; step++)\n        {\n            if(currentIndex + step < arraySize && heightArray[currentIndex] <= heightArray[currentIndex + step])\n                break;\n            if(currentIndex + step < arraySize)\n                maximumJumps= std::max(maximumJumps, 1 + self(self, currentIndex + step));\n\n            if(currentIndex - step >= 0 && heightArray[currentIndex] <= heightArray[currentIndex - step])\n                break;\n            if(currentIndex - step >= 0)\n                maximumJumps= std::max(maximumJumps, 1 + self(self, currentIndex - step));\n        }\n        return jumpCount[currentIndex]= maximumJumps;\n    };\n\n    for(int i= 0; i < arraySize; i++)\n        jumpHelper(jumpHelper, i);\n\n    return *std::max_element(jumpCount.begin(), jumpCount.end());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble factorial(int number)\n{\n    double result = 1;\n    for(int i = 1; i <= number; i++)\n        result *= i;\n    return result;\n}\n\ndouble countCombinations(vector<int> &balls, vector<int> &combinations, int currentBall)\n{\n    double totalCombinations = 1;\n    for(int i = 0; i < currentBall; i++)\n        totalCombinations *= factorial(balls[i] + combinations[i]) / (factorial(balls[i]) * factorial(combinations[i]));\n\n    return totalCombinations;\n}\n\ndouble dfs(vector<int> &balls, vector<int> &combinations, int currentBall)\n{\n    if(currentBall == balls.size())\n    {\n        if(combinations.back() == combinations.front())\n            return countCombinations(balls, combinations, currentBall);\n        else\n            return 0;\n    }\n\n    double result = 0;\n    for(int i = 0; i <= balls[currentBall]; i++)\n    {\n        combinations.push_back(i);\n        result += dfs(balls, combinations, currentBall + 1);\n        combinations.pop_back();\n    }\n\n    return result;\n}\n\ndouble getProbability(vector<int> &balls)\n{\n    int sumBalls = 0;\n    for(int i = 0; i < balls.size(); i++)\n        sumBalls += balls[i];\n\n    double totalCombinations = 1;\n    for(int i = 0; i < balls.size(); i++)\n        totalCombinations *= factorial(balls[i]);\n\n    vector<int> combinations;\n    return dfs(balls, combinations, 0) / totalCombinations;\n}",
    "output": "#include <bits/stdc++.h>\ndouble factorial(int number)\n{\n    double result= 1;\n    for(int i= 1; i <= number; i++)\n        result*= i;\n    return result;\n}\n\ndouble countCombinations(std::vector<int> &balls, std::vector<int> &combinations, int currentBall)\n{\n    double totalCombinations= 1;\n    for(int i= 0; i < currentBall; i++)\n        totalCombinations*= factorial(balls[i] + combinations[i]) / (factorial(balls[i]) * factorial(combinations[i]));\n\n    return totalCombinations;\n}\n\ndouble dfs(std::vector<int> &balls, std::vector<int> &combinations, int currentBall)\n{\n    if(currentBall == balls.size())\n    {\n        if(combinations.back() == combinations.front())\n            return countCombinations(balls, combinations, currentBall);\n        else\n            return 0;\n    }\n\n    double result= 0;\n    for(int i= 0; i <= balls[currentBall]; i++)\n    {\n        combinations.push_back(i);\n        result+= dfs(balls, combinations, currentBall + 1);\n        combinations.pop_back();\n    }\n\n    return result;\n}\n\ndouble getProbability(std::vector<int> &balls)\n{\n    int sumBalls= 0;\n    for(int ball : balls)\n        sumBalls+= ball;\n\n    double totalCombinations= 1;\n    for(int ball : balls)\n        totalCombinations*= factorial(ball);\n\n    std::vector<int> combinations;\n    return dfs(balls, combinations, 0) / totalCombinations;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    vector<int> sourceCount(26, 0);\n    vector<int> targetCount(26, 0);\n    int stepCount = 0;\n\n    for (int i = 0; i < sourceString.size(); i++)\n        sourceCount[sourceString[i] - 'a']++;\n    for (int i = 0; i < targetString.size(); i++)\n        targetCount[targetString[i] - 'a']++;\n\n    for (int index = 0; index < 26; index++)\n    {\n        stepCount += abs(sourceCount[index] - targetCount[index]);\n    }\n\n    return stepCount / 2;\n}",
    "output": "#include <bits/stdc++.h>\n// Include cmath for the abs function\n\nint minSteps(std::string sourceString, std::string targetString)\n{\n    std::vector<int> sourceCount(26, 0);\n    std::vector<int> targetCount(26, 0);\n    int stepCount = 0;\n\n    for(char character : sourceString)\n        sourceCount[character - 'a']++;\n    for(char character : targetString)\n        targetCount[character - 'a']++;\n\n    for(int index = 0; index < 26; index++)\n    {\n        stepCount += std::abs(sourceCount[index] - targetCount[index]);\n    }\n\n    return stepCount / 2;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TweetCounts\n{\n  public:\n    void recordTweet(string tweetName, int timestamp)\n    {\n        tweetRecords[tweetName][timestamp]++;\n    }\n\n    vector<int> getTweetCountsPerFrequency(string frequency, string tweetName, int startTime, int endTime)\n    {\n        int interval;\n        if(frequency == \"minute\")\n            interval = 60;\n        else if(frequency == \"hour\")\n            interval = 3600;\n        else\n            interval = 86400;\n\n        vector<int> result((endTime - startTime) / interval + 1);\n        for (auto it = tweetRecords[tweetName].begin(); it != tweetRecords[tweetName].end(); ++it)\n        {\n            int time = it->first, count = it->second;\n            if (time >= startTime && time <= endTime)\n            {\n                result[(time - startTime) / interval] += count;\n            }\n        }\n\n        return result;\n    }\n\n  private:\n    unordered_map<string, map<int, int>> tweetRecords;\n};",
    "output": "#include <bits/stdc++.h>\nclass TweetCounts\n{\n  public:\n    void recordTweet(std::string tweetName, int timestamp)\n    {\n        tweetRecords[tweetName][timestamp]++;\n    }\n\n    std::vector<int> getTweetCountsPerFrequency(std::string frequency, std::string tweetName, int startTime, int endTime)\n    {\n        int interval;\n        if(frequency == \"minute\")\n            interval= 60;\n        else if(frequency == \"hour\")\n            interval= 3600;\n        else\n            interval= 86400;\n\n        std::vector<int> result((endTime - startTime) / interval + 1);\n        for(const auto &timeCount : tweetRecords[tweetName])\n        {\n            int time= timeCount.first, count= timeCount.second;\n            if(time >= startTime && time <= endTime)\n            {\n                result[(time - startTime) / interval]+= count;\n            }\n        }\n\n        return result;\n    }\n\n  private:\n    std::unordered_map<std::string, std::map<int, int>> tweetRecords;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxStudents(vector<vector<char>> &seatArrangement)\n{\n    int rowCount= seatArrangement.size();\n    int columnCount= seatArrangement[0].size();\n    vector<int> validRows(rowCount);\n    int maxValidState= (1 << columnCount) - 1;\n    for(int rowIndex= 0; rowIndex < rowCount; rowIndex++)\n    {\n        int currentState= 0;\n        for(int columnIndex= 0; columnIndex < columnCount; columnIndex++)\n        {\n            currentState|= (seatArrangement[rowIndex][columnIndex] == '.') << columnIndex;\n        }\n        validRows[rowIndex]= currentState;\n    }\n\n    vector<vector<int>> dp(rowCount, vector<int>(1 << columnCount, -1));\n    function<int(int, int)> depthFirstSearch= [&](int currentRowIndex, int previousState)\n    {\n        if(currentRowIndex >= rowCount)\n            return 0;\n        if(dp[currentRowIndex][previousState] != -1)\n            return dp[currentRowIndex][previousState];\n\n        int maximumStudents= 0;\n        for(int currentState= 0; currentState <= maxValidState; currentState++)\n        {\n            if((currentState & validRows[currentRowIndex]) != currentState)\n                continue;\n            if(currentState & (currentState << 1))\n                continue;\n            if(currentState & (previousState << 1) || previousState & (currentState << 1))\n                continue;\n\n            maximumStudents= max(maximumStudents, depthFirstSearch(currentRowIndex + 1, currentState) + __builtin_popcount(currentState));\n        }\n\n        dp[currentRowIndex][previousState]= maximumStudents;\n        return maximumStudents;\n    };\n\n    return depthFirstSearch(0, 0);\n}",
    "output": "#include <bits/stdc++.h>\nint maxStudents(std::vector<std::vector<char>> &seatArrangement)\n{\n    int rowCount= seatArrangement.size();\n    int columnCount= seatArrangement[0].size();\n    std::vector<int> validRows(rowCount);\n    int maxValidState= (1 << columnCount) - 1;\n    for(int rowIndex= 0; rowIndex < rowCount; rowIndex++)\n    {\n        int currentState= 0;\n        for(int columnIndex= 0; columnIndex < columnCount; columnIndex++)\n        {\n            currentState|= (seatArrangement[rowIndex][columnIndex] == '.') << columnIndex;\n        }\n        validRows[rowIndex]= currentState;\n    }\n\n    std::vector<std::vector<int>> dp(rowCount, std::vector<int>(1 << columnCount, -1));\n    std::function<int(int, int)> depthFirstSearch= [&](int currentRowIndex, int previousState)\n    {\n        if(currentRowIndex >= rowCount)\n            return 0;\n        if(dp[currentRowIndex][previousState] != -1)\n            return dp[currentRowIndex][previousState];\n\n        int maximumStudents= 0;\n        for(int currentState= 0; currentState <= maxValidState; currentState++)\n        {\n            if((currentState & validRows[currentRowIndex]) != currentState)\n                continue;\n            if(currentState & (currentState << 1))\n                continue;\n            if(currentState & (previousState << 1) || previousState & (currentState << 1))\n                continue;\n\n            maximumStudents= std::max(maximumStudents, depthFirstSearch(currentRowIndex + 1, currentState) + __builtin_popcount(currentState));\n        }\n\n        dp[currentRowIndex][previousState]= maximumStudents;\n        return maximumStudents;\n    };\n\n    return depthFirstSearch(0, 0);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring sortString(string inputString)\n{\n    string sortedResult;\n    map<char, int> frequencyMap;\n\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char character = inputString[i];\n        frequencyMap[character]++;\n    }\n\n    while (!frequencyMap.empty())\n    {\n        for (auto iterator = frequencyMap.begin(); iterator != frequencyMap.end();)\n        {\n            sortedResult += iterator->first;\n            iterator->second--;\n\n            if (iterator->second == 0)\n            {\n                iterator = frequencyMap.erase(iterator);\n            }\n            else\n            {\n                ++iterator;\n            }\n        }\n\n        for (auto reverseIterator = frequencyMap.rbegin(); reverseIterator != frequencyMap.rend();)\n        {\n            auto nextIterator = next(reverseIterator).base();\n            sortedResult += reverseIterator->first;\n            reverseIterator->second--;\n\n            if (reverseIterator->second == 0)\n            {\n                frequencyMap.erase(nextIterator);\n            }\n            reverseIterator = reverse_iterator(nextIterator);\n        }\n    }\n\n    return sortedResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string sortString(std::string inputString)\n{\n    std::string sortedResult;\n    std::map<char, int> frequencyMap;\n\n    for(char character : inputString)\n    {\n        frequencyMap[character]++;\n    }\n\n    while(!frequencyMap.empty())\n    {\n        for(auto iterator= frequencyMap.begin(); iterator != frequencyMap.end();)\n        {\n            sortedResult+= iterator->first;\n            iterator->second--;\n\n            if(iterator->second == 0)\n            {\n                iterator= frequencyMap.erase(iterator);\n            }\n            else\n            {\n                ++iterator;\n            }\n        }\n\n        for(auto reverseIterator= frequencyMap.rbegin(); reverseIterator != frequencyMap.rend();)\n        {\n            auto nextIterator= std::next(reverseIterator).base();\n            sortedResult+= reverseIterator->first;\n            reverseIterator->second--;\n\n            if(reverseIterator->second == 0)\n            {\n                frequencyMap.erase(nextIterator);\n            }\n            reverseIterator= std::reverse_iterator(nextIterator);\n        }\n    }\n\n    return sortedResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findTheLongestSubstring(string inputString)\n{\n    unordered_map<int, int> indexMap;\n    indexMap[0]= -1;\n    int longestSubstringLength= 0, stringLength= inputString.length(), currentIndex, vowelBitmask= 0;\n    for(currentIndex= 0; currentIndex < stringLength; ++currentIndex)\n    {\n        if(inputString[currentIndex] == 'a')\n            vowelBitmask^= 1;\n        else if(inputString[currentIndex] == 'e')\n            vowelBitmask^= 2;\n        else if(inputString[currentIndex] == 'i')\n            vowelBitmask^= 4;\n        else if(inputString[currentIndex] == 'o')\n            vowelBitmask^= 8;\n        else if(inputString[currentIndex] == 'u')\n            vowelBitmask^= 16;\n        if(!indexMap.count(vowelBitmask))\n            indexMap[vowelBitmask]= currentIndex;\n        longestSubstringLength= max(longestSubstringLength, currentIndex - indexMap[vowelBitmask]);\n    }\n    return longestSubstringLength;\n}",
    "output": "#include <bits/stdc++.h>\nint findTheLongestSubstring(std::string inputString)\n{\n    std::unordered_map<int, int> indexMap;\n    indexMap[0] = -1;\n    int longestSubstringLength = 0, stringLength = inputString.length(), currentIndex, vowelBitmask = 0;\n    for(currentIndex = 0; currentIndex < stringLength; ++currentIndex)\n    {\n        if(inputString[currentIndex] == 'a')\n            vowelBitmask ^= 1;\n        else if(inputString[currentIndex] == 'e')\n            vowelBitmask ^= 2;\n        else if(inputString[currentIndex] == 'i')\n            vowelBitmask ^= 4;\n        else if(inputString[currentIndex] == 'o')\n            vowelBitmask ^= 8;\n        else if(inputString[currentIndex] == 'u')\n            vowelBitmask ^= 16;\n        if(!indexMap.count(vowelBitmask))\n            indexMap[vowelBitmask] = currentIndex;\n        longestSubstringLength = std::max(longestSubstringLength, currentIndex - indexMap[vowelBitmask]);\n    }\n    return longestSubstringLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nint calculateLongestZigZag(TreeNode *currentNode, bool isLeft, int &maxLength)\n{\n    if(!currentNode)\n        return -1;\n\n    int leftZigZag= calculateLongestZigZag(currentNode->leftChild, true, maxLength);\n    int rightZigZag= calculateLongestZigZag(currentNode->rightChild, false, maxLength);\n\n    maxLength= max(maxLength, max(leftZigZag, rightZigZag) + 1);\n    return isLeft ? rightZigZag + 1 : leftZigZag + 1;\n}\n\nint longestZigZag(TreeNode *rootNode)\n{\n    int maxLength= 0;\n    calculateLongestZigZag(rootNode, true, maxLength);\n    calculateLongestZigZag(rootNode, false, maxLength);\n    return maxLength;\n}",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nint calculateLongestZigZag(TreeNode *currentNode, bool isLeft, int &maxLength)\n{\n    if(!currentNode)\n        return -1;\n\n    int leftZigZag= calculateLongestZigZag(currentNode->leftChild, true, maxLength);\n    int rightZigZag= calculateLongestZigZag(currentNode->rightChild, false, maxLength);\n\n    maxLength= max(maxLength, max(leftZigZag, rightZigZag) + 1);\n    return isLeft ? rightZigZag + 1 : leftZigZag + 1;\n}\n\nint longestZigZag(TreeNode *rootNode)\n{\n    int maxLength= 0;\n    calculateLongestZigZag(rootNode, true, maxLength);\n    calculateLongestZigZag(rootNode, false, maxLength);\n    return maxLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nint maxSumBST(TreeNode *root)\n{\n    int maxSum= 0;\n    helper(root, maxSum);\n    return maxSum;\n}\n\ntuple<int, int, int, bool> helper(TreeNode *currentNode, int &maxSum)\n{\n    if(currentNode == NULL)\n    {\n        return {INT_MAX, INT_MIN, 0, true};\n    }\n\n    auto [leftMin, leftMax, leftSum, isLeftBST]= helper(currentNode->leftChild, maxSum);\n    auto [rightMin, rightMax, rightSum, isRightBST]= helper(currentNode->rightChild, maxSum);\n\n    if(isLeftBST && isRightBST && currentNode->value > leftMax && currentNode->value < rightMin)\n    {\n        int sum= currentNode->value + leftSum + rightSum;\n        maxSum= max(maxSum, sum);\n        return {min(currentNode->value, leftMin), max(currentNode->value, rightMax), sum, true};\n    }\n\n    return {0, 0, 0, false};\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nint maxSumBST(TreeNode *root)\n{\n    int maxSum= 0;\n    helper(root, maxSum);\n    return maxSum;\n}\n\nstd::tuple<int, int, int, bool> helper(TreeNode *currentNode, int &maxSum)\n{\n    if(currentNode == NULL)\n    {\n        return {INT_MAX, INT_MIN, 0, true};\n    }\n\n    auto [leftMin, leftMax, leftSum, isLeftBST]= helper(currentNode->leftChild, maxSum);\n    auto [rightMin, rightMax, rightSum, isRightBST]= helper(currentNode->rightChild, maxSum);\n\n    if(isLeftBST && isRightBST && currentNode->value > leftMax && currentNode->value < rightMin)\n    {\n        int sum= currentNode->value + leftSum + rightSum;\n        maxSum= std::max(maxSum, sum);\n        return {std::min(currentNode->value, leftMin), std::max(currentNode->value, rightMax), sum, true};\n    }\n\n    return {0, 0, 0, false};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countNegatives(vector<vector<int>> &grid)\n{\n    int rowCount= grid.size(), columnCount= grid[0].size(), negativeCount= 0, rowIndex= 0, columnIndex= columnCount - 1;\n    while(rowIndex < rowCount && columnIndex >= 0)\n    {\n        if(grid[rowIndex][columnIndex] < 0)\n        {\n            negativeCount+= columnIndex + 1;\n            rowIndex++;\n        }\n        else\n        {\n            columnIndex--;\n        }\n    }\n    return negativeCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countNegatives(std::vector<std::vector<int>> &grid)\n{\n    int rowCount = grid.size(), columnCount = grid[0].size(), negativeCount = 0, rowIndex = 0, columnIndex = columnCount - 1;\n    while(rowIndex < rowCount && columnIndex >= 0)\n    {\n        if(grid[rowIndex][columnIndex] < 0)\n        {\n            negativeCount += columnIndex + 1;\n            rowIndex++;\n        }\n        else\n        {\n            columnIndex--;\n        }\n    }\n    return negativeCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass ProductOfNumbers\n{\n  public:\n    vector<int> cumulativeProducts;\n\n    ProductOfNumbers()\n    {\n        cumulativeProducts.push_back(1);\n    }\n\n    void add(int number)\n    {\n        if(number == 0)\n        {\n            cumulativeProducts.clear();\n            cumulativeProducts.push_back(1);\n        }\n        else\n        {\n            cumulativeProducts.push_back(cumulativeProducts.back() * number);\n        }\n    }\n\n    int getProduct(int k)\n    {\n        if(k >= cumulativeProducts.size())\n        {\n            return 0;\n        }\n        else\n        {\n            return cumulativeProducts.back() / cumulativeProducts[cumulativeProducts.size() - k - 1];\n        }\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass ProductOfNumbers\n{\n  public:\n    std::vector<int> cumulativeProducts;\n\n    ProductOfNumbers()\n    {\n        cumulativeProducts.push_back(1);\n    }\n\n    void add(int number)\n    {\n        if(number == 0)\n        {\n            cumulativeProducts.clear();\n            cumulativeProducts.push_back(1);\n        }\n        else\n        {\n            cumulativeProducts.push_back(cumulativeProducts.back() * number);\n        }\n    }\n\n    int getProduct(int k)\n    {\n        if(k >= cumulativeProducts.size())\n        {\n            return 0;\n        }\n        else\n        {\n            return cumulativeProducts.back() / cumulativeProducts[cumulativeProducts.size() - k - 1];\n        }\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxEvents(vector<vector<int>> &eventSchedule)\n{\n    sort(eventSchedule.begin(), eventSchedule.end(), [](const vector<int> &startEndA, const vector<int> &startEndB)\n              { return startEndA[1] < startEndB[1]; });\n\n    int totalCount = 0;\n    int lastEventDay = -1;\n\n    for (int i = 0; i < eventSchedule.size(); ++i)\n    {\n        const auto &event = eventSchedule[i];\n        if (event[0] > lastEventDay)\n        {\n            ++totalCount;\n            lastEventDay = event[1];\n        }\n    }\n\n    return totalCount;\n}",
    "output": "#include <bits/stdc++.h>\nint maxEvents(std::vector<std::vector<int>> &eventSchedule)\n{\n    std::sort(eventSchedule.begin(), eventSchedule.end(), [](const std::vector<int> &startEndA, const std::vector<int> &startEndB)\n              { return startEndA[1] < startEndB[1]; });\n\n    int totalCount= 0;\n    int lastEventDay= -1;\n\n    for(const auto &event : eventSchedule)\n    {\n        if(event[0] > lastEventDay)\n        {\n            ++totalCount;\n            lastEventDay= event[1];\n        }\n    }\n\n    return totalCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> runningSum(vector<int> &numberList)\n{\n    for(int index= 1; index < numberList.size(); index++)\n    {\n        numberList[index]+= numberList[index - 1];\n    }\n    return numberList;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> runningSum(std::vector<int> &numberList)\n{\n    for(int index= 1; index < numberList.size(); index++)\n    {\n        numberList[index]+= numberList[index - 1];\n    }\n    return numberList;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findLeastNumOfUniqueInts(vector<int> &inputArray, int elementsToRemove)\n{\n    unordered_map<int, int> elementCount;\n    for(int element : inputArray)\n    {\n        elementCount[element]++;\n    }\n    priority_queue<int, vector<int>, greater<int>> minHeap;\n    for(auto &pair : elementCount)\n    {\n        minHeap.push(pair.second);\n    }\n    while(elementsToRemove > 0 && !minHeap.empty())\n    {\n        elementsToRemove -= minHeap.top();\n        minHeap.pop();\n    }\n    return elementsToRemove == 0 ? minHeap.size() : minHeap.size() + 1;\n}",
    "output": "#include <bits/stdc++.h>\nint findLeastNumOfUniqueInts(std::vector<int> &inputArray, int elementsToRemove)\n{\n    std::unordered_map<int, int> elementCount;\n    for(int element : inputArray)\n    {\n        elementCount[element]++;\n    }\n    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;\n    for(auto &pair : elementCount)\n    {\n        minHeap.push(pair.second);\n    }\n    while(elementsToRemove > 0 && !minHeap.empty())\n    {\n        elementsToRemove -= minHeap.top();\n        minHeap.pop();\n    }\n    return elementsToRemove == 0 ? minHeap.size() : minHeap.size() + 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> smallerNumbersThanCurrent(vector<int> &inputNumbers)\n{\n    vector<int> result(inputNumbers.size(), 0);\n    for(int currentIndex= 0; currentIndex < inputNumbers.size(); ++currentIndex)\n    {\n        for(int comparisonIndex= 0; comparisonIndex < inputNumbers.size(); ++comparisonIndex)\n        {\n            if(inputNumbers[comparisonIndex] < inputNumbers[currentIndex])\n            {\n                ++result[currentIndex];\n            }\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> smallerNumbersThanCurrent(std::vector<int> &inputNumbers)\n{\n    std::vector<int> result(inputNumbers.size(), 0);\n    for(int currentIndex= 0; currentIndex < inputNumbers.size(); ++currentIndex)\n    {\n        for(int comparisonIndex= 0; comparisonIndex < inputNumbers.size(); ++comparisonIndex)\n        {\n            if(inputNumbers[comparisonIndex] < inputNumbers[currentIndex])\n            {\n                ++result[currentIndex];\n            }\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring rankTeams(vector<string> &votes)\n{\n    int numberOfTeams = votes[0].size();\n    vector<vector<int>> teamRanks(26, vector<int>(numberOfTeams, 0));\n\n    for (const string &vote : votes)\n    {\n        for (int i = 0; i < numberOfTeams; ++i)\n        {\n            teamRanks[vote[i] - 'A'][i]++;\n        }\n    }\n\n    string rankedResult = votes[0];\n    sort(rankedResult.begin(), rankedResult.end(), [&](char teamA, char teamB)\n              {\n        for (int i = 0; i < numberOfTeams; ++i) {\n            if (teamRanks[teamA - 'A'][i] != teamRanks[teamB - 'A'][i]) {\n                return teamRanks[teamA - 'A'][i] > teamRanks[teamB - 'A'][i];\n            }\n        }\n        return teamA < teamB; });\n\n    return rankedResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string rankTeams(std::vector<std::string> &votes)\n{\n    int numberOfTeams= votes[0].size();\n    std::vector<std::vector<int>> teamRanks(26, std::vector<int>(numberOfTeams, 0));\n\n    for(const std::string &vote : votes)\n    {\n        for(int i= 0; i < numberOfTeams; ++i)\n        {\n            teamRanks[vote[i] - 'A'][i]++;\n        }\n    }\n\n    std::string rankedResult= votes[0];\n    std::sort(rankedResult.begin(), rankedResult.end(), [&](char teamA, char teamB)\n              {\n        for (int i = 0; i < numberOfTeams; ++i) {\n            if (teamRanks[teamA - 'A'][i] != teamRanks[teamB - 'A'][i]) {\n                return teamRanks[teamA - 'A'][i] > teamRanks[teamB - 'A'][i];\n            }\n        }\n        return teamA < teamB; });\n\n    return rankedResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minCost(vector<vector<int>> &costGrid)\n{\n    int rowCount = costGrid.size();\n    int colCount = costGrid[0].size();\n    vector<vector<int>> cost(rowCount, vector<int>(colCount, 1e6));\n    queue<pair<int, int>> positionQueue;\n\n    auto dfs = [&](int row, int col, int distance)\n    {\n        if(row >= 0 && col >= 0 && row < rowCount && col < colCount && (distance < cost[row][col]))\n        {\n            cost[row][col] = distance;\n            positionQueue.push({row, col});\n        }\n    };\n\n    dfs(0, 0, 0);\n    const vector<pair<int, int>> directionOffsets = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    while(!positionQueue.empty())\n    {\n        int row = positionQueue.front().first;\n        int col = positionQueue.front().second;\n        positionQueue.pop();\n        for(int i = 0; i < 4; ++i)\n        {\n            int newRow = row + directionOffsets[i].first;\n            int newCol = col + directionOffsets[i].second;\n            dfs(newRow, newCol, cost[row][col] + (costGrid[row][col] != i + 1));\n        }\n    }\n    return cost.back().back();\n}",
    "output": "#include <bits/stdc++.h>\nint minCost(std::vector<std::vector<int>> &costGrid)\n{\n    int rowCount= costGrid.size();\n    int colCount= costGrid[0].size();\n    std::vector<std::vector<int>> cost(rowCount, std::vector<int>(colCount, 1e6));\n    std::queue<std::pair<int, int>> positionQueue;\n\n    auto dfs= [&](int row, int col, int distance)\n    {\n        if(row >= 0 && col >= 0 && row < rowCount && col < colCount && (distance < cost[row][col]))\n        {\n            cost[row][col]= distance;\n            positionQueue.push({row, col});\n        }\n    };\n\n    dfs(0, 0, 0);\n    const std::vector<std::pair<int, int>> directionOffsets= {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    while(!positionQueue.empty())\n    {\n        int row= positionQueue.front().first;\n        int col= positionQueue.front().second;\n        positionQueue.pop();\n        for(int i= 0; i < 4; ++i)\n        {\n            int newRow= row + directionOffsets[i].first;\n            int newCol= col + directionOffsets[i].second;\n            dfs(newRow, newCol, cost[row][col] + (costGrid[row][col] != i + 1));\n        }\n    }\n    return cost.back().back();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// for abs\nusing namespace std;\n\nint findTheDistanceValue(vector<int> &firstArray, vector<int> &secondArray, int distance)\n{\n    int validCount= 0;\n    for(int index1= 0; index1 < firstArray.size(); index1++)\n    {\n        bool isValid= true;\n        for(int index2= 0; index2 < secondArray.size(); index2++)\n        {\n            if(abs(firstArray[index1] - secondArray[index2]) <= distance)\n            {\n                isValid= false;\n                break;\n            }\n        }\n        if(isValid)\n            validCount++;\n    }\n    return validCount;\n}",
    "output": "#include <bits/stdc++.h>\nint findTheDistanceValue(std::vector<int> &firstArray, std::vector<int> &secondArray, int distance)\n{\n    int validCount= 0;\n    for(int index1= 0; index1 < firstArray.size(); index1++)\n    {\n        bool isValid= true;\n        for(int index2= 0; index2 < secondArray.size(); index2++)\n        {\n            if(std::abs(firstArray[index1] - secondArray[index2]) <= distance)\n            {\n                isValid= false;\n                break;\n            }\n        }\n        if(isValid)\n            validCount++;\n    }\n    return validCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfFamilies(int totalRows, vector<vector<int>> &reservedSeats)\n{\n    unordered_map<int, int> occupiedSeatsByRow;\n    for (const auto &seat : reservedSeats)\n    {\n        occupiedSeatsByRow[seat[0]] |= 1 << (seat[1] - 1);\n    }\n\n    int maxGroups = (totalRows - occupiedSeatsByRow.size()) * 2;\n    for (const auto &row : occupiedSeatsByRow)\n    {\n        int availableSeats = ~(row.second | (row.second >> 1) | (row.second >> 2) | (row.second >> 3)) & 0x3FF;\n        maxGroups += (availableSeats & (availableSeats >> 1) & (availableSeats >> 2) & (availableSeats >> 3)) != 0;\n    }\n\n    return maxGroups;\n}",
    "output": "#include <bits/stdc++.h>\nint maxNumberOfFamilies(int totalRows, std::vector<std::vector<int>> &reservedSeats)\n{\n    std::unordered_map<int, int> occupiedSeatsByRow;\n    for(const auto &seat : reservedSeats)\n    {\n        occupiedSeatsByRow[seat[0]]|= 1 << (seat[1] - 1);\n    }\n\n    int maxGroups= (totalRows - occupiedSeatsByRow.size()) * 2;\n    for(const auto &row : occupiedSeatsByRow)\n    {\n        int availableSeats= ~(row.second | (row.second >> 1) | (row.second >> 2) | (row.second >> 3)) & 0x3FF;\n        maxGroups+= (availableSeats & (availableSeats >> 1) & (availableSeats >> 2) & (availableSeats >> 3)) != 0;\n    }\n\n    return maxGroups;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint getPower(int number)\n{\n    int stepCount= 0;\n    while(number != 1)\n    {\n        if(number % 2 == 0)\n            number/= 2;\n        else\n            number= 3 * number + 1;\n        stepCount++;\n    }\n    return stepCount;\n}\n\nint sortByPower(int lowerBound, int upperBound, int index)\n{\n    vector<pair<int, int>> numberPowers;\n    for(int i= lowerBound; i <= upperBound; i++)\n    {\n        numberPowers.push_back({getPower(i), i});\n    }\n    sort(numberPowers.begin(), numberPowers.end());\n    return numberPowers[index - 1].second;\n}",
    "output": "#include <bits/stdc++.h>\nint getPower(int number)\n{\n    int stepCount= 0;\n    while(number != 1)\n    {\n        if(number % 2 == 0)\n            number /= 2;\n        else\n            number = 3 * number + 1;\n        stepCount++;\n    }\n    return stepCount;\n}\n\nint sortByPower(int lowerBound, int upperBound, int index)\n{\n    std::vector<std::pair<int, int>> numberPowers;\n    for(int i= lowerBound; i <= upperBound; i++)\n    {\n        numberPowers.push_back({getPower(i), i});\n    }\n    std::sort(numberPowers.begin(), numberPowers.end());\n    return numberPowers[index - 1].second;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxSum(vector<int> &pizzaSlices, int startIndex, int endIndex, int slicesToPick, vector<vector<int>> &memoization)\n{\n    if(slicesToPick == 0)\n        return 0;\n    if(endIndex - startIndex + 1 < slicesToPick * 2)\n        return INT_MIN;\n    if(memoization[startIndex][slicesToPick] != -1)\n        return memoization[startIndex][slicesToPick];\n\n    int pickSlice= calculateMaxSum(pizzaSlices, startIndex + 2, endIndex, slicesToPick - 1, memoization) + pizzaSlices[startIndex];\n    int skipSlice= calculateMaxSum(pizzaSlices, startIndex + 1, endIndex, slicesToPick, memoization);\n\n    memoization[startIndex][slicesToPick]= max(pickSlice, skipSlice);\n    return memoization[startIndex][slicesToPick];\n}\n\nint maxSizeSlices(vector<int> &pizzaSlices)\n{\n    int numberOfSlices= pizzaSlices.size() / 3;\n    vector<vector<int>> memoization1(pizzaSlices.size(), vector<int>(numberOfSlices + 1, -1));\n    vector<vector<int>> memoization2(pizzaSlices.size(), vector<int>(numberOfSlices + 1, -1));\n\n    return max(calculateMaxSum(pizzaSlices, 0, pizzaSlices.size() - 1, numberOfSlices, memoization1),\n               calculateMaxSum(pizzaSlices, 1, pizzaSlices.size(), numberOfSlices, memoization2));\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMaxSum(std::vector<int> &pizzaSlices, int startIndex, int endIndex, int slicesToPick, std::vector<std::vector<int>> &memoization)\n{\n    if(slicesToPick == 0)\n        return 0;\n    if(endIndex - startIndex + 1 < slicesToPick * 2)\n        return INT_MIN;\n    if(memoization[startIndex][slicesToPick] != -1)\n        return memoization[startIndex][slicesToPick];\n\n    int pickSlice = calculateMaxSum(pizzaSlices, startIndex + 2, endIndex, slicesToPick - 1, memoization) + pizzaSlices[startIndex];\n    int skipSlice = calculateMaxSum(pizzaSlices, startIndex + 1, endIndex, slicesToPick, memoization);\n\n    memoization[startIndex][slicesToPick] = std::max(pickSlice, skipSlice);\n    return memoization[startIndex][slicesToPick];\n}\n\nint maxSizeSlices(std::vector<int> &pizzaSlices)\n{\n    int numberOfSlices = pizzaSlices.size() / 3;\n    std::vector<std::vector<int>> memoization1(pizzaSlices.size(), std::vector<int>(numberOfSlices + 1, -1));\n    std::vector<std::vector<int>> memoization2(pizzaSlices.size(), std::vector<int>(numberOfSlices + 1, -1));\n\n    return std::max(calculateMaxSum(pizzaSlices, 0, pizzaSlices.size() - 1, numberOfSlices, memoization1),\n                    calculateMaxSum(pizzaSlices, 1, pizzaSlices.size(), numberOfSlices, memoization2));\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring generateTheString(int length)\n{\n    string result(length, 'a');\n    if(length % 2 == 0)\n    {\n        result[length - 1]= 'b';\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string generateTheString(int length)\n{\n    std::string result(length, 'a');\n    if(length % 2 == 0)\n    {\n        result[length - 1]= 'b';\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countPrefixAligned(const vector<int> &flipValues)\n{\n    int alignedCount= 0;\n    for(int index= 0; index < flipValues.size(); index++)\n    {\n        if(flipValues[index] == index + 1)\n        {\n            alignedCount++;\n        }\n    }\n    return alignedCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countPrefixAligned(const std::vector<int> &flipValues)\n{\n    int alignedCount= 0;\n    for(int index= 0; index < flipValues.size(); index++)\n    {\n        if(flipValues[index] == index + 1)\n        {\n            alignedCount++;\n        }\n    }\n    return alignedCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numOfMinutes(int totalEmployees, int ceoId, vector<int> &managerList, vector<int> &informDuration)\n{\n    vector<vector<int>> subordinateList(totalEmployees);\n    for(int employeeId= 0; employeeId < totalEmployees; ++employeeId)\n    {\n        if(managerList[employeeId] != -1)\n        {\n            subordinateList[managerList[employeeId]].push_back(employeeId);\n        }\n    }\n\n    queue<pair<int, int>> employeeQueue;\n    employeeQueue.push({ceoId, 0});\n    int maxInformTime= 0;\n\n    while(!employeeQueue.empty())\n    {\n        auto [currentEmployee, currentTime]= employeeQueue.front();\n        employeeQueue.pop();\n        maxInformTime= max(maxInformTime, currentTime);\n        for(int i = 0; i < subordinateList[currentEmployee].size(); ++i)\n        {\n            int subordinate = subordinateList[currentEmployee][i];\n            employeeQueue.push({subordinate, currentTime + informDuration[currentEmployee]});\n        }\n    }\n    return maxInformTime;\n}",
    "output": "#include <bits/stdc++.h>\nint numOfMinutes(int totalEmployees, int ceoId, std::vector<int> &managerList, std::vector<int> &informDuration)\n{\n    std::vector<std::vector<int>> subordinateList(totalEmployees);\n    for(int employeeId= 0; employeeId < totalEmployees; ++employeeId)\n    {\n        if(managerList[employeeId] != -1)\n        {\n            subordinateList[managerList[employeeId]].push_back(employeeId);\n        }\n    }\n\n    std::queue<std::pair<int, int>> employeeQueue;\n    employeeQueue.push({ceoId, 0});\n    int maxInformTime= 0;\n\n    while(!employeeQueue.empty())\n    {\n        auto [currentEmployee, currentTime]= employeeQueue.front();\n        employeeQueue.pop();\n        maxInformTime= std::max(maxInformTime, currentTime);\n        for(int subordinate : subordinateList[currentEmployee])\n        {\n            employeeQueue.push({subordinate, currentTime + informDuration[currentEmployee]});\n        }\n    }\n    return maxInformTime;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble depthFirstSearch(int currentNode, int parentNode, int timeRemaining, int targetNode, vector<vector<int>> &graph)\n{\n    if(timeRemaining == 0)\n    {\n        return currentNode == targetNode ? 1.0 : 0.0;\n    }\n    double probability = 0.0;\n    for(int i = 0; i < graph[currentNode].size(); ++i)\n    {\n        int neighbor = graph[currentNode][i];\n        if(neighbor != parentNode)\n        {\n            probability += depthFirstSearch(neighbor, currentNode, timeRemaining - 1, targetNode, graph);\n        }\n    }\n    return probability / (graph[currentNode].size() - (parentNode == -1 ? 0 : 1));\n}\n\ndouble frogPosition(int numberOfNodes, vector<vector<int>> &edges, int timeLimit, int targetNode)\n{\n    vector<vector<int>> graph(numberOfNodes + 1);\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        vector<int> &edge = edges[i];\n        graph[edge[0]].push_back(edge[1]);\n        graph[edge[1]].push_back(edge[0]);\n    }\n    return depthFirstSearch(1, -1, timeLimit, targetNode, graph);\n}",
    "output": "#include <bits/stdc++.h>\ndouble depthFirstSearch(int currentNode, int parentNode, int timeRemaining, int targetNode, std::vector<std::vector<int>> &graph)\n{\n    if(timeRemaining == 0)\n    {\n        return currentNode == targetNode ? 1.0 : 0.0;\n    }\n    double probability = 0.0;\n    for(int neighbor : graph[currentNode])\n    {\n        if(neighbor != parentNode)\n        {\n            probability += depthFirstSearch(neighbor, currentNode, timeRemaining - 1, targetNode, graph);\n        }\n    }\n    return probability / (graph[currentNode].size() - (parentNode == -1 ? 0 : 1));\n}\n\ndouble frogPosition(int numberOfNodes, std::vector<std::vector<int>> &edges, int timeLimit, int targetNode)\n{\n    std::vector<std::vector<int>> graph(numberOfNodes + 1);\n    for(std::vector<int> &edge : edges)\n    {\n        graph[edge[0]].push_back(edge[1]);\n        graph[edge[1]].push_back(edge[0]);\n    }\n    return depthFirstSearch(1, -1, timeLimit, targetNode, graph);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfSemesters(int totalCourses, vector<vector<int>> &courseRelations, int maxCoursesPerSemester)\n{\n    vector<int> courseIndegree(totalCourses + 1, 0);\n    vector<vector<int>> courseGraph(totalCourses + 1);\n\n    for (const auto &relation : courseRelations)\n    {\n        courseGraph[relation[0]].push_back(relation[1]);\n        courseIndegree[relation[1]]++;\n    }\n\n    int totalSemesters = 0;\n    while (totalCourses > 0)\n    {\n        queue<int> zeroIndegreeCourses;\n        for (int index = 1; index < courseIndegree.size(); ++index)\n        {\n            if (courseIndegree[index] == 0)\n            {\n                zeroIndegreeCourses.push(index);\n                courseIndegree[index] = -1;\n            }\n        }\n\n        int coursesTaken = 0;\n        while (!zeroIndegreeCourses.empty() && coursesTaken < maxCoursesPerSemester)\n        {\n            int currentCourse = zeroIndegreeCourses.front();\n            zeroIndegreeCourses.pop();\n            totalCourses--;\n\n            for (int j = 0; j < courseGraph[currentCourse].size(); ++j)\n            {\n                int nextCourse = courseGraph[currentCourse][j];\n                courseIndegree[nextCourse]--;\n            }\n            coursesTaken++;\n        }\n        totalSemesters++;\n    }\n    return totalSemesters;\n}",
    "output": "#include <bits/stdc++.h>\nint minNumberOfSemesters(int totalCourses, std::vector<std::vector<int>> &courseRelations, int maxCoursesPerSemester)\n{\n    std::vector<int> courseIndegree(totalCourses + 1, 0);\n    std::vector<std::vector<int>> courseGraph(totalCourses + 1);\n\n    for(const auto &relation : courseRelations)\n    {\n        courseGraph[relation[0]].push_back(relation[1]);\n        courseIndegree[relation[1]]++;\n    }\n\n    int totalSemesters= 0;\n    while(totalCourses > 0)\n    {\n        std::queue<int> zeroIndegreeCourses;\n        for(int index= 1; index < courseIndegree.size(); ++index)\n        {\n            if(courseIndegree[index] == 0)\n            {\n                zeroIndegreeCourses.push(index);\n                courseIndegree[index]= -1;\n            }\n        }\n\n        int coursesTaken= 0;\n        while(!zeroIndegreeCourses.empty() && coursesTaken < maxCoursesPerSemester)\n        {\n            int currentCourse= zeroIndegreeCourses.front();\n            zeroIndegreeCourses.pop();\n            totalCourses--;\n\n            for(int nextCourse : courseGraph[currentCourse])\n            {\n                courseIndegree[nextCourse]--;\n            }\n            coursesTaken++;\n        }\n        totalSemesters++;\n    }\n    return totalSemesters;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> luckyNumbers(vector<vector<int>> &numberMatrix)\n{\n    int rowCount= numberMatrix.size(), columnCount= numberMatrix[0].size();\n    vector<int> luckyNumbers;\n    for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n    {\n        int minInRow= numberMatrix[rowIndex][0], minInRowIndex= 0;\n        for(int columnIndex= 0; columnIndex < columnCount; ++columnIndex)\n        {\n            if(numberMatrix[rowIndex][columnIndex] < minInRow)\n            {\n                minInRow= numberMatrix[rowIndex][columnIndex];\n                minInRowIndex= columnIndex;\n            }\n        }\n        bool isLucky= true;\n        for(int otherRowIndex= 0; otherRowIndex < rowCount; ++otherRowIndex)\n        {\n            if(numberMatrix[otherRowIndex][minInRowIndex] > minInRow)\n            {\n                isLucky= false;\n                break;\n            }\n        }\n        if(isLucky)\n            luckyNumbers.push_back(minInRow);\n    }\n    return luckyNumbers;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> luckyNumbers(std::vector<std::vector<int>> &numberMatrix)\n{\n    int rowCount = numberMatrix.size(), columnCount = numberMatrix[0].size();\n    std::vector<int> luckyNumbers;\n    for(int rowIndex = 0; rowIndex < rowCount; ++rowIndex)\n    {\n        int minInRow = numberMatrix[rowIndex][0], minInRowIndex = 0;\n        for(int columnIndex = 0; columnIndex < columnCount; ++columnIndex)\n        {\n            if(numberMatrix[rowIndex][columnIndex] < minInRow)\n            {\n                minInRow = numberMatrix[rowIndex][columnIndex];\n                minInRowIndex = columnIndex;\n            }\n        }\n        bool isLucky = true;\n        for(int otherRowIndex = 0; otherRowIndex < rowCount; ++otherRowIndex)\n        {\n            if(numberMatrix[otherRowIndex][minInRowIndex] > minInRow)\n            {\n                isLucky = false;\n                break;\n            }\n        }\n        if(isLucky)\n            luckyNumbers.push_back(minInRow);\n    }\n    return luckyNumbers;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "TreeNode *getTargetCopy(TreeNode *originalNode, TreeNode *clonedNode, TreeNode *targetNode)\n{\n    if(originalNode == NULL)\n        return NULL;\n    if(originalNode == targetNode)\n        return clonedNode;\n\n    TreeNode *leftCopy= getTargetCopy(originalNode->left, clonedNode->left, targetNode);\n    return leftCopy ? leftCopy : getTargetCopy(originalNode->right, clonedNode->right, targetNode);\n}",
    "output": "TreeNode *getTargetCopy(TreeNode *originalNode, TreeNode *clonedNode, TreeNode *targetNode)\n{\n    if(originalNode == NULL)\n        return NULL;\n    if(originalNode == targetNode)\n        return clonedNode;\n\n    TreeNode *leftCopy= getTargetCopy(originalNode->left, clonedNode->left, targetNode);\n    return leftCopy ? leftCopy : getTargetCopy(originalNode->right, clonedNode->right, targetNode);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPerformance(int numberOfEngineers, int maxEngineers, vector<int> &speeds, vector<int> &efficiencies)\n{\n    vector<pair<int, int>> engineerList;\n    for(int index = 0; index < numberOfEngineers; ++index)\n    {\n        engineerList.emplace_back(efficiencies[index], speeds[index]);\n    }\n    sort(engineerList.rbegin(), engineerList.rend());\n\n    long long totalSpeed = 0;\n    long long maxPerformanceResult = 0;\n    priority_queue<int, vector<int>, greater<int>> minHeap;\n    for (int i = 0; i < engineerList.size(); ++i)\n    {\n        auto engineer = engineerList[i];\n        if (minHeap.size() >= maxEngineers)\n        {\n            totalSpeed -= minHeap.top();\n            minHeap.pop();\n        }\n        minHeap.push(engineer.second);\n        totalSpeed += engineer.second;\n        maxPerformanceResult = max(maxPerformanceResult, engineer.first * totalSpeed);\n    }\n    return maxPerformanceResult % 1000000007;\n}",
    "output": "#include <bits/stdc++.h>\nint maxPerformance(int numberOfEngineers, int maxEngineers, std::vector<int> &speeds, std::vector<int> &efficiencies)\n{\n    std::vector<std::pair<int, int>> engineerList;\n    for(int index= 0; index < numberOfEngineers; ++index)\n    {\n        engineerList.emplace_back(efficiencies[index], speeds[index]);\n    }\n    std::sort(engineerList.rbegin(), engineerList.rend());\n\n    long long totalSpeed= 0;\n    long long maxPerformanceResult= 0;\n    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;\n    for(const auto &engineer : engineerList)\n    {\n        if(minHeap.size() >= maxEngineers)\n        {\n            totalSpeed-= minHeap.top();\n            minHeap.pop();\n        }\n        minHeap.push(engineer.second);\n        totalSpeed+= engineer.second;\n        maxPerformanceResult= std::max(maxPerformanceResult, engineer.first * totalSpeed);\n    }\n    return maxPerformanceResult % 1000000007;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countLargestGroup(int upperLimit)\n{\n    int frequency[37]= {0}, largestGroupSize= 0, largestGroupCount= 0;\n\n    for(int currentNumber= 1; currentNumber <= upperLimit; currentNumber++)\n    {\n        int digitSum= 0, tempNumber= currentNumber;\n        while(tempNumber)\n        {\n            digitSum+= tempNumber % 10;\n            tempNumber/= 10;\n        }\n        frequency[digitSum]++;\n        largestGroupSize= max(largestGroupSize, frequency[digitSum]);\n    }\n\n    for(int index= 0; index < 37; index++)\n        if(frequency[index] == largestGroupSize)\n            largestGroupCount++;\n\n    return largestGroupCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countLargestGroup(int upperLimit)\n{\n    int frequency[37]= {0}, largestGroupSize= 0, largestGroupCount= 0;\n\n    for(int currentNumber= 1; currentNumber <= upperLimit; currentNumber++)\n    {\n        int digitSum= 0, tempNumber= currentNumber;\n        while(tempNumber)\n        {\n            digitSum+= tempNumber % 10;\n            tempNumber/= 10;\n        }\n        frequency[digitSum]++;\n        largestGroupSize= std::max(largestGroupSize, frequency[digitSum]);\n    }\n\n    for(int index= 0; index < 37; index++)\n        if(frequency[index] == largestGroupSize)\n            largestGroupCount++;\n\n    return largestGroupCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canConstruct(string inputString, int maxOddCount)\n{\n    int characterCounts[26] = {0};\n\n    for (int i = 0; i < inputString.size(); ++i)\n        characterCounts[inputString[i] - 'a']++;\n\n    int oddCharacterCount = 0;\n    for (int i = 0; i < 26; ++i)\n        oddCharacterCount += characterCounts[i] % 2;\n\n    return oddCharacterCount <= maxOddCount && maxOddCount <= inputString.length();\n}",
    "output": "bool canConstruct(std::string inputString, int maxOddCount)\n{\n    int characterCounts[26]= {0};\n\n    for(char currentCharacter : inputString)\n        characterCounts[currentCharacter - 'a']++;\n\n    int oddCharacterCount= 0;\n    for(int count : characterCounts)\n        oddCharacterCount+= count % 2;\n\n    return oddCharacterCount <= maxOddCount && maxOddCount <= inputString.length();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSatisfaction(vector<int> &satisfactionLevels)\n{\n    sort(satisfactionLevels.begin(), satisfactionLevels.end(), greater<int>());\n    int maximumSatisfaction = 0, currentTotal = 0, accumulatedSatisfaction = 0;\n    for (int i = 0; i < satisfactionLevels.size(); ++i)\n    {\n        int satisfaction = satisfactionLevels[i];\n        currentTotal += satisfaction;\n        if (currentTotal > 0)\n        {\n            accumulatedSatisfaction += currentTotal;\n            maximumSatisfaction = max(maximumSatisfaction, accumulatedSatisfaction);\n        }\n    }\n    return maximumSatisfaction;\n}",
    "output": "#include <bits/stdc++.h>\nint maxSatisfaction(std::vector<int> &satisfactionLevels)\n{\n    std::sort(satisfactionLevels.begin(), satisfactionLevels.end(), std::greater<int>());\n    int maximumSatisfaction= 0, currentTotal= 0, accumulatedSatisfaction= 0;\n    for(int satisfaction : satisfactionLevels)\n    {\n        currentTotal+= satisfaction;\n        if(currentTotal > 0)\n        {\n            accumulatedSatisfaction+= currentTotal;\n            maximumSatisfaction= std::max(maximumSatisfaction, accumulatedSatisfaction);\n        }\n    }\n    return maximumSatisfaction;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countSubmatrices(vector<vector<int>> &matrix)\n{\n    int rows= matrix.size(), columns= matrix[0].size();\n    vector<vector<int>> height(rows, vector<int>(columns));\n    int totalCount= 0;\n\n    for(int rowIndex= 0; rowIndex < rows; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < columns; colIndex++)\n        {\n            if(matrix[rowIndex][colIndex])\n            {\n                height[rowIndex][colIndex]= colIndex == 0 ? 1 : height[rowIndex][colIndex - 1] + 1;\n                int width= height[rowIndex][colIndex];\n                for(int k= rowIndex; k >= 0; k--)\n                {\n                    width= min(width, height[k][colIndex]);\n                    totalCount+= width;\n                }\n            }\n        }\n    }\n    return totalCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countSubmatrices(std::vector<std::vector<int>> &matrix)\n{\n    int rows= matrix.size(), columns= matrix[0].size();\n    std::vector<std::vector<int>> height(rows, std::vector<int>(columns));\n    int totalCount= 0;\n\n    for(int rowIndex= 0; rowIndex < rows; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < columns; colIndex++)\n        {\n            if(matrix[rowIndex][colIndex])\n            {\n                height[rowIndex][colIndex]= colIndex == 0 ? 1 : height[rowIndex][colIndex - 1] + 1;\n                int width= height[rowIndex][colIndex];\n                for(int k= rowIndex; k >= 0; k--)\n                {\n                    width= std::min(width, height[k][colIndex]);\n                    totalCount+= width;\n                }\n            }\n        }\n    }\n    return totalCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> createTargetArray(vector<int> &sourceNumbers, vector<int> &insertionIndices)\n{\n    vector<int> targetArray;\n    for(int currentIndex= 0; currentIndex < sourceNumbers.size(); ++currentIndex)\n    {\n        targetArray.insert(targetArray.begin() + insertionIndices[currentIndex], sourceNumbers[currentIndex]);\n    }\n    return targetArray;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> createTargetArray(std::vector<int> &sourceNumbers, std::vector<int> &insertionIndices)\n{\n    std::vector<int> targetArray;\n    for(int currentIndex= 0; currentIndex < sourceNumbers.size(); ++currentIndex)\n    {\n        targetArray.insert(targetArray.begin() + insertionIndices[currentIndex], sourceNumbers[currentIndex]);\n    }\n    return targetArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Assuming Node class is defined elsewhere\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n};\n\nclass Solution\n{\n  public:\n    Node *findRoot(vector<Node *> nodeList)\n    {\n        int totalValueSum = 0;\n\n        for (int i = 0; i < nodeList.size(); ++i)\n        {\n            Node* currentNode = nodeList[i];\n            totalValueSum += currentNode->val;\n\n            for (int j = 0; j < currentNode->children.size(); ++j)\n            {\n                Node* childNode = currentNode->children[j];\n                totalValueSum -= childNode->val;\n            }\n        }\n\n        for (int i = 0; i < nodeList.size(); ++i)\n        {\n            Node* currentNode = nodeList[i];\n            if (currentNode->val == totalValueSum)\n            {\n                return currentNode;\n            }\n        }\n\n        return NULL;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Node {\npublic:\n    int val;\n    std::vector<Node*> children;\n};\n\nclass Solution\n{\n  public:\n    Node *findRoot(std::vector<Node *> nodeList)\n    {\n        int totalValueSum= 0;\n\n        for(auto &currentNode : nodeList)\n        {\n            totalValueSum+= currentNode->val;\n\n            for(auto &childNode : currentNode->children)\n            {\n                totalValueSum-= childNode->val;\n            }\n        }\n\n        for(auto &currentNode : nodeList)\n        {\n            if(currentNode->val == totalValueSum)\n            {\n                return currentNode;\n            }\n        }\n\n        return NULL;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool hasValidPath(vector<vector<int>> &grid)\n{\n    int rows = grid.size();\n    int columns = grid[0].size();\n    vector<vector<bool>> visited(rows, vector<bool>(columns, false));\n\n    return depthFirstSearch(grid, 0, 0, rows, columns, visited);\n}\n\nbool depthFirstSearch(vector<vector<int>> &grid, int currentX, int currentY, int rows, int columns, vector<vector<bool>> &visited)\n{\n    if(currentX < 0 || currentY < 0 || currentX >= rows || currentY >= columns || visited[currentX][currentY])\n        return false;\n    if(currentX == rows - 1 && currentY == columns - 1)\n        return true;\n\n    visited[currentX][currentY] = true;\n\n    int nextX[4] = {-1, 0, 1, 0};\n    int nextY[4] = {0, 1, 0, -1};\n\n    for(int direction = 0; direction < 4; direction++)\n    {\n        int nextPositionX = currentX + nextX[direction];\n        int nextPositionY = currentY + nextY[direction];\n\n        if(depthFirstSearch(grid, nextPositionX, nextPositionY, rows, columns, visited))\n            return true;\n    }\n\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool hasValidPath(std::vector<std::vector<int>> &grid)\n{\n    int rows= grid.size();\n    int columns= grid[0].size();\n    std::vector<std::vector<bool>> visited(rows, std::vector<bool>(columns, false));\n\n    return depthFirstSearch(grid, 0, 0, rows, columns, visited);\n}\n\nbool depthFirstSearch(std::vector<std::vector<int>> &grid, int currentX, int currentY, int rows, int columns, std::vector<std::vector<bool>> &visited)\n{\n    if(currentX < 0 || currentY < 0 || currentX >= rows || currentY >= columns || visited[currentX][currentY])\n        return false;\n    if(currentX == rows - 1 && currentY == columns - 1)\n        return true;\n\n    visited[currentX][currentY]= true;\n\n    int nextX[4]= {-1, 0, 1, 0};\n    int nextY[4]= {0, 1, 0, -1};\n\n    for(int direction= 0; direction < 4; direction++)\n    {\n        int nextPositionX= currentX + nextX[direction];\n        int nextPositionY= currentY + nextY[direction];\n\n        if(depthFirstSearch(grid, nextPositionX, nextPositionY, rows, columns, visited))\n            return true;\n    }\n\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring findLongestHappyPrefix(string inputString)\n{\n    int stringLength = inputString.length();\n    vector<int> longestPrefixSuffix(stringLength, 0);\n    int prefixLength = 0;\n    int currentIndex = 1;\n    while(currentIndex < stringLength)\n    {\n        if(inputString[currentIndex] == inputString[prefixLength])\n        {\n            prefixLength++;\n            longestPrefixSuffix[currentIndex] = prefixLength;\n            currentIndex++;\n        }\n        else\n        {\n            if(prefixLength != 0)\n            {\n                prefixLength = longestPrefixSuffix[prefixLength - 1];\n            }\n            else\n            {\n                longestPrefixSuffix[currentIndex] = 0;\n                currentIndex++;\n            }\n        }\n    }\n    return inputString.substr(0, longestPrefixSuffix[stringLength - 1]);\n}",
    "output": "std::string findLongestHappyPrefix(std::string inputString)\n{\n    int stringLength= inputString.length();\n    std::vector<int> longestPrefixSuffix(stringLength, 0);\n    int prefixLength= 0;\n    int currentIndex= 1;\n    while(currentIndex < stringLength)\n    {\n        if(inputString[currentIndex] == inputString[prefixLength])\n        {\n            prefixLength++;\n            longestPrefixSuffix[currentIndex]= prefixLength;\n            currentIndex++;\n        }\n        else\n        {\n            if(prefixLength != 0)\n            {\n                prefixLength= longestPrefixSuffix[prefixLength - 1];\n            }\n            else\n            {\n                longestPrefixSuffix[currentIndex]= 0;\n                currentIndex++;\n            }\n        }\n    }\n    return inputString.substr(0, longestPrefixSuffix[stringLength - 1]);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For INT_MAX\nusing namespace std;\n\nint minDifference(vector<int> &numberList)\n{\n    int numberCount= numberList.size();\n    if(numberCount <= 4)\n        return 0;\n    sort(numberList.begin(), numberList.end());\n    int minimumResult= INT_MAX;\n    for(int index= 0; index <= 3; ++index)\n        minimumResult= min(minimumResult, numberList[numberCount - 4 + index] - numberList[index]);\n    return minimumResult;\n}",
    "output": "#include <bits/stdc++.h>\nint minDifference(std::vector<int> &numberList)\n{\n    int numberCount= numberList.size();\n    if(numberCount <= 4)\n        return 0;\n    std::sort(numberList.begin(), numberList.end());\n    int minimumResult= std::numeric_limits<int>::max();\n    for(int index= 0; index <= 3; ++index)\n        minimumResult= std::min(minimumResult, numberList[numberCount - 4 + index] - numberList[index]);\n    return minimumResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findLucky(vector<int> &numbers)\n{\n    unordered_map<int, int> frequencyMap;\n\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        frequencyMap[currentNumber]++;\n    }\n\n    int luckyNumber = -1;\n    for (auto it = frequencyMap.begin(); it != frequencyMap.end(); ++it)\n    {\n        auto &frequencyPair = *it;\n        if (frequencyPair.first == frequencyPair.second)\n        {\n            luckyNumber = max(luckyNumber, frequencyPair.first);\n        }\n    }\n\n    return luckyNumber;\n}",
    "output": "#include <bits/stdc++.h>\nint findLucky(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> frequencyMap;\n\n    for(int currentNumber : numbers)\n    {\n        frequencyMap[currentNumber]++;\n    }\n\n    int luckyNumber= -1;\n    for(auto &frequencyPair : frequencyMap)\n    {\n        if(frequencyPair.first == frequencyPair.second)\n        {\n            luckyNumber= std::max(luckyNumber, frequencyPair.first);\n        }\n    }\n\n    return luckyNumber;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UndergroundSystem\n{\n  public:\n    unordered_map<int, pair<string, int>> checkInData;\n    unordered_map<string, pair<int, int>> travelData;\n\n    UndergroundSystem() {}\n\n    void checkIn(int passengerId, string stationName, int checkInTime)\n    {\n        checkInData[passengerId]= {stationName, checkInTime};\n    }\n\n    void checkOut(int passengerId, string stationName, int checkOutTime)\n    {\n        string startStation= checkInData[passengerId].first;\n        int startTime= checkInData[passengerId].second;\n        string route= startStation + \"_\" + stationName;\n        travelData[route].first+= (checkOutTime - startTime);\n        travelData[route].second+= 1;\n    }\n\n    double getAverageTime(string startStation, string endStation)\n    {\n        string route= startStation + \"_\" + endStation;\n        return (double)travelData[route].first / travelData[route].second;\n    }\n};",
    "output": "#include <bits/stdc++.h>\n// for std::pair\n\nclass UndergroundSystem\n{\n  public:\n    std::unordered_map<int, std::pair<std::string, int>> checkInData;\n    std::unordered_map<std::string, std::pair<int, int>> travelData;\n\n    UndergroundSystem() {}\n\n    void checkIn(int passengerId, std::string stationName, int checkInTime)\n    {\n        checkInData[passengerId]= {stationName, checkInTime};\n    }\n\n    void checkOut(int passengerId, std::string stationName, int checkOutTime)\n    {\n        std::string startStation= checkInData[passengerId].first;\n        int startTime= checkInData[passengerId].second;\n        std::string route= startStation + \"_\" + stationName;\n        travelData[route].first+= (checkOutTime - startTime);\n        travelData[route].second+= 1;\n    }\n\n    double getAverageTime(std::string startStation, std::string endStation)\n    {\n        std::string route= startStation + \"_\" + endStation;\n        return (double)travelData[route].first / travelData[route].second;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo= 1e9 + 7;\n\nint countGoodStrings(string startString, string endString, string forbiddenSubstring)\n{\n    int startLength= startString.size();\n    int forbiddenLength= forbiddenSubstring.size();\n    vector<vector<int>> dynamicProgramming(startLength + 1, vector<int>(forbiddenLength, 0));\n\n    // Preprocess the KMP prefix function for the forbidden substring\n    vector<int> longestPrefixSuffix(forbiddenLength);\n    int prefixLength= 0;\n    for(int i= 1; i < forbiddenLength;)\n    {\n        if(forbiddenSubstring[i] == forbiddenSubstring[prefixLength])\n        {\n            longestPrefixSuffix[i++]= ++prefixLength;\n        }\n        else if(prefixLength)\n        {\n            prefixLength= longestPrefixSuffix[prefixLength - 1];\n        }\n        else\n        {\n            ++i;\n        }\n    }\n\n    vector<vector<int>> count(startString.size() + 1, vector<int>(2, 0));\n    dynamicProgramming[0][0]= 1;\n\n    for(int i= 0; i < startLength; ++i)\n    {\n        for(int j= 0; j < forbiddenLength; ++j)\n        {\n            for(int k= 0; k < 2; ++k)\n            {\n                for(char currentChar= 'a'; currentChar <= (k ? endString[i] : 'z'); ++currentChar)\n                {\n                    int e= j;\n                    while(e && (currentChar != forbiddenSubstring[e]))\n                    {\n                        e= longestPrefixSuffix[e - 1];\n                    }\n\n                    if((currentChar != forbiddenSubstring[e]))\n                    {\n                        e++;\n                    }\n\n                    if(e != forbiddenLength)\n                    {\n                        dynamicProgramming[i + 1][k | (currentChar < endString[i])]+= dynamicProgramming[i][k];\n                        dynamicProgramming[i + 1][k | (currentChar < endString[i])]%= modulo;\n                    }\n                }\n            }\n        }\n    }\n\n    return (dynamicProgramming[startLength][1] - dynamicProgramming[startLength][0] + modulo) % modulo;\n}",
    "output": "#include <bits/stdc++.h>\nconst int modulo= 1e9 + 7;\n\nint countGoodStrings(std::string startString, std::string endString, std::string forbiddenSubstring)\n{\n    int startLength= startString.size();\n    int forbiddenLength= forbiddenSubstring.size();\n    std::vector<std::vector<int>> dynamicProgramming(startLength + 1, std::vector<int>(forbiddenLength, 0));\n\n    // Preprocess the KMP prefix function for the forbidden substring\n    std::vector<int> longestPrefixSuffix(forbiddenLength);\n    int prefixLength= 0;\n    for(int i= 1; i < forbiddenLength;)\n    {\n        if(forbiddenSubstring[i] == forbiddenSubstring[prefixLength])\n        {\n            longestPrefixSuffix[i++]= ++prefixLength;\n        }\n        else if(prefixLength)\n        {\n            prefixLength= longestPrefixSuffix[prefixLength - 1];\n        }\n        else\n        {\n            ++i;\n        }\n    }\n\n    std::vector<std::vector<int>> count(startString.size() + 1, std::vector<int>(2, 0));\n    dynamicProgramming[0][0]= 1;\n\n    for(int i= 0; i < startLength; ++i)\n    {\n        for(int j= 0; j < forbiddenLength; ++j)\n        {\n            for(int k= 0; k < 2; ++k)\n            {\n                for(char currentChar= 'a'; currentChar <= (k ? endString[i] : 'z'); ++currentChar)\n                {\n                    int e= j;\n                    while(e && (currentChar != forbiddenSubstring[e]))\n                    {\n                        e= longestPrefixSuffix[e - 1];\n                    }\n\n                    if((currentChar != forbiddenSubstring[e]))\n                    {\n                        e++;\n                    }\n\n                    if(e != forbiddenLength)\n                    {\n                        dynamicProgramming[i + 1][k | (currentChar < endString[i])]+= dynamicProgramming[i][k];\n                        dynamicProgramming[i + 1][k | (currentChar < endString[i])]%= modulo;\n                    }\n                }\n            }\n        }\n    }\n\n    return (dynamicProgramming[startLength][1] - dynamicProgramming[startLength][0] + modulo) % modulo;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minStartValue(vector<int> &numbers)\n{\n    int minimumSum = 0, currentSum = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        currentSum += number;\n        minimumSum = min(minimumSum, currentSum);\n    }\n    return 1 - minimumSum;\n}",
    "output": "int minStartValue(std::vector<int> &numbers)\n{\n    int minimumSum= 0, currentSum= 0;\n    for(int number : numbers)\n    {\n        currentSum+= number;\n        minimumSum= std::min(minimumSum, currentSum);\n    }\n    return 1 - minimumSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int findMinFibonacciNumbers(int targetSum)\n{\n    if(targetSum == 0)\n        return 0;\n    int previousFib= 0, currentFib= 1;\n    while(currentFib <= targetSum)\n    {\n        swap(previousFib, currentFib);\n        currentFib+= previousFib;\n    }\n    return 1 + findMinFibonacciNumbers(targetSum - previousFib);\n}",
    "output": "int findMinFibonacciNumbers(int targetSum)\n{\n    if(targetSum == 0)\n        return 0;\n    int previousFib= 0, currentFib= 1;\n    while(currentFib <= targetSum)\n    {\n        swap(previousFib, currentFib);\n        currentFib+= previousFib;\n    }\n    return 1 + findMinFibonacciNumbers(targetSum - previousFib);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring getHappyString(int length, int index)\n{\n    vector<string> happyStrings;\n    function<void(string, char)> generateHappyStrings= [&](string currentString, char previousChar)\n    {\n        if(currentString.length() == length)\n        {\n            happyStrings.push_back(currentString);\n            return;\n        }\n        for(char currentChar= 'a'; currentChar <= 'c'; currentChar++)\n        {\n            if(currentChar != previousChar)\n            {\n                generateHappyStrings(currentString + currentChar, currentChar);\n            }\n        }\n    };\n    generateHappyStrings(\"\", ' ');\n    return index <= happyStrings.size() ? happyStrings[index - 1] : \"\";\n}",
    "output": "#include <bits/stdc++.h>\nstd::string getHappyString(int length, int index)\n{\n    std::vector<std::string> happyStrings;\n    std::function<void(std::string, char)> generateHappyStrings= [&](std::string currentString, char previousChar)\n    {\n        if(currentString.length() == length)\n        {\n            happyStrings.push_back(currentString);\n            return;\n        }\n        for(char currentChar= 'a'; currentChar <= 'c'; currentChar++)\n        {\n            if(currentChar != previousChar)\n            {\n                generateHappyStrings(currentString + currentChar, currentChar);\n            }\n        }\n    };\n    generateHappyStrings(\"\", ' ');\n    return index <= happyStrings.size() ? happyStrings[index - 1] : \"\";\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int numWaterBottles(int initialBottles, int exchangeRate)\n{\n    int totalBottles= initialBottles;\n    while(initialBottles >= exchangeRate)\n    {\n        int newBottles= initialBottles / exchangeRate;\n        totalBottles+= newBottles;\n        initialBottles= newBottles + initialBottles % exchangeRate;\n    }\n    return totalBottles;\n}",
    "output": "int numWaterBottles(int initialBottles, int exchangeRate)\n{\n    int totalBottles= initialBottles;\n    while(initialBottles >= exchangeRate)\n    {\n        int newBottles= initialBottles / exchangeRate;\n        totalBottles+= newBottles;\n        initialBottles= newBottles + initialBottles % exchangeRate;\n    }\n    return totalBottles;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> minSubsequence(vector<int> &inputNumbers)\n{\n    sort(inputNumbers.begin(), inputNumbers.end(), greater<int>());\n    int totalSum = 0, currentSum = 0;\n    for (int number : inputNumbers)\n    {\n        totalSum += number;\n    }\n    vector<int> result;\n\n    for (int i = 0; i < inputNumbers.size(); ++i)\n    {\n        int number = inputNumbers[i];\n        currentSum += number;\n        result.push_back(number);\n        if (currentSum > totalSum - currentSum)\n        {\n            break;\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> minSubsequence(std::vector<int> &inputNumbers)\n{\n    std::sort(inputNumbers.begin(), inputNumbers.end(), std::greater<int>());\n    int totalSum= 0, currentSum= 0;\n    for(int number : inputNumbers)\n    {\n        totalSum+= number;\n    }\n    std::vector<int> result;\n    for(int number : inputNumbers)\n    {\n        currentSum+= number;\n        result.push_back(number);\n        if(currentSum > totalSum - currentSum)\n        {\n            break;\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateNumSteps(const string &inputString)\n{\n    int totalSteps = 0, carryOver = 0;\n    for (int index = inputString.size() - 1; index > 0; --index)\n    {\n        if (inputString[index] - '0' + carryOver == 1)\n        {\n            totalSteps += 2;\n            carryOver = 1;\n        }\n        else\n        {\n            totalSteps += carryOver;\n            carryOver = inputString[index] - '0';\n        }\n    }\n\n    return totalSteps + carryOver;\n}",
    "output": "int calculateNumSteps(const std::string &inputString)\n{\n    int totalSteps= 0, carryOver= 0;\n    for(int index= inputString.size() - 1; index > 0; --index)\n    {\n        if(inputString[index] - '0' + carryOver == 1)\n        {\n            totalSteps+= 2;\n            carryOver= 1;\n        }\n        else\n        {\n            totalSteps+= carryOver;\n            carryOver= inputString[index] - '0';\n        }\n    }\n\n    return totalSteps + carryOver;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint closestToTarget(vector<int> &inputArray, int targetValue)\n{\n    int minimumDifference = INT_MAX;\n    unordered_set<int> prefixSet;\n\n    for (int i = 0; i < inputArray.size(); ++i)\n    {\n        int currentNumber = inputArray[i];\n        unordered_set<int> nextPrefixSet;\n        for (int j = 0; j < prefixSet.size(); ++j)\n        {\n            auto it = prefixSet.begin();\n            advance(it, j);\n            int previousPrefix = *it;\n            nextPrefixSet.insert(previousPrefix & currentNumber);\n        }\n        nextPrefixSet.insert(currentNumber);\n\n        for (int prefix : nextPrefixSet)\n        {\n            minimumDifference = min(minimumDifference, abs(prefix - targetValue));\n        }\n        swap(prefixSet, nextPrefixSet);\n    }\n    return minimumDifference;\n}",
    "output": "#include <bits/stdc++.h>\n// For INT_MAX\n // For min and abs\n // For swap\n\nint closestToTarget(std::vector<int> &inputArray, int targetValue)\n{\n    int minimumDifference= INT_MAX;\n    std::unordered_set<int> prefixSet;\n\n    for(int currentNumber : inputArray)\n    {\n        std::unordered_set<int> nextPrefixSet;\n        for(int previousPrefix : prefixSet)\n        {\n            nextPrefixSet.insert(previousPrefix & currentNumber);\n        }\n        nextPrefixSet.insert(currentNumber);\n\n        for(int prefix : nextPrefixSet)\n        {\n            minimumDifference= std::min(minimumDifference, std::abs(prefix - targetValue));\n        }\n        std::swap(prefixSet, nextPrefixSet);\n    }\n    return minimumDifference;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring stoneGameIII(const vector<int> &stoneValues)\n{\n    int totalStones= stoneValues.size();\n    vector<int> dynamicProgramming(totalStones + 1, 0);\n    dynamicProgramming[totalStones - 1]= stoneValues[totalStones - 1];\n    for(int currentStone= totalStones - 2; currentStone >= 0; --currentStone)\n    {\n        dynamicProgramming[currentStone]= stoneValues[currentStone] - dynamicProgramming[currentStone + 1];\n        for(int stonesTaken= 1; stonesTaken < 3; ++stonesTaken)\n        {\n            if(currentStone + stonesTaken < totalStones)\n                dynamicProgramming[currentStone]= max(dynamicProgramming[currentStone], stoneValues[currentStone + stonesTaken] - dynamicProgramming[currentStone + stonesTaken + 1]);\n        }\n    }\n    if(dynamicProgramming[0] > 0)\n        return \"Alice\";\n    if(dynamicProgramming[0] < 0)\n        return \"Bob\";\n    return \"Tie\";\n}",
    "output": "#include <bits/stdc++.h>\nstd::string stoneGameIII(const std::vector<int> &stoneValues)\n{\n    int totalStones= stoneValues.size();\n    std::vector<int> dynamicProgramming(totalStones + 1, 0);\n    dynamicProgramming[totalStones - 1]= stoneValues[totalStones - 1];\n    for(int currentStone= totalStones - 2; currentStone >= 0; --currentStone)\n    {\n        dynamicProgramming[currentStone]= stoneValues[currentStone] - dynamicProgramming[currentStone + 1];\n        for(int stonesTaken= 1; stonesTaken < 3; ++stonesTaken)\n        {\n            if(currentStone + stonesTaken < totalStones)\n                dynamicProgramming[currentStone]= std::max(dynamicProgramming[currentStone], stoneValues[currentStone + stonesTaken] - dynamicProgramming[currentStone + stonesTaken + 1]);\n        }\n    }\n    if(dynamicProgramming[0] > 0)\n        return \"Alice\";\n    if(dynamicProgramming[0] < 0)\n        return \"Bob\";\n    return \"Tie\";\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int countOdds(int lowerBound, int upperBound)\n{\n    return (upperBound - lowerBound) / 2 + ((lowerBound % 2 == 1 || upperBound % 2 == 1) ? 1 : 0);\n}",
    "output": "int countOdds(int lowerBound, int upperBound)\n{\n    return (upperBound - lowerBound) / 2 + ((lowerBound % 2 == 1 || upperBound % 2 == 1) ? 1 : 0);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> findStringMatches(vector<string> &wordList)\n{\n    vector<string> matchedStrings;\n    for (int i = 0; i < wordList.size(); ++i)\n    {\n        const auto &outerWord = wordList[i];\n        for (int j = 0; j < wordList.size(); ++j)\n        {\n            const auto &innerWord = wordList[j];\n            if (outerWord != innerWord && innerWord.find(outerWord) != string::npos)\n            {\n                matchedStrings.push_back(outerWord);\n                break;\n            }\n        }\n    }\n    return matchedStrings;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> findStringMatches(std::vector<std::string> &wordList)\n{\n    std::vector<std::string> matchedStrings;\n    for(const auto &outerWord : wordList)\n    {\n        for(const auto &innerWord : wordList)\n        {\n            if(outerWord != innerWord && innerWord.find(outerWord) != std::string::npos)\n            {\n                matchedStrings.push_back(outerWord);\n                break;\n            }\n        }\n    }\n    return matchedStrings;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> processQueries(vector<int> &queryList, int size)\n{\n    vector<int> numberList(size), result;\n    for(int index = 0; index < size; ++index)\n    {\n        numberList[index] = index + 1;\n    }\n    for (int i = 0; i < queryList.size(); ++i)\n    {\n        int query = queryList[i];\n        int position = find(numberList.begin(), numberList.end(), query) - numberList.begin();\n        result.push_back(position);\n        numberList.erase(numberList.begin() + position);\n        numberList.insert(numberList.begin(), query);\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> processQueries(std::vector<int> &queryList, int size)\n{\n    std::vector<int> numberList(size), result;\n    for(int index= 0; index < size; ++index)\n    {\n        numberList[index]= index + 1;\n    }\n    for(int query : queryList)\n    {\n        int position= std::find(numberList.begin(), numberList.end(), query) - numberList.begin();\n        result.push_back(position);\n        numberList.erase(numberList.begin() + position);\n        numberList.insert(numberList.begin(), query);\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring entityParser(string inputText)\n{\n    unordered_map<string, char> htmlEntities{\n        {\"&quot;\", '\\\"'},\n        {\"&apos;\", '\\''},\n        {\"&amp;\", '&'},\n        {\"&gt;\", '>'},\n        {\"&lt;\", '<'},\n        {\"&frasl;\", '/'}};\n    string parsedResult;\n    for(int currentIndex= 0; currentIndex < inputText.size(); ++currentIndex)\n    {\n        if(inputText[currentIndex] == '&')\n        {\n            string entityBuffer;\n            for(int j= currentIndex; j < inputText.size() && j < currentIndex + 7; ++j)\n            {\n                entityBuffer.push_back(inputText[j]);\n                if(htmlEntities.find(entityBuffer) != htmlEntities.end())\n                {\n                    parsedResult.push_back(htmlEntities[entityBuffer]);\n                    currentIndex= j;\n                    break;\n                }\n            }\n            if(entityBuffer.back() != ';')\n                parsedResult.push_back(inputText[currentIndex]);\n        }\n        else\n        {\n            parsedResult.push_back(inputText[currentIndex]);\n        }\n    }\n    return parsedResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string entityParser(std::string inputText)\n{\n    std::unordered_map<std::string, char> htmlEntities{\n        {\"&quot;\", '\\\"'},\n        {\"&apos;\", '\\''},\n        {\"&amp;\", '&'},\n        {\"&gt;\", '>'},\n        {\"&lt;\", '<'},\n        {\"&frasl;\", '/'}};\n    std::string parsedResult;\n    for(int currentIndex= 0; currentIndex < inputText.size(); ++currentIndex)\n    {\n        if(inputText[currentIndex] == '&')\n        {\n            std::string entityBuffer;\n            for(int j= currentIndex; j < inputText.size() && j < currentIndex + 7; ++j)\n            {\n                entityBuffer.push_back(inputText[j]);\n                if(htmlEntities.find(entityBuffer) != htmlEntities.end())\n                {\n                    parsedResult.push_back(htmlEntities[entityBuffer]);\n                    currentIndex= j;\n                    break;\n                }\n            }\n            if(entityBuffer.back() != ';')\n                parsedResult.push_back(inputText[currentIndex]);\n        }\n        else\n        {\n            parsedResult.push_back(inputText[currentIndex]);\n        }\n    }\n    return parsedResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<bool> kidsWithCandies(vector<int> &candies, int extraCandies)\n{\n    int maxCandies= *max_element(candies.begin(), candies.end());\n    vector<bool> result(candies.size());\n\n    for(int index= 0; index < candies.size(); index++)\n    {\n        result[index]= (candies[index] + extraCandies >= maxCandies);\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<bool> kidsWithCandies(std::vector<int> &candies, int extraCandies)\n{\n    int maxCandies = *std::max_element(candies.begin(), candies.end());\n    std::vector<bool> result(candies.size());\n\n    for(int index = 0; index < candies.size(); index++)\n    {\n        result[index] = (candies[index] + extraCandies >= maxCandies);\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int maxDifference(int inputNumber)\n{\n    int roundedUpToNextTen= inputNumber + 9 - (inputNumber % 10);\n    int reducedByThousandsDigits= inputNumber - (inputNumber / 1000 % 10) * 111;\n\n    return roundedUpToNextTen - reducedByThousandsDigits;\n}",
    "output": "int maxDifference(int inputNumber)\n{\n    int roundedUpToNextTen= inputNumber + 9 - (inputNumber % 10);\n    int reducedByThousandsDigits= inputNumber - (inputNumber / 1000 % 10) * 111;\n\n    return roundedUpToNextTen - reducedByThousandsDigits;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool checkIfCanBreak(string firstString, string secondString)\n{\n    sort(firstString.begin(), firstString.end());\n    sort(secondString.begin(), secondString.end());\n\n    bool canBreakFirst = true, canBreakSecond = true;\n    for(int index = 0; index < firstString.size(); index++)\n    {\n        if(firstString[index] < secondString[index])\n            canBreakFirst = false;\n        if(secondString[index] < firstString[index])\n            canBreakSecond = false;\n    }\n    return canBreakFirst || canBreakSecond;\n}",
    "output": "#include <bits/stdc++.h>\nbool checkIfCanBreak(std::string firstString, std::string secondString)\n{\n    std::sort(firstString.begin(), firstString.end());\n    std::sort(secondString.begin(), secondString.end());\n\n    bool canBreakFirst= true, canBreakSecond= true;\n    for(int index= 0; index < firstString.size(); index++)\n    {\n        if(firstString[index] < secondString[index])\n            canBreakFirst= false;\n        if(secondString[index] < firstString[index])\n            canBreakSecond= false;\n    }\n    return canBreakFirst || canBreakSecond;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numberOfWays(vector<vector<int>> &hats)\n{\n    const int kModulus = 1000000007;\n    const int kMaxHats = 40;\n\n    int numberOfPeople = hats.size();\n    vector<vector<int>> peopleWithHat(kMaxHats);\n    vector<vector<int>> dynamicProgramming(1 << numberOfPeople, vector<int>(kMaxHats + 1, 0));\n\n    for(int personIndex = 0; personIndex < numberOfPeople; ++personIndex)\n    {\n        for(int j = 0; j < hats[personIndex].size(); ++j)\n        {\n            int hat = hats[personIndex][j];\n            peopleWithHat[hat - 1].push_back(personIndex);\n        }\n    }\n\n    dynamicProgramming[0][0] = 1;\n\n    for(int hatIndex = 0; hatIndex < kMaxHats; ++hatIndex)\n    {\n        for(int mask = (1 << numberOfPeople) - 1; mask >= 0; --mask)\n        {\n            dynamicProgramming[mask][hatIndex + 1] = (dynamicProgramming[mask][hatIndex + 1] + dynamicProgramming[mask][hatIndex]) % kModulus;\n            for(int j = 0; j < peopleWithHat[hatIndex].size(); ++j)\n            {\n                int person = peopleWithHat[hatIndex][j];\n                if((mask & (1 << person)) == 0)\n                {\n                    dynamicProgramming[mask | (1 << person)][hatIndex + 1] = (dynamicProgramming[mask | (1 << person)][hatIndex + 1] + dynamicProgramming[mask][hatIndex]) % kModulus;\n                }\n            }\n        }\n    }\n\n    return dynamicProgramming[(1 << numberOfPeople) - 1][kMaxHats];\n}",
    "output": "#include <bits/stdc++.h>\nint numberOfWays(std::vector<std::vector<int>> &hats)\n{\n    const int kModulus= 1000000007;\n    const int kMaxHats= 40;\n\n    int numberOfPeople= hats.size();\n    std::vector<std::vector<int>> peopleWithHat(kMaxHats);\n    std::vector<std::vector<int>> dynamicProgramming(1 << numberOfPeople, std::vector<int>(kMaxHats + 1, 0));\n\n    for(int personIndex= 0; personIndex < numberOfPeople; ++personIndex)\n    {\n        for(int hat : hats[personIndex])\n        {\n            peopleWithHat[hat - 1].push_back(personIndex);\n        }\n    }\n\n    dynamicProgramming[0][0]= 1;\n\n    for(int hatIndex= 0; hatIndex < kMaxHats; ++hatIndex)\n    {\n        for(int mask= (1 << numberOfPeople) - 1; mask >= 0; --mask)\n        {\n            dynamicProgramming[mask][hatIndex + 1]= (dynamicProgramming[mask][hatIndex + 1] + dynamicProgramming[mask][hatIndex]) % kModulus;\n            for(int person : peopleWithHat[hatIndex])\n            {\n                if((mask & (1 << person)) == 0)\n                {\n                    dynamicProgramming[mask | (1 << person)][hatIndex + 1]= (dynamicProgramming[mask | (1 << person)][hatIndex + 1] + dynamicProgramming[mask][hatIndex]) % kModulus;\n                }\n            }\n        }\n    }\n\n    return dynamicProgramming[(1 << numberOfPeople) - 1][kMaxHats];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<string>> displayTable(vector<vector<string>> &orders)\n{\n    set<string> foodItems;\n    map<int, map<string, int>> tableOrders;\n\n    for (int i = 0; i < orders.size(); ++i)\n    {\n        const auto &order = orders[i];\n        foodItems.insert(order[2]);\n        tableOrders[stoi(order[1])][order[2]]++;\n    }\n\n    vector<vector<string>> result;\n    vector<string> header;\n    header.push_back(\"Table\");\n    header.insert(header.end(), foodItems.begin(), foodItems.end());\n    result.push_back(header);\n\n    for (const auto &entry : tableOrders)\n    {\n        vector<string> row;\n        row.push_back(to_string(entry.first));\n        for (const auto &food : foodItems)\n        {\n            row.push_back(to_string(entry.second[food]));\n        }\n        result.push_back(row);\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<std::string>> displayTable(std::vector<std::vector<std::string>> &orders)\n{\n    std::set<std::string> foodItems;\n    std::map<int, std::map<std::string, int>> tableOrders;\n\n    for(const auto &order : orders)\n    {\n        foodItems.insert(order[2]);\n        tableOrders[std::stoi(order[1])][order[2]]++;\n    }\n\n    std::vector<std::vector<std::string>> result;\n    std::vector<std::string> header;\n    header.push_back(\"Table\");\n    header.insert(header.end(), foodItems.begin(), foodItems.end());\n    result.push_back(header);\n\n    for(const auto &entry : tableOrders)\n    {\n        std::vector<std::string> row;\n        row.push_back(std::to_string(entry.first));\n        for(const auto &food : foodItems)\n        {\n            row.push_back(std::to_string(entry.second[food]));\n        }\n        result.push_back(row);\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfFrogs(string croakSequence)\n{\n    int croakCounts[5] = {0}, maxFrogs = 0;\n\n    for (int i = 0; i < croakSequence.size(); ++i)\n    {\n        char sound = croakSequence[i];\n        int index = string(\"croak\").find(sound);\n        if (index == 0)\n        {\n            croakCounts[0]++;\n            maxFrogs = max(maxFrogs, croakCounts[0]);\n        }\n        else if (croakCounts[index - 1] > 0)\n        {\n            croakCounts[index - 1]--;\n            croakCounts[index]++;\n        }\n        else\n        {\n            return -1;\n        }\n    }\n\n    if (croakCounts[0] == croakCounts[4])\n    {\n        return maxFrogs;\n    }\n    else\n    {\n        return -1;\n    }\n}",
    "output": "#include <bits/stdc++.h>\nint minNumberOfFrogs(std::string croakSequence)\n{\n    int croakCounts[5]= {0}, maxFrogs= 0;\n\n    for(char sound : croakSequence)\n    {\n        int index= std::string(\"croak\").find(sound);\n        if(index == 0)\n        {\n            croakCounts[0]++;\n            maxFrogs= std::max(maxFrogs, croakCounts[0]);\n        }\n        else if(croakCounts[index - 1] > 0)\n        {\n            croakCounts[index - 1]--;\n            croakCounts[index]++;\n        }\n        else\n        {\n            return -1;\n        }\n    }\n\n    if(croakCounts[0] == croakCounts[4])\n    {\n        return maxFrogs;\n    }\n    else\n    {\n        return -1;\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int calculateNumberOfWays(int numberOfItems, int numberOfChoices, int condition, int modulo= 1'000'000'007)\n{\n    if(condition > 1)\n    {\n        long long totalWays= 1;\n        for(int index= 0; index < numberOfItems; ++index)\n        {\n            totalWays= (totalWays * numberOfChoices) % modulo;\n        }\n        return totalWays;\n    }\n    return numberOfItems % 2 == 0 ? 1 : numberOfChoices;\n}",
    "output": "int calculateNumberOfWays(int numberOfItems, int numberOfChoices, int condition, int modulo= 1'000'000'007)\n{\n    if(condition > 1)\n    {\n        long long totalWays= 1;\n        for(int index= 0; index < numberOfItems; ++index)\n        {\n            totalWays= (totalWays * numberOfChoices) % modulo;\n        }\n        return totalWays;\n    }\n    return numberOfItems % 2 == 0 ? 1 : numberOfChoices;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumSwaps(vector<vector<int>> &grid)\n{\n    int gridSize= grid.size();\n    int swapCount= 0;\n\n    for(int currentRow= 0; currentRow < gridSize; ++currentRow)\n    {\n        int zeroRow= -1;\n        for(int searchRow= currentRow; searchRow < gridSize; ++searchRow)\n        {\n            if(grid[searchRow][currentRow] == 0)\n            {\n                zeroRow= searchRow;\n                break;\n            }\n        }\n        if(zeroRow == -1)\n        {\n            return -1;\n        }\n\n        while(zeroRow > currentRow)\n        {\n            swap(grid[zeroRow], grid[zeroRow - 1]);\n            swapCount++;\n            zeroRow--;\n        }\n    }\n    return swapCount;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMinimumSwaps(std::vector<std::vector<int>> &grid)\n{\n    int gridSize= grid.size();\n    int swapCount= 0;\n\n    for(int currentRow= 0; currentRow < gridSize; ++currentRow)\n    {\n        int zeroRow= -1;\n        for(int searchRow= currentRow; searchRow < gridSize; ++searchRow)\n        {\n            if(grid[searchRow][currentRow] == 0)\n            {\n                zeroRow= searchRow;\n                break;\n            }\n        }\n        if(zeroRow == -1)\n        {\n            return -1;\n        }\n\n        while(zeroRow > currentRow)\n        {\n            std::swap(grid[zeroRow], grid[zeroRow - 1]);\n            swapCount++;\n            zeroRow--;\n        }\n    }\n    return swapCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxScore(string inputString)\n{\n    int countLeftZeros = 0, countRightOnes = 0, maximumScore = 0;\n    for (char character : inputString)\n        if (character == '1')\n            countRightOnes++;\n\n    for (int index = 0; index < inputString.size() - 1; index++)\n    {\n        if (inputString[index] == '0')\n            countLeftZeros++;\n        else\n            countRightOnes--;\n        maximumScore = max(maximumScore, countLeftZeros + countRightOnes);\n    }\n    return maximumScore;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMaxScore(std::string inputString)\n{\n    int countLeftZeros= 0, countRightOnes= 0, maximumScore= 0;\n    for(char character : inputString)\n        if(character == '1')\n            countRightOnes++;\n\n    for(int index= 0; index < inputString.size() - 1; index++)\n    {\n        if(inputString[index] == '0')\n            countLeftZeros++;\n        else\n            countRightOnes--;\n        maximumScore= std::max(maximumScore, countLeftZeros + countRightOnes);\n    }\n    return maximumScore;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(vector<int> &cardPoints, int numberOfCards)\n{\n    int totalCards= cardPoints.size();\n    int initialTotal= 0;\n    for(int index= 0; index < numberOfCards; ++index)\n    {\n        initialTotal+= cardPoints[index];\n    }\n\n    int maximumScore= initialTotal;\n    for(int index= numberOfCards - 1, j= totalCards - 1; index >= 0; --index, --j)\n    {\n        initialTotal+= cardPoints[j] - cardPoints[index];\n        maximumScore= max(maximumScore, initialTotal);\n    }\n\n    return maximumScore;\n}",
    "output": "#include <bits/stdc++.h>\nint maxScore(std::vector<int> &cardPoints, int numberOfCards)\n{\n    int totalCards = cardPoints.size();\n    int initialTotal = 0;\n    for(int index = 0; index < numberOfCards; ++index)\n    {\n        initialTotal += cardPoints[index];\n    }\n\n    int maximumScore = initialTotal;\n    for(int index = numberOfCards - 1, j = totalCards - 1; index >= 0; --index, --j)\n    {\n        initialTotal += cardPoints[j] - cardPoints[index];\n        maximumScore = std::max(maximumScore, initialTotal);\n    }\n\n    return maximumScore;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For std::reverse\nusing namespace std;\n\nvector<int> findDiagonalOrder(vector<vector<int>> &numberGrid)\n{\n    vector<int> diagonalOrder;\n    int rowCount = numberGrid.size();\n    map<int, vector<int>> diagonalMap;\n\n    for(int rowIndex = 0; rowIndex < rowCount; rowIndex++)\n    {\n        for(int colIndex = 0; colIndex < numberGrid[rowIndex].size(); colIndex++)\n        {\n            diagonalMap[rowIndex + colIndex].push_back(numberGrid[rowIndex][colIndex]);\n        }\n    }\n\n    for(auto it = diagonalMap.begin(); it != diagonalMap.end(); ++it)\n    {\n        reverse(it->second.begin(), it->second.end());\n        diagonalOrder.insert(diagonalOrder.end(), it->second.begin(), it->second.end());\n    }\n\n    return diagonalOrder;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findDiagonalOrder(std::vector<std::vector<int>> &numberGrid)\n{\n    std::vector<int> diagonalOrder;\n    int rowCount= numberGrid.size();\n    std::map<int, std::vector<int>> diagonalMap;\n\n    for(int rowIndex= 0; rowIndex < rowCount; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < numberGrid[rowIndex].size(); colIndex++)\n        {\n            diagonalMap[rowIndex + colIndex].push_back(numberGrid[rowIndex][colIndex]);\n        }\n    }\n\n    for(auto &diagonal : diagonalMap)\n    {\n        std::reverse(diagonal.second.begin(), diagonal.second.end());\n        diagonalOrder.insert(diagonalOrder.end(), diagonal.second.begin(), diagonal.second.end());\n    }\n\n    return diagonalOrder;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canConvertString(string sourceString, string targetString, int maxSteps)\n{\n    if(sourceString.length() != targetString.length())\n        return false;\n    vector<int> shiftCount(26, 0);\n    for(int index= 0; index < sourceString.length(); index++)\n    {\n        int shiftDifference= (targetString[index] - sourceString[index] + 26) % 26;\n        if(shiftDifference > 0)\n        {\n            shiftCount[shiftDifference]++;\n        }\n    }\n    for(int shift= 1; shift < 26; shift++)\n    {\n        if(shiftCount[shift] > 0)\n        {\n            if(shiftCount[shift] * 26 - 26 + shift > maxSteps)\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool canConvertString(std::string sourceString, std::string targetString, int maxSteps)\n{\n    if(sourceString.length() != targetString.length())\n        return false;\n    std::vector<int> shiftCount(26, 0);\n    for(int index= 0; index < sourceString.length(); index++)\n    {\n        int shiftDifference= (targetString[index] - sourceString[index] + 26) % 26;\n        if(shiftDifference > 0)\n        {\n            shiftCount[shiftDifference]++;\n        }\n    }\n    for(int shift= 1; shift < 26; shift++)\n    {\n        if(shiftCount[shift] > 0)\n        {\n            if(shiftCount[shift] * 26 - 26 + shift > maxSteps)\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minInsertions(string inputString)\n{\n    int openParenthesesCount= 0, insertionCount= 0;\n    int length= inputString.length();\n    for(int index= 0; index < length; index++)\n    {\n        if(inputString[index] == '(')\n        {\n            openParenthesesCount++;\n        }\n        else\n        {\n            if(openParenthesesCount == 0)\n                insertionCount++;\n            else\n                openParenthesesCount--;\n            if(index == length - 1 || inputString[index + 1] != ')')\n            {\n                insertionCount++;\n                index++;\n            }\n        }\n    }\n    return insertionCount + openParenthesesCount * 2;\n}",
    "output": "#include <bits/stdc++.h>\nint minInsertions(std::string inputString)\n{\n    int openParenthesesCount= 0, insertionCount= 0;\n    int length= inputString.length();\n    for(int index= 0; index < length; index++)\n    {\n        if(inputString[index] == '(')\n        {\n            openParenthesesCount++;\n        }\n        else\n        {\n            if(openParenthesesCount == 0)\n                insertionCount++;\n            else\n                openParenthesesCount--;\n            if(index == length - 1 || inputString[index + 1] != ')')\n            {\n                insertionCount++;\n                index++;\n            }\n        }\n    }\n    return insertionCount + openParenthesesCount * 2;\n}\n"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPower(const string &inputString)\n{\n    int maxPower= 0, currentPower= 1;\n\n    for(int index= 1; index < inputString.length(); ++index)\n    {\n        if(inputString[index] == inputString[index - 1])\n        {\n            currentPower++;\n        }\n        else\n        {\n            maxPower= max(maxPower, currentPower);\n            currentPower= 1;\n        }\n    }\n\n    return max(maxPower, currentPower);\n}",
    "output": "int maxPower(const std::string &inputString)\n{\n    int maxPower= 0, currentPower= 1;\n\n    for(int index= 1; index < inputString.length(); ++index)\n    {\n        if(inputString[index] == inputString[index - 1])\n        {\n            currentPower++;\n        }\n        else\n        {\n            maxPower= std::max(maxPower, currentPower);\n            currentPower= 1;\n        }\n    }\n\n    return std::max(maxPower, currentPower);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int countGoodNodes(TreeNode *currentNode, int maxValue= INT_MIN)\n{\n    if(!currentNode)\n        return 0;\n    int goodNodeCount= 0;\n    if(currentNode->val >= maxValue)\n    {\n        goodNodeCount= 1;\n        maxValue= currentNode->val;\n    }\n    return goodNodeCount + countGoodNodes(currentNode->left, maxValue) + countGoodNodes(currentNode->right, maxValue);\n}",
    "output": "int countGoodNodes(TreeNode *currentNode, int maxValue= INT_MIN)\n{\n    if(!currentNode)\n        return 0;\n    int goodNodeCount= 0;\n    if(currentNode->val >= maxValue)\n    {\n        goodNodeCount= 1;\n        maxValue= currentNode->val;\n    }\n    return goodNodeCount + countGoodNodes(currentNode->left, maxValue) + countGoodNodes(currentNode->right, maxValue);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestNumber(vector<int> &cost, int target)\n{\n    vector<string> dynamicProgramming(target + 1, \"\");\n    dynamicProgramming[0]= \"\";\n\n    for(int currentTarget= 1; currentTarget <= target; ++currentTarget)\n    {\n        for(int digit= 1; digit <= 9; ++digit)\n        {\n            if(currentTarget >= cost[digit - 1])\n            {\n                string tempString= dynamicProgramming[currentTarget - cost[digit - 1]] + char('0' + digit);\n                if(dynamicProgramming[currentTarget].length() <= tempString.length())\n                {\n                    dynamicProgramming[currentTarget]= tempString;\n                }\n            }\n        }\n    }\n\n    return dynamicProgramming[target].empty() ? \"0\" : dynamicProgramming[target];\n}",
    "output": "#include <bits/stdc++.h>\nstd::string largestNumber(std::vector<int> &cost, int target)\n{\n    std::vector<std::string> dynamicProgramming(target + 1, \"\");\n    dynamicProgramming[0]= \"\";\n\n    for(int currentTarget= 1; currentTarget <= target; ++currentTarget)\n    {\n        for(int digit= 1; digit <= 9; ++digit)\n        {\n            if(currentTarget >= cost[digit - 1])\n            {\n                std::string tempString= dynamicProgramming[currentTarget - cost[digit - 1]] + char('0' + digit);\n                if(dynamicProgramming[currentTarget].length() <= tempString.length())\n                {\n                    dynamicProgramming[currentTarget]= tempString;\n                }\n            }\n        }\n    }\n\n    return dynamicProgramming[target].empty() ? \"0\" : dynamicProgramming[target];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNonOverlapping(vector<int> &numbers, int target)\n{\n    unordered_map<int, int> prefixSum;\n    int currentSum = 0, nonOverlappingCount = 0;\n    prefixSum[0] = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        const int &number = numbers[i];\n        currentSum += number;\n        if (prefixSum.find(currentSum - target) != prefixSum.end())\n        {\n            nonOverlappingCount = max(nonOverlappingCount, 1 + prefixSum[currentSum - target]);\n        }\n        prefixSum[currentSum] = nonOverlappingCount;\n    }\n    return nonOverlappingCount;\n}",
    "output": "#include <bits/stdc++.h>\nint maxNonOverlapping(std::vector<int> &numbers, int target)\n{\n    std::unordered_map<int, int> prefixSum;\n    int currentSum= 0, nonOverlappingCount= 0;\n    prefixSum[0]= 0;\n    for(const int &number : numbers)\n    {\n        currentSum+= number;\n        if(prefixSum.find(currentSum - target) != prefixSum.end())\n        {\n            nonOverlappingCount= std::max(nonOverlappingCount, 1 + prefixSum[currentSum - target]);\n        }\n        prefixSum[currentSum]= nonOverlappingCount;\n    }\n    return nonOverlappingCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring destCity(vector<vector<string>> &paths)\n{\n    unordered_set<string> startingCities;\n    for (int i = 0; i < paths.size(); ++i)\n        startingCities.insert(paths[i][0]);\n\n    for (int i = 0; i < paths.size(); ++i)\n    {\n        if (startingCities.find(paths[i][1]) == startingCities.end())\n            return paths[i][1];\n    }\n\n    return \"\";\n}",
    "output": "#include <bits/stdc++.h>\nstd::string destCity(std::vector<std::vector<std::string>> &paths)\n{\n    std::unordered_set<std::string> startingCities;\n    for(const auto &path : paths)\n        startingCities.insert(path[0]);\n\n    for(const auto &path : paths)\n    {\n        if(startingCities.find(path[1]) == startingCities.end())\n            return path[1];\n    }\n\n    return \"\";\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool areElementsKLengthApart(vector<int> &numbers, int k)\n{\n    int lastOneIndex= -1;\n    for(int currentIndex= 0; currentIndex < numbers.size(); currentIndex++)\n    {\n        if(numbers[currentIndex] == 1)\n        {\n            if(lastOneIndex != -1 && currentIndex - lastOneIndex <= k)\n            {\n                return false;\n            }\n            lastOneIndex= currentIndex;\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool areElementsKLengthApart(std::vector<int> &numbers, int k)\n{\n    int lastOneIndex= -1;\n    for(int currentIndex= 0; currentIndex < numbers.size(); currentIndex++)\n    {\n        if(numbers[currentIndex] == 1)\n        {\n            if(lastOneIndex != -1 && currentIndex - lastOneIndex <= k)\n            {\n                return false;\n            }\n            lastOneIndex= currentIndex;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint kthSmallest(const vector<vector<int>> &matrix, int k)\n{\n    int rowCount= matrix.size(), colCount= matrix[0].size();\n\n    auto comparator= [&](const vector<int> &a, const vector<int> &b)\n    {\n        return a[0] > b[0];\n    };\n\n    priority_queue<vector<int>, vector<vector<int>>, decltype(comparator)> minHeap(comparator);\n    minHeap.push({matrix[0][0], 0, 0});\n\n    vector<vector<bool>> visited(rowCount, vector<bool>(colCount, false));\n    visited[0][0]= true;\n\n    int result;\n    while(k--)\n    {\n        auto current= minHeap.top();\n        minHeap.pop();\n        result= current[0];\n        int currentRow= current[1], currentCol= current[2];\n\n        if(currentRow < rowCount - 1 && !visited[currentRow + 1][currentCol])\n        {\n            minHeap.push({result - matrix[currentRow][currentCol] + matrix[currentRow + 1][currentCol], currentRow + 1, currentCol});\n            visited[currentRow + 1][currentCol]= true;\n        }\n        if(currentCol < colCount - 1 && !visited[currentRow][currentCol + 1])\n        {\n            minHeap.push({result - matrix[currentRow][currentCol] + matrix[currentRow][currentCol + 1], currentRow, currentCol + 1});\n            visited[currentRow][currentCol + 1]= true;\n        }\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nint kthSmallest(const std::vector<std::vector<int>> &matrix, int k)\n{\n    int rowCount= matrix.size(), colCount= matrix[0].size();\n\n    auto comparator= [&](const std::vector<int> &a, const std::vector<int> &b)\n    {\n        return a[0] > b[0];\n    };\n\n    std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, decltype(comparator)> minHeap(comparator);\n    minHeap.push({matrix[0][0], 0, 0});\n\n    std::vector<std::vector<bool>> visited(rowCount, std::vector<bool>(colCount, false));\n    visited[0][0]= true;\n\n    int result;\n    while(k--)\n    {\n        auto current= minHeap.top();\n        minHeap.pop();\n        result= current[0];\n        int currentRow= current[1], currentCol= current[2];\n\n        if(currentRow < rowCount - 1 && !visited[currentRow + 1][currentCol])\n        {\n            minHeap.push({result - matrix[currentRow][currentCol] + matrix[currentRow + 1][currentCol], currentRow + 1, currentCol});\n            visited[currentRow + 1][currentCol]= true;\n        }\n        if(currentCol < colCount - 1 && !visited[currentRow][currentCol + 1])\n        {\n            minHeap.push({result - matrix[currentRow][currentCol] + matrix[currentRow][currentCol + 1], currentRow, currentCol + 1});\n            visited[currentRow][currentCol + 1]= true;\n        }\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int minOperations(int numberOfItems)\n{\n    return numberOfItems * numberOfItems / 4;\n}",
    "output": "int minOperations(int numberOfItems)\n{\n    return numberOfItems * numberOfItems / 4;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> buildArray(vector<int> &target, int maxValue)\n{\n    vector<string> result;\n    int currentValue = 1;\n    for (int i = 0; i < target.size(); ++i)\n    {\n        int number = target[i];\n        while (currentValue < number)\n        {\n            result.push_back(\"Push\");\n            result.push_back(\"Pop\");\n            currentValue++;\n        }\n        result.push_back(\"Push\");\n        currentValue++;\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> buildArray(std::vector<int> &target, int maxValue)\n{\n    std::vector<std::string> result;\n    int currentValue= 1;\n    for(int number : target)\n    {\n        while(currentValue < number)\n        {\n            result.push_back(\"Push\");\n            result.push_back(\"Pop\");\n            currentValue++;\n        }\n        result.push_back(\"Push\");\n        currentValue++;\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countTriplets(vector<int> &array)\n{\n    int arraySize= array.size();\n    vector<int> cumulativeXOR(arraySize + 1, 0);\n\n    for(int index= 0; index < arraySize; index++)\n    {\n        cumulativeXOR[index + 1]= cumulativeXOR[index] ^ array[index];\n    }\n\n    int tripletCount= 0;\n    for(int startIndex= 0; startIndex < arraySize; startIndex++)\n    {\n        for(int endIndex= startIndex + 1; endIndex < arraySize; endIndex++)\n        {\n            if(cumulativeXOR[startIndex] == cumulativeXOR[endIndex + 1])\n                tripletCount+= endIndex - startIndex;\n        }\n    }\n    return tripletCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countTriplets(std::vector<int> &array)\n{\n    int arraySize = array.size();\n    std::vector<int> cumulativeXOR(arraySize + 1, 0);\n\n    for(int index = 0; index < arraySize; index++)\n    {\n        cumulativeXOR[index + 1] = cumulativeXOR[index] ^ array[index];\n    }\n\n    int tripletCount = 0;\n    for(int startIndex = 0; startIndex < arraySize; startIndex++)\n    {\n        for(int endIndex = startIndex + 1; endIndex < arraySize; endIndex++)\n        {\n            if(cumulativeXOR[startIndex] == cumulativeXOR[endIndex + 1])\n                tripletCount += endIndex - startIndex;\n        }\n    }\n    return tripletCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minTime(int nodeCount, vector<vector<int>> &edges, vector<bool> &hasApple)\n{\n    unordered_map<int, unordered_map<int, int>> adjacencyList;\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]][edge[1]] = 0;\n        adjacencyList[edge[1]][edge[0]] = 0;\n    }\n\n    function<int(int, int)> depthFirstSearch = [&](int currentNode, int parentNode)\n    {\n        int totalTime = 0;\n        for(auto it = adjacencyList[currentNode].begin(); it != adjacencyList[currentNode].end(); ++it)\n        {\n            int neighborNode = it->first;\n            if(neighborNode == parentNode)\n                continue;\n            totalTime += depthFirstSearch(neighborNode, currentNode) * 2;\n        }\n        return totalTime + (hasApple[currentNode] || totalTime);\n    };\n\n    return depthFirstSearch(0, -1);\n}",
    "output": "#include <bits/stdc++.h>\nint minTime(int nodeCount, std::vector<std::vector<int>> &edges, std::vector<bool> &hasApple)\n{\n    std::unordered_map<int, std::unordered_map<int, int>> adjacencyList;\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]][edge[1]]= 0;\n        adjacencyList[edge[1]][edge[0]]= 0;\n    }\n\n    std::function<int(int, int)> depthFirstSearch= [&](int currentNode, int parentNode)\n    {\n        int totalTime= 0;\n        for(auto &[neighborNode, _] : adjacencyList[currentNode])\n        {\n            if(neighborNode == parentNode)\n                continue;\n            totalTime+= depthFirstSearch(neighborNode, currentNode) * 2;\n        }\n        return totalTime + (hasApple[currentNode] || totalTime);\n    };\n\n    return depthFirstSearch(0, -1);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canBeEqual(vector<int> &targetArray, vector<int> &sourceArray)\n{\n    sort(targetArray.begin(), targetArray.end());\n    sort(sourceArray.begin(), sourceArray.end());\n    return targetArray == sourceArray;\n}",
    "output": "#include <bits/stdc++.h>\nbool canBeEqual(std::vector<int> &targetArray, std::vector<int> &sourceArray)\n{\n    std::sort(targetArray.begin(), targetArray.end());\n    std::sort(sourceArray.begin(), sourceArray.end());\n    return targetArray == sourceArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool hasAllCodes(string binaryString, int codeLength)\n{\n    int requiredCodes= 1 << codeLength;\n    unordered_set<string> foundCodes;\n\n    for(int i= 0; i <= binaryString.size() - codeLength; i++)\n    {\n        foundCodes.insert(binaryString.substr(i, codeLength));\n    }\n\n    return foundCodes.size() == requiredCodes;\n}",
    "output": "bool hasAllCodes(std::string binaryString, int codeLength)\n{\n    int requiredCodes= 1 << codeLength;\n    std::unordered_set<std::string> foundCodes;\n\n    for(int i= 0; i <= binaryString.size() - codeLength; i++)\n    {\n        foundCodes.insert(binaryString.substr(i, codeLength));\n    }\n\n    return foundCodes.size() == requiredCodes;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(int source, unordered_map<int, vector<int>> &courseGraph, vector<bool> &visitedCourses, vector<bool> &prerequisiteClosure, int destination)\n{\n    if(source == destination)\n    {\n        prerequisiteClosure[destination]= true;\n        return;\n    }\n    if(visitedCourses[source])\n        return;\n    visitedCourses[source]= true;\n    for(int i = 0; i < courseGraph[source].size(); ++i)\n    {\n        int neighbor = courseGraph[source][i];\n        depthFirstSearch(neighbor, courseGraph, visitedCourses, prerequisiteClosure, destination);\n        if(prerequisiteClosure[destination])\n            return;\n    }\n}\n\nvector<bool> checkIfPrerequisite(int totalCourses, vector<vector<int>> &prerequisites, vector<vector<int>> &queries)\n{\n    unordered_map<int, vector<int>> courseGraph;\n\n    for(auto &pre : prerequisites)\n    {\n        courseGraph[pre[0]].push_back(pre[1]);\n    }\n\n    vector<bool> result(queries.size());\n\n    for(int queryIndex= 0; queryIndex < queries.size(); ++queryIndex)\n    {\n        vector<bool> visitedCourses(totalCourses, false);\n        vector<bool> prerequisiteClosure(totalCourses, false);\n        depthFirstSearch(queries[queryIndex][0], courseGraph, visitedCourses, prerequisiteClosure, queries[queryIndex][1]);\n        result[queryIndex]= prerequisiteClosure[queries[queryIndex][1]];\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nvoid depthFirstSearch(int source, std::unordered_map<int, std::vector<int>> &courseGraph, std::vector<bool> &visitedCourses, std::vector<bool> &prerequisiteClosure, int destination)\n{\n    if(source == destination)\n    {\n        prerequisiteClosure[destination]= true;\n        return;\n    }\n    if(visitedCourses[source])\n        return;\n    visitedCourses[source]= true;\n    for(int neighbor : courseGraph[source])\n    {\n        depthFirstSearch(neighbor, courseGraph, visitedCourses, prerequisiteClosure, destination);\n        if(prerequisiteClosure[destination])\n            return;\n    }\n}\n\nstd::vector<bool> checkIfPrerequisite(int totalCourses, std::vector<std::vector<int>> &prerequisites, std::vector<std::vector<int>> &queries)\n{\n    std::unordered_map<int, std::vector<int>> courseGraph;\n\n    for(auto &pre : prerequisites)\n    {\n        courseGraph[pre[0]].push_back(pre[1]);\n    }\n\n    std::vector<bool> result(queries.size());\n\n    for(int queryIndex= 0; queryIndex < queries.size(); ++queryIndex)\n    {\n        std::vector<bool> visitedCourses(totalCourses, false);\n        std::vector<bool> prerequisiteClosure(totalCourses, false);\n        depthFirstSearch(queries[queryIndex][0], courseGraph, visitedCourses, prerequisiteClosure, queries[queryIndex][1]);\n        result[queryIndex]= prerequisiteClosure[queries[queryIndex][1]];\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint cherryPickup(vector<vector<int>> &grid)\n{\n    int totalRows = grid.size();\n    int totalCols = grid[0].size();\n    vector<vector<vector<int>>> dynamicProgramming(totalRows, vector<vector<int>>(totalCols, vector<int>(totalCols, 0)));\n\n    for (int currentRow = totalRows - 1; currentRow >= 0; --currentRow)\n    {\n        for (int firstColumn = 0; firstColumn < totalCols; ++firstColumn)\n        {\n            for (int secondColumn = 0; secondColumn < totalCols; ++secondColumn)\n            {\n                int currentCell = currentRow < totalRows - 1 ? dynamicProgramming[currentRow + 1][firstColumn][secondColumn] : 0;\n                currentCell += grid[currentRow][firstColumn] + (firstColumn != secondColumn ? grid[currentRow][secondColumn] : 0);\n\n                int maxValue = 0;\n                for (int moveFirst = -1; moveFirst <= 1; ++moveFirst)\n                {\n                    for (int moveSecond = -1; moveSecond <= 1; ++moveSecond)\n                    {\n                        int newFirstColumn = firstColumn + moveFirst;\n                        int newSecondColumn = secondColumn + moveSecond;\n                        if (newFirstColumn >= 0 && newFirstColumn < totalCols && newSecondColumn >= 0 && newSecondColumn < totalCols)\n                        {\n                            maxValue = max(maxValue, dynamicProgramming[currentRow][newFirstColumn][newSecondColumn]);\n                        }\n                    }\n                }\n\n                dynamicProgramming[currentRow][firstColumn][secondColumn] = currentCell + maxValue;\n            }\n        }\n    }\n\n    return dynamicProgramming[0][0][totalCols - 1];\n}",
    "output": "#include <bits/stdc++.h>\nint cherryPickup(std::vector<std::vector<int>> &grid)\n{\n    int totalRows= grid.size();\n    int totalCols= grid[0].size();\n    std::vector<std::vector<std::vector<int>>> dynamicProgramming(totalRows, std::vector<std::vector<int>>(totalCols, std::vector<int>(totalCols, 0)));\n\n    for(int currentRow= totalRows - 1; currentRow >= 0; --currentRow)\n    {\n        for(int firstColumn= 0; firstColumn < totalCols; ++firstColumn)\n        {\n            for(int secondColumn= 0; secondColumn < totalCols; ++secondColumn)\n            {\n                int currentCell= currentRow < totalRows - 1 ? dynamicProgramming[currentRow + 1][firstColumn][secondColumn] : 0;\n                currentCell+= grid[currentRow][firstColumn] + (firstColumn != secondColumn ? grid[currentRow][secondColumn] : 0);\n\n                int maxValue= 0;\n                for(int moveFirst= -1; moveFirst <= 1; ++moveFirst)\n                {\n                    for(int moveSecond= -1; moveSecond <= 1; ++moveSecond)\n                    {\n                        int newFirstColumn= firstColumn + moveFirst;\n                        int newSecondColumn= secondColumn + moveSecond;\n                        if(newFirstColumn >= 0 && newFirstColumn < totalCols && newSecondColumn >= 0 && newSecondColumn < totalCols)\n                        {\n                            maxValue= std::max(maxValue, dynamicProgramming[currentRow][newFirstColumn][newSecondColumn]);\n                        }\n                    }\n                }\n\n                dynamicProgramming[currentRow][firstColumn][secondColumn]= currentCell + maxValue;\n            }\n        }\n    }\n\n    return dynamicProgramming[0][0][totalCols - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countBusyStudents(vector<int> &startTime, vector<int> &endTime, int queryTime)\n{\n    int studentCount= 0;\n    for(int index= 0; index < startTime.size(); index++)\n    {\n        if(startTime[index] <= queryTime && endTime[index] >= queryTime)\n        {\n            studentCount++;\n        }\n    }\n    return studentCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countBusyStudents(std::vector<int> &startTime, std::vector<int> &endTime, int queryTime)\n{\n    int studentCount= 0;\n    for(int index= 0; index < startTime.size(); index++)\n    {\n        if(startTime[index] <= queryTime && endTime[index] >= queryTime)\n        {\n            studentCount++;\n        }\n    }\n    return studentCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring arrangeWords(string text)\n{\n    text[0] = tolower(text[0]);\n    istringstream inputStream(text);\n    vector<pair<string, int>> wordPairs;\n    string currentWord;\n    int wordIndex = 0;\n    while (inputStream >> currentWord)\n    {\n        wordPairs.emplace_back(currentWord, wordIndex++);\n    }\n    stable_sort(wordPairs.begin(), wordPairs.end(), [](const auto &a, const auto &b)\n                 { return a.first.length() < b.first.length(); });\n    ostringstream outputStream;\n    for (int i = 0; i < wordPairs.size(); ++i)\n    {\n        const auto &wordPair = wordPairs[i];\n        if (i != 0)\n            outputStream << ' ';\n        outputStream << wordPair.first;\n    }\n    auto resultString = outputStream.str();\n    resultString[0] = toupper(resultString[0]);\n    return resultString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string arrangeWords(std::string text)\n{\n    text[0]= tolower(text[0]);\n    std::istringstream inputStream(text);\n    std::vector<std::pair<std::string, int>> wordPairs;\n    std::string currentWord;\n    int wordIndex= 0;\n    while(inputStream >> currentWord)\n    {\n        wordPairs.emplace_back(currentWord, wordIndex++);\n    }\n    std::stable_sort(wordPairs.begin(), wordPairs.end(), [](const auto &a, const auto &b)\n                     { return a.first.length() < b.first.length(); });\n    std::ostringstream outputStream;\n    for(const auto &wordPair : wordPairs)\n    {\n        if(&wordPair != &wordPairs[0])\n            outputStream << ' ';\n        outputStream << wordPair.first;\n    }\n    auto resultString= outputStream.str();\n    resultString[0]= toupper(resultString[0]);\n    return resultString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findPeopleIndexes(vector<vector<string>> &favoriteCompanies)\n{\n    vector<int> uniquePeopleIndexes;\n    for(int personIndex= 0; personIndex < favoriteCompanies.size(); personIndex++)\n    {\n        bool isSubset= false;\n        for(int compareIndex= 0; compareIndex < favoriteCompanies.size() && !isSubset; compareIndex++)\n        {\n            if(personIndex != compareIndex && includes(favoriteCompanies[compareIndex].begin(), favoriteCompanies[compareIndex].end(),\n                                                       favoriteCompanies[personIndex].begin(), favoriteCompanies[personIndex].end()))\n            {\n                isSubset= true;\n            }\n        }\n        if(!isSubset)\n            uniquePeopleIndexes.push_back(personIndex);\n    }\n    return uniquePeopleIndexes;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findPeopleIndexes(std::vector<std::vector<std::string>> &favoriteCompanies)\n{\n    std::vector<int> uniquePeopleIndexes;\n    for(int personIndex= 0; personIndex < favoriteCompanies.size(); personIndex++)\n    {\n        bool isSubset= false;\n        for(int compareIndex= 0; compareIndex < favoriteCompanies.size() && !isSubset; compareIndex++)\n        {\n            if(personIndex != compareIndex && std::includes(favoriteCompanies[compareIndex].begin(), favoriteCompanies[compareIndex].end(),\n                                                           favoriteCompanies[personIndex].begin(), favoriteCompanies[personIndex].end()))\n            {\n                isSubset= true;\n            }\n        }\n        if(!isSubset)\n            uniquePeopleIndexes.push_back(personIndex);\n    }\n    return uniquePeopleIndexes;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For std::max\nusing namespace std;\n\nint maxNumberOfDarts(vector<vector<int>> &dartPositions, int radius)\n{\n    int numberOfDarts= dartPositions.size();\n    int maxDartsCount= 1;\n\n    for(int firstDartIndex= 0; firstDartIndex < numberOfDarts; firstDartIndex++)\n    {\n        for(int secondDartIndex= firstDartIndex + 1; secondDartIndex < numberOfDarts; secondDartIndex++)\n        {\n            double distanceBetweenDarts= hypot(dartPositions[secondDartIndex][0] - dartPositions[firstDartIndex][0],\n                                               dartPositions[secondDartIndex][1] - dartPositions[firstDartIndex][1]);\n            if(distanceBetweenDarts > 2.0 * radius)\n                continue;\n\n            double angle= acos(distanceBetweenDarts / (2.0 * radius));\n            for(int direction= 0; direction < 2; direction++)\n            {\n                double locationAngle= angle * (direction == 0 ? 1 : -1);\n                double circleCenterX= dartPositions[firstDartIndex][0] + radius * (dartPositions[secondDartIndex][0] - dartPositions[firstDartIndex][0]) / distanceBetweenDarts * cos(locationAngle) - radius * (dartPositions[secondDartIndex][1] - dartPositions[firstDartIndex][1]) / distanceBetweenDarts * sin(locationAngle);\n                double circleCenterY= dartPositions[firstDartIndex][1] + radius * (dartPositions[secondDartIndex][0] - dartPositions[firstDartIndex][0]) / distanceBetweenDarts * sin(locationAngle) + radius * (dartPositions[secondDartIndex][1] - dartPositions[firstDartIndex][1]) / distanceBetweenDarts * cos(locationAngle);\n\n                int countDartsInsideCircle= 0;\n                for(int dartIndex= 0; dartIndex < numberOfDarts; dartIndex++)\n                {\n                    double newDistance= hypot(dartPositions[dartIndex][0] - circleCenterX, dartPositions[dartIndex][1] - circleCenterY);\n                    if(newDistance <= radius + 1e-5)\n                        countDartsInsideCircle++;\n                }\n\n                maxDartsCount= max(maxDartsCount, countDartsInsideCircle);\n            }\n        }\n    }\n\n    return maxDartsCount;\n}",
    "output": "#include <bits/stdc++.h>\n// Necessary for std::max\n\nint maxNumberOfDarts(std::vector<std::vector<int>> &dartPositions, int radius)\n{\n    int numberOfDarts= dartPositions.size();\n    int maxDartsCount= 1;\n\n    for(int firstDartIndex= 0; firstDartIndex < numberOfDarts; firstDartIndex++)\n    {\n        for(int secondDartIndex= firstDartIndex + 1; secondDartIndex < numberOfDarts; secondDartIndex++)\n        {\n            double distanceBetweenDarts= std::hypot(dartPositions[secondDartIndex][0] - dartPositions[firstDartIndex][0],\n                                                     dartPositions[secondDartIndex][1] - dartPositions[firstDartIndex][1]);\n            if(distanceBetweenDarts > 2.0 * radius)\n                continue;\n\n            double angle= std::acos(distanceBetweenDarts / (2.0 * radius));\n            for(int direction= 0; direction < 2; direction++)\n            {\n                double locationAngle= angle * (direction == 0 ? 1 : -1);\n                double circleCenterX= dartPositions[firstDartIndex][0] + radius * (dartPositions[secondDartIndex][0] - dartPositions[firstDartIndex][0]) / distanceBetweenDarts * std::cos(locationAngle) - radius * (dartPositions[secondDartIndex][1] - dartPositions[firstDartIndex][1]) / distanceBetweenDarts * std::sin(locationAngle);\n                double circleCenterY= dartPositions[firstDartIndex][1] + radius * (dartPositions[secondDartIndex][0] - dartPositions[firstDartIndex][0]) / distanceBetweenDarts * std::sin(locationAngle) + radius * (dartPositions[secondDartIndex][1] - dartPositions[firstDartIndex][1]) / distanceBetweenDarts * std::cos(locationAngle);\n\n                int countDartsInsideCircle= 0;\n                for(int dartIndex= 0; dartIndex < numberOfDarts; dartIndex++)\n                {\n                    double newDistance= std::hypot(dartPositions[dartIndex][0] - circleCenterX, dartPositions[dartIndex][1] - circleCenterY);\n                    if(newDistance <= radius + 1e-5)\n                        countDartsInsideCircle++;\n                }\n\n                maxDartsCount= std::max(maxDartsCount, countDartsInsideCircle);\n            }\n        }\n    }\n\n    return maxDartsCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBoxesInWarehouse(vector<int> &boxSizes, vector<int> &warehouseHeights)\n{\n    int warehouseSize= warehouseHeights.size();\n    for(int i= 1; i < warehouseSize; i++)\n        warehouseHeights[i]= min(warehouseHeights[i], warehouseHeights[i - 1]);\n    sort(boxSizes.rbegin(), boxSizes.rend());\n    int boxIndex= 0;\n    int boxesCount= 0;\n    for(int i= 0; i < warehouseSize && boxIndex < boxSizes.size(); i++)\n    {\n        if(boxSizes[boxIndex] <= warehouseHeights[i])\n        {\n            boxesCount++;\n            boxIndex++;\n        }\n    }\n    return boxesCount;\n}",
    "output": "#include <bits/stdc++.h>\nint maxBoxesInWarehouse(std::vector<int> &boxSizes, std::vector<int> &warehouseHeights)\n{\n    int warehouseSize= warehouseHeights.size();\n    for(int i= 1; i < warehouseSize; i++)\n        warehouseHeights[i]= std::min(warehouseHeights[i], warehouseHeights[i - 1]);\n    std::sort(boxSizes.rbegin(), boxSizes.rend());\n    int boxIndex= 0;\n    int boxesCount= 0;\n    for(int i= 0; i < warehouseSize && boxIndex < boxSizes.size(); i++)\n    {\n        if(boxSizes[boxIndex] <= warehouseHeights[i])\n        {\n            boxesCount++;\n            boxIndex++;\n        }\n    }\n    return boxesCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint isPrefixOfWord(string sentence, string searchWord)\n{\n    istringstream inputStream(sentence);\n    string currentWord;\n    int wordIndex = 1;\n    while(inputStream >> currentWord)\n    {\n        if(currentWord.substr(0, searchWord.size()) == searchWord)\n        {\n            return wordIndex;\n        }\n        wordIndex++;\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint isPrefixOfWord(std::string sentence, std::string searchWord)\n{\n    std::istringstream inputStream(sentence);\n    std::string currentWord;\n    int wordIndex= 1;\n    while(inputStream >> currentWord)\n    {\n        if(currentWord.substr(0, searchWord.size()) == searchWord)\n        {\n            return wordIndex;\n        }\n        wordIndex++;\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxVowels(string inputString, int substringLength)\n{\n    int maxVowelCount= 0, currentVowelCount= 0;\n    for(int index= 0; index < inputString.length(); index++)\n    {\n        currentVowelCount+= (inputString[index] == 'a' || inputString[index] == 'e' || inputString[index] == 'i' || inputString[index] == 'o' || inputString[index] == 'u');\n        if(index >= substringLength)\n            currentVowelCount-= (inputString[index - substringLength] == 'a' || inputString[index - substringLength] == 'e' || inputString[index - substringLength] == 'i' || inputString[index - substringLength] == 'o' || inputString[index - substringLength] == 'u');\n        maxVowelCount= max(maxVowelCount, currentVowelCount);\n    }\n    return maxVowelCount;\n}",
    "output": "#include <bits/stdc++.h>\nint maxVowels(std::string inputString, int substringLength)\n{\n    int maxVowelCount= 0, currentVowelCount= 0;\n    for(int index= 0; index < inputString.length(); index++)\n    {\n        currentVowelCount+= (inputString[index] == 'a' || inputString[index] == 'e' || inputString[index] == 'i' || inputString[index] == 'o' || inputString[index] == 'u');\n        if(index >= substringLength)\n            currentVowelCount-= (inputString[index - substringLength] == 'a' || inputString[index - substringLength] == 'e' || inputString[index - substringLength] == 'i' || inputString[index - substringLength] == 'o' || inputString[index - substringLength] == 'u');\n        maxVowelCount= std::max(maxVowelCount, currentVowelCount);\n    }\n    return maxVowelCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int countPseudoPalindromicPaths(TreeNode *currentNode, int pathCount= 0)\n{\n    if(!currentNode)\n        return 0;\n    pathCount^= 1 << (currentNode->val - 1);\n    if(!currentNode->left && !currentNode->right)\n        return (pathCount & (pathCount - 1)) == 0;\n    return countPseudoPalindromicPaths(currentNode->left, pathCount) + countPseudoPalindromicPaths(currentNode->right, pathCount);\n}",
    "output": "int countPseudoPalindromicPaths(TreeNode *currentNode, int pathCount= 0)\n{\n    if(!currentNode)\n        return 0;\n    pathCount^= 1 << (currentNode->val - 1);\n    if(!currentNode->left && !currentNode->right)\n        return (pathCount & (pathCount - 1)) == 0;\n    return countPseudoPalindromicPaths(currentNode->left, pathCount) + countPseudoPalindromicPaths(currentNode->right, pathCount);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For INT_MIN\nusing namespace std;\n\nint maxDotProduct(vector<int> &firstVector, vector<int> &secondVector)\n{\n    int firstSize= firstVector.size(), secondSize= secondVector.size();\n    vector<vector<int>> dynamicProgramming(firstSize + 1, vector<int>(secondSize + 1, INT_MIN));\n    for(int i= 1; i <= firstSize; ++i)\n    {\n        for(int j= 1; j <= secondSize; ++j)\n        {\n            dynamicProgramming[i][j]= max({dynamicProgramming[i][j], dynamicProgramming[i - 1][j], dynamicProgramming[i][j - 1], dynamicProgramming[i - 1][j - 1] + firstVector[i - 1] * secondVector[j - 1], firstVector[i - 1] * secondVector[j - 1]});\n        }\n    }\n    return dynamicProgramming[firstSize][secondSize];\n}",
    "output": "#include <bits/stdc++.h>\nint maxDotProduct(std::vector<int> &firstVector, std::vector<int> &secondVector)\n{\n    int firstSize= firstVector.size(), secondSize= secondVector.size();\n    std::vector<std::vector<int>> dynamicProgramming(firstSize + 1, std::vector<int>(secondSize + 1, INT_MIN));\n    for(int i= 1; i <= firstSize; ++i)\n    {\n        for(int j= 1; j <= secondSize; ++j)\n        {\n            dynamicProgramming[i][j]= std::max({dynamicProgramming[i][j], dynamicProgramming[i - 1][j], dynamicProgramming[i][j - 1], dynamicProgramming[i - 1][j - 1] + firstVector[i - 1] * secondVector[j - 1], firstVector[i - 1] * secondVector[j - 1]});\n        }\n    }\n    return dynamicProgramming[firstSize][secondSize];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> finalPrices(vector<int> &itemPrices)\n{\n    for(int currentIndex= 0; currentIndex < itemPrices.size(); currentIndex++)\n    {\n        for(int nextIndex= currentIndex + 1; nextIndex < itemPrices.size(); nextIndex++)\n        {\n            if(itemPrices[nextIndex] <= itemPrices[currentIndex])\n            {\n                itemPrices[currentIndex]-= itemPrices[nextIndex];\n                break;\n            }\n        }\n    }\n    return itemPrices;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> finalPrices(std::vector<int> &itemPrices)\n{\n    for(int currentIndex= 0; currentIndex < itemPrices.size(); currentIndex++)\n    {\n        for(int nextIndex= currentIndex + 1; nextIndex < itemPrices.size(); nextIndex++)\n        {\n            if(itemPrices[nextIndex] <= itemPrices[currentIndex])\n            {\n                itemPrices[currentIndex]-= itemPrices[nextIndex];\n                break;\n            }\n        }\n    }\n    return itemPrices;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass SubrectangleQueries\n{\n  public:\n    vector<vector<int>> rectangleMatrix;\n    \n    SubrectangleQueries(vector<vector<int>> &rectangle)\n    {\n        this->rectangleMatrix = rectangle;\n    }\n\n    void updateSubrectangle(int startRow, int startCol, int endRow, int endCol, int newValue)\n    {\n        for(int i = startRow; i <= endRow; i++)\n        {\n            for(int j = startCol; j <= endCol; j++)\n            {\n                rectangleMatrix[i][j] = newValue;\n            }\n        }\n    }\n\n    int getValue(int row, int col)\n    {\n        return rectangleMatrix[row][col];\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass SubrectangleQueries\n{\n  public:\n    std::vector<std::vector<int>> rectangleMatrix;\n    SubrectangleQueries(std::vector<std::vector<int>> &rectangle)\n    {\n        this->rectangleMatrix = rectangle;\n    }\n\n    void updateSubrectangle(int startRow, int startCol, int endRow, int endCol, int newValue)\n    {\n        for(int i = startRow; i <= endRow; i++)\n        {\n            for(int j = startCol; j <= endCol; j++)\n            {\n                rectangleMatrix[i][j] = newValue;\n            }\n        }\n    }\n\n    int getValue(int row, int col)\n    {\n        return rectangleMatrix[row][col];\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minSumOfLengths(vector<int> &numbers, int target)\n{\n    int arraySize= numbers.size(), currentSum= 0, minLength= numeric_limits<int>::max();\n    int result= numeric_limits<int>::max();\n    unordered_map<int, int> sumIndexMap;\n    sumIndexMap.reserve(arraySize + 1);\n    sumIndexMap[0]= -1;\n\n    for(int index= 0; index < arraySize; ++index)\n    {\n        currentSum+= numbers[index];\n        if(currentSum >= target && sumIndexMap.count(currentSum - target) > 0)\n        {\n            if(sumIndexMap[currentSum - target] > -1 && minLength != numeric_limits<int>::max())\n            {\n                result= min(result, index - sumIndexMap[currentSum - target] + minLength);\n            }\n            minLength= min(minLength, index - sumIndexMap[currentSum - target]);\n        }\n        sumIndexMap[currentSum]= index;\n    }\n    return result == numeric_limits<int>::max() ? -1 : result;\n}",
    "output": "#include <bits/stdc++.h>\nint minSumOfLengths(std::vector<int> &numbers, int target)\n{\n    int arraySize= numbers.size(), currentSum= 0, minLength= std::numeric_limits<int>::max();\n    int result= std::numeric_limits<int>::max();\n    std::unordered_map<int, int> sumIndexMap;\n    sumIndexMap.reserve(arraySize + 1);\n    sumIndexMap[0]= -1;\n\n    for(int index= 0; index < arraySize; ++index)\n    {\n        currentSum+= numbers[index];\n        if(currentSum >= target && sumIndexMap.count(currentSum - target) > 0)\n        {\n            if(sumIndexMap[currentSum - target] > -1 && minLength != std::numeric_limits<int>::max())\n            {\n                result= std::min(result, index - sumIndexMap[currentSum - target] + minLength);\n            }\n            minLength= std::min(minLength, index - sumIndexMap[currentSum - target]);\n        }\n        sumIndexMap[currentSum]= index;\n    }\n    return result == std::numeric_limits<int>::max() ? -1 : result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findLengthOfShortestSubarray(vector<int> &inputArray)\n{\n    int arraySize= inputArray.size(), leftIndex= 0, rightIndex= arraySize - 1;\n    while(leftIndex < arraySize - 1 && inputArray[leftIndex] <= inputArray[leftIndex + 1])\n        leftIndex++;\n    if(leftIndex == arraySize - 1)\n        return 0;\n    while(rightIndex > 0 && inputArray[rightIndex] >= inputArray[rightIndex - 1])\n        rightIndex--;\n    int shortestSubarrayLength= min(arraySize - leftIndex - 1, rightIndex);\n    for(int startIndex= 0, endIndex= rightIndex; startIndex <= leftIndex && endIndex < arraySize;)\n    {\n        if(inputArray[startIndex] <= inputArray[endIndex])\n        {\n            shortestSubarrayLength= min(shortestSubarrayLength, endIndex - startIndex - 1);\n            startIndex++;\n        }\n        else\n        {\n            endIndex++;\n        }\n    }\n    return shortestSubarrayLength;\n}",
    "output": "#include <bits/stdc++.h>\nint findLengthOfShortestSubarray(std::vector<int> &inputArray)\n{\n    int arraySize= inputArray.size(), leftIndex= 0, rightIndex= arraySize - 1;\n    while(leftIndex < arraySize - 1 && inputArray[leftIndex] <= inputArray[leftIndex + 1])\n        leftIndex++;\n    if(leftIndex == arraySize - 1)\n        return 0;\n    while(rightIndex > 0 && inputArray[rightIndex] >= inputArray[rightIndex - 1])\n        rightIndex--;\n    int shortestSubarrayLength= std::min(arraySize - leftIndex - 1, rightIndex);\n    for(int startIndex= 0, endIndex= rightIndex; startIndex <= leftIndex && endIndex < arraySize;)\n    {\n        if(inputArray[startIndex] <= inputArray[endIndex])\n        {\n            shortestSubarrayLength= std::min(shortestSubarrayLength, endIndex - startIndex - 1);\n            startIndex++;\n        }\n        else\n        {\n            endIndex++;\n        }\n    }\n    return shortestSubarrayLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxArea(int height, int width, vector<int> &horizontalCuts, vector<int> &verticalCuts)\n{\n    sort(horizontalCuts.begin(), horizontalCuts.end());\n    sort(verticalCuts.begin(), verticalCuts.end());\n\n    int maxHeight= max(horizontalCuts[0], height - horizontalCuts.back());\n    int maxWidth= max(verticalCuts[0], width - verticalCuts.back());\n\n    for(int i= 1; i < horizontalCuts.size(); ++i)\n    {\n        maxHeight= max(maxHeight, horizontalCuts[i] - horizontalCuts[i - 1]);\n    }\n\n    for(int i= 1; i < verticalCuts.size(); ++i)\n    {\n        maxWidth= max(maxWidth, verticalCuts[i] - verticalCuts[i - 1]);\n    }\n\n    return (long long)maxHeight * maxWidth % 1000000007;\n}",
    "output": "#include <bits/stdc++.h>\nint maxArea(int height, int width, std::vector<int> &horizontalCuts, std::vector<int> &verticalCuts)\n{\n    std::sort(horizontalCuts.begin(), horizontalCuts.end());\n    std::sort(verticalCuts.begin(), verticalCuts.end());\n\n    int maxHeight = std::max(horizontalCuts[0], height - horizontalCuts.back());\n    int maxWidth = std::max(verticalCuts[0], width - verticalCuts.back());\n\n    for(int i = 1; i < horizontalCuts.size(); ++i)\n    {\n        maxHeight = std::max(maxHeight, horizontalCuts[i] - horizontalCuts[i - 1]);\n    }\n\n    for(int i = 1; i < verticalCuts.size(); ++i)\n    {\n        maxWidth = std::max(maxWidth, verticalCuts[i] - verticalCuts[i - 1]);\n    }\n\n    return (long long)maxHeight * maxWidth % 1000000007;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(int currentNode, int parentNode, vector<vector<int>> &graph, int &reorderCount)\n{\n    if(currentNode != 0 && parentNode == 0)\n        reorderCount++;\n\n    for(int i = 0; i < graph[currentNode].size(); ++i)\n    {\n        int neighbor = graph[currentNode][i];\n        if(neighbor != parentNode)\n        {\n            depthFirstSearch(neighbor, currentNode, graph, reorderCount);\n        }\n    }\n}\n\nint minReorder(int totalNodes, vector<vector<int>> &connections)\n{\n    vector<vector<int>> graph(totalNodes);\n    for(auto &connection : connections)\n    {\n        graph[connection[0]].push_back(connection[1]);\n        graph[connection[1]].push_back(connection[0]);\n    }\n\n    int reorderCount= 0;\n    depthFirstSearch(0, -1, graph, reorderCount);\n    return reorderCount;\n}",
    "output": "#include <bits/stdc++.h>\nvoid depthFirstSearch(int currentNode, int parentNode, std::vector<std::vector<int>> &graph, int &reorderCount)\n{\n    if(currentNode != 0 && parentNode == 0)\n        reorderCount++;\n\n    for(int neighbor : graph[currentNode])\n    {\n        if(neighbor != parentNode)\n        {\n            depthFirstSearch(neighbor, currentNode, graph, reorderCount);\n        }\n    }\n}\n\nint minReorder(int totalNodes, std::vector<std::vector<int>> &connections)\n{\n    std::vector<std::vector<int>> graph(totalNodes);\n    for(auto &connection : connections)\n    {\n        graph[connection[0]].push_back(connection[1]);\n        graph[connection[1]].push_back(connection[0]);\n    }\n\n    int reorderCount= 0;\n    depthFirstSearch(0, -1, graph, reorderCount);\n    return reorderCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble probabilityDP[50][50][50];\nclass Solution\n{\n  public:\n    double getProbability(vector<int> &ballCounts)\n    {\n        int totalBalls = 0, numberOfColors = ballCounts.size();\n        for (int i = 0; i < ballCounts.size(); ++i)\n            totalBalls += ballCounts[i];\n        vector<int> prefixSum;\n        prefixSum.push_back(0);\n        for (int i = 0; i < ballCounts.size(); ++i)\n            prefixSum.push_back(prefixSum.back() + ballCounts[i]);\n\n        memset(probabilityDP, 0, sizeof(probabilityDP));\n        probabilityDP[0][0][0] = 1;\n        for (int colorIndex = 0; colorIndex < numberOfColors; ++colorIndex)\n            for (int ballCountIndex = colorIndex; ballCountIndex >= 0; --ballCountIndex)\n                for (int x = prefixSum[colorIndex + 1]; x >= 0; --x)\n                    for (int y = prefixSum[colorIndex + 1] - x; y >= 0; --y)\n                        if (x + y <= ballCounts[colorIndex])\n                            for (int d = max(0, ballCounts[colorIndex] - 2 * y); d <= x; ++d)\n                            {\n                                double tempProbability = 1;\n                                for (int z = 1; z <= d; ++z)\n                                    tempProbability *= x + y + 1 - z, tempProbability /= z;\n                                for (int z = 1; z <= y; ++z)\n                                    tempProbability *= x + y + d + 1 - z, tempProbability /= z;\n                                for (int z = 1; z <= ballCounts[colorIndex] - y - y - d; ++z)\n                                    tempProbability *= x + y + d + 1 - z, tempProbability /= z;\n                                probabilityDP[colorIndex + 1][ballCountIndex + 1][x + d] += probabilityDP[colorIndex][ballCountIndex][x] * tempProbability;\n                                probabilityDP[colorIndex + 1][ballCountIndex][x + d] += probabilityDP[colorIndex][ballCountIndex][x] * tempProbability;\n                            }\n\n        return (probabilityDP[numberOfColors][numberOfColors >> 1][totalBalls >> 1] - (1e-5 > probabilityDP[numberOfColors][numberOfColors >> 1][totalBalls >> 1])) / (totalBalls % 2 ? 1 : (1ll << (totalBalls >> 1)));\n    }\n};",
    "output": "#include <bits/stdc++.h>\ndouble probabilityDP[50][50][50];\nclass Solution\n{\n  public:\n    double getProbability(std::vector<int> &ballCounts)\n    {\n        int totalBalls= 0, numberOfColors= ballCounts.size();\n        for(int count : ballCounts)\n            totalBalls+= count;\n        std::vector<int> prefixSum;\n        prefixSum.push_back(0);\n        for(int count : ballCounts)\n            prefixSum.push_back(prefixSum.back() + count);\n\n        std::memset(probabilityDP, 0, sizeof(probabilityDP));\n        probabilityDP[0][0][0]= 1;\n        for(int colorIndex= 0; colorIndex < numberOfColors; ++colorIndex)\n            for(int ballCountIndex= colorIndex; ballCountIndex >= 0; --ballCountIndex)\n                for(int x= prefixSum[colorIndex + 1]; x >= 0; --x)\n                    for(int y= prefixSum[colorIndex + 1] - x; y >= 0; --y)\n                        if(x + y <= ballCounts[colorIndex])\n                            for(int d= std::max(0, ballCounts[colorIndex] - 2 * y); d <= x; ++d)\n                            {\n                                double tempProbability= 1;\n                                for(int z= 1; z <= d; ++z)\n                                    tempProbability*= x + y + 1 - z, tempProbability/= z;\n                                for(int z= 1; z <= y; ++z)\n                                    tempProbability*= x + y + d + 1 - z, tempProbability/= z;\n                                for(int z= 1; z <= ballCounts[colorIndex] - y - y - d; ++z)\n                                    tempProbability*= x + y + d + 1 - z, tempProbability/= z;\n                                probabilityDP[colorIndex + 1][ballCountIndex + 1][x + d]+= probabilityDP[colorIndex][ballCountIndex][x] * tempProbability;\n                                probabilityDP[colorIndex + 1][ballCountIndex][x + d]+= probabilityDP[colorIndex][ballCountIndex][x] * tempProbability;\n                            }\n\n        return (probabilityDP[numberOfColors][numberOfColors >> 1][totalBalls >> 1] - (1e-5 > probabilityDP[numberOfColors][numberOfColors >> 1][totalBalls >> 1])) / (totalBalls % 2 ? 1 : (1ll << (totalBalls >> 1)));\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumTime(string colorSequence, vector<int> &timeNeeded)\n{\n    int totalTime= 0, previousIndex= -1;\n    for(int currentIndex= 0; currentIndex < colorSequence.length() - 1; currentIndex++)\n    {\n        if(colorSequence[currentIndex] == colorSequence[currentIndex + 1])\n        {\n            if(previousIndex == -1 || timeNeeded[currentIndex] < timeNeeded[previousIndex])\n                previousIndex= currentIndex;\n            if(timeNeeded[currentIndex + 1] < timeNeeded[previousIndex])\n                previousIndex= currentIndex + 1;\n            totalTime+= timeNeeded[previousIndex];\n            timeNeeded[previousIndex]= 1000000;\n            previousIndex= -1;\n        }\n    }\n    return totalTime;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMinimumTime(std::string colorSequence, std::vector<int> &timeNeeded)\n{\n    int totalTime= 0, previousIndex= -1;\n    for(int currentIndex= 0; currentIndex < colorSequence.length() - 1; currentIndex++)\n    {\n        if(colorSequence[currentIndex] == colorSequence[currentIndex + 1])\n        {\n            if(previousIndex == -1 || timeNeeded[currentIndex] < timeNeeded[previousIndex])\n                previousIndex= currentIndex;\n            if(timeNeeded[currentIndex + 1] < timeNeeded[previousIndex])\n                previousIndex= currentIndex + 1;\n            totalTime+= timeNeeded[previousIndex];\n            timeNeeded[previousIndex]= 1000000;\n            previousIndex= -1;\n        }\n    }\n    return totalTime;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UnionFind\n{\n  public:\n    vector<int> parent;\n    int componentCount;\n\n    UnionFind(int size)\n    {\n        parent.resize(size);\n        componentCount = size;\n        for (int index = 0; index < size; ++index)\n        {\n            parent[index] = index;\n        }\n    }\n\n    int find(int node)\n    {\n        if (node != parent[node])\n            parent[node] = find(parent[node]);\n        return parent[node];\n    }\n\n    bool unite(int nodeX, int nodeY)\n    {\n        int rootX = find(nodeX);\n        int rootY = find(nodeY);\n        if (rootX != rootY)\n        {\n            parent[rootX] = rootY;\n            componentCount--;\n            return true;\n        }\n        return false;\n    }\n};\n\nint maxNumEdgesToRemove(int numNodes, vector<vector<int>> &edges)\n{\n    UnionFind ufForTypeA(numNodes + 1), ufForTypeB(numNodes + 1);\n    int commonEdgeCount = 0;\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        if (edges[i][0] == 3)\n        {\n            if (ufForTypeA.unite(edges[i][1], edges[i][2]))\n            {\n                ufForTypeB.unite(edges[i][1], edges[i][2]);\n                commonEdgeCount++;\n            }\n        }\n    }\n\n    int removedEdgeCount = 0;\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        UnionFind *uf = (edges[i][0] == 1) ? &ufForTypeA : (edges[i][0] == 2) ? &ufForTypeB : NULL;\n        if (uf && !uf->unite(edges[i][1], edges[i][2]))\n        {\n            removedEdgeCount++;\n        }\n    }\n\n    if (ufForTypeA.componentCount != 2 || ufForTypeB.componentCount != 2)\n        return -1;\n    return removedEdgeCount - commonEdgeCount;\n}",
    "output": "#include <bits/stdc++.h>\nclass UnionFind\n{\n  public:\n    std::vector<int> parent;\n    int componentCount;\n\n    UnionFind(int size)\n    {\n        parent.resize(size);\n        componentCount= size;\n        for(int index= 0; index < size; ++index)\n        {\n            parent[index]= index;\n        }\n    }\n\n    int find(int node)\n    {\n        if(node != parent[node])\n            parent[node]= find(parent[node]);\n        return parent[node];\n    }\n\n    bool unite(int nodeX, int nodeY)\n    {\n        int rootX= find(nodeX);\n        int rootY= find(nodeY);\n        if(rootX != rootY)\n        {\n            parent[rootX]= rootY;\n            componentCount--;\n            return true;\n        }\n        return false;\n    }\n};\n\nint maxNumEdgesToRemove(int numNodes, std::vector<std::vector<int>> &edges)\n{\n    UnionFind ufForTypeA(numNodes + 1), ufForTypeB(numNodes + 1);\n    int commonEdgeCount= 0;\n\n    for(auto &edge : edges)\n    {\n        if(edge[0] == 3)\n        {\n            if(ufForTypeA.unite(edge[1], edge[2]))\n            {\n                ufForTypeB.unite(edge[1], edge[2]);\n                commonEdgeCount++;\n            }\n        }\n    }\n\n    int removedEdgeCount= 0;\n    for(auto &edge : edges)\n    {\n        UnionFind *uf= (edge[0] == 1) ? &ufForTypeA : (edge[0] == 2) ? &ufForTypeB\n                                                                     : NULL;\n        if(uf && !uf->unite(edge[1], edge[2]))\n        {\n            removedEdgeCount++;\n        }\n    }\n\n    if(ufForTypeA.componentCount != 2 || ufForTypeB.componentCount != 2)\n        return -1;\n    return removedEdgeCount - commonEdgeCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> shuffle(vector<int> &numberList, int halfSize)\n{\n    vector<int> shuffledList;\n    for(int index= 0; index < halfSize; ++index)\n    {\n        shuffledList.push_back(numberList[index]);\n        shuffledList.push_back(numberList[index + halfSize]);\n    }\n    return shuffledList;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> shuffle(std::vector<int> &numberList, int halfSize)\n{\n    std::vector<int> shuffledList;\n    for(int index= 0; index < halfSize; ++index)\n    {\n        shuffledList.push_back(numberList[index]);\n        shuffledList.push_back(numberList[index + halfSize]);\n    }\n    return shuffledList;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass BrowserHistory\n{\n  public:\n    int currentIndex;\n    vector<string> history;\n\n    BrowserHistory(string homepage)\n    {\n        history.push_back(homepage);\n        currentIndex = 0;\n    }\n\n    void visit(string url)\n    {\n        history.resize(currentIndex + 1);\n        history.push_back(url);\n        currentIndex++;\n    }\n\n    string back(int steps)\n    {\n        currentIndex -= min(steps, currentIndex);\n        return history[currentIndex];\n    }\n\n    string forward(int steps)\n    {\n        currentIndex += min(steps, (int)(history.size() - 1 - currentIndex));\n        return history[currentIndex];\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass BrowserHistory\n{\n  public:\n    int currentIndex;\n    std::vector<std::string> history;\n\n    BrowserHistory(std::string homepage)\n    {\n        history.push_back(homepage);\n        currentIndex = 0;\n    }\n\n    void visit(std::string url)\n    {\n        history.resize(currentIndex + 1);\n        history.push_back(url);\n        currentIndex++;\n    }\n\n    std::string back(int steps)\n    {\n        currentIndex -= std::min(steps, currentIndex);\n        return history[currentIndex];\n    }\n\n    std::string forward(int steps)\n    {\n        currentIndex += std::min(steps, (int)(history.size() - 1 - currentIndex));\n        return history[currentIndex];\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumCost(vector<int> &houseColors, vector<vector<int>> &paintingCost, int totalHouses, int totalColors, int targetNeighborhoods)\n{\n    int dynamicProgramming[totalHouses][totalColors][targetNeighborhoods + 1];\n    memset(dynamicProgramming, 0x3f, sizeof(dynamicProgramming));\n\n    if(houseColors[0] != 0)\n    {\n        dynamicProgramming[0][houseColors[0] - 1][1]= 0;\n    }\n    else\n    {\n        for(int colorIndex= 0; colorIndex < totalColors; colorIndex++)\n        {\n            dynamicProgramming[0][colorIndex][1]= paintingCost[0][colorIndex];\n        }\n    }\n\n    for(int houseIndex= 1; houseIndex < totalHouses; houseIndex++)\n        for(int colorIndex= 0; colorIndex < totalColors; colorIndex++)\n            for(int neighborhoodCount= 1; neighborhoodCount <= targetNeighborhoods; neighborhoodCount++)\n            {\n                if(houseColors[houseIndex] != 0 && houseColors[houseIndex] != colorIndex + 1)\n                {\n                    continue;\n                }\n                int currentPaintCost= (houseColors[houseIndex] != 0) ? 0 : paintingCost[houseIndex][colorIndex];\n\n                for(int previousColorIndex= 0; previousColorIndex < totalColors; previousColorIndex++)\n                {\n                    if(previousColorIndex == colorIndex)\n                    {\n                        dynamicProgramming[houseIndex][colorIndex][neighborhoodCount]= min(dynamicProgramming[houseIndex][colorIndex][neighborhoodCount], dynamicProgramming[houseIndex - 1][previousColorIndex][neighborhoodCount] + currentPaintCost);\n                    }\n                    else\n                    {\n                        dynamicProgramming[houseIndex][colorIndex][neighborhoodCount]= min(dynamicProgramming[houseIndex][colorIndex][neighborhoodCount], dynamicProgramming[houseIndex - 1][previousColorIndex][neighborhoodCount - 1] + currentPaintCost);\n                    }\n                }\n            }\n\n    int minimumCost= 1e9;\n    for(int colorIndex= 0; colorIndex < totalColors; colorIndex++)\n    {\n        minimumCost= min(minimumCost, dynamicProgramming[totalHouses - 1][colorIndex][targetNeighborhoods]);\n    }\n    return (minimumCost == 1e9) ? -1 : minimumCost;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMinimumCost(std::vector<int> &houseColors, std::vector<std::vector<int>> &paintingCost, int totalHouses, int totalColors, int targetNeighborhoods)\n{\n    int dynamicProgramming[totalHouses][totalColors][targetNeighborhoods + 1];\n    std::memset(dynamicProgramming, 0x3f, sizeof(dynamicProgramming));\n\n    if(houseColors[0] != 0)\n    {\n        dynamicProgramming[0][houseColors[0] - 1][1] = 0;\n    }\n    else\n    {\n        for(int colorIndex = 0; colorIndex < totalColors; colorIndex++)\n        {\n            dynamicProgramming[0][colorIndex][1] = paintingCost[0][colorIndex];\n        }\n    }\n\n    for(int houseIndex = 1; houseIndex < totalHouses; houseIndex++)\n        for(int colorIndex = 0; colorIndex < totalColors; colorIndex++)\n            for(int neighborhoodCount = 1; neighborhoodCount <= targetNeighborhoods; neighborhoodCount++)\n            {\n                if(houseColors[houseIndex] != 0 && houseColors[houseIndex] != colorIndex + 1)\n                {\n                    continue;\n                }\n                int currentPaintCost = (houseColors[houseIndex] != 0) ? 0 : paintingCost[houseIndex][colorIndex];\n\n                for(int previousColorIndex = 0; previousColorIndex < totalColors; previousColorIndex++)\n                {\n                    if(previousColorIndex == colorIndex)\n                    {\n                        dynamicProgramming[houseIndex][colorIndex][neighborhoodCount] = std::min(dynamicProgramming[houseIndex][colorIndex][neighborhoodCount], dynamicProgramming[houseIndex - 1][previousColorIndex][neighborhoodCount] + currentPaintCost);\n                    }\n                    else\n                    {\n                        dynamicProgramming[houseIndex][colorIndex][neighborhoodCount] = std::min(dynamicProgramming[houseIndex][colorIndex][neighborhoodCount], dynamicProgramming[houseIndex - 1][previousColorIndex][neighborhoodCount - 1] + currentPaintCost);\n                    }\n                }\n            }\n\n    int minimumCost = 1e9;\n    for(int colorIndex = 0; colorIndex < totalColors; colorIndex++)\n    {\n        minimumCost = std::min(minimumCost, dynamicProgramming[totalHouses - 1][colorIndex][targetNeighborhoods]);\n    }\n    return (minimumCost == 1e9) ? -1 : minimumCost;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble average(vector<int> &salaries)\n{\n    double totalSum = 0;\n    int minimumSalary = *min_element(salaries.begin(), salaries.end());\n    int maximumSalary = *max_element(salaries.begin(), salaries.end());\n    \n    for (int i = 0; i < salaries.size(); ++i)\n    {\n        int currentSalary = salaries[i];\n        totalSum += currentSalary;\n    }\n    \n    totalSum -= (minimumSalary + maximumSalary);\n    return totalSum / (salaries.size() - 2);\n}",
    "output": "#include <bits/stdc++.h>\ndouble average(std::vector<int> &salaries)\n{\n    double totalSum = 0;\n    int minimumSalary = *std::min_element(salaries.begin(), salaries.end());\n    int maximumSalary = *std::max_element(salaries.begin(), salaries.end());\n    for(int currentSalary : salaries)\n    {\n        totalSum += currentSalary;\n    }\n    totalSum -= (minimumSalary + maximumSalary);\n    return totalSum / (salaries.size() - 2);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int kthFactor(int number, int k)\n{\n    for(int factor= 1; factor <= number; ++factor)\n    {\n        if(number % factor == 0)\n        {\n            --k;\n            if(k == 0)\n                return factor;\n        }\n    }\n    return -1;\n}",
    "output": "int kthFactor(int number, int k)\n{\n    for(int factor= 1; factor <= number; ++factor)\n    {\n        if(number % factor == 0)\n        {\n            --k;\n            if(k == 0)\n                return factor;\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMaxLength(vector<int> &numArray)\n{\n    int maxLength= 0, zeroCount= 0, oneCount= 0;\n    unordered_map<int, int> countMap;\n    countMap[0]= -1;\n\n    for(int index= 0; index < numArray.size(); ++index)\n    {\n        if(numArray[index] == 0)\n            zeroCount++;\n        else\n            oneCount++;\n\n        if(countMap.count(zeroCount - oneCount) == 0)\n            countMap[zeroCount - oneCount]= index;\n        else\n            maxLength= max(maxLength, index - countMap[zeroCount - oneCount]);\n    }\n    return maxLength;\n}",
    "output": "#include <bits/stdc++.h>\nint findMaxLength(std::vector<int> &numArray)\n{\n    int maxLength= 0, zeroCount= 0, oneCount= 0;\n    std::unordered_map<int, int> countMap;\n    countMap[0]= -1;\n\n    for(int index= 0; index < numArray.size(); ++index)\n    {\n        if(numArray[index] == 0)\n            zeroCount++;\n        else\n            oneCount++;\n\n        if(countMap.count(zeroCount - oneCount) == 0)\n            countMap[zeroCount - oneCount]= index;\n        else\n            maxLength= std::max(maxLength, index - countMap[zeroCount - oneCount]);\n    }\n    return maxLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint sumOddLengthSubarrays(vector<int> &array)\n{\n    int totalSum= 0, arraySize= array.size();\n    for(int index= 0; index < arraySize; index++)\n    {\n        int oddSubarraysCount= ((index + 1) * (arraySize - index) + 1) / 2;\n        totalSum+= array[index] * oddSubarraysCount;\n    }\n    return totalSum;\n}",
    "output": "#include <bits/stdc++.h>\nint sumOddLengthSubarrays(std::vector<int> &array)\n{\n    int totalSum= 0, arraySize= array.size();\n    for(int index= 0; index < arraySize; index++)\n    {\n        int oddSubarraysCount= ((index + 1) * (arraySize - index) + 1) / 2;\n        totalSum+= array[index] * oddSubarraysCount;\n    }\n    return totalSum;\n}\n"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo = 1000000007;\n\nint maxSumRangeQuery(vector<int> &numbers, vector<vector<int>> &requests)\n{\n    int size = numbers.size();\n    vector<int> frequency(size, 0);\n    for (int i = 0; i < requests.size(); i++)\n    {\n        auto &request = requests[i];\n        frequency[request[0]]++;\n        if (request[1] + 1 < size)\n            frequency[request[1] + 1]--;\n    }\n    for (int i = 1; i < size; i++)\n    {\n        frequency[i] += frequency[i - 1];\n    }\n    sort(numbers.begin(), numbers.end());\n    sort(frequency.begin(), frequency.end());\n\n    long long result = 0;\n    for (int i = 0; i < size; i++)\n    {\n        result = (result + (long long)numbers[i] * frequency[i]) % modulo;\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nconst int modulo= 1000000007;\n\nint maxSumRangeQuery(std::vector<int> &numbers, std::vector<std::vector<int>> &requests)\n{\n    int size= numbers.size();\n    std::vector<int> frequency(size, 0);\n    for(auto &request : requests)\n    {\n        frequency[request[0]]++;\n        if(request[1] + 1 < size)\n            frequency[request[1] + 1]--;\n    }\n    for(int i= 1; i < size; i++)\n    {\n        frequency[i]+= frequency[i - 1];\n    }\n    std::sort(numbers.begin(), numbers.end());\n    std::sort(frequency.begin(), frequency.end());\n\n    long long result= 0;\n    for(int i= 0; i < size; i++)\n    {\n        result= (result + (long long)numbers[i] * frequency[i]) % modulo;\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minSubarray(vector<int> &numbers, int target)\n{\n    int arraySize = numbers.size(), minimumLength = arraySize, requiredSum = 0, currentSum = 0;\n    for (int i = 0; i < arraySize; ++i)\n        requiredSum = (requiredSum + numbers[i]) % target;\n    if (requiredSum == 0)\n        return 0;\n    unordered_map<int, int> lastSeenIndex;\n    lastSeenIndex[0] = -1;\n    for (int index = 0; index < arraySize; index++)\n    {\n        currentSum = (currentSum + numbers[index]) % target;\n        lastSeenIndex[currentSum] = index;\n        minimumLength = min(minimumLength, index - lastSeenIndex[(currentSum - requiredSum + target) % target]);\n    }\n    return minimumLength < arraySize ? minimumLength : -1;\n}",
    "output": "#include <bits/stdc++.h>\nint minSubarray(std::vector<int> &numbers, int target)\n{\n    int arraySize = numbers.size(), minimumLength = arraySize, requiredSum = 0, currentSum = 0;\n    for(int number : numbers)\n        requiredSum = (requiredSum + number) % target;\n    if(requiredSum == 0)\n        return 0;\n    std::unordered_map<int, int> lastSeenIndex;\n    lastSeenIndex[0] = -1;\n    for(int index = 0; index < arraySize; index++)\n    {\n        currentSum = (currentSum + numbers[index]) % target;\n        lastSeenIndex[currentSum] = index;\n        minimumLength = std::min(minimumLength, index - lastSeenIndex[(currentSum - requiredSum + target) % target]);\n    }\n    return minimumLength < arraySize ? minimumLength : -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPrintable(vector<vector<int>> &targetGrid)\n{\n    unordered_map<int, vector<int>> colorBounds;\n    int rowCount = targetGrid.size(), columnCount = targetGrid[0].size();\n    for (int rowIndex = 0; rowIndex < rowCount; ++rowIndex)\n    {\n        for (int columnIndex = 0; columnIndex < columnCount; ++columnIndex)\n        {\n            int color = targetGrid[rowIndex][columnIndex];\n            if (!colorBounds.count(color))\n                colorBounds[color] = {rowIndex, columnIndex, rowIndex, columnIndex};\n            else\n            {\n                colorBounds[color][0] = min(colorBounds[color][0], rowIndex);\n                colorBounds[color][1] = min(colorBounds[color][1], columnIndex);\n                colorBounds[color][2] = max(colorBounds[color][2], rowIndex);\n                colorBounds[color][3] = max(colorBounds[color][3], columnIndex);\n            }\n        }\n    }\n\n    set<int> remainingColors;\n    for (const auto &pair : colorBounds)\n    {\n        remainingColors.insert(pair.first);\n    }\n    while (!remainingColors.empty())\n    {\n        bool progressMade = false;\n        for (auto it = remainingColors.begin(); it != remainingColors.end();)\n        {\n            int color = *it;\n            const auto &bounds = colorBounds[color];\n            bool isContained = true;\n            for (int rowIndex = bounds[0]; rowIndex <= bounds[2] && isContained; ++rowIndex)\n            {\n                for (int columnIndex = bounds[1]; columnIndex <= bounds[3]; ++columnIndex)\n                {\n                    if (targetGrid[rowIndex][columnIndex] != color && targetGrid[rowIndex][columnIndex] != -1)\n                    {\n                        isContained = false;\n                        break;\n                    }\n                }\n            }\n            if (isContained)\n            {\n                for (int rowIndex = bounds[0]; rowIndex <= bounds[2]; ++rowIndex)\n                {\n                    for (int columnIndex = bounds[1]; columnIndex <= bounds[3]; ++columnIndex)\n                    {\n                        targetGrid[rowIndex][columnIndex] = -1;\n                    }\n                }\n                it = remainingColors.erase(it);\n                progressMade = true;\n            }\n            else\n            {\n                ++it;\n            }\n        }\n        if (!progressMade)\n            return false;\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isPrintable(std::vector<std::vector<int>> &targetGrid)\n{\n    std::unordered_map<int, std::vector<int>> colorBounds;\n    int rowCount= targetGrid.size(), columnCount= targetGrid[0].size();\n    for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n    {\n        for(int columnIndex= 0; columnIndex < columnCount; ++columnIndex)\n        {\n            int color= targetGrid[rowIndex][columnIndex];\n            if(!colorBounds.count(color))\n                colorBounds[color]= {rowIndex, columnIndex, rowIndex, columnIndex};\n            else\n            {\n                colorBounds[color][0]= std::min(colorBounds[color][0], rowIndex);\n                colorBounds[color][1]= std::min(colorBounds[color][1], columnIndex);\n                colorBounds[color][2]= std::max(colorBounds[color][2], rowIndex);\n                colorBounds[color][3]= std::max(colorBounds[color][3], columnIndex);\n            }\n        }\n    }\n\n    std::set<int> remainingColors;\n    for(const auto &pair : colorBounds)\n    {\n        remainingColors.insert(pair.first);\n    }\n    while(!remainingColors.empty())\n    {\n        bool progressMade= false;\n        for(auto it= remainingColors.begin(); it != remainingColors.end();)\n        {\n            int color= *it;\n            const auto &bounds= colorBounds[color];\n            bool isContained= true;\n            for(int rowIndex= bounds[0]; rowIndex <= bounds[2] && isContained; ++rowIndex)\n            {\n                for(int columnIndex= bounds[1]; columnIndex <= bounds[3]; ++columnIndex)\n                {\n                    if(targetGrid[rowIndex][columnIndex] != color && targetGrid[rowIndex][columnIndex] != -1)\n                    {\n                        isContained= false;\n                        break;\n                    }\n                }\n            }\n            if(isContained)\n            {\n                for(int rowIndex= bounds[0]; rowIndex <= bounds[2]; ++rowIndex)\n                {\n                    for(int columnIndex= bounds[1]; columnIndex <= bounds[3]; ++columnIndex)\n                    {\n                        targetGrid[rowIndex][columnIndex]= -1;\n                    }\n                }\n                it= remainingColors.erase(it);\n                progressMade= true;\n            }\n            else\n            {\n                ++it;\n            }\n        }\n        if(!progressMade)\n            return false;\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring reorderSpaces(string text)\n{\n    int totalSpaces = 0, totalWords = 0;\n\n    for (int i = 0; i < text.size(); ++i)\n    {\n        char character = text[i];\n        if (character == ' ')\n            totalSpaces++;\n    }\n\n    istringstream inputStream(text);\n    vector<string> wordsList;\n    string currentWord;\n\n    while (inputStream >> currentWord)\n    {\n        wordsList.push_back(currentWord);\n        totalWords++;\n    }\n\n    int spacesBetweenWords = totalWords == 1 ? 0 : totalSpaces / (totalWords - 1);\n    int extraSpaces = totalWords == 1 ? totalSpaces : totalSpaces % (totalWords - 1);\n\n    string result;\n\n    for (int i = 0; i < totalWords; i++)\n    {\n        result += wordsList[i];\n        if (i != totalWords - 1)\n        {\n            result.append(spacesBetweenWords, ' ');\n        }\n        else\n        {\n            result.append(extraSpaces, ' ');\n        }\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string reorderSpaces(std::string text)\n{\n    int totalSpaces= 0, totalWords= 0;\n\n    for(char character : text)\n    {\n        if(character == ' ')\n            totalSpaces++;\n    }\n\n    std::istringstream inputStream(text);\n    std::vector<std::string> wordsList;\n    std::string currentWord;\n\n    while(inputStream >> currentWord)\n    {\n        wordsList.push_back(currentWord);\n        totalWords++;\n    }\n\n    int spacesBetweenWords= totalWords == 1 ? 0 : totalSpaces / (totalWords - 1);\n    int extraSpaces= totalWords == 1 ? totalSpaces : totalSpaces % (totalWords - 1);\n\n    std::string result;\n\n    for(int i= 0; i < totalWords; i++)\n    {\n        result+= wordsList[i];\n        if(i != totalWords - 1)\n        {\n            result.append(spacesBetweenWords, ' ');\n        }\n        else\n        {\n            result.append(extraSpaces, ' ');\n        }\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxUniqueSplit(const string &inputString, int currentIndex = 0, unordered_set<string> &uniqueSubstrings = unordered_set<string>())\n{\n    if(currentIndex == inputString.size())\n        return 0;\n    int maxUniqueCount = -1;\n    for(int endIndex = currentIndex + 1; endIndex <= inputString.size(); ++endIndex)\n    {\n        string substring = inputString.substr(currentIndex, endIndex - currentIndex);\n        if(uniqueSubstrings.find(substring) == uniqueSubstrings.end())\n        {\n            uniqueSubstrings.insert(substring);\n            int uniqueSplitCount = maxUniqueSplit(inputString, endIndex, uniqueSubstrings);\n            if(uniqueSplitCount != -1)\n                maxUniqueCount = max(maxUniqueCount, uniqueSplitCount + 1);\n            uniqueSubstrings.erase(substring);\n        }\n    }\n    return maxUniqueCount;\n}",
    "output": "#include <bits/stdc++.h>\nint maxUniqueSplit(const std::string &inputString, int currentIndex= 0, std::unordered_set<std::string> &uniqueSubstrings= std::unordered_set<std::string>())\n{\n    if(currentIndex == inputString.size())\n        return 0;\n    int maxUniqueCount= -1;\n    for(int endIndex= currentIndex + 1; endIndex <= inputString.size(); ++endIndex)\n    {\n        std::string substring= inputString.substr(currentIndex, endIndex - currentIndex);\n        if(uniqueSubstrings.find(substring) == uniqueSubstrings.end())\n        {\n            uniqueSubstrings.insert(substring);\n            int uniqueSplitCount= maxUniqueSplit(inputString, endIndex, uniqueSubstrings);\n            if(uniqueSplitCount != -1)\n                maxUniqueCount= std::max(maxUniqueCount, uniqueSplitCount + 1);\n            uniqueSubstrings.erase(substring);\n        }\n    }\n    return maxUniqueCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxProductPath(vector<vector<int>> &grid)\n{\n    int rowCount= grid.size(), columnCount= grid[0].size(), modulus= 1e9 + 7;\n    vector<vector<vector<long long>>> dynamicProgramming(rowCount, vector<vector<long long>>(columnCount, vector<long long>(2, 0)));\n    dynamicProgramming[0][0][0]= dynamicProgramming[0][0][1]= grid[0][0];\n\n    for(int rowIndex= 1; rowIndex < rowCount; ++rowIndex)\n        dynamicProgramming[rowIndex][0][0]= dynamicProgramming[rowIndex][0][1]= grid[rowIndex][0] * dynamicProgramming[rowIndex - 1][0][0];\n\n    for(int columnIndex= 1; columnIndex < columnCount; ++columnIndex)\n        dynamicProgramming[0][columnIndex][0]= dynamicProgramming[0][columnIndex][1]= grid[0][columnIndex] * dynamicProgramming[0][columnIndex - 1][0];\n\n    for(int rowIndex= 1; rowIndex < rowCount; ++rowIndex)\n    {\n        for(int columnIndex= 1; columnIndex < columnCount; ++columnIndex)\n        {\n            if(grid[rowIndex][columnIndex] < 0)\n            {\n                dynamicProgramming[rowIndex][columnIndex][0]= min(grid[rowIndex][columnIndex] * dynamicProgramming[rowIndex - 1][columnIndex][1], grid[rowIndex][columnIndex] * dynamicProgramming[rowIndex][columnIndex - 1][1]);\n                dynamicProgramming[rowIndex][columnIndex][1]= max(grid[rowIndex][columnIndex] * dynamicProgramming[rowIndex - 1][columnIndex][0], grid[rowIndex][columnIndex] * dynamicProgramming[rowIndex][columnIndex - 1][0]);\n            }\n            else\n            {\n                dynamicProgramming[rowIndex][columnIndex][0]= min(grid[rowIndex][columnIndex] * dynamicProgramming[rowIndex - 1][columnIndex][0], grid[rowIndex][columnIndex] * dynamicProgramming[rowIndex][columnIndex - 1][0]);\n                dynamicProgramming[rowIndex][columnIndex][1]= max(grid[rowIndex][columnIndex] * dynamicProgramming[rowIndex - 1][columnIndex][1], grid[rowIndex][columnIndex] * dynamicProgramming[rowIndex][columnIndex - 1][1]);\n            }\n        }\n    }\n\n    return dynamicProgramming.back().back()[1] < 0 ? -1 : dynamicProgramming.back().back()[1] % modulus;\n}",
    "output": "#include <bits/stdc++.h>\nint maxProductPath(std::vector<std::vector<int>> &grid)\n{\n    int rowCount= grid.size(), columnCount= grid[0].size(), modulus= 1e9 + 7;\n    std::vector<std::vector<std::vector<long long>>> dynamicProgramming(rowCount, std::vector<std::vector<long long>>(columnCount, std::vector<long long>(2, 0)));\n    dynamicProgramming[0][0][0]= dynamicProgramming[0][0][1]= grid[0][0];\n\n    for(int rowIndex= 1; rowIndex < rowCount; ++rowIndex)\n        dynamicProgramming[rowIndex][0][0]= dynamicProgramming[rowIndex][0][1]= grid[rowIndex][0] * dynamicProgramming[rowIndex - 1][0][0];\n\n    for(int columnIndex= 1; columnIndex < columnCount; ++columnIndex)\n        dynamicProgramming[0][columnIndex][0]= dynamicProgramming[0][columnIndex][1]= grid[0][columnIndex] * dynamicProgramming[0][columnIndex - 1][0];\n\n    for(int rowIndex= 1; rowIndex < rowCount; ++rowIndex)\n    {\n        for(int columnIndex= 1; columnIndex < columnCount; ++columnIndex)\n        {\n            if(grid[rowIndex][columnIndex] < 0)\n            {\n                dynamicProgramming[rowIndex][columnIndex][0]= std::min(grid[rowIndex][columnIndex] * dynamicProgramming[rowIndex - 1][columnIndex][1], grid[rowIndex][columnIndex] * dynamicProgramming[rowIndex][columnIndex - 1][1]);\n                dynamicProgramming[rowIndex][columnIndex][1]= std::max(grid[rowIndex][columnIndex] * dynamicProgramming[rowIndex - 1][columnIndex][0], grid[rowIndex][columnIndex] * dynamicProgramming[rowIndex][columnIndex - 1][0]);\n            }\n            else\n            {\n                dynamicProgramming[rowIndex][columnIndex][0]= std::min(grid[rowIndex][columnIndex] * dynamicProgramming[rowIndex - 1][columnIndex][0], grid[rowIndex][columnIndex] * dynamicProgramming[rowIndex][columnIndex - 1][0]);\n                dynamicProgramming[rowIndex][columnIndex][1]= std::max(grid[rowIndex][columnIndex] * dynamicProgramming[rowIndex - 1][columnIndex][1], grid[rowIndex][columnIndex] * dynamicProgramming[rowIndex][columnIndex - 1][1]);\n            }\n        }\n    }\n\n    return dynamicProgramming.back().back()[1] < 0 ? -1 : dynamicProgramming.back().back()[1] % modulus;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint connectTwoGroups(vector<vector<int>> &connectionCost)\n{\n    int group1Size= connectionCost.size(), group2Size= connectionCost[0].size();\n    vector<int> minimumCost(group2Size, INT_MAX);\n\n    for(int group1Index= 0; group1Index < group1Size; group1Index++)\n    {\n        for(int group2Index= 0; group2Index < group2Size; group2Index++)\n        {\n            minimumCost[group2Index]= min(minimumCost[group2Index], connectionCost[group1Index][group2Index]);\n        }\n    }\n\n    int totalCost= 0;\n    for(int group1Index= 0; group1Index < group1Size; group1Index++)\n    {\n        totalCost+= *min_element(connectionCost[group1Index].begin(), connectionCost[group1Index].end());\n    }\n\n    for(int group2Index= 0; group2Index < group2Size; group2Index++)\n    {\n        totalCost+= minimumCost[group2Index];\n    }\n\n    return totalCost;\n}",
    "output": "#include <bits/stdc++.h>\nint connectTwoGroups(std::vector<std::vector<int>> &connectionCost)\n{\n    int group1Size = connectionCost.size(), group2Size = connectionCost[0].size();\n    std::vector<int> minimumCost(group2Size, INT_MAX);\n\n    for(int group1Index = 0; group1Index < group1Size; group1Index++)\n    {\n        for(int group2Index = 0; group2Index < group2Size; group2Index++)\n        {\n            minimumCost[group2Index] = std::min(minimumCost[group2Index], connectionCost[group1Index][group2Index]);\n        }\n    }\n\n    int totalCost = 0;\n    for(int group1Index = 0; group1Index < group1Size; group1Index++)\n    {\n        totalCost += *std::min_element(connectionCost[group1Index].begin(), connectionCost[group1Index].end());\n    }\n\n    for(int group2Index = 0; group2Index < group2Size; group2Index++)\n    {\n        totalCost += minimumCost[group2Index];\n    }\n\n    return totalCost;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// for isdigit\nusing namespace std;\n\nclass Solution\n{\n  public:\n    struct TreeNode\n    {\n        char value;\n        TreeNode *leftChild;\n        TreeNode *rightChild;\n        TreeNode(char x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    };\n\n    TreeNode *createExpressionTree(string expression)\n    {\n        stack<TreeNode *> nodeStack;\n        stack<char> operatorStack;\n        for(int i= 0; i < expression.size(); ++i)\n        {\n            if(isdigit(expression[i]))\n            {\n                nodeStack.push(new TreeNode(expression[i]));\n            }\n            else if(expression[i] == '(')\n            {\n                operatorStack.push(expression[i]);\n            }\n            else if(expression[i] == ')')\n            {\n                while(operatorStack.top() != '(')\n                {\n                    processStacks(nodeStack, operatorStack);\n                }\n                operatorStack.pop();\n            }\n            else\n            {\n                while(!operatorStack.empty() && hasHigherPrecedence(operatorStack.top(), expression[i]))\n                {\n                    processStacks(nodeStack, operatorStack);\n                }\n                operatorStack.push(expression[i]);\n            }\n        }\n        while(!operatorStack.empty())\n        {\n            processStacks(nodeStack, operatorStack);\n        }\n        return nodeStack.top();\n    }\n\n    bool hasHigherPrecedence(char operatorA, char operatorB)\n    {\n        if(operatorA == '(')\n            return false;\n        if(operatorB == '(' || operatorB == ')')\n            return true;\n        if((operatorA == '*' || operatorA == '/') && (operatorB == '+' || operatorB == '-'))\n            return true;\n        return false;\n    }\n\n    void processStacks(stack<TreeNode *> &nodeStack, stack<char> &operatorStack)\n    {\n        TreeNode *rightChild= nodeStack.top();\n        nodeStack.pop();\n        TreeNode *leftChild= nodeStack.top();\n        nodeStack.pop();\n        TreeNode *operatorNode= new TreeNode(operatorStack.top());\n        operatorStack.pop();\n        operatorNode->leftChild= leftChild;\n        operatorNode->rightChild= rightChild;\n        nodeStack.push(operatorNode);\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Solution\n{\n  public:\n    struct TreeNode\n    {\n        char value;\n        TreeNode *leftChild;\n        TreeNode *rightChild;\n        TreeNode(char x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    };\n\n    TreeNode *createExpressionTree(std::string expression)\n    {\n        std::stack<TreeNode *> nodeStack;\n        std::stack<char> operatorStack;\n        for(int i= 0; i < expression.size(); ++i)\n        {\n            if(std::isdigit(expression[i]))\n            {\n                nodeStack.push(new TreeNode(expression[i]));\n            }\n            else if(expression[i] == '(')\n            {\n                operatorStack.push(expression[i]);\n            }\n            else if(expression[i] == ')')\n            {\n                while(operatorStack.top() != '(')\n                {\n                    processStacks(nodeStack, operatorStack);\n                }\n                operatorStack.pop();\n            }\n            else\n            {\n                while(!operatorStack.empty() && hasHigherPrecedence(operatorStack.top(), expression[i]))\n                {\n                    processStacks(nodeStack, operatorStack);\n                }\n                operatorStack.push(expression[i]);\n            }\n        }\n        while(!operatorStack.empty())\n        {\n            processStacks(nodeStack, operatorStack);\n        }\n        return nodeStack.top();\n    }\n\n    bool hasHigherPrecedence(char operatorA, char operatorB)\n    {\n        if(operatorA == '(')\n            return false;\n        if(operatorB == '(' || operatorB == ')')\n            return true;\n        if((operatorA == '*' || operatorA == '/') && (operatorB == '+' || operatorB == '-'))\n            return true;\n        return false;\n    }\n\n    void processStacks(std::stack<TreeNode *> &nodeStack, std::stack<char> &operatorStack)\n    {\n        TreeNode *rightChild= nodeStack.top();\n        nodeStack.pop();\n        TreeNode *leftChild= nodeStack.top();\n        nodeStack.pop();\n        TreeNode *operatorNode= new TreeNode(operatorStack.top());\n        operatorStack.pop();\n        operatorNode->leftChild= leftChild;\n        operatorNode->rightChild= rightChild;\n        nodeStack.push(operatorNode);\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<string> &logEntries)\n{\n    int currentDepth = 0;\n    for (int i = 0; i < logEntries.size(); ++i)\n    {\n        const string &logEntry = logEntries[i];\n        if (logEntry == \"../\")\n        {\n            currentDepth = max(0, currentDepth - 1);\n        }\n        else if (logEntry != \"./\")\n        {\n            currentDepth += 1;\n        }\n    }\n    return currentDepth;\n}",
    "output": "#include <bits/stdc++.h>\nint minOperations(std::vector<std::string> &logEntries)\n{\n    int currentDepth= 0;\n    for(const std::string &logEntry : logEntries)\n    {\n        if(logEntry == \"../\")\n        {\n            currentDepth= std::max(0, currentDepth - 1);\n        }\n        else if(logEntry != \"./\")\n        {\n            currentDepth+= 1;\n        }\n    }\n    return currentDepth;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperationsMaxProfit(vector<int> &customerQueue, int boardingCost, int runningCost)\n{\n    int waitingCustomers= 0;\n    int totalProfit= 0;\n    int maxProfit= 0;\n    int totalRotations= 0;\n    int optimalResult= -1;\n\n    for(int i= 0; i < customerQueue.size() || waitingCustomers > 0; ++i)\n    {\n        if(i < customerQueue.size())\n        {\n            waitingCustomers+= customerQueue[i];\n        }\n        int boardedCustomers= min(waitingCustomers, 4);\n        waitingCustomers-= boardedCustomers;\n        totalProfit+= boardedCustomers * boardingCost - runningCost;\n\n        if(totalProfit > maxProfit)\n        {\n            maxProfit= totalProfit;\n            optimalResult= totalRotations + 1;\n        }\n        totalRotations++;\n    }\n    return optimalResult;\n}",
    "output": "#include <bits/stdc++.h>\n// For std::min\n\nint minOperationsMaxProfit(std::vector<int> &customerQueue, int boardingCost, int runningCost)\n{\n    int waitingCustomers= 0;\n    int totalProfit= 0;\n    int maxProfit= 0;\n    int totalRotations= 0;\n    int optimalResult= -1;\n\n    for(int i= 0; i < customerQueue.size() || waitingCustomers > 0; ++i)\n    {\n        if(i < customerQueue.size())\n        {\n            waitingCustomers+= customerQueue[i];\n        }\n        int boardedCustomers= std::min(waitingCustomers, 4);\n        waitingCustomers-= boardedCustomers;\n        totalProfit+= boardedCustomers * boardingCost - runningCost;\n\n        if(totalProfit > maxProfit)\n        {\n            maxProfit= totalProfit;\n            optimalResult= totalRotations + 1;\n        }\n        totalRotations++;\n    }\n    return optimalResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass ThroneInheritance\n{\n  public:\n    ThroneInheritance(string kingName) : king(kingName) {}\n\n    void birth(string parentName, string childName)\n    {\n        familyTree[parentName].push_back(childName);\n    }\n\n    void death(string name)\n    {\n        deceased.insert(name);\n    }\n\n    vector<string> getInheritanceOrder()\n    {\n        vector<string> inheritanceOrder;\n        dfs(king, inheritanceOrder);\n        return inheritanceOrder;\n    }\n\n  private:\n    void dfs(string name, vector<string> &inheritanceOrder)\n    {\n        if(!deceased.count(name))\n        {\n            inheritanceOrder.push_back(name);\n        }\n        for (int i = 0; i < familyTree[name].size(); ++i)\n        {\n            dfs(familyTree[name][i], inheritanceOrder);\n        }\n    }\n\n    string king;\n    unordered_map<string, vector<string>> familyTree;\n    set<string> deceased;\n};",
    "output": "#include <bits/stdc++.h>\nclass ThroneInheritance\n{\n  public:\n    ThroneInheritance(std::string kingName) : king(kingName) {}\n\n    void birth(std::string parentName, std::string childName)\n    {\n        familyTree[parentName].push_back(childName);\n    }\n\n    void death(std::string name)\n    {\n        deceased.insert(name);\n    }\n\n    std::vector<std::string> getInheritanceOrder()\n    {\n        std::vector<std::string> inheritanceOrder;\n        dfs(king, inheritanceOrder);\n        return inheritanceOrder;\n    }\n\n  private:\n    void dfs(std::string name, std::vector<std::string> &inheritanceOrder)\n    {\n        if(!deceased.count(name))\n        {\n            inheritanceOrder.push_back(name);\n        }\n        for(const auto &child : familyTree[name])\n        {\n            dfs(child, inheritanceOrder);\n        }\n    }\n\n    std::string king;\n    std::unordered_map<std::string, std::vector<std::string>> familyTree;\n    std::set<std::string> deceased;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maximumRequests(int buildingCount, vector<vector<int>> &requests)\n{\n    int requestCount = requests.size();\n    int maxRequests = 0;\n\n    for(int i = 0; i < (1 << requestCount); ++i)\n    {\n        vector<int> netTransfers(buildingCount, 0);\n        int acceptedRequestCount = 0;\n\n        for(int j = 0; j < requestCount; ++j)\n        {\n            if(i & (1 << j))\n            {\n                netTransfers[requests[j][0]]--;\n                netTransfers[requests[j][1]]++;\n                acceptedRequestCount++;\n            }\n        }\n\n        bool isValid = true;\n        for(int j = 0; j < netTransfers.size(); ++j)\n        {\n            if(netTransfers[j])\n            {\n                isValid = false;\n                break;\n            }\n        }\n\n        if(isValid)\n            maxRequests = max(maxRequests, acceptedRequestCount);\n    }\n\n    return maxRequests;\n}",
    "output": "#include <bits/stdc++.h>\nint maximumRequests(int buildingCount, std::vector<std::vector<int>> &requests)\n{\n    int requestCount= requests.size();\n    int maxRequests= 0;\n\n    for(int i= 0; i < (1 << requestCount); ++i)\n    {\n        std::vector<int> netTransfers(buildingCount, 0);\n        int acceptedRequestCount= 0;\n\n        for(int j= 0; j < requestCount; ++j)\n        {\n            if(i & (1 << j))\n            {\n                netTransfers[requests[j][0]]--;\n                netTransfers[requests[j][1]]++;\n                acceptedRequestCount++;\n            }\n        }\n\n        bool isValid= true;\n        for(int transfer : netTransfers)\n        {\n            if(transfer)\n            {\n                isValid= false;\n                break;\n            }\n        }\n\n        if(isValid)\n            maxRequests= std::max(maxRequests, acceptedRequestCount);\n    }\n\n    return maxRequests;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *findNearestRightNode(TreeNode *rootNode, TreeNode *targetNode)\n{\n    if(!rootNode)\n        return NULL;\n\n    queue<TreeNode *> nodeQueue;\n    nodeQueue.push(rootNode);\n\n    while(!nodeQueue.empty())\n    {\n        int currentLevelSize= nodeQueue.size();\n\n        for(int i= 0; i < currentLevelSize; i++)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n\n            if(currentNode == targetNode)\n            {\n                return i < currentLevelSize - 1 ? nodeQueue.front() : NULL;\n            }\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n    }\n\n    return NULL;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *findNearestRightNode(TreeNode *rootNode, TreeNode *targetNode)\n{\n    if(!rootNode)\n        return NULL;\n\n    std::queue<TreeNode *> nodeQueue;\n    nodeQueue.push(rootNode);\n\n    while(!nodeQueue.empty())\n    {\n        int currentLevelSize= nodeQueue.size();\n\n        for(int i= 0; i < currentLevelSize; i++)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n\n            if(currentNode == targetNode)\n            {\n                return i < currentLevelSize - 1 ? nodeQueue.front() : NULL;\n            }\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n    }\n\n    return NULL;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> runningSum(vector<int> &numberList)\n{\n    for(int index= 1; index < numberList.size(); index++)\n    {\n        numberList[index]+= numberList[index - 1];\n    }\n    return numberList;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> runningSum(std::vector<int> &numberList)\n{\n    for(int index= 1; index < numberList.size(); index++)\n    {\n        numberList[index]+= numberList[index - 1];\n    }\n    return numberList;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findLeastNumOfUniqueInts(vector<int> &inputArray, int removalCount)\n{\n    unordered_map<int, int> frequencyMap;\n    for(int i = 0; i < inputArray.size(); ++i)\n    {\n        frequencyMap[inputArray[i]]++;\n    }\n\n    priority_queue<int, vector<int>, greater<int>> minFrequencyHeap;\n    for(auto it = frequencyMap.begin(); it != frequencyMap.end(); ++it)\n    {\n        minFrequencyHeap.push(it->second);\n    }\n\n    while(removalCount > 0 && !minFrequencyHeap.empty())\n    {\n        removalCount -= minFrequencyHeap.top();\n        minFrequencyHeap.pop();\n    }\n\n    return removalCount == 0 ? minFrequencyHeap.size() : minFrequencyHeap.size() + 1;\n}",
    "output": "#include <bits/stdc++.h>\nint findLeastNumOfUniqueInts(std::vector<int> &inputArray, int removalCount)\n{\n    std::unordered_map<int, int> frequencyMap;\n    for(int currentNumber : inputArray)\n    {\n        frequencyMap[currentNumber]++;\n    }\n\n    std::priority_queue<int, std::vector<int>, std::greater<int>> minFrequencyHeap;\n    for(const auto &frequencyEntry : frequencyMap)\n    {\n        minFrequencyHeap.push(frequencyEntry.second);\n    }\n\n    while(removalCount > 0)\n    {\n        removalCount-= minFrequencyHeap.top();\n        minFrequencyHeap.pop();\n    }\n\n    return removalCount == 0 ? minFrequencyHeap.size() : minFrequencyHeap.size() + 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minDays(vector<int> &bloomDay, int requiredBouquets, int flowersPerBouquet)\n{\n    int left = *min_element(bloomDay.begin(), bloomDay.end());\n    int right = *max_element(bloomDay.begin(), bloomDay.end());\n\n    while (left < right)\n    {\n        int mid = left + (right - left) / 2;\n        int bouquets = 0, flowers = 0;\n        for (int j = 0; j < bloomDay.size(); ++j)\n        {\n            int day = bloomDay[j];\n            if (day > mid)\n            {\n                flowers = 0;\n            }\n            else\n            {\n                flowers++;\n                if (flowers == flowersPerBouquet)\n                {\n                    bouquets++;\n                    flowers = 0;\n                }\n            }\n        }\n        if (bouquets >= requiredBouquets)\n        {\n            right = mid;\n        }\n        else\n        {\n            left = mid + 1;\n        }\n    }\n\n    return requiredBouquets == 0 ? -1 : left;\n}",
    "output": "#include <bits/stdc++.h>\nint minDays(std::vector<int> &bloomDay, int requiredBouquets, int flowersPerBouquet)\n{\n    int left= *std::min_element(bloomDay.begin(), bloomDay.end());\n    int right= *std::max_element(bloomDay.begin(), bloomDay.end());\n\n    while(left < right)\n    {\n        int mid= left + (right - left) / 2;\n        int bouquets= 0, flowers= 0;\n        for(int day : bloomDay)\n        {\n            if(day > mid)\n            {\n                flowers= 0;\n            }\n            else\n            {\n                flowers++;\n                if(flowers == flowersPerBouquet)\n                {\n                    bouquets++;\n                    flowers= 0;\n                }\n            }\n        }\n        if(bouquets >= requiredBouquets)\n        {\n            right= mid;\n        }\n        else\n        {\n            left= mid + 1;\n        }\n    }\n\n    return requiredBouquets == 0 ? -1 : left;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findBusiestServers(int totalServers, vector<int> &arrivalTimes, vector<int> &loadTimes)\n{\n    vector<int> serverStatus(totalServers, -1); // -1 means available\n    vector<int> serverRequestCount(totalServers, 0);\n\n    for(int requestIndex= 0; requestIndex < arrivalTimes.size(); requestIndex++)\n    {\n        int serverIndex= requestIndex % totalServers;\n        for(int j= 0; j < totalServers; j++)\n        {\n            if(serverStatus[serverIndex] <= arrivalTimes[requestIndex])\n            {\n                serverStatus[serverIndex]= arrivalTimes[requestIndex] + loadTimes[requestIndex];\n                serverRequestCount[serverIndex]++;\n                break;\n            }\n            serverIndex= (serverIndex + 1) % totalServers;\n        }\n    }\n\n    int maxRequests= *max_element(serverRequestCount.begin(), serverRequestCount.end());\n    vector<int> busiestServers;\n    for(int i= 0; i < totalServers; i++)\n    {\n        if(serverRequestCount[i] == maxRequests)\n        {\n            busiestServers.push_back(i);\n        }\n    }\n    return busiestServers;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findBusiestServers(int totalServers, std::vector<int> &arrivalTimes, std::vector<int> &loadTimes)\n{\n    std::vector<int> serverStatus(totalServers, -1); // -1 means available\n    std::vector<int> serverRequestCount(totalServers, 0);\n\n    for(int requestIndex= 0; requestIndex < arrivalTimes.size(); requestIndex++)\n    {\n        int serverIndex= requestIndex % totalServers;\n        for(int j= 0; j < totalServers; j++)\n        {\n            if(serverStatus[serverIndex] <= arrivalTimes[requestIndex])\n            {\n                serverStatus[serverIndex]= arrivalTimes[requestIndex] + loadTimes[requestIndex];\n                serverRequestCount[serverIndex]++;\n                break;\n            }\n            serverIndex= (serverIndex + 1) % totalServers;\n        }\n    }\n\n    int maxRequests= *std::max_element(serverRequestCount.begin(), serverRequestCount.end());\n    std::vector<int> busiestServers;\n    for(int i= 0; i < totalServers; i++)\n    {\n        if(serverRequestCount[i] == maxRequests)\n        {\n            busiestServers.push_back(i);\n        }\n    }\n    return busiestServers;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint specialArray(vector<int> &numbers)\n{\n    int maximumValue = *max_element(numbers.begin(), numbers.end());\n    for(int currentValue = 1; currentValue <= maximumValue; ++currentValue)\n    {\n        int count = 0;\n        for(int j = 0; j < numbers.size(); ++j)\n        {\n            int number = numbers[j];\n            if(number >= currentValue)\n                count++;\n        }\n        if(count == currentValue)\n            return currentValue;\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint specialArray(std::vector<int> &numbers)\n{\n    int maximumValue = *std::max_element(numbers.begin(), numbers.end());\n    for(int currentValue = 1; currentValue <= maximumValue; ++currentValue)\n    {\n        int count = 0;\n        for(int number : numbers)\n        {\n            if(number >= currentValue)\n                count++;\n        }\n        if(count == currentValue)\n            return currentValue;\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For using numeric_limits\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nusing namespace std;\n\nbool isEvenOddTree(TreeNode *root)\n{\n    if(!root)\n        return false;\n\n    queue<TreeNode *> nodeQueue;\n    nodeQueue.push(root);\n    int currentLevel= 0;\n\n    while(!nodeQueue.empty())\n    {\n        int levelSize= nodeQueue.size();\n        int previousValue= (currentLevel % 2 == 0) ? 0 : numeric_limits<int>::max();\n\n        for(int i= 0; i < levelSize; ++i)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n\n            if((currentLevel % 2 == 0 && (currentNode->value % 2 == 0 || currentNode->value <= previousValue)) ||\n               (currentLevel % 2 != 0 && (currentNode->value % 2 != 0 || currentNode->value >= previousValue)))\n            {\n                return false;\n            }\n\n            previousValue= currentNode->value;\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n\n        currentLevel++;\n    }\n\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nbool isEvenOddTree(TreeNode *root)\n{\n    if(!root)\n        return false;\n\n    std::queue<TreeNode *> nodeQueue;\n    nodeQueue.push(root);\n    int currentLevel= 0;\n\n    while(!nodeQueue.empty())\n    {\n        int levelSize= nodeQueue.size();\n        int previousValue= (currentLevel % 2 == 0) ? 0 : 1e6 + 1;\n\n        for(int i= 0; i < levelSize; ++i)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n\n            if((currentLevel % 2 == 0 && (currentNode->value % 2 == 0 || currentNode->value <= previousValue)) ||\n               (currentLevel % 2 != 0 && (currentNode->value % 2 != 0 || currentNode->value >= previousValue)))\n            {\n                return false;\n            }\n\n            previousValue= currentNode->value;\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n\n        currentLevel++;\n    }\n\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int xorOperation(int elementCount, int startValue)\n{\n    int xorResult= 0;\n    for(int index= 0; index < elementCount; ++index)\n    {\n        xorResult^= (startValue + 2 * index);\n    }\n    return xorResult;\n}",
    "output": "int xorOperation(int elementCount, int startValue)\n{\n    int xorResult= 0;\n    for(int index= 0; index < elementCount; ++index)\n    {\n        xorResult^= (startValue + 2 * index);\n    }\n    return xorResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> getFolderNames(vector<string> &folderNames)\n{\n    unordered_map<string, int> nameCount;\n    vector<string> uniqueFolderNames;\n\n    for (int i = 0; i < folderNames.size(); ++i)\n    {\n        const auto &currentName = folderNames[i];\n        if (nameCount[currentName] == 0)\n        {\n            uniqueFolderNames.push_back(currentName);\n            nameCount[currentName] = 1;\n        }\n        else\n        {\n            int suffixIndex = nameCount[currentName];\n            while (nameCount[currentName + \"(\" + to_string(suffixIndex) + \")\"] != 0)\n            {\n                suffixIndex++;\n            }\n            uniqueFolderNames.push_back(currentName + \"(\" + to_string(suffixIndex) + \")\");\n            nameCount[currentName + \"(\" + to_string(suffixIndex) + \")\"] = 1;\n            nameCount[currentName] = suffixIndex + 1;\n        }\n    }\n\n    return uniqueFolderNames;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> getFolderNames(std::vector<std::string> &folderNames)\n{\n    std::unordered_map<std::string, int> nameCount;\n    std::vector<std::string> uniqueFolderNames;\n\n    for(const auto &currentName : folderNames)\n    {\n        if(nameCount[currentName] == 0)\n        {\n            uniqueFolderNames.push_back(currentName);\n            nameCount[currentName]= 1;\n        }\n        else\n        {\n            int suffixIndex= nameCount[currentName];\n            while(nameCount[currentName + \"(\" + std::to_string(suffixIndex) + \")\"] != 0)\n            {\n                suffixIndex++;\n            }\n            uniqueFolderNames.push_back(currentName + \"(\" + std::to_string(suffixIndex) + \")\");\n            nameCount[currentName + \"(\" + std::to_string(suffixIndex) + \")\"]= 1;\n            nameCount[currentName]= suffixIndex + 1;\n        }\n    }\n\n    return uniqueFolderNames;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> avoidFlood(vector<int> &rainDays)\n{\n    vector<int> result(rainDays.size(), -1);\n    unordered_map<int, int> filledLakes;\n    set<int> dryDays;\n\n    for(int dayIndex = 0; dayIndex < rainDays.size(); ++dayIndex)\n    {\n        if(rainDays[dayIndex] == 0)\n        {\n            dryDays.insert(dayIndex);\n        }\n        else\n        {\n            int currentLake = rainDays[dayIndex];\n            if(filledLakes.count(currentLake))\n            {\n                auto it = dryDays.lower_bound(filledLakes[currentLake]);\n                if(it == dryDays.end())\n                    return {};\n                result[*it] = currentLake;\n                dryDays.erase(it);\n            }\n            filledLakes[currentLake] = dayIndex;\n        }\n    }\n\n    for (int i = 0; i < dryDays.size(); ++i)\n    {\n        result[*std::next(dryDays.begin(), i)] = 1;\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> avoidFlood(std::vector<int> &rainDays)\n{\n    std::vector<int> result(rainDays.size(), -1);\n    std::unordered_map<int, int> filledLakes;\n    std::set<int> dryDays;\n\n    for(int dayIndex= 0; dayIndex < rainDays.size(); ++dayIndex)\n    {\n        if(rainDays[dayIndex] == 0)\n        {\n            dryDays.insert(dayIndex);\n        }\n        else\n        {\n            int currentLake= rainDays[dayIndex];\n            if(filledLakes.count(currentLake))\n            {\n                auto it= dryDays.lower_bound(filledLakes[currentLake]);\n                if(it == dryDays.end())\n                    return {};\n                result[*it]= currentLake;\n                dryDays.erase(it);\n            }\n            filledLakes[currentLake]= dayIndex;\n        }\n    }\n\n    for(int dryDay : dryDays)\n    {\n        result[dryDay]= 1;\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxDepth(string inputString)\n{\n    int currentDepth = 0, maximumDepth = 0;\n\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentCharacter = inputString[i];\n        if (currentCharacter == '(')\n        {\n            currentDepth++;\n            maximumDepth = max(currentDepth, maximumDepth);\n        }\n        else if (currentCharacter == ')')\n        {\n            currentDepth--;\n        }\n    }\n\n    return maximumDepth;\n}",
    "output": "int maxDepth(std::string inputString)\n{\n    int currentDepth= 0, maximumDepth= 0;\n\n    for(char currentCharacter : inputString)\n    {\n        if(currentCharacter == '(')\n        {\n            currentDepth++;\n            maximumDepth= std::max(currentDepth, maximumDepth);\n        }\n        else if(currentCharacter == ')')\n        {\n            currentDepth--;\n        }\n    }\n\n    return maximumDepth;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateRangeSum(vector<int> &numberList, int totalNumbers, int leftIndex, int rightIndex)\n{\n    const int modulo= 1e9 + 7;\n    vector<int> prefixSums(totalNumbers * (totalNumbers + 1) / 2);\n    int currentIndex= 0;\n    for(int startIndex= 0; startIndex < totalNumbers; ++startIndex)\n    {\n        int currentSum= 0;\n        for(int endIndex= startIndex; endIndex < totalNumbers; ++endIndex)\n        {\n            currentSum+= numberList[endIndex];\n            prefixSums[currentIndex++]= currentSum;\n        }\n    }\n    sort(prefixSums.begin(), prefixSums.end());\n    int totalResult= 0;\n    for(int i= leftIndex - 1; i < rightIndex; ++i)\n    {\n        totalResult= (totalResult + prefixSums[i]) % modulo;\n    }\n    return totalResult;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateRangeSum(std::vector<int> &numberList, int totalNumbers, int leftIndex, int rightIndex)\n{\n    const int modulo= 1e9 + 7;\n    std::vector<int> prefixSums(totalNumbers * (totalNumbers + 1) / 2);\n    int currentIndex= 0;\n    for(int startIndex= 0; startIndex < totalNumbers; ++startIndex)\n    {\n        int currentSum= 0;\n        for(int endIndex= startIndex; endIndex < totalNumbers; ++endIndex)\n        {\n            currentSum+= numberList[endIndex];\n            prefixSums[currentIndex++]= currentSum;\n        }\n    }\n    std::sort(prefixSums.begin(), prefixSums.end());\n    int totalResult= 0;\n    for(int i= leftIndex - 1; i < rightIndex; ++i)\n    {\n        totalResult= (totalResult + prefixSums[i]) % modulo;\n    }\n    return totalResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minDifference(vector<int> &numberList)\n{\n    int listSize= numberList.size();\n    if(listSize < 5)\n        return 0;\n\n    sort(numberList.begin(), numberList.end());\n\n    return min({numberList[listSize - 1] - numberList[3],\n                numberList[listSize - 2] - numberList[2],\n                numberList[listSize - 3] - numberList[1],\n                numberList[listSize - 4] - numberList[0]});\n}",
    "output": "#include <bits/stdc++.h>\nint minDifference(std::vector<int> &numberList)\n{\n    int listSize= numberList.size();\n    if(listSize < 5)\n        return 0;\n\n    std::sort(numberList.begin(), numberList.end());\n\n    return std::min({numberList[listSize - 1] - numberList[3],\n                     numberList[listSize - 2] - numberList[2],\n                     numberList[listSize - 3] - numberList[1],\n                     numberList[listSize - 4] - numberList[0]});\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool winnerSquareGame(int total)\n{\n    vector<bool> dp(total + 1, false);\n    for(int current= 1; current <= total; ++current)\n    {\n        for(int square= 1; square * square <= current; ++square)\n        {\n            if(!dp[current - square * square])\n            {\n                dp[current]= true;\n                break;\n            }\n        }\n    }\n    return dp[total];\n}",
    "output": "#include <bits/stdc++.h>\nbool winnerSquareGame(int total)\n{\n    std::vector<bool> dp(total + 1, false);\n    for(int current= 1; current <= total; ++current)\n    {\n        for(int square= 1; square * square <= current; ++square)\n        {\n            if(!dp[current - square * square])\n            {\n                dp[current]= true;\n                break;\n            }\n        }\n    }\n    return dp[total];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass FontInfo {\npublic:\n    int getHeight(int fontSize) { /* implementation */ }\n    int getWidth(int fontSize, char character) { /* implementation */ }\n};\n\nint maxFontSize(string text, int maxWidth, int maxHeight, vector<int> &fontSizes, FontInfo fontInformation)\n{\n    int left = 0, right = fontSizes.size() - 1, mid, result = -1;\n    while (left <= right)\n    {\n        mid = left + (right - left) / 2;\n        int fontSize = fontSizes[mid];\n        int totalWidth = 0, totalHeight = fontInformation.getHeight(fontSize);\n        \n        for (int i = 0; i < text.size(); ++i)\n        {\n            char character = text[i];\n            totalWidth += fontInformation.getWidth(fontSize, character);\n        }\n        \n        if (totalWidth <= maxWidth && totalHeight <= maxHeight)\n        {\n            result = fontSize;\n            left = mid + 1;\n        }\n        else\n        {\n            right = mid - 1;\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nint maxFontSize(std::string text, int maxWidth, int maxHeight, std::vector<int> &fontSizes, FontInfo fontInformation)\n{\n    int left= 0, right= fontSizes.size() - 1, mid, result= -1;\n    while(left <= right)\n    {\n        mid= left + (right - left) / 2;\n        int fontSize= fontSizes[mid];\n        int totalWidth= 0, totalHeight= fontInformation.getHeight(fontSize);\n        for(char character : text)\n            totalWidth+= fontInformation.getWidth(fontSize, character);\n        if(totalWidth <= maxWidth && totalHeight <= maxHeight)\n        {\n            result= fontSize;\n            left= mid + 1;\n        }\n        else\n        {\n            right= mid - 1;\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPathCrossing(string path)\n{\n    set<pair<int, int>> visitedPositions;\n    int currentX = 0, currentY = 0;\n    visitedPositions.insert({currentX, currentY});\n    \n    for (int i = 0; i < path.size(); ++i)\n    {\n        char direction = path[i];\n        if (direction == 'N')\n            currentY++;\n        else if (direction == 'S')\n            currentY--;\n        else if (direction == 'E')\n            currentX++;\n        else if (direction == 'W')\n            currentX--;\n        \n        if (visitedPositions.count({currentX, currentY}))\n            return true;\n        \n        visitedPositions.insert({currentX, currentY});\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool isPathCrossing(std::string path)\n{\n    std::set<std::pair<int, int>> visitedPositions;\n    int currentX= 0, currentY= 0;\n    visitedPositions.insert({currentX, currentY});\n    for(char direction : path)\n    {\n        if(direction == 'N')\n            currentY++;\n        else if(direction == 'S')\n            currentY--;\n        else if(direction == 'E')\n            currentX++;\n        else if(direction == 'W')\n            currentX--;\n        if(visitedPositions.count({currentX, currentY}))\n            return true;\n        visitedPositions.insert({currentX, currentY});\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canArrange(vector<int> &numbers, int divisor)\n{\n    vector<int> remainderCounts(divisor, 0);\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        remainderCounts[(number % divisor + divisor) % divisor]++;\n    }\n    if (remainderCounts[0] % 2 != 0)\n    {\n        return false;\n    }\n    for (int i = 1; i <= divisor / 2; i++)\n    {\n        if (remainderCounts[i] != remainderCounts[divisor - i])\n        {\n            return false;\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool canArrange(std::vector<int> &numbers, int divisor)\n{\n    std::vector<int> remainderCounts(divisor, 0);\n    for(int number : numbers)\n    {\n        remainderCounts[(number % divisor + divisor) % divisor]++;\n    }\n    if(remainderCounts[0] % 2 != 0)\n    {\n        return false;\n    }\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(remainderCounts[i] != remainderCounts[divisor - i])\n        {\n            return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numSubseq(vector<int> &numberArray, int target)\n{\n    int arraySize = numberArray.size();\n    int modulus = 1e9 + 7;\n\n    sort(numberArray.begin(), numberArray.end());\n\n    vector<long long> powerOfTwo(arraySize, 1);\n    for(int index = 1; index < arraySize; ++index)\n    {\n        powerOfTwo[index] = (powerOfTwo[index - 1] * 2) % modulus;\n    }\n\n    int result = 0;\n    int rightIndex = arraySize;\n    for(int leftIndex = 0; leftIndex < arraySize; ++leftIndex)\n    {\n        while(rightIndex > leftIndex && numberArray[leftIndex] + numberArray[rightIndex - 1] > target)\n        {\n            --rightIndex;\n        }\n\n        result = (result + powerOfTwo[rightIndex - leftIndex]) % modulus;\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nint numSubseq(std::vector<int> &numberArray, int target)\n{\n    int arraySize= numberArray.size();\n    int modulus= 1e9 + 7;\n\n    std::sort(numberArray.begin(), numberArray.end());\n\n    std::vector<long long> powerOfTwo(arraySize, 1);\n    for(int index= 1; index < arraySize; ++index)\n    {\n        powerOfTwo[index]= (powerOfTwo[index - 1] * 2) % modulus;\n    }\n\n    int result= 0;\n    int rightIndex= arraySize;\n    for(int leftIndex= 0; leftIndex < arraySize; ++leftIndex)\n    {\n        while(rightIndex > leftIndex && numberArray[leftIndex] + numberArray[rightIndex - 1] > target)\n        {\n            --rightIndex;\n        }\n\n        result= (result + powerOfTwo[rightIndex - leftIndex]) % modulus;\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMaxValueOfEquation(vector<vector<int>> &points, int maxDistance)\n{\n    int maxValue = INT_MIN, leftIndex = 0;\n    vector<pair<int, int>> deque;\n\n    for (int i = 0; i < points.size(); ++i)\n    {\n        auto &point = points[i];\n        while (!deque.empty() && point[0] - deque.front().second > maxDistance)\n            deque.erase(deque.begin());\n\n        if (!deque.empty())\n            maxValue = max(maxValue, point[1] + point[0] + deque.front().first);\n\n        while (!deque.empty() && point[1] - point[0] >= deque.back().first)\n            deque.pop_back();\n\n        deque.emplace_back(point[1] - point[0], point[0]);\n    }\n\n    return maxValue;\n}",
    "output": "#include <bits/stdc++.h>\nint findMaxValueOfEquation(std::vector<std::vector<int>> &points, int maxDistance)\n{\n    int maxValue = std::numeric_limits<int>::min(), leftIndex = 0;\n    std::vector<std::pair<int, int>> deque;\n\n    for(auto &point : points)\n    {\n        while(!deque.empty() && point[0] - deque.front().second > maxDistance)\n            deque.erase(deque.begin());\n\n        if(!deque.empty())\n            maxValue = std::max(maxValue, point[1] + point[0] + deque.front().first);\n\n        while(!deque.empty() && point[1] - point[0] >= deque.back().first)\n            deque.pop_back();\n\n        deque.emplace_back(point[1] - point[0], point[0]);\n    }\n\n    return maxValue;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxLengthBetweenEqualCharacters(string inputString)\n{\n    int maxLength = -1;\n    unordered_map<char, int> characterIndexMap;\n\n    for(int currentIndex = 0; currentIndex < inputString.length(); ++currentIndex)\n    {\n        if(characterIndexMap.find(inputString[currentIndex]) == characterIndexMap.end())\n        {\n            characterIndexMap[inputString[currentIndex]] = currentIndex;\n        }\n        else\n        {\n            maxLength = max(maxLength, currentIndex - characterIndexMap[inputString[currentIndex]] - 1);\n        }\n    }\n    return maxLength;\n}",
    "output": "int maxLengthBetweenEqualCharacters(std::string inputString)\n{\n    int maxLength= -1;\n    std::unordered_map<char, int> characterIndexMap;\n\n    for(int currentIndex= 0; currentIndex < inputString.length(); ++currentIndex)\n    {\n        if(characterIndexMap.find(inputString[currentIndex]) == characterIndexMap.end())\n        {\n            characterIndexMap[inputString[currentIndex]]= currentIndex;\n        }\n        else\n        {\n            maxLength= std::max(maxLength, currentIndex - characterIndexMap[inputString[currentIndex]] - 1);\n        }\n    }\n    return maxLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring findLexSmallestString(string inputString, int incrementValue, int rotationValue)\n{\n    string lexicographicallySmallestString = inputString;\n    int stringLength = inputString.length();\n    string rotatedString;\n\n    for (int index = 0; index < stringLength; index += 2)\n    {\n        for (int incrementIndex = 0; incrementIndex < 10; ++incrementIndex)\n        {\n            rotatedString = inputString.substr(stringLength - rotationValue) + inputString.substr(0, stringLength - rotationValue);\n            string tempString = rotatedString;\n\n            for (int tempIndex = 1; tempIndex < stringLength; tempIndex += 2)\n                tempString[tempIndex] = '0' + (tempString[tempIndex] - '0' + incrementValue) % 10;\n\n            lexicographicallySmallestString = min(lexicographicallySmallestString, tempString);\n            inputString = rotatedString;\n        }\n        inputString[stringLength - index - 1] = '0' + (inputString[stringLength - index - 1] - '0' + incrementValue) % 10;\n    }\n\n    return lexicographicallySmallestString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string findLexSmallestString(std::string inputString, int incrementValue, int rotationValue)\n{\n    std::string lexicographicallySmallestString= inputString;\n    int stringLength= inputString.length();\n    std::string rotatedString;\n\n    for(int index= 0; index < stringLength; index+= 2)\n    {\n        for(int incrementIndex= 0; incrementIndex < 10; ++incrementIndex)\n        {\n            rotatedString= inputString.substr(stringLength - rotationValue) + inputString.substr(0, stringLength - rotationValue);\n            std::string tempString= rotatedString;\n\n            for(int tempIndex= 1; tempIndex < stringLength; tempIndex+= 2)\n                tempString[tempIndex]= '0' + (tempString[tempIndex] - '0' + incrementValue) % 10;\n\n            lexicographicallySmallestString= std::min(lexicographicallySmallestString, tempString);\n            inputString= rotatedString;\n        }\n        inputString[stringLength - index - 1]= '0' + (inputString[stringLength - index - 1] - '0' + incrementValue) % 10;\n    }\n\n    return lexicographicallySmallestString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canMakeArithmeticProgression(vector<int> &numberArray)\n{\n    sort(numberArray.begin(), numberArray.end());\n    int commonDifference= numberArray[1] - numberArray[0];\n    for(int index= 2; index < numberArray.size(); index++)\n    {\n        if(numberArray[index] - numberArray[index - 1] != commonDifference)\n        {\n            return false;\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool canMakeArithmeticProgression(std::vector<int> &numberArray)\n{\n    std::sort(numberArray.begin(), numberArray.end());\n    int commonDifference = numberArray[1] - numberArray[0];\n    for(int index = 2; index < numberArray.size(); index++)\n    {\n        if(numberArray[index] - numberArray[index - 1] != commonDifference)\n        {\n            return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// for max and min functions\nusing namespace std;\n\nint lastMoment(int totalPositions, vector<int> &leftPositions, vector<int> &rightPositions)\n{\n    int farthestLeft = 0;\n    int nearestRight = totalPositions;\n\n    for (int i = 0; i < leftPositions.size(); ++i)\n    {\n        farthestLeft = max(farthestLeft, leftPositions[i]);\n    }\n\n    for (int i = 0; i < rightPositions.size(); ++i)\n    {\n        nearestRight = min(nearestRight, rightPositions[i]);\n    }\n\n    return max(farthestLeft, totalPositions - nearestRight);\n}",
    "output": "#include <bits/stdc++.h>\nint lastMoment(int totalPositions, std::vector<int> &leftPositions, std::vector<int> &rightPositions)\n{\n    int farthestLeft= 0;\n    int nearestRight= totalPositions;\n\n    for(int position : leftPositions)\n    {\n        farthestLeft= std::max(farthestLeft, position);\n    }\n\n    for(int position : rightPositions)\n    {\n        nearestRight= std::min(nearestRight, position);\n    }\n\n    return std::max(farthestLeft, totalPositions - nearestRight);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countSubmatricesWithAllOnes(vector<vector<int>> &matrix)\n{\n    int rowCount= matrix.size(), columnCount= matrix[0].size();\n    vector<vector<int>> widths(rowCount, vector<int>(columnCount));\n    int totalCount= 0;\n\n    for(int rowIndex= 0; rowIndex < rowCount; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < columnCount; colIndex++)\n        {\n            if(matrix[rowIndex][colIndex] == 1)\n            {\n                widths[rowIndex][colIndex]= (colIndex == 0) ? 1 : widths[rowIndex][colIndex - 1] + 1;\n                int minWidth= widths[rowIndex][colIndex];\n                for(int heightIndex= rowIndex; heightIndex >= 0; heightIndex--)\n                {\n                    minWidth= min(minWidth, widths[heightIndex][colIndex]);\n                    totalCount+= minWidth;\n                }\n            }\n        }\n    }\n    return totalCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countSubmatricesWithAllOnes(std::vector<std::vector<int>> &matrix)\n{\n    int rowCount = matrix.size(), columnCount = matrix[0].size();\n    std::vector<std::vector<int>> widths(rowCount, std::vector<int>(columnCount));\n    int totalCount = 0;\n\n    for(int rowIndex = 0; rowIndex < rowCount; rowIndex++)\n    {\n        for(int colIndex = 0; colIndex < columnCount; colIndex++)\n        {\n            if(matrix[rowIndex][colIndex] == 1)\n            {\n                widths[rowIndex][colIndex] = (colIndex == 0) ? 1 : widths[rowIndex][colIndex - 1] + 1;\n                int minWidth = widths[rowIndex][colIndex];\n                for(int heightIndex = rowIndex; heightIndex >= 0; heightIndex--)\n                {\n                    minWidth = std::min(minWidth, widths[heightIndex][colIndex]);\n                    totalCount += minWidth;\n                }\n            }\n        }\n    }\n    return totalCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring minInteger(string number, int swaps)\n{\n    if(swaps == 0)\n        return number;\n    int length= number.size();\n    for(int currentIndex= 0; currentIndex < length; ++currentIndex)\n    {\n        int minIndex= currentIndex;\n        for(int j= currentIndex + 1; j < length && j - currentIndex <= swaps; ++j)\n        {\n            if(number[j] < number[minIndex])\n            {\n                minIndex= j;\n            }\n        }\n        char minDigit= number[minIndex];\n        for(int j= minIndex; j > currentIndex; --j)\n        {\n            number[j]= number[j - 1];\n        }\n        number[currentIndex]= minDigit;\n        swaps-= minIndex - currentIndex;\n    }\n    return number;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string minInteger(std::string number, int swaps)\n{\n    if(swaps == 0)\n        return number;\n    int length = number.size();\n    for(int currentIndex = 0; currentIndex < length; ++currentIndex)\n    {\n        int minIndex = currentIndex;\n        for(int j = currentIndex + 1; j < length && j - currentIndex <= swaps; ++j)\n        {\n            if(number[j] < number[minIndex])\n            {\n                minIndex = j;\n            }\n        }\n        char minDigit = number[minIndex];\n        for(int j = minIndex; j > currentIndex; --j)\n        {\n            number[j] = number[j - 1];\n        }\n        number[currentIndex] = minDigit;\n        swaps -= minIndex - currentIndex;\n    }\n    return number;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int countOdds(int lowerBound, int upperBound)\n{\n    return (upperBound + 1) / 2 - lowerBound / 2;\n}",
    "output": "int countOdds(int lowerBound, int upperBound)\n{\n    return (upperBound + 1) / 2 - lowerBound / 2;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countOfSubarrays(vector<int> &inputArray)\n{\n    int oddCount = 0, evenCount = 1, currentSum = 0, totalResult = 0;\n    int modulus = 1e9 + 7;\n    for (int i = 0; i < inputArray.size(); ++i)\n    {\n        int element = inputArray[i];\n        currentSum = (currentSum + element) % 2;\n        if (currentSum % 2 == 0)\n        {\n            evenCount++;\n        }\n        else\n        {\n            oddCount++;\n        }\n        totalResult = (totalResult + oddCount) % modulus;\n    }\n    return totalResult;\n}",
    "output": "#include <bits/stdc++.h>\nint countOfSubarrays(std::vector<int> &inputArray)\n{\n    int oddCount= 0, evenCount= 1, currentSum= 0, totalResult= 0;\n    int modulus= 1e9 + 7;\n    for(int element : inputArray)\n    {\n        currentSum= (currentSum + element) % 2;\n        if(currentSum % 2 == 0)\n        {\n            evenCount++;\n        }\n        else\n        {\n            oddCount++;\n        }\n        totalResult= (totalResult + oddCount) % modulus;\n    }\n    return totalResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numSplits(string inputString)\n{\n    unordered_set<char> uniqueCharsLeft, uniqueCharsRight;\n    vector<int> uniqueCountLeft(inputString.size()), uniqueCountRight(inputString.size());\n    int validSplitsCount= 0;\n\n    for(int index= 0; index < inputString.size(); ++index)\n    {\n        uniqueCharsLeft.insert(inputString[index]);\n        uniqueCountLeft[index]= uniqueCharsLeft.size();\n    }\n\n    for(int index= inputString.size() - 1; index > 0; --index)\n    {\n        uniqueCharsRight.insert(inputString[index]);\n        uniqueCountRight[index]= uniqueCharsRight.size();\n    }\n\n    for(int index= 0; index < inputString.size() - 1; ++index)\n    {\n        if(uniqueCountLeft[index] == uniqueCountRight[index + 1])\n        {\n            ++validSplitsCount;\n        }\n    }\n\n    return validSplitsCount;\n}",
    "output": "#include <bits/stdc++.h>\nint numSplits(std::string inputString)\n{\n    std::unordered_set<char> uniqueCharsLeft, uniqueCharsRight;\n    std::vector<int> uniqueCountLeft(inputString.size()), uniqueCountRight(inputString.size());\n    int validSplitsCount = 0;\n\n    for(int index = 0; index < inputString.size(); ++index)\n    {\n        uniqueCharsLeft.insert(inputString[index]);\n        uniqueCountLeft[index] = uniqueCharsLeft.size();\n    }\n\n    for(int index = inputString.size() - 1; index > 0; --index)\n    {\n        uniqueCharsRight.insert(inputString[index]);\n        uniqueCountRight[index] = uniqueCharsRight.size();\n    }\n\n    for(int index = 0; index < inputString.size() - 1; ++index)\n    {\n        if(uniqueCountLeft[index] == uniqueCountRight[index + 1])\n        {\n            ++validSplitsCount;\n        }\n    }\n\n    return validSplitsCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class PolynomialNode\n{\n  public:\n    int coefficient, power;\n    PolynomialNode *next;\n    PolynomialNode(int c, int p) : coefficient(c), power(p), next(NULL) {}\n};\n\nPolynomialNode *addPolynomial(PolynomialNode *firstPolynomial, PolynomialNode *secondPolynomial)\n{\n    PolynomialNode *dummyNode= new PolynomialNode(0, 0);\n    PolynomialNode *currentNode= dummyNode;\n\n    while(firstPolynomial && secondPolynomial)\n    {\n        if(firstPolynomial->power > secondPolynomial->power)\n        {\n            currentNode->next= firstPolynomial;\n            firstPolynomial= firstPolynomial->next;\n        }\n        else if(firstPolynomial->power < secondPolynomial->power)\n        {\n            currentNode->next= secondPolynomial;\n            secondPolynomial= secondPolynomial->next;\n        }\n        else\n        {\n            int sum= firstPolynomial->coefficient + secondPolynomial->coefficient;\n            if(sum != 0)\n            {\n                currentNode->next= new PolynomialNode(sum, firstPolynomial->power);\n                currentNode= currentNode->next;\n            }\n            firstPolynomial= firstPolynomial->next;\n            secondPolynomial= secondPolynomial->next;\n        }\n        currentNode= currentNode->next;\n    }\n\n    if(firstPolynomial)\n    {\n        currentNode->next= firstPolynomial;\n    }\n    else\n    {\n        currentNode->next= secondPolynomial;\n    }\n    return dummyNode->next;\n}",
    "output": "class PolynomialNode\n{\n  public:\n    int coefficient, power;\n    PolynomialNode *next;\n    PolynomialNode(int c, int p) : coefficient(c), power(p), next(NULL) {}\n};\n\nPolynomialNode *addPolynomial(PolynomialNode *firstPolynomial, PolynomialNode *secondPolynomial)\n{\n    PolynomialNode *dummyNode= new PolynomialNode(0, 0);\n    PolynomialNode *currentNode= dummyNode;\n\n    while(firstPolynomial && secondPolynomial)\n    {\n        if(firstPolynomial->power > secondPolynomial->power)\n        {\n            currentNode->next= firstPolynomial;\n            firstPolynomial= firstPolynomial->next;\n        }\n        else if(firstPolynomial->power < secondPolynomial->power)\n        {\n            currentNode->next= secondPolynomial;\n            secondPolynomial= secondPolynomial->next;\n        }\n        else\n        {\n            int sum= firstPolynomial->coefficient + secondPolynomial->coefficient;\n            if(sum != 0)\n            {\n                currentNode->next= new PolynomialNode(sum, firstPolynomial->power);\n                currentNode= currentNode->next;\n            }\n            firstPolynomial= firstPolynomial->next;\n            secondPolynomial= secondPolynomial->next;\n        }\n        currentNode= currentNode->next;\n    }\n\n    if(firstPolynomial)\n    {\n        currentNode->next= firstPolynomial;\n    }\n    else\n    {\n        currentNode->next= secondPolynomial;\n    }\n    return dummyNode->next;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countSubstrings(string binaryString)\n{\n    int modulus = 1000000007;\n    long long substringCount = 0;\n    int consecutiveOnesCount = 0;\n    for (int i = 0; i < binaryString.size(); ++i)\n    {\n        char character = binaryString[i];\n        consecutiveOnesCount = (character == '1') ? consecutiveOnesCount + 1 : 0;\n        substringCount = (substringCount + consecutiveOnesCount) % modulus;\n    }\n    return substringCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countSubstrings(std::string binaryString)\n{\n    int modulus= 1000000007;\n    long long substringCount= 0;\n    int consecutiveOnesCount= 0;\n    for(char character : binaryString)\n    {\n        consecutiveOnesCount= (character == '1') ? consecutiveOnesCount + 1 : 0;\n        substringCount= (substringCount + consecutiveOnesCount) % modulus;\n    }\n    return substringCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minLengthEncoded(const string &inputString, int maxReplacements)\n{\n    int stringLength = inputString.length();\n    vector<vector<int>> dynamicProgrammingTable(stringLength + 1, vector<int>(maxReplacements + 1, 0));\n\n    for(int currentIndex = 1; currentIndex <= stringLength; ++currentIndex)\n    {\n        for(int replacementCount = 0; replacementCount <= maxReplacements; ++replacementCount)\n        {\n            int characterCount = 1;\n            dynamicProgrammingTable[currentIndex][replacementCount] = currentIndex - replacementCount;\n            for(int previousIndex = currentIndex - 2; previousIndex >= 0 && currentIndex - 2 - previousIndex <= replacementCount; --previousIndex)\n            {\n                if(inputString[previousIndex] == inputString[currentIndex - 1])\n                    characterCount++;\n                else\n                    characterCount = 1;\n                int usedReplacements = currentIndex - 2 - previousIndex;\n                int newPosition = currentIndex - 1 - characterCount - usedReplacements + 1;\n                if(characterCount >= 100)\n                    newPosition += 4;\n                else if(characterCount >= 10)\n                    newPosition += 3;\n                else if(characterCount >= 2)\n                    newPosition += 2;\n                else\n                    newPosition++;\n                dynamicProgrammingTable[currentIndex][replacementCount] = min(dynamicProgrammingTable[currentIndex][replacementCount], newPosition + dynamicProgrammingTable[previousIndex][replacementCount - usedReplacements]);\n            }\n        }\n    }\n    return dynamicProgrammingTable[stringLength][maxReplacements];\n}",
    "output": "#include <bits/stdc++.h>\nint minLengthEncoded(const std::string &inputString, int maxReplacements)\n{\n    int stringLength= inputString.length();\n    std::vector<std::vector<int>> dynamicProgrammingTable(stringLength + 1, std::vector<int>(maxReplacements + 1, 0));\n\n    for(int currentIndex= 1; currentIndex <= stringLength; ++currentIndex)\n    {\n        for(int replacementCount= 0; replacementCount <= maxReplacements; ++replacementCount)\n        {\n            int characterCount= 1;\n            dynamicProgrammingTable[currentIndex][replacementCount]= currentIndex - replacementCount;\n            for(int previousIndex= currentIndex - 2; previousIndex >= 0 && currentIndex - 2 - previousIndex <= replacementCount; --previousIndex)\n            {\n                if(inputString[previousIndex] == inputString[currentIndex - 1])\n                    characterCount++;\n                else\n                    characterCount= 1;\n                int usedReplacements= currentIndex - 2 - previousIndex;\n                int newPosition= currentIndex - 1 - characterCount - usedReplacements + 1;\n                if(characterCount >= 100)\n                    newPosition+= 4;\n                else if(characterCount >= 10)\n                    newPosition+= 3;\n                else if(characterCount >= 2)\n                    newPosition+= 2;\n                else\n                    newPosition++;\n                dynamicProgrammingTable[currentIndex][replacementCount]= std::min(dynamicProgrammingTable[currentIndex][replacementCount], newPosition + dynamicProgrammingTable[previousIndex][replacementCount - usedReplacements]);\n            }\n        }\n    }\n    return dynamicProgrammingTable[stringLength][maxReplacements];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble getMinDistSum(vector<vector<int>> &positionCoordinates)\n{\n    double sumX = 0;\n    double sumY = 0;\n    for (int i = 0; i < positionCoordinates.size(); ++i)\n    {\n        const auto &position = positionCoordinates[i];\n        sumX += position[0];\n        sumY += position[1];\n    }\n    int numberOfPositions = positionCoordinates.size();\n    sumX /= numberOfPositions;\n    sumY /= numberOfPositions;\n    return sumX;\n}",
    "output": "#include <bits/stdc++.h>\ndouble getMinDistSum(std::vector<std::vector<int>> &positionCoordinates)\n{\n    double sumX= 0;\n    double sumY= 0;\n    for(const auto &position : positionCoordinates)\n    {\n        sumX+= position[0];\n        sumY+= position[1];\n    }\n    int numberOfPositions= positionCoordinates.size();\n    sumX/= numberOfPositions;\n    sumY/= numberOfPositions;\n    return sumX;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numWays(vector<string> &wordList, string target)\n{\n    int wordCount = wordList.size(), targetLength = target.size();\n    vector<vector<int>> characterCount(wordCount, vector<int>(26, 0));\n    vector<vector<int>> dynamicProgramming(targetLength, vector<int>(wordCount, 0));\n    const int modulus = 1e9 + 7;\n\n    for (int wordIndex = 0; wordIndex < wordCount; wordIndex++)\n    {\n        for (int characterIndex = 0; characterIndex < wordList[wordIndex].size(); characterIndex++)\n        {\n            char character = wordList[wordIndex][characterIndex];\n            characterCount[wordIndex][character - 'a']++;\n        }\n    }\n\n    for (int wordIndex = 0; wordIndex < wordCount; wordIndex++)\n    {\n        dynamicProgramming[0][wordIndex] = characterCount[wordIndex][target[0] - 'a'];\n    }\n\n    for (int targetIndex = 1; targetIndex < targetLength; targetIndex++)\n    {\n        for (int wordIndex = 0; wordIndex < wordCount; wordIndex++)\n        {\n            for (int previousWordIndex = 0; previousWordIndex < wordCount; previousWordIndex++)\n            {\n                dynamicProgramming[targetIndex][wordIndex] = (dynamicProgramming[targetIndex][wordIndex] +\n                                                             (long long)dynamicProgramming[targetIndex - 1][previousWordIndex] * characterCount[wordIndex][target[targetIndex] - 'a']) %\n                                                            modulus;\n            }\n        }\n    }\n\n    int result = 0;\n    for (int wordIndex = 0; wordIndex < wordCount; wordIndex++)\n    {\n        result = (result + dynamicProgramming[targetLength - 1][wordIndex]) % modulus;\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::unordered_map<std::string, int> numWays(std::vector<std::string> &wordList, std::string target)\n{\n    int wordCount = wordList.size(), targetLength = target.size();\n    std::vector<std::vector<int>> characterCount(wordCount, std::vector<int>(26, 0));\n    std::vector<std::vector<int>> dynamicProgramming(targetLength, std::vector<int>(wordCount, 0));\n    const int modulus = 1e9 + 7;\n\n    for(int wordIndex = 0; wordIndex < wordCount; wordIndex++)\n    {\n        for(char character : wordList[wordIndex])\n        {\n            characterCount[wordIndex][character - 'a']++;\n        }\n    }\n\n    for(int wordIndex = 0; wordIndex < wordCount; wordIndex++)\n    {\n        dynamicProgramming[0][wordIndex] = characterCount[wordIndex][target[0] - 'a'];\n    }\n\n    for(int targetIndex = 1; targetIndex < targetLength; targetIndex++)\n    {\n        for(int wordIndex = 0; wordIndex < wordCount; wordIndex++)\n        {\n            for(int previousWordIndex = 0; previousWordIndex < wordCount; previousWordIndex++)\n            {\n                dynamicProgramming[targetIndex][wordIndex] = (dynamicProgramming[targetIndex][wordIndex] +\n                                                             (long long)dynamicProgramming[targetIndex - 1][previousWordIndex] * characterCount[wordIndex][target[targetIndex] - 'a']) %\n                                                            modulus;\n            }\n        }\n    }\n\n    int result = 0;\n    for(int wordIndex = 0; wordIndex < wordCount; wordIndex++)\n    {\n        result = (result + dynamicProgramming[targetLength - 1][wordIndex]) % modulus;\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canFormArray(vector<int> &targetArray, vector<vector<int>> &pieces)\n{\n    unordered_map<int, vector<int>> pieceMap;\n    for (int i = 0; i < pieces.size(); ++i)\n    {\n        pieceMap[pieces[i][0]] = pieces[i];\n    }\n\n    int currentIndex = 0;\n    while (currentIndex < targetArray.size())\n    {\n        if (pieceMap.find(targetArray[currentIndex]) == pieceMap.end())\n        {\n            return false;\n        }\n        vector<int> &currentPiece = pieceMap[targetArray[currentIndex]];\n        for (int j = 0; j < currentPiece.size(); ++j)\n        {\n            if (currentPiece[j] != targetArray[currentIndex])\n            {\n                return false;\n            }\n            ++currentIndex;\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool canFormArray(std::vector<int> &targetArray, std::vector<std::vector<int>> &pieces)\n{\n    std::unordered_map<int, std::vector<int>> pieceMap;\n    for(auto &piece : pieces)\n    {\n        pieceMap[piece[0]]= piece;\n    }\n\n    int currentIndex= 0;\n    while(currentIndex < targetArray.size())\n    {\n        if(pieceMap.find(targetArray[currentIndex]) == pieceMap.end())\n        {\n            return false;\n        }\n        std::vector<int> &currentPiece= pieceMap[targetArray[currentIndex]];\n        for(int j= 0; j < currentPiece.size(); ++j)\n        {\n            if(currentPiece[j] != targetArray[currentIndex])\n            {\n                return false;\n            }\n            ++currentIndex;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countVowelStrings(int length)\n{\n    vector<int> vowelCount= {1, 1, 1, 1, 1};\n    for(int currentLength= 2; currentLength <= length; currentLength++)\n    {\n        for(int index= 3; index >= 0; index--)\n        {\n            vowelCount[index]= vowelCount[index] + vowelCount[index + 1];\n        }\n    }\n    return accumulate(vowelCount.begin(), vowelCount.end(), 0);\n}",
    "output": "#include <bits/stdc++.h>\nint countVowelStrings(int length)\n{\n    std::vector<int> vowelCount= {1, 1, 1, 1, 1};\n    for(int currentLength= 2; currentLength <= length; currentLength++)\n    {\n        for(int index= 3; index >= 0; index--)\n        {\n            vowelCount[index]= vowelCount[index] + vowelCount[index + 1];\n        }\n    }\n    return std::accumulate(vowelCount.begin(), vowelCount.end(), 0);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int maxWaterBottles(int totalBottles, int exchangeRate)\n{\n    int totalDrunk= totalBottles;\n    while(totalBottles >= exchangeRate)\n    {\n        int newBottles= totalBottles / exchangeRate;\n        totalDrunk+= newBottles;\n        totalBottles= newBottles + totalBottles % exchangeRate;\n    }\n    return totalDrunk;\n}",
    "output": "int maxWaterBottles(int totalBottles, int exchangeRate)\n{\n    int totalDrunk= totalBottles;\n    while(totalBottles >= exchangeRate)\n    {\n        int newBottles= totalBottles / exchangeRate;\n        totalDrunk+= newBottles;\n        totalBottles= newBottles + totalBottles % exchangeRate;\n    }\n    return totalDrunk;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(int currentNode, const vector<vector<int>> &graph, const string &labels, vector<int> &result, vector<int> &labelCount)\n{\n    int previousCount = labelCount[labels[currentNode] - 'a'];\n    labelCount[labels[currentNode] - 'a']++;\n    result[currentNode] = labelCount[labels[currentNode] - 'a'] - previousCount;\n\n    for (int i = 0; i < graph[currentNode].size(); ++i)\n    {\n        int childNode = graph[currentNode][i];\n        depthFirstSearch(childNode, graph, labels, result, labelCount);\n    }\n\n    labelCount[labels[currentNode] - 'a'] = previousCount;\n}\n\nvector<int> countSubTrees(int nodeCount, vector<vector<int>> &edges, string labels)\n{\n    vector<vector<int>> graph(nodeCount);\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        const auto &edge = edges[i];\n        graph[edge[1]].push_back(edge[0]);\n    }\n    vector<int> result(nodeCount);\n    vector<int> labelCount(26);\n    depthFirstSearch(0, graph, labels, result, labelCount);\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nvoid depthFirstSearch(int currentNode, const std::vector<std::vector<int>> &graph, const std::string &labels, std::vector<int> &result, std::vector<int> &labelCount)\n{\n    int previousCount= labelCount[labels[currentNode] - 'a'];\n    labelCount[labels[currentNode] - 'a']++;\n    result[currentNode]= labelCount[labels[currentNode] - 'a'] - previousCount;\n\n    for(auto childNode : graph[currentNode])\n    {\n        depthFirstSearch(childNode, graph, labels, result, labelCount);\n    }\n\n    labelCount[labels[currentNode] - 'a']= previousCount;\n}\n\nstd::vector<int> countSubTrees(int nodeCount, std::vector<std::vector<int>> &edges, std::string labels)\n{\n    std::vector<std::vector<int>> graph(nodeCount);\n    for(const auto &edge : edges)\n    {\n        graph[edge[1]].push_back(edge[0]);\n    }\n    std::vector<int> result(nodeCount);\n    std::vector<int> labelCount(26);\n    depthFirstSearch(0, graph, labels, result, labelCount);\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> maxNumOfSubstrings(string inputString)\n{\n    vector<int> lastOccurrence(26, -1);\n    for(int currentIndex= 0; currentIndex < (int)inputString.size(); ++currentIndex)\n    {\n        lastOccurrence[inputString[currentIndex] - 'a']= currentIndex;\n    }\n\n    vector<string> resultSubstrings;\n    int previousIndex= -1, maxRightIndex= -1;\n    for(int currentIndex= 0; currentIndex < (int)inputString.size(); ++currentIndex)\n    {\n        maxRightIndex= max(maxRightIndex, lastOccurrence[inputString[currentIndex] - 'a']);\n        if(maxRightIndex == currentIndex)\n        {\n            resultSubstrings.push_back(inputString.substr(previousIndex + 1, maxRightIndex - previousIndex));\n            previousIndex= currentIndex;\n        }\n    }\n\n    return resultSubstrings;\n}",
    "output": "std::vector<std::string> maxNumOfSubstrings(std::string inputString)\n{\n    std::vector<int> lastOccurrence(26, -1);\n    for(int currentIndex= 0; currentIndex < (int)inputString.size(); ++currentIndex)\n    {\n        lastOccurrence[inputString[currentIndex] - 'a']= currentIndex;\n    }\n\n    std::vector<std::string> resultSubstrings;\n    int previousIndex= -1, maxRightIndex= -1;\n    for(int currentIndex= 0; currentIndex < (int)inputString.size(); ++currentIndex)\n    {\n        maxRightIndex= std::max(maxRightIndex, lastOccurrence[inputString[currentIndex] - 'a']);\n        if(maxRightIndex == currentIndex)\n        {\n            resultSubstrings.push_back(inputString.substr(previousIndex + 1, maxRightIndex - previousIndex));\n            previousIndex= currentIndex;\n        }\n    }\n\n    return resultSubstrings;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findKthPositive(vector<int> &sortedArray, int kth)\n{\n    int index= 0, currentNumber= 1;\n    while(kth > 0)\n    {\n        if(index < sortedArray.size() && sortedArray[index] == currentNumber)\n        {\n            index++;\n        }\n        else\n        {\n            kth--;\n        }\n        currentNumber++;\n    }\n    return currentNumber - 1;\n}",
    "output": "#include <bits/stdc++.h>\nint findKthPositive(std::vector<int> &sortedArray, int kth)\n{\n    int index= 0, currentNumber= 1;\n    while(kth > 0)\n    {\n        if(index < sortedArray.size() && sortedArray[index] == currentNumber)\n        {\n            index++;\n        }\n        else\n        {\n            kth--;\n        }\n        currentNumber++;\n    }\n    return currentNumber - 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canConvert(string sourceString, string targetString, int maxOperations)\n{\n    int totalDifference= 0;\n    for(int index= 0; index < sourceString.length(); index++)\n    {\n        int currentDifference= (targetString[index] - sourceString[index] + 26) % 26;\n        if(currentDifference > 0)\n        {\n            totalDifference+= currentDifference;\n            maxOperations-= currentDifference;\n        }\n    }\n    return maxOperations >= 0 && maxOperations >= totalDifference - sourceString.length() && maxOperations % 26 == 0;\n}",
    "output": "#include <bits/stdc++.h>\nbool canConvert(std::string sourceString, std::string targetString, int maxOperations)\n{\n    int totalDifference= 0;\n    for(int index= 0; index < sourceString.length(); index++)\n    {\n        int currentDifference= (targetString[index] - sourceString[index] + 26) % 26;\n        if(currentDifference > 0)\n        {\n            totalDifference+= currentDifference;\n            maxOperations-= currentDifference;\n        }\n    }\n    return maxOperations >= 0 && maxOperations >= totalDifference - sourceString.length() && maxOperations % 26 == 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumInsertions(string parenthesesString)\n{\n    int totalInsertions= 0, currentDepth= 0;\n    for(int index= 0; index < parenthesesString.size(); ++index)\n    {\n        if(parenthesesString[index] == '(')\n        {\n            currentDepth+= 2;\n        }\n        else\n        {\n            if(parenthesesString[index - 1] == '(')\n            {\n                --currentDepth;\n            }\n            else\n            {\n                currentDepth-= 2;\n            }\n            if(currentDepth < 0)\n            {\n                totalInsertions-= currentDepth;\n                currentDepth= 0;\n            }\n        }\n    }\n    return totalInsertions + currentDepth;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMinimumInsertions(std::string parenthesesString)\n{\n    int totalInsertions= 0, currentDepth= 0;\n    for(int index= 0; index < parenthesesString.size(); ++index)\n    {\n        if(parenthesesString[index] == '(')\n        {\n            currentDepth+= 2;\n        }\n        else\n        {\n            if(parenthesesString[index - 1] == '(')\n            {\n                --currentDepth;\n            }\n            else\n            {\n                currentDepth-= 2;\n            }\n            if(currentDepth < 0)\n            {\n                totalInsertions-= currentDepth;\n                currentDepth= 0;\n            }\n        }\n    }\n    return totalInsertions + currentDepth;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNonOverlapping(vector<int> &numberList, int targetSum)\n{\n    int currentSum = 0, nonOverlappingCount = 0;\n    unordered_map<int, int> sumMap;\n    sumMap[0] = 1;\n    \n    for (int i = 0; i < numberList.size(); ++i)\n    {\n        int currentNumber = numberList[i];\n        currentSum += currentNumber;\n        if (sumMap[currentSum - targetSum])\n        {\n            nonOverlappingCount++;\n            sumMap.clear();\n            sumMap[0] = 1;\n            currentSum = 0;\n        }\n        else\n        {\n            sumMap[currentSum]++;\n        }\n    }\n    return nonOverlappingCount;\n}",
    "output": "#include <bits/stdc++.h>\nint maxNonOverlapping(std::vector<int> &numberList, int targetSum)\n{\n    int currentSum= 0, nonOverlappingCount= 0;\n    std::unordered_map<int, int> sumMap;\n    sumMap[0]= 1;\n    for(int currentNumber : numberList)\n    {\n        currentSum+= currentNumber;\n        if(sumMap[currentSum - targetSum])\n        {\n            nonOverlappingCount++;\n            sumMap.clear();\n            sumMap[0]= 1;\n            currentSum= 0;\n        }\n        else\n        {\n            sumMap[currentSum]++;\n        }\n    }\n    return nonOverlappingCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class Node\n{\n  public:\n    int value;\n    Node *leftChild;\n    Node *rightChild;\n    Node *parentNode;\n};\n\nNode *lowestCommonAncestor(Node *firstNode, Node *secondNode)\n{\n    Node *currentNodeA= firstNode;\n    Node *currentNodeB= secondNode;\n    while(currentNodeA != currentNodeB)\n    {\n        currentNodeA= currentNodeA->parentNode ? currentNodeA->parentNode : secondNode;\n        currentNodeB= currentNodeB->parentNode ? currentNodeB->parentNode : firstNode;\n    }\n    return currentNodeA;\n}",
    "output": "class Node\n{\n  public:\n    int value;\n    Node *leftChild;\n    Node *rightChild;\n    Node *parentNode;\n};\n\nNode *lowestCommonAncestor(Node *firstNode, Node *secondNode)\n{\n    Node *currentNodeA= firstNode;\n    Node *currentNodeB= secondNode;\n    while(currentNodeA != currentNodeB)\n    {\n        currentNodeA= currentNodeA->parentNode ? currentNodeA->parentNode : secondNode;\n        currentNodeB= currentNodeB->parentNode ? currentNodeB->parentNode : firstNode;\n    }\n    return currentNodeA;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(string target)\n{\n    int operationCount = 0;\n    char currentBit = '0';\n    for (int i = 0; i < target.size(); ++i)\n    {\n        char bit = target[i];\n        if (bit != currentBit)\n        {\n            operationCount++;\n            currentBit = bit;\n        }\n    }\n    return operationCount;\n}",
    "output": "#include <bits/stdc++.h>\nint minOperations(std::string target)\n{\n    int operationCount= 0;\n    char currentBit= '0';\n    for(char bit : target)\n    {\n        if(bit != currentBit)\n        {\n            operationCount++;\n            currentBit= bit;\n        }\n    }\n    return operationCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nint depthFirstSearch(TreeNode *currentNode, int maxDistance, vector<int> &depths)\n{\n    if(!currentNode)\n        return 0;\n    if(!currentNode->left && !currentNode->right)\n    {\n        depths.push_back(0);\n        return 1;\n    }\n    vector<int> leftDepths, rightDepths;\n    int pairCount = depthFirstSearch(currentNode->left, maxDistance, leftDepths) + depthFirstSearch(currentNode->right, maxDistance, rightDepths);\n    \n    for (int i = 0; i < leftDepths.size(); ++i)\n    {\n        for (int j = 0; j < rightDepths.size(); ++j)\n        {\n            if (leftDepths[i] + rightDepths[j] + 2 <= maxDistance)\n                pairCount++;\n        }\n    }\n    \n    for (int i = 0; i < leftDepths.size(); ++i)\n        depths.push_back(leftDepths[i] + 1);\n    for (int i = 0; i < rightDepths.size(); ++i)\n        depths.push_back(rightDepths[i] + 1);\n    \n    return pairCount;\n}\n\nint countPairs(TreeNode *root, int maxDistance)\n{\n    vector<int> depths;\n    return depthFirstSearch(root, maxDistance, depths);\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nint depthFirstSearch(TreeNode *currentNode, int maxDistance, std::vector<int> &depths)\n{\n    if(!currentNode)\n        return 0;\n    if(!currentNode->left && !currentNode->right)\n    {\n        depths.push_back(0);\n        return 1;\n    }\n    std::vector<int> leftDepths, rightDepths;\n    int pairCount= depthFirstSearch(currentNode->left, maxDistance, leftDepths) + depthFirstSearch(currentNode->right, maxDistance, rightDepths);\n    for(int left : leftDepths)\n    {\n        for(int right : rightDepths)\n        {\n            if(left + right + 2 <= maxDistance)\n                pairCount++;\n        }\n    }\n    for(int left : leftDepths)\n        depths.push_back(left + 1);\n    for(int right : rightDepths)\n        depths.push_back(right + 1);\n    return pairCount;\n}\n\nint countPairs(TreeNode *root, int maxDistance)\n{\n    std::vector<int> depths;\n    return depthFirstSearch(root, maxDistance, depths);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumJumps(vector<int> &forbiddenPositions, int forwardJump, int backwardJump, int targetPosition)\n{\n    set<pair<int, int>> visitedPositions;\n    set<int> forbiddenSet(forbiddenPositions.begin(), forbiddenPositions.end());\n    queue<pair<int, pair<int, int>>> positionQueue;\n    positionQueue.push({0, {0, 0}});\n    visitedPositions.insert({0, 0});\n    while(!positionQueue.empty())\n    {\n        auto [currentPosition, stepStatus]= positionQueue.front();\n        positionQueue.pop();\n        int steps= stepStatus.first;\n        int backwardStatus= stepStatus.second;\n        if(currentPosition == targetPosition)\n            return steps;\n        int forwardPosition= currentPosition + forwardJump;\n        int backwardPosition= currentPosition - backwardJump;\n        if(forwardPosition <= 6000 && !forbiddenSet.count(forwardPosition) && !visitedPositions.count({forwardPosition, 0}))\n        {\n            visitedPositions.insert({forwardPosition, 0});\n            positionQueue.push({forwardPosition, {steps + 1, 0}});\n        }\n        if(backwardStatus == 0 && backwardPosition > 0 && !forbiddenSet.count(backwardPosition) && !visitedPositions.count({backwardPosition, 1}))\n        {\n            visitedPositions.insert({backwardPosition, 1});\n            positionQueue.push({backwardPosition, {steps + 1, 1}});\n        }\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint minimumJumps(std::vector<int> &forbiddenPositions, int forwardJump, int backwardJump, int targetPosition)\n{\n    std::set<std::pair<int, int>> visitedPositions;\n    std::set<int> forbiddenSet(forbiddenPositions.begin(), forbiddenPositions.end());\n    std::queue<std::pair<int, std::pair<int, int>>> positionQueue;\n    positionQueue.push({0, {0, 0}});\n    visitedPositions.insert({0, 0});\n    while(!positionQueue.empty())\n    {\n        auto [currentPosition, stepStatus]= positionQueue.front();\n        positionQueue.pop();\n        int steps= stepStatus.first;\n        int backwardStatus= stepStatus.second;\n        if(currentPosition == targetPosition)\n            return steps;\n        int forwardPosition= currentPosition + forwardJump;\n        int backwardPosition= currentPosition - backwardJump;\n        if(forwardPosition <= 6000 && !forbiddenSet.count(forwardPosition) && !visitedPositions.count({forwardPosition, 0}))\n        {\n            visitedPositions.insert({forwardPosition, 0});\n            positionQueue.push({forwardPosition, {steps + 1, 0}});\n        }\n        if(backwardStatus == 0 && backwardPosition > 0 && !forbiddenSet.count(backwardPosition) && !visitedPositions.count({backwardPosition, 1}))\n        {\n            visitedPositions.insert({backwardPosition, 1});\n            positionQueue.push({backwardPosition, {steps + 1, 1}});\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canDistribute(vector<int> &itemCounts, vector<int> &quantityNeeded)\n{\n    unordered_map<int, int> itemFrequency;\n    for(int item : itemCounts)\n    {\n        itemFrequency[item]++;\n    }\n\n    vector<int> availableQuantities;\n    for(auto &pair : itemFrequency)\n    {\n        availableQuantities.push_back(pair.second);\n    }\n\n    sort(quantityNeeded.begin(), quantityNeeded.end(), greater<int>());\n\n    auto depthFirstSearch= [&](int currentIndex, vector<int> &availableQuantities)\n    {\n        if(currentIndex == quantityNeeded.size())\n        {\n            return true;\n        }\n        for(int i= 0; i < availableQuantities.size(); ++i)\n        {\n            if(availableQuantities[i] >= quantityNeeded[currentIndex])\n            {\n                availableQuantities[i]-= quantityNeeded[currentIndex];\n                if(depthFirstSearch(currentIndex + 1, availableQuantities))\n                    return true;\n                availableQuantities[i]+= quantityNeeded[currentIndex];\n            }\n        }\n        return false;\n    };\n\n    return depthFirstSearch(0, availableQuantities);\n}",
    "output": "#include <bits/stdc++.h>\nbool canDistribute(std::vector<int> &itemCounts, std::vector<int> &quantityNeeded)\n{\n    std::unordered_map<int, int> itemFrequency;\n    for(int item : itemCounts)\n    {\n        itemFrequency[item]++;\n    }\n\n    std::vector<int> availableQuantities;\n    for(auto &pair : itemFrequency)\n    {\n        availableQuantities.push_back(pair.second);\n    }\n\n    std::sort(quantityNeeded.begin(), quantityNeeded.end(), std::greater<int>());\n\n    auto depthFirstSearch= [&](int currentIndex, std::vector<int> &availableQuantities)\n    {\n        if(currentIndex == quantityNeeded.size())\n        {\n            return true;\n        }\n        for(int i= 0; i < availableQuantities.size(); ++i)\n        {\n            if(availableQuantities[i] >= quantityNeeded[currentIndex])\n            {\n                availableQuantities[i]-= quantityNeeded[currentIndex];\n                if(depthFirstSearch(currentIndex + 1, availableQuantities))\n                    return true;\n                availableQuantities[i]+= quantityNeeded[currentIndex];\n            }\n        }\n        return false;\n    };\n\n    return depthFirstSearch(0, availableQuantities);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countGoodTriplets(vector<int> &inputArray, int differenceA, int differenceB, int differenceC)\n{\n    int tripletCount= 0;\n    for(int firstIndex= 0; firstIndex < inputArray.size(); firstIndex++)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < inputArray.size(); secondIndex++)\n        {\n            if(abs(inputArray[firstIndex] - inputArray[secondIndex]) <= differenceA)\n            {\n                for(int thirdIndex= secondIndex + 1; thirdIndex < inputArray.size(); thirdIndex++)\n                {\n                    if(abs(inputArray[secondIndex] - inputArray[thirdIndex]) <= differenceB && abs(inputArray[firstIndex] - inputArray[thirdIndex]) <= differenceC)\n                    {\n                        tripletCount++;\n                    }\n                }\n            }\n        }\n    }\n    return tripletCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countGoodTriplets(std::vector<int> &inputArray, int differenceA, int differenceB, int differenceC)\n{\n    int tripletCount= 0;\n    for(int firstIndex= 0; firstIndex < inputArray.size(); firstIndex++)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < inputArray.size(); secondIndex++)\n        {\n            if(std::abs(inputArray[firstIndex] - inputArray[secondIndex]) <= differenceA)\n            {\n                for(int thirdIndex= secondIndex + 1; thirdIndex < inputArray.size(); thirdIndex++)\n                {\n                    if(std::abs(inputArray[secondIndex] - inputArray[thirdIndex]) <= differenceB && std::abs(inputArray[firstIndex] - inputArray[thirdIndex]) <= differenceC)\n                    {\n                        tripletCount++;\n                    }\n                }\n            }\n        }\n    }\n    return tripletCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint getWinner(vector<int> &contestants, int consecutiveWinsRequired)\n{\n    int currentWinner= contestants[0];\n    int consecutiveWins= 0;\n\n    for(int i= 1; i < contestants.size(); ++i)\n    {\n        if(contestants[i] > currentWinner)\n        {\n            currentWinner= contestants[i];\n            consecutiveWins= 0;\n        }\n        if(++consecutiveWins == consecutiveWinsRequired)\n        {\n            break;\n        }\n    }\n    return currentWinner;\n}",
    "output": "#include <bits/stdc++.h>\nint getWinner(std::vector<int> &contestants, int consecutiveWinsRequired)\n{\n    int currentWinner= contestants[0];\n    int consecutiveWins= 0;\n\n    for(int i= 1; i < contestants.size(); ++i)\n    {\n        if(contestants[i] > currentWinner)\n        {\n            currentWinner= contestants[i];\n            consecutiveWins= 0;\n        }\n        if(++consecutiveWins == consecutiveWinsRequired)\n        {\n            break;\n        }\n    }\n    return currentWinner;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minSwaps(vector<vector<int>> &grid)\n{\n    int gridSize = grid.size();\n    vector<int> rowZerosCount(gridSize, 0);\n\n    for(int rowIndex = 0; rowIndex < gridSize; ++rowIndex)\n    {\n        for(int columnIndex = gridSize - 1; columnIndex >= 0; --columnIndex)\n        {\n            if(grid[rowIndex][columnIndex] == 0)\n            {\n                rowZerosCount[rowIndex]++;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n\n    int totalSteps = 0;\n    for(int rowIndex = 0; rowIndex < gridSize; ++rowIndex)\n    {\n        int targetZeros = gridSize - rowIndex - 1;\n        int currentRow = rowIndex;\n        while(currentRow < gridSize && rowZerosCount[currentRow] < targetZeros)\n        {\n            currentRow++;\n        }\n        if(currentRow == gridSize)\n        {\n            return -1;\n        }\n        totalSteps += currentRow - rowIndex;\n        rowZerosCount.erase(rowZerosCount.begin() + currentRow);\n        rowZerosCount.insert(rowZerosCount.begin() + rowIndex, targetZeros);\n    }\n    return totalSteps;\n}",
    "output": "int minSwaps(std::vector<std::vector<int>> &grid)\n{\n    int gridSize= grid.size();\n    std::vector<int> rowZerosCount(gridSize, 0);\n\n    for(int rowIndex= 0; rowIndex < gridSize; ++rowIndex)\n    {\n        for(int columnIndex= gridSize - 1; columnIndex >= 0; --columnIndex)\n        {\n            if(grid[rowIndex][columnIndex] == 0)\n            {\n                rowZerosCount[rowIndex]++;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n\n    int totalSteps= 0;\n    for(int rowIndex= 0; rowIndex < gridSize; ++rowIndex)\n    {\n        int targetZeros= gridSize - rowIndex - 1;\n        int currentRow= rowIndex;\n        while(currentRow < gridSize && rowZerosCount[currentRow] < targetZeros)\n        {\n            currentRow++;\n        }\n        if(currentRow == gridSize)\n        {\n            return -1;\n        }\n        totalSteps+= currentRow - rowIndex;\n        rowZerosCount.erase(rowZerosCount.begin() + currentRow);\n        rowZerosCount.insert(rowZerosCount.begin() + rowIndex, targetZeros);\n    }\n    return totalSteps;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSum(vector<int> &firstArray, vector<int> &secondArray)\n{\n    int modulus= 1e9 + 7;\n    int firstSize= firstArray.size(), secondSize= secondArray.size();\n    long firstDp[firstSize + 1]= {0}, secondDp[secondSize + 1]= {0};\n    int firstIndex= firstSize - 1, secondIndex= secondSize - 1;\n    while(firstIndex >= 0 || secondIndex >= 0)\n    {\n        long firstValue= firstIndex >= 0 ? firstDp[firstIndex] + firstArray[firstIndex] : LONG_MIN;\n        long secondValue= secondIndex >= 0 ? secondDp[secondIndex] + secondArray[secondIndex] : LONG_MIN;\n        set<int> seenElements;\n        if(firstValue > secondValue)\n        {\n            firstDp[firstIndex--]= firstValue % modulus;\n            seenElements.insert(firstArray[firstIndex + 1]);\n        }\n        else\n        {\n            secondDp[secondIndex--]= secondValue % modulus;\n            seenElements.insert(secondArray[secondIndex + 1]);\n        }\n    }\n    return max(firstDp[0], secondDp[0]) % modulus;\n}",
    "output": "#include <bits/stdc++.h>\nint maxSum(std::vector<int> &firstArray, std::vector<int> &secondArray)\n{\n    int modulus= 1e9 + 7;\n    int firstSize= firstArray.size(), secondSize= secondArray.size();\n    long firstDp[firstSize + 1]= {0}, secondDp[secondSize + 1]= {0};\n    int firstIndex= firstSize - 1, secondIndex= secondSize - 1;\n    while(firstIndex >= 0 || secondIndex >= 0)\n    {\n        long firstValue= firstIndex >= 0 ? firstDp[firstIndex] + firstArray[firstIndex] : LONG_MIN;\n        long secondValue= secondIndex >= 0 ? secondDp[secondIndex] + secondArray[secondIndex] : LONG_MIN;\n        std::set<int> seenElements;\n        if(firstValue > secondValue)\n        {\n            firstDp[firstIndex--]= firstValue % modulus;\n            seenElements.insert(firstArray[firstIndex + 1]);\n        }\n        else\n        {\n            secondDp[secondIndex--]= secondValue % modulus;\n            seenElements.insert(secondArray[secondIndex + 1]);\n        }\n    }\n    return std::max(firstDp[0], secondDp[0]) % modulus;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring insertThousandSeparator(int number)\n{\n    string formattedNumber = to_string(number);\n    int digitCount = 0;\n    for(int index = formattedNumber.size() - 1; index > 0; --index)\n    {\n        digitCount++;\n        if(digitCount % 3 == 0)\n        {\n            formattedNumber.insert(index, \".\");\n        }\n    }\n    return formattedNumber;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string insertThousandSeparator(int number)\n{\n    std::string formattedNumber= std::to_string(number);\n    int digitCount= 0;\n    for(int index= formattedNumber.size() - 1; index > 0; --index)\n    {\n        digitCount++;\n        if(digitCount % 3 == 0)\n        {\n            formattedNumber.insert(index, \".\");\n        }\n    }\n    return formattedNumber;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumOperations(vector<int> &numbers)\n{\n    int totalOperations = 0;\n    int bitCount[32] = {0};\n    for(int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        for(int bitIndex = 0; bitIndex < 32; ++bitIndex)\n        {\n            if(number & (1 << bitIndex))\n            {\n                bitCount[bitIndex]++;\n            }\n        }\n    }\n    for(int i = 0; i < 32; ++i)\n    {\n        totalOperations = max(totalOperations, bitCount[i]);\n    }\n    return totalOperations + 31;\n}",
    "output": "#include <bits/stdc++.h>\nint minNumOperations(std::vector<int> &numbers)\n{\n    int totalOperations= 0;\n    int bitCount[32]= {0};\n    for(int number : numbers)\n    {\n        for(int bitIndex= 0; bitIndex < 32; ++bitIndex)\n        {\n            if(number & (1 << bitIndex))\n            {\n                bitCount[bitIndex]++;\n            }\n        }\n    }\n    for(int count : bitCount)\n    {\n        totalOperations= std::max(totalOperations, count);\n    }\n    return totalOperations + 31;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool depthFirstSearch(vector<vector<char>> &characterGrid, int currentX, int currentY, int startX, int startY, int searchDepth)\n{\n    if(currentX < 0 || currentY < 0 || currentX >= characterGrid.size() || currentY >= characterGrid[0].size() || characterGrid[currentX][currentY] != characterGrid[startX][startY])\n        return false;\n\n    characterGrid[currentX][currentY] = '*';\n\n    static vector<vector<int>> movementDirections = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    for (int i = 0; i < movementDirections.size(); ++i)\n    {\n        int newX = currentX + movementDirections[i][0];\n        int newY = currentY + movementDirections[i][1];\n\n        if (newX == startX && newY == startY && searchDepth >= 4)\n            return true;\n\n        if (depthFirstSearch(characterGrid, newX, newY, startX, startY, searchDepth + 1))\n            return true;\n    }\n\n    characterGrid[currentX][currentY] = characterGrid[startX][startY];\n\n    return false;\n}\n\nbool containsCycle(vector<vector<char>> &characterGrid)\n{\n    for (int rowIndex = 0; rowIndex < characterGrid.size(); ++rowIndex)\n    {\n        for (int colIndex = 0; colIndex < characterGrid[0].size(); ++colIndex)\n        {\n            if (depthFirstSearch(characterGrid, rowIndex, colIndex, rowIndex, colIndex, 0))\n                return true;\n        }\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool depthFirstSearch(std::vector<std::vector<char>> &characterGrid, int currentX, int currentY, int startX, int startY, int searchDepth)\n{\n    if(currentX < 0 || currentY < 0 || currentX >= characterGrid.size() || currentY >= characterGrid[0].size() || characterGrid[currentX][currentY] != characterGrid[startX][startY])\n        return false;\n\n    characterGrid[currentX][currentY]= '*';\n\n    static std::vector<std::vector<int>> movementDirections= {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    for(auto &direction : movementDirections)\n    {\n        int newX= currentX + direction[0];\n        int newY= currentY + direction[1];\n\n        if(newX == startX && newY == startY && searchDepth >= 4)\n            return true;\n\n        if(depthFirstSearch(characterGrid, newX, newY, startX, startY, searchDepth + 1))\n            return true;\n    }\n\n    characterGrid[currentX][currentY]= characterGrid[startX][startY];\n\n    return false;\n}\n\nbool containsCycle(std::vector<std::vector<char>> &characterGrid)\n{\n    for(int rowIndex= 0; rowIndex < characterGrid.size(); ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex < characterGrid[0].size(); ++colIndex)\n        {\n            if(depthFirstSearch(characterGrid, rowIndex, colIndex, rowIndex, colIndex, 0))\n                return true;\n        }\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countOfFairs(int *numbers, int arraySize)\n{\n    int evenSum= 0, oddSum= 0, leftEvenSum= 0, leftOddSum= 0, fairCount= 0;\n    for(int index= 0; index < arraySize; ++index)\n    {\n        if(index % 2 == 0)\n            evenSum+= numbers[index];\n        else\n            oddSum+= numbers[index];\n    }\n    for(int index= 0; index < arraySize; ++index)\n    {\n        if(index % 2 == 0)\n        {\n            evenSum-= numbers[index];\n            if(leftEvenSum + oddSum == leftOddSum + evenSum)\n                ++fairCount;\n            leftEvenSum+= numbers[index];\n        }\n        else\n        {\n            oddSum-= numbers[index];\n            if(leftEvenSum + oddSum == leftOddSum + evenSum)\n                ++fairCount;\n            leftOddSum+= numbers[index];\n        }\n    }\n    return fairCount;\n}",
    "output": "int countOfFairs(int *numbers, int arraySize)\n{\n    int evenSum= 0, oddSum= 0, leftEvenSum= 0, leftOddSum= 0, fairCount= 0;\n    for(int index= 0; index < arraySize; ++index)\n    {\n        if(index % 2 == 0)\n            evenSum+= numbers[index];\n        else\n            oddSum+= numbers[index];\n    }\n    for(int index= 0; index < arraySize; ++index)\n    {\n        if(index % 2 == 0)\n        {\n            evenSum-= numbers[index];\n            if(leftEvenSum + oddSum == leftOddSum + evenSum)\n                ++fairCount;\n            leftEvenSum+= numbers[index];\n        }\n        else\n        {\n            oddSum-= numbers[index];\n            if(leftEvenSum + oddSum == leftOddSum + evenSum)\n                ++fairCount;\n            leftOddSum+= numbers[index];\n        }\n    }\n    return fairCount;\n}\n"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumEffort(vector<vector<int>> &tasks)\n{\n    sort(tasks.begin(), tasks.end(), [](vector<int> &currentTask, vector<int> &nextTask)\n         { return currentTask[1] - currentTask[0] > nextTask[1] - nextTask[0]; });\n    int maximumEffort = 0, totalEffort = 0;\n    for (int i = 0; i < tasks.size(); ++i)\n    {\n        auto &task = tasks[i];\n        maximumEffort = max(maximumEffort, totalEffort + task[1]);\n        totalEffort += task[0];\n    }\n    return maximumEffort;\n}",
    "output": "#include <bits/stdc++.h>\nint minimumEffort(std::vector<std::vector<int>> &tasks)\n{\n    std::sort(tasks.begin(), tasks.end(), [](std::vector<int> &currentTask, std::vector<int> &nextTask)\n         { return currentTask[1] - currentTask[0] > nextTask[1] - nextTask[0]; });\n    int maximumEffort= 0, totalEffort= 0;\n    for(auto &task : tasks)\n    {\n        maximumEffort= std::max(maximumEffort, totalEffort + task[1]);\n        totalEffort+= task[0];\n    }\n    return maximumEffort;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring makeGood(string inputString)\n{\n    string cleanString;\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentChar = inputString[i];\n        if (!cleanString.empty() && abs(cleanString.back() - currentChar) == 32)\n        {\n            cleanString.pop_back();\n        }\n        else\n        {\n            cleanString.push_back(currentChar);\n        }\n    }\n    return cleanString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string makeGood(std::string inputString)\n{\n    std::string cleanString;\n    for(char currentChar : inputString)\n    {\n        if(!cleanString.empty() && abs(cleanString.back() - currentChar) == 32)\n        {\n            cleanString.pop_back();\n        }\n        else\n        {\n            cleanString.push_back(currentChar);\n        }\n    }\n    return cleanString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint longestAwesomeSubstring(string inputString)\n{\n    int stringLength = inputString.length();\n    int maximumLength = 0;\n    for(int startIndex = 0; startIndex < stringLength; ++startIndex)\n    {\n        for(int endIndex = startIndex + 1; endIndex <= stringLength; ++endIndex)\n        {\n            string substring = inputString.substr(startIndex, endIndex - startIndex);\n            if(isAwesome(substring))\n            {\n                maximumLength = max(maximumLength, endIndex - startIndex);\n            }\n        }\n    }\n    return maximumLength;\n}\n\nbool isAwesome(string inputString)\n{\n    int oddCharacterCount = 0;\n    int characterFrequency[26] = {0};\n    for(int i = 0; i < inputString.length(); ++i)\n    {\n        characterFrequency[inputString[i] - 'a']++;\n    }\n    for(int i = 0; i < 26; i++)\n    {\n        if(characterFrequency[i] % 2 == 1)\n        {\n            oddCharacterCount++;\n        }\n    }\n    return (oddCharacterCount <= 1);\n}",
    "output": "int longestAwesomeSubstring(std::string inputString)\n{\n    int stringLength= inputString.length();\n    int maximumLength= 0;\n    for(int startIndex= 0; startIndex < stringLength; ++startIndex)\n    {\n        for(int endIndex= startIndex + 1; endIndex <= stringLength; ++endIndex)\n        {\n            std::string substring= inputString.substr(startIndex, endIndex - startIndex);\n            if(isAwesome(substring))\n            {\n                maximumLength= std::max(maximumLength, endIndex - startIndex);\n            }\n        }\n    }\n    return maximumLength;\n}\n\nbool isAwesome(std::string inputString)\n{\n    int oddCharacterCount= 0;\n    int characterFrequency[26]= {0};\n    for(char character : inputString)\n    {\n        characterFrequency[character - 'a']++;\n    }\n    for(int i= 0; i < 26; i++)\n    {\n        if(characterFrequency[i] % 2 == 1)\n        {\n            oddCharacterCount++;\n        }\n    }\n    return (oddCharacterCount <= 1);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minCost(int length, vector<int> &cutPositions)\n{\n    cutPositions.push_back(0);\n    cutPositions.push_back(length);\n    sort(cutPositions.begin(), cutPositions.end());\n    int numberOfCuts = cutPositions.size();\n    vector<vector<int>> costDP(numberOfCuts, vector<int>(numberOfCuts, 0));\n\n    for(int segmentLength = 2; segmentLength < numberOfCuts; ++segmentLength)\n    {\n        for(int startIndex = 0; startIndex < numberOfCuts - segmentLength; ++startIndex)\n        {\n            int endIndex = startIndex + segmentLength;\n            costDP[startIndex][endIndex] = INT_MAX;\n            for(int cutIndex = startIndex + 1; cutIndex < endIndex; ++cutIndex)\n            {\n                costDP[startIndex][endIndex] = min(costDP[startIndex][endIndex],\n                                                    costDP[startIndex][cutIndex] +\n                                                    costDP[cutIndex][endIndex] +\n                                                    cutPositions[endIndex] - cutPositions[startIndex]);\n            }\n        }\n    }\n\n    return costDP[0][numberOfCuts - 1];\n}",
    "output": "#include <bits/stdc++.h>\nint minCost(int length, std::vector<int> &cutPositions)\n{\n    cutPositions.push_back(0);\n    cutPositions.push_back(length);\n    std::sort(cutPositions.begin(), cutPositions.end());\n    int numberOfCuts= cutPositions.size();\n    std::vector<std::vector<int>> costDP(numberOfCuts, std::vector<int>(numberOfCuts, 0));\n\n    for(int segmentLength= 2; segmentLength < numberOfCuts; ++segmentLength)\n    {\n        for(int startIndex= 0; startIndex < numberOfCuts - segmentLength; ++startIndex)\n        {\n            int endIndex= startIndex + segmentLength;\n            costDP[startIndex][endIndex]= INT_MAX;\n            for(int cutIndex= startIndex + 1; cutIndex < endIndex; ++cutIndex)\n            {\n                costDP[startIndex][endIndex]= std::min(costDP[startIndex][endIndex],\n                                                       costDP[startIndex][cutIndex] +\n                                                           costDP[cutIndex][endIndex] +\n                                                           cutPositions[endIndex] - cutPositions[startIndex]);\n            }\n        }\n    }\n\n    return costDP[0][numberOfCuts - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass FrontMiddleBackQueue\n{\n    deque<int> frontDeque, backDeque;\n\n  public:\n    FrontMiddleBackQueue()\n    {\n    }\n\n    void pushFront(int value)\n    {\n        frontDeque.push_front(value);\n        if(frontDeque.size() > backDeque.size() + 1)\n        {\n            backDeque.push_front(frontDeque.back());\n            frontDeque.pop_back();\n        }\n    }\n\n    void pushMiddle(int value)\n    {\n        if(frontDeque.size() < backDeque.size())\n        {\n            frontDeque.push_back(value);\n        }\n        else\n        {\n            backDeque.push_front(value);\n        }\n    }\n\n    void pushBack(int value)\n    {\n        backDeque.push_back(value);\n        if(backDeque.size() > frontDeque.size())\n        {\n            frontDeque.push_back(backDeque.front());\n            backDeque.pop_front();\n        }\n    }\n\n    int popFront()\n    {\n        if(frontDeque.empty() && backDeque.empty())\n            return -1;\n        int returnedValue= frontDeque.front();\n        frontDeque.pop_front();\n        if(frontDeque.size() + 1 < backDeque.size())\n        {\n            frontDeque.push_back(backDeque.front());\n            backDeque.pop_front();\n        }\n        return returnedValue;\n    }\n\n    int popMiddle()\n    {\n        if(frontDeque.empty() && backDeque.empty())\n            return -1;\n        int returnedValue;\n        if(frontDeque.size() < backDeque.size())\n        {\n            returnedValue= backDeque.front();\n            backDeque.pop_front();\n        }\n        else\n        {\n            returnedValue= frontDeque.back();\n            frontDeque.pop_back();\n        }\n        if(backDeque.size() > frontDeque.size())\n        {\n            frontDeque.push_back(backDeque.front());\n            backDeque.pop_front();\n        }\n        return returnedValue;\n    }\n\n    int popBack()\n    {\n        if(frontDeque.empty() && backDeque.empty())\n            return -1;\n        int returnedValue= backDeque.back();\n        backDeque.pop_back();\n        if(frontDeque.size() > backDeque.size() + 1)\n        {\n            backDeque.push_front(frontDeque.back());\n            frontDeque.pop_back();\n        }\n        return returnedValue;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass FrontMiddleBackQueue\n{\n    std::deque<int> frontDeque, backDeque;\n\n  public:\n    FrontMiddleBackQueue()\n    {\n    }\n\n    void pushFront(int value)\n    {\n        frontDeque.push_front(value);\n        if(frontDeque.size() > backDeque.size() + 1)\n        {\n            backDeque.push_front(frontDeque.back());\n            frontDeque.pop_back();\n        }\n    }\n\n    void pushMiddle(int value)\n    {\n        if(frontDeque.size() < backDeque.size())\n        {\n            frontDeque.push_back(value);\n        }\n        else\n        {\n            backDeque.push_front(value);\n        }\n    }\n\n    void pushBack(int value)\n    {\n        backDeque.push_back(value);\n        if(backDeque.size() > frontDeque.size())\n        {\n            frontDeque.push_back(backDeque.front());\n            backDeque.pop_front();\n        }\n    }\n\n    int popFront()\n    {\n        if(frontDeque.empty() && backDeque.empty())\n            return -1;\n        int returnedValue= frontDeque.front();\n        frontDeque.pop_front();\n        if(frontDeque.size() + 1 < backDeque.size())\n        {\n            frontDeque.push_back(backDeque.front());\n            backDeque.pop_front();\n        }\n        return returnedValue;\n    }\n\n    int popMiddle()\n    {\n        if(frontDeque.empty() && backDeque.empty())\n            return -1;\n        int returnedValue;\n        if(frontDeque.size() < backDeque.size())\n        {\n            returnedValue= backDeque.front();\n            backDeque.pop_front();\n        }\n        else\n        {\n            returnedValue= frontDeque.back();\n            frontDeque.pop_back();\n        }\n        if(backDeque.size() > frontDeque.size())\n        {\n            frontDeque.push_back(backDeque.front());\n            backDeque.pop_front();\n        }\n        return returnedValue;\n    }\n\n    int popBack()\n    {\n        if(frontDeque.empty() && backDeque.empty())\n            return -1;\n        int returnedValue= backDeque.back();\n        backDeque.pop_back();\n        if(frontDeque.size() > backDeque.size() + 1)\n        {\n            backDeque.push_front(frontDeque.back());\n            frontDeque.pop_back();\n        }\n        return returnedValue;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumMountainRemovals(vector<int> &mountainHeights)\n{\n    int numberOfHeights= mountainHeights.size();\n    vector<int> leftIncreasingCount(numberOfHeights), rightIncreasingCount(numberOfHeights);\n    for(int i= 1; i < numberOfHeights; ++i)\n    {\n        leftIncreasingCount[i]= leftIncreasingCount[i - 1] + (mountainHeights[i] > mountainHeights[i - 1]);\n        rightIncreasingCount[numberOfHeights - i - 1]= rightIncreasingCount[numberOfHeights - i] + (mountainHeights[numberOfHeights - i - 1] > mountainHeights[numberOfHeights - i]);\n    }\n    int minimumRemovals= numberOfHeights - 3;\n    for(int i= 1; i < numberOfHeights - 1; ++i)\n    {\n        minimumRemovals= min(minimumRemovals, numberOfHeights - 1 - leftIncreasingCount[i] - rightIncreasingCount[i]);\n    }\n    return minimumRemovals;\n}",
    "output": "#include <bits/stdc++.h>\nint minimumMountainRemovals(std::vector<int> &mountainHeights)\n{\n    int numberOfHeights= mountainHeights.size();\n    std::vector<int> leftIncreasingCount(numberOfHeights), rightIncreasingCount(numberOfHeights);\n    for(int i= 1; i < numberOfHeights; ++i)\n    {\n        leftIncreasingCount[i]= leftIncreasingCount[i - 1] + (mountainHeights[i] > mountainHeights[i - 1]);\n        rightIncreasingCount[numberOfHeights - i - 1]= rightIncreasingCount[numberOfHeights - i] + (mountainHeights[numberOfHeights - i - 1] > mountainHeights[numberOfHeights - i]);\n    }\n    int minimumRemovals= numberOfHeights - 3;\n    for(int i= 1; i < numberOfHeights - 1; ++i)\n    {\n        minimumRemovals= std::min(minimumRemovals, numberOfHeights - 1 - leftIncreasingCount[i] - rightIncreasingCount[i]);\n    }\n    return minimumRemovals;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maximumWealth(vector<vector<int>> &accounts)\n{\n    int maxWealth = 0;\n    for (int i = 0; i < accounts.size(); ++i)\n    {\n        int totalWealth = 0;\n        for (int j = 0; j < accounts[i].size(); ++j)\n        {\n            totalWealth += accounts[i][j];\n        }\n        maxWealth = max(maxWealth, totalWealth);\n    }\n    return maxWealth;\n}",
    "output": "#include <bits/stdc++.h>\nint maximumWealth(std::vector<std::vector<int>> &accounts)\n{\n    int maxWealth= 0;\n    for(auto &customer : accounts)\n    {\n        int totalWealth= 0;\n        for(int account : customer)\n        {\n            totalWealth+= account;\n        }\n        maxWealth= std::max(maxWealth, totalWealth);\n    }\n    return maxWealth;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> mostCompetitive(vector<int> &inputNumbers, int desiredSize)\n{\n    stack<int> numberStack;\n    int totalSize= inputNumbers.size();\n    for(int currentIndex= 0; currentIndex < totalSize; currentIndex++)\n    {\n        while(!numberStack.empty() && numberStack.top() > inputNumbers[currentIndex] && numberStack.size() + totalSize - currentIndex > desiredSize)\n        {\n            numberStack.pop();\n        }\n        if(numberStack.size() < desiredSize)\n        {\n            numberStack.push(inputNumbers[currentIndex]);\n        }\n    }\n    vector<int> resultVector(desiredSize);\n    for(int resultIndex= desiredSize - 1; resultIndex >= 0; resultIndex--)\n    {\n        resultVector[resultIndex]= numberStack.top();\n        numberStack.pop();\n    }\n    return resultVector;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> mostCompetitive(std::vector<int> &inputNumbers, int desiredSize)\n{\n    std::stack<int> numberStack;\n    int totalSize= inputNumbers.size();\n    for(int currentIndex= 0; currentIndex < totalSize; currentIndex++)\n    {\n        while(!numberStack.empty() && numberStack.top() > inputNumbers[currentIndex] && numberStack.size() + totalSize - currentIndex > desiredSize)\n        {\n            numberStack.pop();\n        }\n        if(numberStack.size() < desiredSize)\n        {\n            numberStack.push(inputNumbers[currentIndex]);\n        }\n    }\n    std::vector<int> resultVector(desiredSize);\n    for(int resultIndex= desiredSize - 1; resultIndex >= 0; resultIndex--)\n    {\n        resultVector[resultIndex]= numberStack.top();\n        numberStack.pop();\n    }\n    return resultVector;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int minOperations(int totalElements)\n{\n    return totalElements * (totalElements - 1) / 2;\n}",
    "output": "int minOperations(int totalElements)\n{\n    return totalElements * (totalElements - 1) / 2;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canPlaceBalls(int minDistance, const vector<int> &positions, int totalBalls)\n{\n    int lastPosition = positions[0];\n    int placedBalls = 1;\n\n    for(int index = 1; index < positions.size(); index++)\n    {\n        if(positions[index] - lastPosition >= minDistance)\n        {\n            placedBalls++;\n            lastPosition = positions[index];\n\n            if(placedBalls == totalBalls)\n            {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nint maxDistance(vector<int> &positions, int totalBalls)\n{\n    sort(positions.begin(), positions.end());\n\n    int leftBound = 1;\n    int rightBound = positions.back() - positions[0];\n    int maxDistanceFound = 0;\n\n    while(leftBound <= rightBound)\n    {\n        int midDistance = (leftBound + rightBound) / 2;\n        if(canPlaceBalls(midDistance, positions, totalBalls))\n        {\n            maxDistanceFound = midDistance;\n            leftBound = midDistance + 1;\n        }\n        else\n        {\n            rightBound = midDistance - 1;\n        }\n    }\n\n    return maxDistanceFound;\n}",
    "output": "#include <bits/stdc++.h>\nbool canPlaceBalls(int minDistance, const std::vector<int> &positions, int totalBalls)\n{\n    int lastPosition= positions[0];\n    int placedBalls= 1;\n\n    for(int index= 1; index < positions.size(); index++)\n    {\n        if(positions[index] - lastPosition >= minDistance)\n        {\n            placedBalls++;\n            lastPosition= positions[index];\n\n            if(placedBalls == totalBalls)\n            {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nint maxDistance(std::vector<int> &positions, int totalBalls)\n{\n    std::sort(positions.begin(), positions.end());\n\n    int leftBound= 1;\n    int rightBound= positions.back() - positions[0];\n    int maxDistanceFound= 0;\n\n    while(leftBound <= rightBound)\n    {\n        int midDistance= (leftBound + rightBound) / 2;\n        if(canPlaceBalls(midDistance, positions, totalBalls))\n        {\n            maxDistanceFound= midDistance;\n            leftBound= midDistance + 1;\n        }\n        else\n        {\n            rightBound= midDistance - 1;\n        }\n    }\n\n    return maxDistanceFound;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nTreeNode *findLowestCommonAncestor(TreeNode *root, const vector<TreeNode *> &targetNodes)\n{\n    if(root == NULL || find(targetNodes.begin(), targetNodes.end(), root) != targetNodes.end())\n        return root;\n    TreeNode *leftAncestor= findLowestCommonAncestor(root->leftChild, targetNodes);\n    TreeNode *rightAncestor= findLowestCommonAncestor(root->rightChild, targetNodes);\n    if(leftAncestor != NULL && rightAncestor != NULL)\n        return root;\n    return leftAncestor != NULL ? leftAncestor : rightAncestor;\n}",
    "output": "#include <bits/stdc++.h>\nclass TreeNode\n{\n  public:\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nTreeNode *findLowestCommonAncestor(TreeNode *root, const std::vector<TreeNode *> &targetNodes)\n{\n    if(root == NULL || std::find(targetNodes.begin(), targetNodes.end(), root) != targetNodes.end())\n        return root;\n    TreeNode *leftAncestor = findLowestCommonAncestor(root->leftChild, targetNodes);\n    TreeNode *rightAncestor = findLowestCommonAncestor(root->rightChild, targetNodes);\n    if(leftAncestor != NULL && rightAncestor != NULL)\n        return root;\n    return leftAncestor != NULL ? leftAncestor : rightAncestor;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numWays(string binaryString)\n{\n    int countOfOnes = 0;\n    for (int i = 0; i < binaryString.size(); ++i)\n    {\n        char character = binaryString[i];\n        if (character == '1')\n            countOfOnes++;\n    }\n    if (countOfOnes % 3 != 0)\n        return 0;\n\n    int target = countOfOnes / 3;\n    if (target == 0)\n    {\n        long length = binaryString.length();\n        return ((length - 1) * (length - 2) / 2) % 1000000007;\n    }\n\n    int onesCount1 = 0, onesCount2 = 0;\n    long waysCount1 = 0, waysCount2 = 0;\n    for (int i = 0; i < binaryString.size(); ++i)\n    {\n        char character = binaryString[i];\n        if (character == '1')\n        {\n            onesCount1++;\n            if (onesCount1 == target)\n            {\n                waysCount1++;\n                onesCount1 = 0;\n            }\n\n            onesCount2++;\n            if (onesCount2 == target * 2)\n            {\n                waysCount2++;\n                onesCount2 = 0;\n            }\n        }\n    }\n\n    return (waysCount1 * waysCount2) % 1000000007;\n}",
    "output": "#include <bits/stdc++.h>\nint numWays(std::string binaryString)\n{\n    int countOfOnes= 0;\n    for(char character : binaryString)\n    {\n        if(character == '1')\n            countOfOnes++;\n    }\n    if(countOfOnes % 3 != 0)\n        return 0;\n\n    int target= countOfOnes / 3;\n    if(target == 0)\n    {\n        long length= binaryString.length();\n        return ((length - 1) * (length - 2) / 2) % 1000000007;\n    }\n\n    int onesCount1= 0, onesCount2= 0;\n    long waysCount1= 0, waysCount2= 0;\n    for(char character : binaryString)\n    {\n        if(character == '1')\n        {\n            onesCount1++;\n            if(onesCount1 == target)\n            {\n                waysCount1++;\n                onesCount1= 0;\n            }\n\n            onesCount2++;\n            if(onesCount2 == target * 2)\n            {\n                waysCount2++;\n                onesCount2= 0;\n            }\n        }\n    }\n\n    return (waysCount1 * waysCount2) % 1000000007;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findLengthOfShortestSubarray(vector<int> &inputArray)\n{\n    int arraySize= inputArray.size();\n    int leftIndex= 0, rightIndex= arraySize - 1;\n\n    while(leftIndex < arraySize - 1 && inputArray[leftIndex] <= inputArray[leftIndex + 1])\n        leftIndex++;\n    if(leftIndex == arraySize - 1)\n        return 0;\n\n    while(rightIndex > 0 && inputArray[rightIndex] >= inputArray[rightIndex - 1])\n        rightIndex--;\n\n    int shortestLength= min(rightIndex, arraySize - leftIndex - 1);\n\n    int leftPointer= 0, rightPointer= rightIndex;\n\n    while(leftPointer <= leftIndex && rightPointer < arraySize)\n    {\n        if(inputArray[leftPointer] <= inputArray[rightPointer])\n        {\n            shortestLength= min(shortestLength, rightPointer - leftPointer - 1);\n            leftPointer++;\n        }\n        else\n        {\n            rightPointer++;\n        }\n    }\n\n    return shortestLength;\n}",
    "output": "#include <bits/stdc++.h>\nint findLengthOfShortestSubarray(std::vector<int> &inputArray)\n{\n    int arraySize= inputArray.size();\n    int leftIndex= 0, rightIndex= arraySize - 1;\n\n    while(leftIndex < arraySize - 1 && inputArray[leftIndex] <= inputArray[leftIndex + 1])\n        leftIndex++;\n    if(leftIndex == arraySize - 1)\n        return 0;\n\n    while(rightIndex > 0 && inputArray[rightIndex] >= inputArray[rightIndex - 1])\n        rightIndex--;\n\n    int shortestLength= std::min(rightIndex, arraySize - leftIndex - 1);\n\n    int leftPointer= 0, rightPointer= rightIndex;\n\n    while(leftPointer <= leftIndex && rightPointer < arraySize)\n    {\n        if(inputArray[leftPointer] <= inputArray[rightPointer])\n        {\n            shortestLength= std::min(shortestLength, rightPointer - leftPointer - 1);\n            leftPointer++;\n        }\n        else\n        {\n            rightPointer++;\n        }\n    }\n\n    return shortestLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countRoutes(vector<int> &locations, int start, int finish, int fuel, int currentLocation= -1, int remainingFuel= -1, vector<vector<int>> &memoization= vector<vector<int>>(100, vector<int>(201, -1)))\n{\n    if(currentLocation == -1)\n    {\n        currentLocation= start;\n        remainingFuel= fuel;\n    }\n\n    if(remainingFuel < 0)\n        return 0;\n\n    if(memoization[currentLocation][remainingFuel] != -1)\n        return memoization[currentLocation][remainingFuel];\n\n    int totalRoutes= (currentLocation == finish);\n    for(int nextLocation= 0; nextLocation < locations.size(); nextLocation++)\n    {\n        if(nextLocation != currentLocation)\n        {\n            totalRoutes+= countRoutes(locations, start, finish, fuel, nextLocation, remainingFuel - abs(locations[currentLocation] - locations[nextLocation]), memoization);\n            totalRoutes%= 1000000007;\n        }\n    }\n    memoization[currentLocation][remainingFuel]= totalRoutes;\n    return totalRoutes;\n}",
    "output": "#include <bits/stdc++.h>\nint countRoutes(std::vector<int> &locations, int start, int finish, int fuel, int currentLocation= -1, int remainingFuel= -1, std::vector<std::vector<int>> &memoization= std::vector<std::vector<int>>(100, std::vector<int>(201, -1)))\n{\n    if(currentLocation == -1)\n    {\n        currentLocation= start;\n        remainingFuel= fuel;\n    }\n\n    if(remainingFuel < 0)\n        return 0;\n\n    if(memoization[currentLocation][remainingFuel] != -1)\n        return memoization[currentLocation][remainingFuel];\n\n    int totalRoutes= (currentLocation == finish);\n    for(int nextLocation= 0; nextLocation < locations.size(); nextLocation++)\n    {\n        if(nextLocation != currentLocation)\n        {\n            totalRoutes+= countRoutes(locations, start, finish, fuel, nextLocation, remainingFuel - abs(locations[currentLocation] - locations[nextLocation]), memoization);\n            totalRoutes%= 1000000007;\n        }\n    }\n    memoization[currentLocation][remainingFuel]= totalRoutes;\n    return totalRoutes;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> mostVisited(int totalRooms, vector<int> &rounds)\n{\n    vector<int> visitCount(totalRooms + 1, 0);\n\n    for(int i= 1; i < rounds.size(); i++)\n    {\n        int startRoom= rounds[i - 1], endRoom= rounds[i];\n        while(startRoom != endRoom)\n        {\n            visitCount[startRoom]++;\n            startRoom= startRoom % totalRooms + 1;\n        }\n    }\n    visitCount[rounds.back()]++;\n\n    int maxVisitCount= *max_element(visitCount.begin(), visitCount.end());\n    vector<int> resultRooms;\n\n    for(int i= 1; i <= totalRooms; i++)\n    {\n        if(visitCount[i] == maxVisitCount)\n            resultRooms.push_back(i);\n    }\n\n    return resultRooms;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> mostVisited(int totalRooms, std::vector<int> &rounds)\n{\n    std::vector<int> visitCount(totalRooms + 1, 0);\n\n    for(int i= 1; i < rounds.size(); i++)\n    {\n        int startRoom= rounds[i - 1], endRoom= rounds[i];\n        while(startRoom != endRoom)\n        {\n            visitCount[startRoom]++;\n            startRoom= startRoom % totalRooms + 1;\n        }\n    }\n    visitCount[rounds.back()]++;\n\n    int maxVisitCount= *std::max_element(visitCount.begin(), visitCount.end());\n    std::vector<int> resultRooms;\n\n    for(int i= 1; i <= totalRooms; i++)\n    {\n        if(visitCount[i] == maxVisitCount)\n            resultRooms.push_back(i);\n    }\n\n    return resultRooms;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findLatestStep(vector<int> &inputArray, int targetLength)\n{\n    int arraySize = inputArray.size();\n    vector<int> leftLength(arraySize + 2, 0), rightLength(arraySize + 2, 0);\n    int segmentCount = 0, latestResult = -1;\n\n    for(int i = 0; i < arraySize; ++i)\n    {\n        int position = inputArray[i];\n        int leftSegmentLength = rightLength[position - 1];\n        int rightSegmentLength = leftLength[position + 1];\n        int newSegmentLength = leftSegmentLength + rightSegmentLength + 1;\n\n        if(leftSegmentLength == targetLength || rightSegmentLength == targetLength)\n        {\n            segmentCount--;\n        }\n\n        if(newSegmentLength == targetLength)\n        {\n            segmentCount++;\n        }\n\n        if(newSegmentLength > 0)\n        {\n            leftLength[position - leftSegmentLength] = newSegmentLength;\n            rightLength[position + rightSegmentLength] = newSegmentLength;\n            latestResult = i + 1;\n        }\n    }\n\n    return segmentCount > 0 ? latestResult : -1;\n}",
    "output": "#include <bits/stdc++.h>\nint findLatestStep(std::vector<int> &inputArray, int targetLength)\n{\n    int arraySize= inputArray.size();\n    std::vector<int> leftLength(arraySize + 2, 0), rightLength(arraySize + 2, 0);\n    int segmentCount= 0, latestResult= -1;\n\n    for(int i= 0; i < arraySize; ++i)\n    {\n        int position= inputArray[i];\n        int leftSegmentLength= rightLength[position - 1];\n        int rightSegmentLength= leftLength[position + 1];\n        int newSegmentLength= leftSegmentLength + rightSegmentLength + 1;\n\n        if(leftSegmentLength == targetLength || rightSegmentLength == targetLength)\n        {\n            segmentCount--;\n        }\n\n        if(newSegmentLength == targetLength)\n        {\n            segmentCount++;\n        }\n\n        if(newSegmentLength > 0)\n        {\n            leftLength[position - leftSegmentLength]= newSegmentLength;\n            rightLength[position + rightSegmentLength]= newSegmentLength;\n            latestResult= i + 1;\n        }\n    }\n\n    return segmentCount > 0 ? latestResult : -1;\n}\n"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(const vector<int> &stoneValue, int startIndex, int endIndex, vector<vector<int>> &memo)\n{\n    if(startIndex == endIndex)\n        return 0;\n    if(memo[startIndex][endIndex] != -1)\n        return memo[startIndex][endIndex];\n\n    int leftSum= 0, rightSum= 0;\n    for(int i= startIndex; i < endIndex; ++i)\n    {\n        leftSum+= stoneValue[i];\n        rightSum= 0;\n        for(int j= i + 1; j <= endIndex; ++j)\n            rightSum+= stoneValue[j];\n\n        if(leftSum > rightSum)\n            memo[startIndex][endIndex]= max(memo[startIndex][endIndex], rightSum + maxScore(stoneValue, i + 1, endIndex, memo));\n        else if(leftSum < rightSum)\n            memo[startIndex][endIndex]= max(memo[startIndex][endIndex], leftSum + maxScore(stoneValue, startIndex, i, memo));\n        else\n            memo[startIndex][endIndex]= max(memo[startIndex][endIndex], leftSum + max(maxScore(stoneValue, startIndex, i, memo), maxScore(stoneValue, i + 1, endIndex, memo)));\n    }\n    return memo[startIndex][endIndex];\n}\n\nint stoneGameV(vector<int> &stoneValue)\n{\n    int numberOfStones= stoneValue.size();\n    vector<vector<int>> memo(numberOfStones, vector<int>(numberOfStones, -1));\n    return maxScore(stoneValue, 0, numberOfStones - 1, memo);\n}",
    "output": "#include <bits/stdc++.h>\nint maxScore(const std::vector<int> &stoneValue, int startIndex, int endIndex, std::vector<std::vector<int>> &memo)\n{\n    if(startIndex == endIndex)\n        return 0;\n    if(memo[startIndex][endIndex] != -1)\n        return memo[startIndex][endIndex];\n\n    int leftSum= 0, rightSum= 0;\n    for(int i= startIndex; i < endIndex; ++i)\n    {\n        leftSum+= stoneValue[i];\n        rightSum= 0;\n        for(int j= i + 1; j <= endIndex; ++j)\n            rightSum+= stoneValue[j];\n\n        if(leftSum > rightSum)\n            memo[startIndex][endIndex]= std::max(memo[startIndex][endIndex], rightSum + maxScore(stoneValue, i + 1, endIndex, memo));\n        else if(leftSum < rightSum)\n            memo[startIndex][endIndex]= std::max(memo[startIndex][endIndex], leftSum + maxScore(stoneValue, startIndex, i, memo));\n        else\n            memo[startIndex][endIndex]= std::max(memo[startIndex][endIndex], leftSum + std::max(maxScore(stoneValue, startIndex, i, memo), maxScore(stoneValue, i + 1, endIndex, memo)));\n    }\n    return memo[startIndex][endIndex];\n}\n\nint stoneGameV(std::vector<int> &stoneValue)\n{\n    int numberOfStones= stoneValue.size();\n    std::vector<std::vector<int>> memo(numberOfStones, std::vector<int>(numberOfStones, -1));\n    return maxScore(stoneValue, 0, numberOfStones - 1, memo);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint stoneGameVI(vector<int> &aliceValues, vector<int> &bobValues)\n{\n    int numberOfStones = aliceValues.size();\n    vector<pair<int, int>> stoneValuePairs;\n    for(int index = 0; index < numberOfStones; ++index)\n    {\n        stoneValuePairs.push_back({aliceValues[index] + bobValues[index], index});\n    }\n\n    sort(stoneValuePairs.rbegin(), stoneValuePairs.rend());\n    int aliceSum = 0, bobSum = 0;\n    for(int index = 0; index < numberOfStones; ++index)\n    {\n        if(index % 2 == 0)\n        {\n            aliceSum += aliceValues[stoneValuePairs[index].second];\n        }\n        else\n        {\n            bobSum += bobValues[stoneValuePairs[index].second];\n        }\n    }\n\n    return (aliceSum == bobSum) ? 0 : ((aliceSum > bobSum) ? 1 : -1);\n}",
    "output": "#include <bits/stdc++.h>\nint stoneGameVI(std::vector<int> &aliceValues, std::vector<int> &bobValues)\n{\n    int numberOfStones= aliceValues.size();\n    std::vector<std::pair<int, int>> stoneValuePairs;\n    for(int index= 0; index < numberOfStones; ++index)\n    {\n        stoneValuePairs.push_back({aliceValues[index] + bobValues[index], index});\n    }\n\n    std::sort(stoneValuePairs.rbegin(), stoneValuePairs.rend());\n    int aliceSum= 0, bobSum= 0;\n    for(int index= 0; index < numberOfStones; ++index)\n    {\n        if(index % 2 == 0)\n        {\n            aliceSum+= aliceValues[stoneValuePairs[index].second];\n        }\n        else\n        {\n            bobSum+= bobValues[stoneValuePairs[index].second];\n        }\n    }\n\n    return (aliceSum == bobSum) ? 0 : ((aliceSum > bobSum) ? 1 : -1);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumTrips(vector<vector<int>> &boxes, int portsCount, int maxBoxes, int maxWeight)\n{\n    int totalTrips= 0, currentIndex= 0, numberOfBoxes= boxes.size();\n    while(currentIndex < numberOfBoxes)\n    {\n        int currentWeightLimit= maxWeight, previousPort= 0;\n        for(int boxCount= 0; boxCount < maxBoxes && currentIndex < numberOfBoxes; ++currentIndex)\n        {\n            if(boxes[currentIndex][1] <= currentWeightLimit)\n            {\n                if(previousPort != boxes[currentIndex][0])\n                {\n                    previousPort= boxes[currentIndex][0];\n                    ++totalTrips;\n                }\n                currentWeightLimit-= boxes[currentIndex][1];\n                ++boxCount;\n            }\n        }\n        ++totalTrips;\n    }\n    return totalTrips;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMinimumTrips(std::vector<std::vector<int>> &boxes, int portsCount, int maxBoxes, int maxWeight)\n{\n    int totalTrips= 0, currentIndex= 0, numberOfBoxes= boxes.size();\n    while(currentIndex < numberOfBoxes)\n    {\n        int currentWeightLimit= maxWeight, previousPort= 0;\n        for(int boxCount= 0; boxCount < maxBoxes && currentIndex < numberOfBoxes; ++currentIndex)\n        {\n            if(boxes[currentIndex][1] <= currentWeightLimit)\n            {\n                if(previousPort != boxes[currentIndex][0])\n                {\n                    previousPort= boxes[currentIndex][0];\n                    ++totalTrips;\n                }\n                currentWeightLimit-= boxes[currentIndex][1];\n                ++boxCount;\n            }\n        }\n        ++totalTrips;\n    }\n    return totalTrips;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int calculateNumberOfMatches(int totalTeams)\n{\n    int totalMatches= 0;\n    while(totalTeams > 1)\n    {\n        totalMatches+= totalTeams / 2;\n        totalTeams= (totalTeams + 1) / 2;\n    }\n    return totalMatches;\n}",
    "output": "int calculateNumberOfMatches(int totalTeams)\n{\n    int totalMatches= 0;\n    while(totalTeams > 1)\n    {\n        totalMatches+= totalTeams / 2;\n        totalTeams= (totalTeams + 1) / 2;\n    }\n    return totalMatches;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool containsPattern(vector<int> &inputArray, int patternLength, int repetitions)\n{\n    int arraySize= inputArray.size();\n    if(patternLength * repetitions > arraySize)\n        return false;\n\n    for(int startIndex= 0; startIndex + patternLength * repetitions <= arraySize; startIndex++)\n    {\n        bool patternFound= true;\n        for(int currentIndex= 0; currentIndex < patternLength; currentIndex++)\n        {\n            for(int repeatIndex= 1; repeatIndex < repetitions; repeatIndex++)\n            {\n                if(inputArray[startIndex + currentIndex] != inputArray[startIndex + currentIndex + repeatIndex * patternLength])\n                {\n                    patternFound= false;\n                    break;\n                }\n            }\n            if(!patternFound)\n                break;\n        }\n        if(patternFound)\n            return true;\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool containsPattern(std::vector<int> &inputArray, int patternLength, int repetitions)\n{\n    int arraySize= inputArray.size();\n    if(patternLength * repetitions > arraySize)\n        return false;\n\n    for(int startIndex= 0; startIndex + patternLength * repetitions <= arraySize; startIndex++)\n    {\n        bool patternFound= true;\n        for(int currentIndex= 0; currentIndex < patternLength; currentIndex++)\n        {\n            for(int repeatIndex= 1; repeatIndex < repetitions; repeatIndex++)\n            {\n                if(inputArray[startIndex + currentIndex] != inputArray[startIndex + currentIndex + repeatIndex * patternLength])\n                {\n                    patternFound= false;\n                    break;\n                }\n            }\n            if(!patternFound)\n                break;\n        }\n        if(patternFound)\n            return true;\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxLen(vector<int> &numberList)\n{\n    int maxLength = 0, currentLength = 0, currentNegativeLength = 0;\n\n    for (int i = 0; i < numberList.size(); ++i)\n    {\n        int number = numberList[i];\n        if (number > 0)\n        {\n            ++currentLength;\n            if (currentNegativeLength > 0)\n                ++currentNegativeLength;\n        }\n        else if (number < 0)\n        {\n            int temp = currentLength;\n            currentLength = currentNegativeLength;\n            currentNegativeLength = temp + 1;\n        }\n        else\n        {\n            currentLength = 0;\n            currentNegativeLength = 0;\n        }\n        maxLength = max(maxLength, currentLength);\n    }\n\n    return maxLength;\n}",
    "output": "#include <bits/stdc++.h>\nint getMaxLen(std::vector<int> &numberList)\n{\n    int maxLength= 0, currentLength= 0, currentNegativeLength= 0;\n\n    for(int number : numberList)\n    {\n        if(number > 0)\n        {\n            ++currentLength;\n            if(currentNegativeLength > 0)\n                ++currentNegativeLength;\n        }\n        else if(number < 0)\n        {\n            int temp= currentLength;\n            currentLength= currentNegativeLength;\n            currentNegativeLength= temp + 1;\n        }\n        else\n        {\n            currentLength= 0;\n            currentNegativeLength= 0;\n        }\n        maxLength= std::max(maxLength, currentLength);\n    }\n\n    return maxLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numTrees(int numberOfNodes)\n{\n    vector<int> dynamicProgrammingTable(numberOfNodes + 1, 0);\n    dynamicProgrammingTable[0] = 1;\n    dynamicProgrammingTable[1] = 1;\n\n    for(int currentNodes = 2; currentNodes <= numberOfNodes; ++currentNodes)\n    {\n        for(int leftSubtreeNodes = 0; leftSubtreeNodes < currentNodes; ++leftSubtreeNodes)\n        {\n            dynamicProgrammingTable[currentNodes] += dynamicProgrammingTable[leftSubtreeNodes] * dynamicProgrammingTable[currentNodes - 1 - leftSubtreeNodes];\n            dynamicProgrammingTable[currentNodes] %= 1000000007;\n        }\n    }\n\n    return dynamicProgrammingTable[numberOfNodes];\n}",
    "output": "#include <bits/stdc++.h>\nint numTrees(int numberOfNodes)\n{\n    std::vector<int> dynamicProgrammingTable(numberOfNodes + 1, 0);\n    dynamicProgrammingTable[0]= 1;\n    dynamicProgrammingTable[1]= 1;\n\n    for(int currentNodes= 2; currentNodes <= numberOfNodes; ++currentNodes)\n    {\n        for(int leftSubtreeNodes= 0; leftSubtreeNodes < currentNodes; ++leftSubtreeNodes)\n        {\n            dynamicProgrammingTable[currentNodes]+= dynamicProgrammingTable[leftSubtreeNodes] * dynamicProgrammingTable[currentNodes - 1 - leftSubtreeNodes];\n            dynamicProgrammingTable[currentNodes]%= 1000000007;\n        }\n    }\n\n    return dynamicProgrammingTable[numberOfNodes];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minSubarray(vector<int> &numbers, int target)\n{\n    int arraySize = numbers.size(), requiredSum = 0, currentSum = 0, result = arraySize;\n    for(int i = 0; i < arraySize; ++i)\n        requiredSum = (requiredSum + numbers[i]) % target;\n    if(requiredSum == 0)\n        return 0;\n    unordered_map<int, int> lastSeenIndex;\n    lastSeenIndex[currentSum] = -1;\n    for(int index = 0; index < arraySize; ++index)\n    {\n        currentSum = (currentSum + numbers[index]) % target;\n        lastSeenIndex[currentSum] = index;\n        int neededValue = (currentSum - requiredSum + target) % target;\n        if(lastSeenIndex.count(neededValue))\n        {\n            result = min(result, index - lastSeenIndex[neededValue]);\n        }\n    }\n    return result == arraySize ? -1 : result;\n}",
    "output": "#include <bits/stdc++.h>\nint minSubarray(std::vector<int> &numbers, int target)\n{\n    int arraySize = numbers.size(), requiredSum = 0, currentSum = 0, result = arraySize;\n    for(int number : numbers)\n        requiredSum = (requiredSum + number) % target;\n    if(requiredSum == 0)\n        return 0;\n    \n    std::unordered_map<int, int> lastSeenIndex;\n    lastSeenIndex[currentSum] = -1;\n    \n    for(int index = 0; index < arraySize; ++index)\n    {\n        currentSum = (currentSum + numbers[index]) % target;\n        lastSeenIndex[currentSum] = index;\n        int neededValue = (currentSum - requiredSum + target) % target;\n        if(lastSeenIndex.count(neededValue))\n        {\n            result = std::min(result, index - lastSeenIndex[neededValue]);\n        }\n    }\n    return result == arraySize ? -1 : result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo = 1e9 + 7;\nint maxSumRangeQuery(vector<int> &numbers, vector<vector<int>> &requests)\n{\n    vector<int> count(numbers.size());\n    for (int i = 0; i < requests.size(); ++i)\n    {\n        count[requests[i][0]]++;\n        if (requests[i][1] + 1 < numbers.size())\n            count[requests[i][1] + 1]--;\n    }\n\n    for (int index = 1; index < numbers.size(); index++)\n    {\n        count[index] += count[index - 1];\n    }\n\n    sort(numbers.begin(), numbers.end());\n    sort(count.begin(), count.end());\n\n    long long totalSum = 0;\n    for (int index = 0; index < numbers.size(); index++)\n    {\n        totalSum += (long long)numbers[index] * count[index];\n        totalSum %= modulo;\n    }\n\n    return totalSum;\n}",
    "output": "#include <bits/stdc++.h>\nconst int modulo= 1e9 + 7;\nint maxSumRangeQuery(std::vector<int> &numbers, std::vector<std::vector<int>> &requests)\n{\n    std::vector<int> count(numbers.size());\n    for(auto &request : requests)\n    {\n        count[request[0]]++;\n        if(request[1] + 1 < numbers.size())\n            count[request[1] + 1]--;\n    }\n\n    for(int index= 1; index < numbers.size(); index++)\n    {\n        count[index]+= count[index - 1];\n    }\n\n    std::sort(numbers.begin(), numbers.end());\n    std::sort(count.begin(), count.end());\n\n    long long totalSum= 0;\n    for(int index= 0; index < numbers.size(); index++)\n    {\n        totalSum+= (long long)numbers[index] * count[index];\n        totalSum%= modulo;\n    }\n\n    return totalSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPrintable(vector<vector<int>> &targetGrid)\n{\n    int rowCount= targetGrid.size(), colCount= targetGrid[0].size();\n    vector<int> topBound(61, rowCount), bottomBound(61, -1), leftBound(61, colCount), rightBound(61, -1);\n    vector<vector<bool>> visited(rowCount, vector<bool>(colCount, false));\n\n    for(int currentRow= 0; currentRow < rowCount; ++currentRow)\n    {\n        for(int currentCol= 0; currentCol < colCount; ++currentCol)\n        {\n            int color= targetGrid[currentRow][currentCol];\n            topBound[color]= min(topBound[color], currentRow);\n            bottomBound[color]= max(bottomBound[color], currentRow);\n            leftBound[color]= min(leftBound[color], currentCol);\n            rightBound[color]= max(rightBound[color], currentCol);\n        }\n    }\n\n    function<bool(int)> depthFirstSearch= [&](int position)\n    {\n        int currentRow= position / colCount, currentCol= position % colCount;\n        if(visited[currentRow][currentCol])\n            return true;\n        int color= targetGrid[currentRow][currentCol];\n        if(currentRow < topBound[color] || currentRow > bottomBound[color] || currentCol < leftBound[color] || currentCol > rightBound[color])\n            return false;\n        visited[currentRow][currentCol]= true;\n        for(int k= 1; k <= 60; ++k)\n        {\n            if(k == color)\n                continue;\n            if(currentRow >= topBound[k] && currentRow <= bottomBound[k] && currentCol >= leftBound[k] && currentCol <= rightBound[k])\n                return false;\n            if(!depthFirstSearch(((currentRow - topBound[k]) * (rightBound[k] - leftBound[k] + 1)) + currentCol - leftBound[k]))\n                return false;\n        }\n        return true;\n    };\n\n    for(int color= 1; color <= 60; ++color)\n    {\n        for(int currentRow= topBound[color]; currentRow <= bottomBound[color]; ++currentRow)\n        {\n            for(int currentCol= leftBound[color]; currentCol <= rightBound[color]; ++currentCol)\n            {\n                if(!visited[currentRow][currentCol] && !depthFirstSearch(currentRow * colCount + currentCol))\n                    return false;\n            }\n        }\n    }\n\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isPrintable(std::vector<std::vector<int>> &targetGrid)\n{\n    int rowCount = targetGrid.size(), colCount = targetGrid[0].size();\n    std::vector<int> topBound(61, rowCount), bottomBound(61, -1), leftBound(61, colCount), rightBound(61, -1);\n    std::vector<std::vector<bool>> visited(rowCount, std::vector<bool>(colCount, false));\n\n    for(int currentRow = 0; currentRow < rowCount; ++currentRow)\n    {\n        for(int currentCol = 0; currentCol < colCount; ++currentCol)\n        {\n            int color = targetGrid[currentRow][currentCol];\n            topBound[color] = std::min(topBound[color], currentRow);\n            bottomBound[color] = std::max(bottomBound[color], currentRow);\n            leftBound[color] = std::min(leftBound[color], currentCol);\n            rightBound[color] = std::max(rightBound[color], currentCol);\n        }\n    }\n\n    std::function<bool(int)> depthFirstSearch = [&](int position)\n    {\n        int currentRow = position / colCount, currentCol = position % colCount;\n        if(visited[currentRow][currentCol])\n            return true;\n        int color = targetGrid[currentRow][currentCol];\n        if(currentRow < topBound[color] || currentRow > bottomBound[color] || currentCol < leftBound[color] || currentCol > rightBound[color])\n            return false;\n        visited[currentRow][currentCol] = true;\n        for(int k = 1; k <= 60; ++k)\n        {\n            if(k == color)\n                continue;\n            if(currentRow >= topBound[k] && currentRow <= bottomBound[k] && currentCol >= leftBound[k] && currentCol <= rightBound[k])\n                return false;\n            if(!depthFirstSearch(((currentRow - topBound[k]) * (rightBound[k] - leftBound[k] + 1)) + currentCol - leftBound[k]))\n                return false;\n        }\n        return true;\n    };\n\n    for(int color = 1; color <= 60; ++color)\n    {\n        for(int currentRow = topBound[color]; currentRow <= bottomBound[color]; ++currentRow)\n        {\n            for(int currentCol = leftBound[color]; currentCol <= rightBound[color]; ++currentCol)\n            {\n                if(!visited[currentRow][currentCol] && !depthFirstSearch(currentRow * colCount + currentCol))\n                    return false;\n            }\n        }\n    }\n\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<bool> distanceLimitedPathsExist(int nodeCount, vector<vector<int>> &edgeList, vector<vector<int>> &queries)\n{\n    unordered_map<int, vector<pair<int, int>>> adjacencyList;\n    for (int i = 0; i < edgeList.size(); i++)\n    {\n        auto &edge = edgeList[i];\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n        adjacencyList[edge[1]].emplace_back(edge[0], edge[2]);\n    }\n\n    vector<bool> queryResults(queries.size());\n    for (int queryIndex = 0; queryIndex < queries.size(); queryIndex++)\n    {\n        int startNode = queries[queryIndex][0], endNode = queries[queryIndex][1], distanceLimit = queries[queryIndex][2];\n\n        queue<pair<int, int>> bfsQueue;\n        bfsQueue.push({startNode, 0});\n        vector<bool> visitedNodes(nodeCount, false);\n        visitedNodes[startNode] = true;\n\n        while (!bfsQueue.empty())\n        {\n            auto currentNode = bfsQueue.front();\n            bfsQueue.pop();\n\n            for (int i = 0; i < adjacencyList[currentNode.first].size(); i++)\n            {\n                auto &neighbor = adjacencyList[currentNode.first][i];\n                if (currentNode.second + neighbor.second < distanceLimit)\n                {\n                    if (neighbor.first == endNode)\n                    {\n                        queryResults[queryIndex] = true;\n                        break;\n                    }\n                    if (!visitedNodes[neighbor.first])\n                    {\n                        visitedNodes[neighbor.first] = true;\n                        bfsQueue.push({neighbor.first, currentNode.second + neighbor.second});\n                    }\n                }\n            }\n            if (queryResults[queryIndex])\n                break;\n        }\n    }\n    return queryResults;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<bool> distanceLimitedPathsExist(int nodeCount, std::vector<std::vector<int>> &edgeList, std::vector<std::vector<int>> &queries)\n{\n    std::unordered_map<int, std::vector<std::pair<int, int>>> adjacencyList;\n    for(auto &edge : edgeList)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n        adjacencyList[edge[1]].emplace_back(edge[0], edge[2]);\n    }\n\n    std::vector<bool> queryResults(queries.size());\n    for(int queryIndex= 0; queryIndex < queries.size(); queryIndex++)\n    {\n        int startNode= queries[queryIndex][0], endNode= queries[queryIndex][1], distanceLimit= queries[queryIndex][2];\n\n        std::queue<std::pair<int, int>> bfsQueue;\n        bfsQueue.push({startNode, 0});\n        std::vector<bool> visitedNodes(nodeCount, false);\n        visitedNodes[startNode]= true;\n\n        while(!bfsQueue.empty())\n        {\n            auto currentNode= bfsQueue.front();\n            bfsQueue.pop();\n\n            for(auto &neighbor : adjacencyList[currentNode.first])\n            {\n                if(currentNode.second + neighbor.second < distanceLimit)\n                {\n                    if(neighbor.first == endNode)\n                    {\n                        queryResults[queryIndex]= true;\n                        break;\n                    }\n                    if(!visitedNodes[neighbor.first])\n                    {\n                        visitedNodes[neighbor.first]= true;\n                        bfsQueue.push({neighbor.first, currentNode.second + neighbor.second});\n                    }\n                }\n            }\n            if(queryResults[queryIndex])\n                break;\n        }\n    }\n    return queryResults;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring modifyString(string inputString)\n{\n    for(int index= 0; index < inputString.size(); index++)\n    {\n        if(inputString[index] == '?')\n        {\n            for(char character= 'a'; character <= 'z'; character++)\n            {\n                if((index - 1 < 0 || inputString[index - 1] != character) && (index + 1 >= inputString.size() || inputString[index + 1] != character))\n                {\n                    inputString[index]= character;\n                    break;\n                }\n            }\n        }\n    }\n    return inputString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string modifyString(std::string inputString)\n{\n    for(int index= 0; index < inputString.size(); index++)\n    {\n        if(inputString[index] == '?')\n        {\n            for(char character= 'a'; character <= 'z'; character++)\n            {\n                if((index - 1 < 0 || inputString[index - 1] != character) && (index + 1 >= inputString.size() || inputString[index + 1] != character))\n                {\n                    inputString[index]= character;\n                    break;\n                }\n            }\n        }\n    }\n    return inputString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeToRemoveBalloons(const string &balloonColors, const vector<int> &removalTimes)\n{\n    int totalBalloons = balloonColors.size();\n    int timeMatrix[totalBalloons][26];\n    for(int balloonIndex = 0; balloonIndex < totalBalloons; balloonIndex++)\n    {\n        for(int colorIndex = 0; colorIndex < 26; colorIndex++)\n        {\n            timeMatrix[balloonIndex][colorIndex] = 1e9;\n        }\n    }\n\n    for(int colorIndex = 0; colorIndex < 26; colorIndex++)\n    {\n        if(balloonColors[0] != 'A' + colorIndex)\n            timeMatrix[0][colorIndex] = removalTimes[0];\n    }\n\n    for(int balloonIndex = 1; balloonIndex < totalBalloons; balloonIndex++)\n    {\n        for(int previousColorIndex = 0; previousColorIndex < 26; previousColorIndex++)\n        {\n            for(int currentColorIndex = 0; currentColorIndex < 26; currentColorIndex++)\n            {\n                if(previousColorIndex != currentColorIndex && balloonColors[balloonIndex] != 'A' + previousColorIndex)\n                {\n                    timeMatrix[balloonIndex][previousColorIndex] = min(timeMatrix[balloonIndex][previousColorIndex], timeMatrix[balloonIndex - 1][currentColorIndex] + removalTimes[balloonIndex]);\n                }\n            }\n        }\n    }\n\n    int minimumRemovalTime = 1e9;\n    for(int colorIndex = 0; colorIndex < 26; colorIndex++)\n    {\n        minimumRemovalTime = min(minimumRemovalTime, timeMatrix[totalBalloons - 1][colorIndex]);\n    }\n    return minimumRemovalTime;\n}",
    "output": "#include <bits/stdc++.h>\nint minTimeToRemoveBalloons(const std::string &balloonColors, const std::vector<int> &removalTimes)\n{\n    int totalBalloons= balloonColors.size();\n    int timeMatrix[totalBalloons][26];\n    for(int balloonIndex= 0; balloonIndex < totalBalloons; balloonIndex++)\n    {\n        for(int colorIndex= 0; colorIndex < 26; colorIndex++)\n        {\n            timeMatrix[balloonIndex][colorIndex]= 1e9;\n        }\n    }\n\n    for(int colorIndex= 0; colorIndex < 26; colorIndex++)\n    {\n        if(balloonColors[0] != 'A' + colorIndex)\n            timeMatrix[0][colorIndex]= removalTimes[0];\n    }\n\n    for(int balloonIndex= 1; balloonIndex < totalBalloons; balloonIndex++)\n    {\n        for(int previousColorIndex= 0; previousColorIndex < 26; previousColorIndex++)\n        {\n            for(int currentColorIndex= 0; currentColorIndex < 26; currentColorIndex++)\n            {\n                if(previousColorIndex != currentColorIndex && balloonColors[balloonIndex] != 'A' + previousColorIndex)\n                {\n                    timeMatrix[balloonIndex][previousColorIndex]= std::min(timeMatrix[balloonIndex][previousColorIndex], timeMatrix[balloonIndex - 1][currentColorIndex] + removalTimes[balloonIndex]);\n                }\n            }\n        }\n    }\n\n    int minimumRemovalTime= 1e9;\n    for(int colorIndex= 0; colorIndex < 26; colorIndex++)\n    {\n        minimumRemovalTime= std::min(minimumRemovalTime, timeMatrix[totalBalloons - 1][colorIndex]);\n    }\n    return minimumRemovalTime;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumEdgesToRemove(int nodeCount, vector<vector<int>> &edges)\n{\n    vector<int> parentArray(2 * nodeCount + 1);\n    iota(parentArray.begin(), parentArray.end(), 0);\n    function<int(int)> findParent= [&](int x)\n    { return x == parentArray[x] ? x : parentArray[x]= findParent(parentArray[x]); };\n    auto uniteSets= [&](int x, int y)\n    { x = findParent(x); y = findParent(y); if (x != y) return parentArray[x] = y, true; return false; };\n    \n    sort(edges.begin(), edges.end(), greater<vector<int>>());\n    int edgesRemoved= 0, remainingEdges= nodeCount - 1;\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        int edgeType = edges[i][0], nodeU = edges[i][1], nodeV = edges[i][2] + nodeCount;\n        if(edgeType == 3)\n            if(uniteSets(nodeU, nodeV))\n                --remainingEdges;\n        if(!remainingEdges)\n            break;\n    }\n    \n    for(int currentEdgeType= 1; currentEdgeType < 3; ++currentEdgeType)\n    {\n        int count= 0;\n        for (int i = 0; i < edges.size(); ++i)\n        {\n            int type = edges[i][0], nodeA = edges[i][1], nodeB = edges[i][2] + nodeCount;\n            if(type == currentEdgeType)\n                if(uniteSets(nodeA, nodeB))\n                    ++count;\n        }\n        if(remainingEdges + count < nodeCount - 1)\n            return -1;\n        edgesRemoved += count;\n    }\n    return edgesRemoved;\n}",
    "output": "#include <bits/stdc++.h>\nint maxNumEdgesToRemove(int nodeCount, std::vector<std::vector<int>> &edges)\n{\n    std::vector<int> parentArray(2 * nodeCount + 1);\n    std::iota(parentArray.begin(), parentArray.end(), 0);\n    std::function<int(int)> findParent= [&](int x)\n    { return x == parentArray[x] ? x : parentArray[x]= findParent(parentArray[x]); };\n    auto uniteSets= [&](int x, int y)\n    { x = findParent(x); y = findParent(y); if (x != y) return parentArray[x] = y, true; return false; };\n    std::sort(edges.begin(), edges.end(), std::greater<std::vector<int>>());\n    int edgesRemoved= 0, remainingEdges= nodeCount - 1;\n    for(auto &edge : edges)\n    {\n        int edgeType, nodeU, nodeV;\n        std::tie(edgeType, nodeU, nodeV)= std::make_tuple(edge[0], edge[1], edge[2] + nodeCount);\n        if(edgeType == 3)\n            if(uniteSets(nodeU, nodeV))\n                --remainingEdges;\n        if(!remainingEdges)\n            break;\n    }\n    for(int currentEdgeType= 1; currentEdgeType < 3; ++currentEdgeType)\n    {\n        int count= 0;\n        for(auto &edge : edges)\n        {\n            int type, nodeA, nodeB;\n            std::tie(type, nodeA, nodeB)= std::make_tuple(edge[0], edge[1], edge[2] + nodeCount);\n            if(type == currentEdgeType)\n                if(uniteSets(nodeA, nodeB))\n                    ++count;\n        }\n        if(remainingEdges + count < nodeCount - 1)\n            return -1;\n        edgesRemoved+= count;\n    }\n    return edgesRemoved;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring generateMaximumBinaryString(string binaryString)\n{\n    int zeroCount = 0;\n    int oneCount = 0;\n\n    for (int i = 0; i < binaryString.size(); ++i)\n    {\n        char character = binaryString[i];\n        if (character == '0')\n        {\n            zeroCount++;\n        }\n        else\n        {\n            oneCount++;\n        }\n    }\n\n    if (zeroCount <= 1)\n    {\n        return binaryString;\n    }\n\n    string maximumBinary = \"\";\n    for (int i = 0; i < oneCount; ++i)\n    {\n        maximumBinary += '1';\n    }\n    for (int i = 0; i < zeroCount - 1; ++i)\n    {\n        maximumBinary += '0';\n    }\n    maximumBinary += \"1####1\";\n    return maximumBinary.substr(0, binaryString.length());\n}",
    "output": "#include <bits/stdc++.h>\nstd::string generateMaximumBinaryString(std::string binaryString)\n{\n    int zeroCount= 0;\n    int oneCount= 0;\n\n    for(char character : binaryString)\n    {\n        if(character == '0')\n        {\n            zeroCount++;\n        }\n        else\n        {\n            oneCount++;\n        }\n    }\n\n    if(zeroCount <= 1)\n    {\n        return binaryString;\n    }\n\n    std::string maximumBinary= \"\";\n    for(int i= 0; i < oneCount; ++i)\n    {\n        maximumBinary+= '1';\n    }\n    for(int i= 0; i < zeroCount - 1; ++i)\n    {\n        maximumBinary+= '0';\n    }\n    maximumBinary+= \"1####1\";\n    return maximumBinary.substr(0, binaryString.length());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// for abs function\nusing namespace std;\n\nint calculateMinimumMoves(vector<int> &numberArray, int subarraySize)\n{\n    vector<int> onePositions;\n    int totalMoves= 0;\n    for(int index= 0; index < numberArray.size(); index++)\n    {\n        if(numberArray[index] == 1)\n        {\n            onePositions.push_back(index);\n        }\n    }\n    for(int index= 0; index + subarraySize <= onePositions.size(); index++)\n    {\n        int medianPosition= onePositions[index + subarraySize / 2];\n        for(int innerIndex= index; innerIndex < index + subarraySize; innerIndex++)\n        {\n            totalMoves+= abs(onePositions[innerIndex] - medianPosition);\n        }\n    }\n    return totalMoves;\n}",
    "output": "#include <bits/stdc++.h>\n// for abs\n\nint calculateMinimumMoves(std::vector<int> &numberArray, int subarraySize)\n{\n    std::vector<int> onePositions;\n    int totalMoves= 0;\n    for(int index= 0; index < numberArray.size(); index++)\n    {\n        if(numberArray[index] == 1)\n        {\n            onePositions.push_back(index);\n        }\n    }\n    for(int index= 0; index + subarraySize <= onePositions.size(); index++)\n    {\n        int medianPosition= onePositions[index + subarraySize / 2];\n        for(int innerIndex= index; innerIndex < index + subarraySize; innerIndex++)\n        {\n            totalMoves+= std::abs(onePositions[innerIndex] - medianPosition);\n        }\n    }\n    return totalMoves;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countSpecialPositions(vector<vector<int>> &matrix)\n{\n    int rowCount= matrix.size(), colCount= matrix[0].size();\n    vector<int> rowSum(rowCount, 0), colSum(colCount, 0);\n\n    for(int currentRowIndex= 0; currentRowIndex < rowCount; ++currentRowIndex)\n    {\n        for(int currentColIndex= 0; currentColIndex < colCount; ++currentColIndex)\n        {\n            if(matrix[currentRowIndex][currentColIndex] == 1)\n            {\n                ++rowSum[currentRowIndex];\n                ++colSum[currentColIndex];\n            }\n        }\n    }\n\n    int specialPositionCount= 0;\n    for(int currentRowIndex= 0; currentRowIndex < rowCount; ++currentRowIndex)\n    {\n        for(int currentColIndex= 0; currentColIndex < colCount; ++currentColIndex)\n        {\n            if(matrix[currentRowIndex][currentColIndex] == 1 && rowSum[currentRowIndex] == 1 && colSum[currentColIndex] == 1)\n            {\n                ++specialPositionCount;\n            }\n        }\n    }\n\n    return specialPositionCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countSpecialPositions(std::vector<std::vector<int>> &matrix)\n{\n    int rowCount= matrix.size(), colCount= matrix[0].size();\n    std::vector<int> rowSum(rowCount, 0), colSum(colCount, 0);\n\n    for(int currentRowIndex= 0; currentRowIndex < rowCount; ++currentRowIndex)\n    {\n        for(int currentColIndex= 0; currentColIndex < colCount; ++currentColIndex)\n        {\n            if(matrix[currentRowIndex][currentColIndex] == 1)\n            {\n                ++rowSum[currentRowIndex];\n                ++colSum[currentColIndex];\n            }\n        }\n    }\n\n    int specialPositionCount= 0;\n    for(int currentRowIndex= 0; currentRowIndex < rowCount; ++currentRowIndex)\n    {\n        for(int currentColIndex= 0; currentColIndex < colCount; ++currentColIndex)\n        {\n            if(matrix[currentRowIndex][currentColIndex] == 1 && rowSum[currentRowIndex] == 1 && colSum[currentColIndex] == 1)\n            {\n                ++specialPositionCount;\n            }\n        }\n    }\n\n    return specialPositionCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint unhappyFriends(int totalFriends, vector<vector<int>> &preferences, vector<vector<int>> &pairs)\n{\n    vector<int> partnerMapping(totalFriends);\n    for (int i = 0; i < pairs.size(); ++i)\n    {\n        partnerMapping[pairs[i][0]] = pairs[i][1];\n        partnerMapping[pairs[i][1]] = pairs[i][0];\n    }\n\n    int unhappyFriendCount = 0;\n    for (int friendIndex = 0; friendIndex < totalFriends; friendIndex++)\n    {\n        int partnerIndex = partnerMapping[friendIndex];\n        vector<int> &preferenceList = preferences[friendIndex];\n        int partnerPreferenceIndex = -1;\n        for (int i = 0; i < preferenceList.size(); i++)\n        {\n            if (preferenceList[i] == partnerIndex)\n            {\n                partnerPreferenceIndex = i;\n                break;\n            }\n        }\n\n        for (int i = 0; i < partnerPreferenceIndex; i++)\n        {\n            int preferredFriend = preferenceList[i];\n            int preferredPartner = partnerMapping[preferredFriend];\n            vector<int> &preferredFriendPreferences = preferences[preferredFriend];\n            for (int j = 0; j < preferredFriendPreferences.size(); j++)\n            {\n                if (preferredFriendPreferences[j] == friendIndex)\n                {\n                    unhappyFriendCount++;\n                    break;\n                }\n                else if (preferredFriendPreferences[j] == preferredPartner)\n                {\n                    break;\n                }\n            }\n        }\n    }\n\n    return unhappyFriendCount / 2;\n}",
    "output": "#include <bits/stdc++.h>\nint unhappyFriends(int totalFriends, std::vector<std::vector<int>> &preferences, std::vector<std::vector<int>> &pairs)\n{\n    std::vector<int> partnerMapping(totalFriends);\n    for(std::vector<int> &pair : pairs)\n    {\n        partnerMapping[pair[0]]= pair[1];\n        partnerMapping[pair[1]]= pair[0];\n    }\n\n    int unhappyFriendCount= 0;\n    for(int friendIndex= 0; friendIndex < totalFriends; friendIndex++)\n    {\n        int partnerIndex= partnerMapping[friendIndex];\n        std::vector<int> &preferenceList= preferences[friendIndex];\n        int partnerPreferenceIndex= -1;\n        for(int i= 0; i < preferenceList.size(); i++)\n        {\n            if(preferenceList[i] == partnerIndex)\n            {\n                partnerPreferenceIndex= i;\n                break;\n            }\n        }\n\n        for(int i= 0; i < partnerPreferenceIndex; i++)\n        {\n            int preferredFriend= preferenceList[i];\n            int preferredPartner= partnerMapping[preferredFriend];\n            std::vector<int> &preferredFriendPreferences= preferences[preferredFriend];\n            for(int j= 0; j < preferredFriendPreferences.size(); j++)\n            {\n                if(preferredFriendPreferences[j] == friendIndex)\n                {\n                    unhappyFriendCount++;\n                    break;\n                }\n                else if(preferredFriendPreferences[j] == preferredPartner)\n                {\n                    break;\n                }\n            }\n        }\n    }\n\n    return unhappyFriendCount / 2;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minCostConnectPoints(vector<vector<int>> &pointCoordinates)\n{\n    int totalPoints = pointCoordinates.size();\n    vector<int> minimumCost(totalPoints);\n    vector<bool> isVisited(totalPoints, false);\n    fill(minimumCost.begin(), minimumCost.end(), INT_MAX);\n    minimumCost[0] = 0;\n\n    int totalCost = 0;\n\n    for(int i = 0; i < totalPoints; ++i)\n    {\n        int currentMinCost = INT_MAX;\n        int currentPoint = -1;\n        for(int j = 0; j < totalPoints; ++j)\n        {\n            if(!isVisited[j] && minimumCost[j] < currentMinCost)\n            {\n                currentMinCost = minimumCost[j];\n                currentPoint = j;\n            }\n        }\n\n        isVisited[currentPoint] = true;\n        totalCost += currentMinCost;\n\n        for(int j = 0; j < totalPoints; ++j)\n        {\n            if(!isVisited[j])\n            {\n                int newCost = abs(pointCoordinates[currentPoint][0] - pointCoordinates[j][0]) + abs(pointCoordinates[currentPoint][1] - pointCoordinates[j][1]);\n                minimumCost[j] = min(minimumCost[j], newCost);\n            }\n        }\n    }\n\n    return totalCost;\n}",
    "output": "#include <bits/stdc++.h>\nint minCostConnectPoints(std::vector<std::vector<int>> &pointCoordinates)\n{\n    int totalPoints= pointCoordinates.size();\n    std::vector<int> minimumCost(totalPoints);\n    std::vector<bool> isVisited(totalPoints, false);\n    std::fill(minimumCost.begin(), minimumCost.end(), INT_MAX);\n    minimumCost[0]= 0;\n\n    int totalCost= 0;\n\n    for(int i= 0; i < totalPoints; ++i)\n    {\n        int currentMinCost= INT_MAX;\n        int currentPoint= -1;\n        for(int j= 0; j < totalPoints; ++j)\n        {\n            if(!isVisited[j] && minimumCost[j] < currentMinCost)\n            {\n                currentMinCost= minimumCost[j];\n                currentPoint= j;\n            }\n        }\n\n        isVisited[currentPoint]= true;\n        totalCost+= currentMinCost;\n\n        for(int j= 0; j < totalPoints; ++j)\n        {\n            if(!isVisited[j])\n            {\n                int newCost= std::abs(pointCoordinates[currentPoint][0] - pointCoordinates[j][0]) + std::abs(pointCoordinates[currentPoint][1] - pointCoordinates[j][1]);\n                minimumCost[j]= std::min(minimumCost[j], newCost);\n            }\n        }\n    }\n\n    return totalCost;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canTransform(string sourceString, string targetString)\n{\n    int sourceIndex= 0, targetIndex= 0;\n    while(sourceIndex < sourceString.size() && targetIndex < targetString.size())\n    {\n        if(sourceString[sourceIndex] == targetString[targetIndex])\n        {\n            sourceIndex++;\n            targetIndex++;\n        }\n        else\n        {\n            sourceIndex++;\n        }\n    }\n    return targetIndex == targetString.size();\n}",
    "output": "#include <bits/stdc++.h>\nbool canTransform(std::string sourceString, std::string targetString)\n{\n    int sourceIndex= 0, targetIndex= 0;\n    while(sourceIndex < sourceString.size() && targetIndex < targetString.size())\n    {\n        if(sourceString[sourceIndex] == targetString[targetIndex])\n        {\n            sourceIndex++;\n            targetIndex++;\n        }\n        else\n        {\n            sourceIndex++;\n        }\n    }\n    return targetIndex == targetString.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass ParkingSystem\n{\n  public:\n    ParkingSystem(int bigSlots, int mediumSlots, int smallSlots)\n    {\n        parkingSlots= {bigSlots, mediumSlots, smallSlots};\n    }\n\n    bool addCar(int carType)\n    {\n        if(parkingSlots[carType - 1] > 0)\n        {\n            parkingSlots[carType - 1]--;\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n  private:\n    vector<int> parkingSlots;\n};",
    "output": "#include <bits/stdc++.h>\nclass ParkingSystem\n{\n  public:\n    ParkingSystem(int bigSlots, int mediumSlots, int smallSlots)\n    {\n        parkingSlots = {bigSlots, mediumSlots, smallSlots};\n    }\n\n    bool addCar(int carType)\n    {\n        if(parkingSlots[carType - 1] > 0)\n        {\n            parkingSlots[carType - 1]--;\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n  private:\n    std::vector<int> parkingSlots;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> busiestServers(int totalServers, vector<int> &arrivalTimes, vector<int> &loadTimes)\n{\n    vector<int> serverRequestCounts(totalServers, 0);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> requestQueue;\n    queue<int> availableServerIds;\n\n    for(int serverId= 0; serverId < totalServers; ++serverId)\n    {\n        availableServerIds.push(serverId);\n    }\n\n    for(int index= 0; index < arrivalTimes.size(); ++index)\n    {\n        while(!requestQueue.empty() && requestQueue.top().first <= arrivalTimes[index])\n        {\n            availableServerIds.push(requestQueue.top().second);\n            requestQueue.pop();\n        }\n\n        if(!availableServerIds.empty())\n        {\n            int serverId= availableServerIds.front();\n            availableServerIds.pop();\n            serverRequestCounts[serverId]++;\n            requestQueue.push({arrivalTimes[index] + loadTimes[index], serverId});\n        }\n    }\n\n    int maxRequestCount= 0;\n    for(int j = 0; j < serverRequestCounts.size(); ++j) // traditional for loop\n    {\n        maxRequestCount = max(maxRequestCount, serverRequestCounts[j]);\n    }\n\n    vector<int> resultServers;\n    for(int i= 0; i < totalServers; ++i)\n    {\n        if(serverRequestCounts[i] == maxRequestCount)\n        {\n            resultServers.push_back(i);\n        }\n    }\n\n    return resultServers;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> busiestServers(int totalServers, std::vector<int> &arrivalTimes, std::vector<int> &loadTimes)\n{\n    std::vector<int> serverRequestCounts(totalServers, 0);\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> requestQueue;\n    std::queue<int> availableServerIds;\n\n    for(int serverId= 0; serverId < totalServers; ++serverId)\n    {\n        availableServerIds.push(serverId);\n    }\n\n    for(int index= 0; index < arrivalTimes.size(); ++index)\n    {\n        while(!requestQueue.empty() && requestQueue.top().first <= arrivalTimes[index])\n        {\n            availableServerIds.push(requestQueue.top().second);\n            requestQueue.pop();\n        }\n\n        if(!availableServerIds.empty())\n        {\n            int serverId= availableServerIds.front();\n            availableServerIds.pop();\n            serverRequestCounts[serverId]++;\n            requestQueue.push({arrivalTimes[index] + loadTimes[index], serverId});\n        }\n    }\n\n    int maxRequestCount= 0;\n    for(int requests : serverRequestCounts)\n    {\n        maxRequestCount= std::max(maxRequestCount, requests);\n    }\n\n    std::vector<int> resultServers;\n    for(int i= 0; i < totalServers; ++i)\n    {\n        if(serverRequestCounts[i] == maxRequestCount)\n        {\n            resultServers.push_back(i);\n        }\n    }\n\n    return resultServers;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> restoreMatrix(vector<int> &rowSum, vector<int> &colSum)\n{\n    int rowCount = rowSum.size();\n    int colCount = colSum.size();\n    vector<vector<int>> result(rowCount, vector<int>(colCount, 0));\n\n    for(int rowIndex = 0; rowIndex < rowCount; ++rowIndex)\n    {\n        for(int colIndex = 0; colIndex < colCount; ++colIndex)\n        {\n            int value = min(rowSum[rowIndex], colSum[colIndex]);\n            result[rowIndex][colIndex] = value;\n            rowSum[rowIndex] -= value;\n            colSum[colIndex] -= value;\n        }\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> restoreMatrix(std::vector<int> &rowSum, std::vector<int> &colSum)\n{\n    int rowCount= rowSum.size();\n    int colCount= colSum.size();\n    std::vector<std::vector<int>> result(rowCount, std::vector<int>(colCount, 0));\n\n    for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex < colCount; ++colIndex)\n        {\n            int value= std::min(rowSum[rowIndex], colSum[colIndex]);\n            result[rowIndex][colIndex]= value;\n            rowSum[rowIndex]-= value;\n            colSum[colIndex]-= value;\n        }\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countWaysToSplit(vector<int> &numbers)\n{\n    int modulo= 1e9 + 7;\n    int size= numbers.size();\n    vector<long long> prefixSum(size + 1, 0);\n    for(int index= 0; index < size; index++)\n    {\n        prefixSum[index + 1]= prefixSum[index] + numbers[index];\n    }\n    int result= 0;\n    int leftIndex= 0, rightIndex= 0;\n    for(int midIndex= 1; midIndex < size - 1; midIndex++)\n    {\n        while(leftIndex + 1 < midIndex && prefixSum[leftIndex + 1] * 2 <= prefixSum[midIndex])\n        {\n            leftIndex++;\n        }\n        while(rightIndex < midIndex || (rightIndex + 1 < size && prefixSum[rightIndex + 1] - prefixSum[midIndex] <= prefixSum[size] - prefixSum[rightIndex + 1]))\n        {\n            rightIndex++;\n        }\n        if(rightIndex >= midIndex && prefixSum[midIndex] - prefixSum[leftIndex] <= prefixSum[rightIndex] - prefixSum[midIndex])\n        {\n            result= (result + rightIndex - midIndex + 1) % modulo;\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nint countWaysToSplit(std::vector<int> &numbers)\n{\n    int modulo= 1e9 + 7;\n    int size= numbers.size();\n    std::vector<long long> prefixSum(size + 1, 0);\n    for(int index= 0; index < size; index++)\n    {\n        prefixSum[index + 1]= prefixSum[index] + numbers[index];\n    }\n    int result= 0;\n    int leftIndex= 0, rightIndex= 0;\n    for(int midIndex= 1; midIndex < size - 1; midIndex++)\n    {\n        while(leftIndex + 1 < midIndex && prefixSum[leftIndex + 1] * 2 <= prefixSum[midIndex])\n        {\n            leftIndex++;\n        }\n        while(rightIndex < midIndex || (rightIndex + 1 < size && prefixSum[rightIndex + 1] - prefixSum[midIndex] <= prefixSum[size] - prefixSum[rightIndex + 1]))\n        {\n            rightIndex++;\n        }\n        if(rightIndex >= midIndex && prefixSum[midIndex] - prefixSum[leftIndex] <= prefixSum[rightIndex] - prefixSum[midIndex])\n        {\n            result= (result + rightIndex - midIndex + 1) % modulo;\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &targetArray, vector<int> &inputArray)\n{\n    unordered_map<int, int> positionMap;\n    for(int index = 0; index < targetArray.size(); ++index)\n    {\n        positionMap[targetArray[index]] = index;\n    }\n\n    vector<int> longestIncreasingSubsequence;\n    for(int i = 0; i < inputArray.size(); ++i)\n    {\n        const int &element = inputArray[i];\n        if(positionMap.find(element) != positionMap.end())\n        {\n            auto indexPosition = lower_bound(longestIncreasingSubsequence.begin(), longestIncreasingSubsequence.end(), positionMap[element]);\n            if(indexPosition == longestIncreasingSubsequence.end())\n            {\n                longestIncreasingSubsequence.push_back(positionMap[element]);\n            }\n            else\n            {\n                *indexPosition = positionMap[element];\n            }\n        }\n    }\n    return targetArray.size() - longestIncreasingSubsequence.size();\n}",
    "output": "#include <bits/stdc++.h>\nint minOperations(std::vector<int> &targetArray, std::vector<int> &inputArray)\n{\n    std::unordered_map<int, int> positionMap;\n    for(int index= 0; index < targetArray.size(); ++index)\n    {\n        positionMap[targetArray[index]]= index;\n    }\n\n    std::vector<int> longestIncreasingSubsequence;\n    for(const int &element : inputArray)\n    {\n        if(positionMap.find(element) != positionMap.end())\n        {\n            auto indexPosition= std::lower_bound(longestIncreasingSubsequence.begin(), longestIncreasingSubsequence.end(), positionMap[element]);\n            if(indexPosition == longestIncreasingSubsequence.end())\n            {\n                longestIncreasingSubsequence.push_back(positionMap[element]);\n            }\n            else\n            {\n                *indexPosition= positionMap[element];\n            }\n        }\n    }\n    return targetArray.size() - longestIncreasingSubsequence.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring reorderSpaces(const string &inputText)\n{\n    int totalSpaces = 0;\n    vector<string> wordList;\n\n    stringstream stringStream(inputText);\n    string currentWord;\n    while(stringStream >> currentWord)\n    {\n        wordList.push_back(currentWord);\n        totalSpaces += count(currentWord.begin(), currentWord.end(), ' ');\n    }\n\n    if(wordList.size() == 1)\n    {\n        return wordList[0] + string(totalSpaces, ' ');\n    }\n\n    int spacesBetweenWords = totalSpaces / (wordList.size() - 1);\n    int extraSpaces = totalSpaces % (wordList.size() - 1);\n    string result;\n\n    for(size_t i = 0; i < wordList.size(); i++)\n    {\n        result += wordList[i];\n        if(i < wordList.size() - 1)\n        {\n            result += string(spacesBetweenWords, ' ');\n        }\n    }\n\n    result += string(extraSpaces, ' ');\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string reorderSpaces(const std::string &inputText)\n{\n    int totalSpaces= 0;\n    std::vector<std::string> wordList;\n\n    std::stringstream stringStream(inputText);\n    std::string currentWord;\n    while(stringStream >> currentWord)\n    {\n        wordList.push_back(currentWord);\n        totalSpaces+= std::count(currentWord.begin(), currentWord.end(), ' ');\n    }\n\n    if(wordList.size() == 1)\n    {\n        return wordList[0] + std::string(totalSpaces, ' ');\n    }\n\n    int spacesBetweenWords= totalSpaces / (wordList.size() - 1);\n    int extraSpaces= totalSpaces % (wordList.size() - 1);\n    std::string result;\n\n    for(size_t i= 0; i < wordList.size(); i++)\n    {\n        result+= wordList[i];\n        if(i < wordList.size() - 1)\n        {\n            result+= std::string(spacesBetweenWords, ' ');\n        }\n    }\n\n    result+= std::string(extraSpaces, ' ');\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxProductPath(vector<vector<int>> &grid)\n{\n    int rowCount= grid.size(), columnCount= grid[0].size(), modulus= 1e9 + 7;\n    vector<vector<vector<long long>>> dynamicProgramming(rowCount, vector<vector<long long>>(columnCount, vector<long long>(2)));\n\n    dynamicProgramming[0][0]= {grid[0][0], grid[0][0]};\n\n    for(int rowIndex= 1; rowIndex < rowCount; rowIndex++)\n    {\n        dynamicProgramming[rowIndex][0][0]= dynamicProgramming[rowIndex][0][1]= dynamicProgramming[rowIndex - 1][0][0] * grid[rowIndex][0];\n    }\n    for(int columnIndex= 1; columnIndex < columnCount; columnIndex++)\n    {\n        dynamicProgramming[0][columnIndex][0]= dynamicProgramming[0][columnIndex][1]= dynamicProgramming[0][columnIndex - 1][0] * grid[0][columnIndex];\n    }\n\n    for(int rowIndex= 1; rowIndex < rowCount; rowIndex++)\n    {\n        for(int columnIndex= 1; columnIndex < columnCount; columnIndex++)\n        {\n            if(grid[rowIndex][columnIndex] < 0)\n            {\n                dynamicProgramming[rowIndex][columnIndex][0]= min(dynamicProgramming[rowIndex - 1][columnIndex][1], dynamicProgramming[rowIndex][columnIndex - 1][1]) * grid[rowIndex][columnIndex];\n                dynamicProgramming[rowIndex][columnIndex][1]= max(dynamicProgramming[rowIndex - 1][columnIndex][0], dynamicProgramming[rowIndex][columnIndex - 1][0]) * grid[rowIndex][columnIndex];\n            }\n            else\n            {\n                dynamicProgramming[rowIndex][columnIndex][0]= max(dynamicProgramming[rowIndex - 1][columnIndex][0], dynamicProgramming[rowIndex][columnIndex - 1][0]) * grid[rowIndex][columnIndex];\n                dynamicProgramming[rowIndex][columnIndex][1]= min(dynamicProgramming[rowIndex - 1][columnIndex][1], dynamicProgramming[rowIndex][columnIndex - 1][1]) * grid[rowIndex][columnIndex];\n            }\n        }\n    }\n\n    return dynamicProgramming[rowCount - 1][columnCount - 1][0] >= 0 ? dynamicProgramming[rowCount - 1][columnCount - 1][0] % modulus : -1;\n}",
    "output": "#include <bits/stdc++.h>\nint maxProductPath(std::vector<std::vector<int>> &grid)\n{\n    int rowCount = grid.size(), columnCount = grid[0].size(), modulus = 1e9 + 7;\n    std::vector<std::vector<std::vector<long long>>> dynamicProgramming(rowCount, std::vector<std::vector<long long>>(columnCount, std::vector<long long>(2)));\n\n    dynamicProgramming[0][0] = {grid[0][0], grid[0][0]};\n\n    for(int rowIndex = 1; rowIndex < rowCount; rowIndex++)\n    {\n        dynamicProgramming[rowIndex][0][0] = dynamicProgramming[rowIndex][0][1] = dynamicProgramming[rowIndex - 1][0][0] * grid[rowIndex][0];\n    }\n    for(int columnIndex = 1; columnIndex < columnCount; columnIndex++)\n    {\n        dynamicProgramming[0][columnIndex][0] = dynamicProgramming[0][columnIndex][1] = dynamicProgramming[0][columnIndex - 1][0] * grid[0][columnIndex];\n    }\n\n    for(int rowIndex = 1; rowIndex < rowCount; rowIndex++)\n    {\n        for(int columnIndex = 1; columnIndex < columnCount; columnIndex++)\n        {\n            if(grid[rowIndex][columnIndex] < 0)\n            {\n                dynamicProgramming[rowIndex][columnIndex][0] = std::min(dynamicProgramming[rowIndex - 1][columnIndex][1], dynamicProgramming[rowIndex][columnIndex - 1][1]) * grid[rowIndex][columnIndex];\n                dynamicProgramming[rowIndex][columnIndex][1] = std::max(dynamicProgramming[rowIndex - 1][columnIndex][0], dynamicProgramming[rowIndex][columnIndex - 1][0]) * grid[rowIndex][columnIndex];\n            }\n            else\n            {\n                dynamicProgramming[rowIndex][columnIndex][0] = std::max(dynamicProgramming[rowIndex - 1][columnIndex][0], dynamicProgramming[rowIndex][columnIndex - 1][0]) * grid[rowIndex][columnIndex];\n                dynamicProgramming[rowIndex][columnIndex][1] = std::min(dynamicProgramming[rowIndex - 1][columnIndex][1], dynamicProgramming[rowIndex][columnIndex - 1][1]) * grid[rowIndex][columnIndex];\n            }\n        }\n    }\n\n    return dynamicProgramming[rowCount - 1][columnCount - 1][0] >= 0 ? dynamicProgramming[rowCount - 1][columnCount - 1][0] % modulus : -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minCost(vector<vector<int>> &costMatrix, int numberOfItems, int numberOfOptions)\n{\n    vector<int> dynamicProgramming(numberOfOptions + 1, INT_MAX);\n    dynamicProgramming[0]= 0;\n\n    for(int itemIndex= 0; itemIndex < numberOfItems; ++itemIndex)\n    {\n        for(int optionIndex= numberOfOptions; optionIndex >= 0; --optionIndex)\n        {\n            int minimumCost= INT_MAX;\n            for(int option= 0; option < numberOfOptions; ++option)\n            {\n                if(((1 << option) & optionIndex) == 0)\n                {\n                    minimumCost= min(minimumCost, costMatrix[itemIndex][option] + dynamicProgramming[optionIndex | (1 << option)]);\n                }\n            }\n            dynamicProgramming[optionIndex]= min(dynamicProgramming[optionIndex], minimumCost);\n        }\n    }\n\n    return dynamicProgramming[(1 << numberOfOptions) - 1];\n}",
    "output": "#include <bits/stdc++.h>\nint minCost(std::vector<std::vector<int>> &costMatrix, int numberOfItems, int numberOfOptions)\n{\n    std::vector<int> dynamicProgramming(numberOfOptions + 1, std::numeric_limits<int>::max());\n    dynamicProgramming[0] = 0;\n\n    for(int itemIndex = 0; itemIndex < numberOfItems; ++itemIndex)\n    {\n        for(int optionIndex = numberOfOptions; optionIndex >= 0; --optionIndex)\n        {\n            int minimumCost = std::numeric_limits<int>::max();\n            for(int option = 0; option < numberOfOptions; ++option)\n            {\n                if(((1 << option) & optionIndex) == 0)\n                {\n                    minimumCost = std::min(minimumCost, costMatrix[itemIndex][option] + dynamicProgramming[optionIndex | (1 << option)]);\n                }\n            }\n            dynamicProgramming[optionIndex] = std::min(dynamicProgramming[optionIndex], minimumCost);\n        }\n    }\n\n    return dynamicProgramming[(1 << numberOfOptions) - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> constructDistancedSequence(int number)\n{\n    vector<int> result(2 * number - 1, 0);\n    function<bool(int, int)> depthFirstSearch= [&](int index, int unusedNumbers)\n    {\n        if(index == result.size())\n            return true;\n        if(result[index])\n            return depthFirstSearch(index + 1, unusedNumbers);\n        for(int currentNumber= number; currentNumber > 0; --currentNumber)\n        {\n            if((unusedNumbers >> currentNumber) & 1)\n            {\n                if(currentNumber == 1 || index + currentNumber < result.size() && !result[index + currentNumber])\n                {\n                    result[index]= currentNumber;\n                    if(currentNumber > 1)\n                        result[index + currentNumber]= currentNumber;\n                    if(depthFirstSearch(index + 1, unusedNumbers ^ (1 << currentNumber)))\n                        return true;\n                    result[index]= 0;\n                    if(currentNumber > 1)\n                        result[index + currentNumber]= 0;\n                }\n            }\n        }\n        return false;\n    };\n    depthFirstSearch(0, (1 << (number + 1)) - 2);\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> constructDistancedSequence(int number)\n{\n    std::vector<int> result(2 * number - 1, 0);\n    std::function<bool(int, int)> depthFirstSearch = [&](int index, int unusedNumbers)\n    {\n        if(index == result.size())\n            return true;\n        if(result[index])\n            return depthFirstSearch(index + 1, unusedNumbers);\n        for(int currentNumber = number; currentNumber > 0; --currentNumber)\n        {\n            if((unusedNumbers >> currentNumber) & 1)\n            {\n                if(currentNumber == 1 || index + currentNumber < result.size() && !result[index + currentNumber])\n                {\n                    result[index] = currentNumber;\n                    if(currentNumber > 1)\n                        result[index + currentNumber] = currentNumber;\n                    if(depthFirstSearch(index + 1, unusedNumbers ^ (1 << currentNumber)))\n                        return true;\n                    result[index] = 0;\n                    if(currentNumber > 1)\n                        result[index + currentNumber] = 0;\n                }\n            }\n        }\n        return false;\n    };\n    depthFirstSearch(0, (1 << (number + 1)) - 2);\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint checkWays(vector<vector<int>> &pairList)\n{\n    unordered_map<int, int> candidateCount;\n    for (int i = 0; i < pairList.size(); ++i)\n    {\n        ++candidateCount[pairList[i][0]];\n        ++candidateCount[pairList[i][1]];\n    }\n\n    int uniqueRootCount = 0;\n    for (auto it = candidateCount.begin(); it != candidateCount.end(); ++it)\n    {\n        if (it->second == 1)\n        {\n            ++uniqueRootCount;\n            if (uniqueRootCount > 1)\n            {\n                return 2;\n            }\n        }\n    }\n\n    return uniqueRootCount;\n}",
    "output": "#include <bits/stdc++.h>\nint checkWays(std::vector<std::vector<int>> &pairList)\n{\n    std::unordered_map<int, int> candidateCount;\n    for(const auto &pair : pairList)\n    {\n        ++candidateCount[pair[0]];\n        ++candidateCount[pair[1]];\n    }\n\n    int uniqueRootCount= 0;\n    for(const auto &candidate : candidateCount)\n    {\n        if(candidate.second == 1)\n        {\n            ++uniqueRootCount;\n            if(uniqueRootCount > 1)\n            {\n                return 2;\n            }\n        }\n    }\n\n    return uniqueRootCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<string> &logs)\n{\n    int currentDepth = 0;\n    for (int i = 0; i < logs.size(); ++i)\n    {\n        const string &logEntry = logs[i];\n        if (logEntry == \"../\")\n        {\n            if (currentDepth > 0)\n            {\n                currentDepth--;\n            }\n        }\n        else if (logEntry != \"./\")\n        {\n            currentDepth++;\n        }\n    }\n    return currentDepth;\n}",
    "output": "#include <bits/stdc++.h>\nint minOperations(std::vector<std::string> &logs)\n{\n    int currentDepth= 0;\n    for(const std::string &logEntry : logs)\n    {\n        if(logEntry == \"../\")\n        {\n            if(currentDepth > 0)\n            {\n                currentDepth--;\n            }\n        }\n        else if(logEntry != \"./\")\n        {\n            currentDepth++;\n        }\n    }\n    return currentDepth;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperationsMaxProfit(vector<int> &customerQueue, int boardingCost, int runningCost)\n{\n    int totalRotations= 0, waitingCustomers= 0, onBoardCustomers= 0, currentProfit= 0, maxProfit= 0, maxRotations= 0;\n    while(!customerQueue.empty() || waitingCustomers > 0)\n    {\n        if(!customerQueue.empty())\n        {\n            waitingCustomers+= customerQueue.front();\n            customerQueue.erase(customerQueue.begin());\n        }\n\n        onBoardCustomers= min(waitingCustomers, 4);\n        waitingCustomers-= onBoardCustomers;\n        currentProfit+= onBoardCustomers * boardingCost - runningCost;\n        totalRotations++;\n\n        if(currentProfit > maxProfit)\n        {\n            maxProfit= currentProfit;\n            maxRotations= totalRotations;\n        }\n    }\n    return maxProfit > 0 ? maxRotations : -1;\n}",
    "output": "#include <bits/stdc++.h>\nint minOperationsMaxProfit(std::vector<int> &customerQueue, int boardingCost, int runningCost)\n{\n    int totalRotations= 0, waitingCustomers= 0, onBoardCustomers= 0, currentProfit= 0, maxProfit= 0, maxRotations= 0;\n    while(!customerQueue.empty() || waitingCustomers > 0)\n    {\n        if(!customerQueue.empty())\n        {\n            waitingCustomers+= customerQueue.front();\n            customerQueue.erase(customerQueue.begin());\n        }\n\n        onBoardCustomers= std::min(waitingCustomers, 4);\n        waitingCustomers-= onBoardCustomers;\n        currentProfit+= onBoardCustomers * boardingCost - runningCost;\n        totalRotations++;\n\n        if(currentProfit > maxProfit)\n        {\n            maxProfit= currentProfit;\n            maxRotations= totalRotations;\n        }\n    }\n    return maxProfit > 0 ? maxRotations : -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass ThroneInheritance\n{\n    unordered_map<string, vector<string>> childrenMap;\n    unordered_map<string, bool> isAlive;\n    string kingName;\n\n  public:\n    ThroneInheritance(string initialKingName) : kingName(initialKingName)\n    {\n        isAlive[initialKingName] = true;\n    }\n\n    void birth(string parentName, string childName)\n    {\n        childrenMap[parentName].push_back(childName);\n        isAlive[childName] = true;\n    }\n\n    void death(string name)\n    {\n        isAlive[name] = false;\n    }\n\n    vector<string> getInheritanceOrder()\n    {\n        vector<string> inheritanceOrder;\n        getSuccessor(kingName, inheritanceOrder);\n        return inheritanceOrder;\n    }\n\n    void getSuccessor(string name, vector<string> &inheritanceOrder)\n    {\n        if (isAlive[name])\n        {\n            inheritanceOrder.push_back(name);\n        }\n        for (size_t i = 0; i < childrenMap[name].size(); ++i)\n        {\n            getSuccessor(childrenMap[name][i], inheritanceOrder);\n        }\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass ThroneInheritance\n{\n    std::unordered_map<std::string, std::vector<std::string>> childrenMap;\n    std::unordered_map<std::string, bool> isAlive;\n    std::string kingName;\n\n  public:\n    ThroneInheritance(std::string initialKingName) : kingName(initialKingName)\n    {\n        isAlive[initialKingName]= true;\n    }\n\n    void birth(std::string parentName, std::string childName)\n    {\n        childrenMap[parentName].push_back(childName);\n        isAlive[childName]= true;\n    }\n\n    void death(std::string name)\n    {\n        isAlive[name]= false;\n    }\n\n    std::vector<std::string> getInheritanceOrder()\n    {\n        std::vector<std::string> inheritanceOrder;\n        getSuccessor(kingName, inheritanceOrder);\n        return inheritanceOrder;\n    }\n\n    void getSuccessor(std::string name, std::vector<std::string> &inheritanceOrder)\n    {\n        if(isAlive[name])\n        {\n            inheritanceOrder.push_back(name);\n        }\n        for(const auto &child : childrenMap[name])\n        {\n            getSuccessor(child, inheritanceOrder);\n        }\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAchievableRequests(int numberOfBuildings, vector<vector<int>> &requests, int currentIndex = 0, vector<int> buildingCounts = {})\n{\n    if (buildingCounts.empty())\n    {\n        buildingCounts.resize(numberOfBuildings, 0);\n    }\n    if (currentIndex == requests.size())\n    {\n        for (int i = 0; i < buildingCounts.size(); ++i)\n        {\n            if (buildingCounts[i] != 0)\n                return 0;\n        }\n        return 0;\n    }\n    int ignoredRequests = maxAchievableRequests(numberOfBuildings, requests, currentIndex + 1, buildingCounts);\n    buildingCounts[requests[currentIndex][0]]++;\n    buildingCounts[requests[currentIndex][1]]--;\n\n    int acceptedRequests = 1 + maxAchievableRequests(numberOfBuildings, requests, currentIndex + 1, buildingCounts);\n\n    return max(ignoredRequests, acceptedRequests);\n}",
    "output": "#include <bits/stdc++.h>\nint maxAchievableRequests(int numberOfBuildings, std::vector<std::vector<int>> &requests, int currentIndex= 0, std::vector<int> buildingCounts= {})\n{\n    if(buildingCounts.empty())\n    {\n        buildingCounts.resize(numberOfBuildings, 0);\n    }\n    if(currentIndex == requests.size())\n    {\n        for(int count : buildingCounts)\n        {\n            if(count != 0)\n                return 0;\n        }\n        return 0;\n    }\n    int ignoredRequests= maxAchievableRequests(numberOfBuildings, requests, currentIndex + 1, buildingCounts);\n    buildingCounts[requests[currentIndex][0]]++;\n    buildingCounts[requests[currentIndex][1]]--;\n\n    int acceptedRequests= 1 + maxAchievableRequests(numberOfBuildings, requests, currentIndex + 1, buildingCounts);\n\n    return std::max(ignoredRequests, acceptedRequests);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass DistanceLimitedPathsExist\n{\n  public:\n    DistanceLimitedPathsExist(int nodeCount, const vector<vector<int>> &edgeList)\n    {\n        parent.resize(nodeCount);\n        for(int index = 0; index < nodeCount; ++index)\n        {\n            parent[index] = index;\n        }\n        sort(edgeList.begin(), edgeList.end(), [](const auto &a, const auto &b)\n                  { return a[2] < b[2]; });\n        for(int i = 0; i < edgeList.size(); ++i)\n        {\n            const auto &edge = edgeList[i];\n            int rootA = find(edge[0]);\n            int rootB = find(edge[1]);\n            if(rootA != rootB)\n            {\n                parent[rootA] = rootB;\n                minimumSpanningTree.emplace_back(edge);\n            }\n        }\n    }\n\n    bool query(int nodeA, int nodeB, int limit)\n    {\n        for(int i = 0; i < minimumSpanningTree.size(); ++i)\n        {\n            const auto &edge = minimumSpanningTree[i];\n            if(edge[2] >= limit)\n                break;\n            nodeA = unionSet(edge[0], nodeA);\n            nodeB = unionSet(edge[1], nodeB);\n            if(nodeA == nodeB)\n                return true;\n        }\n        return false;\n    }\n\n  private:\n    int find(int node)\n    {\n        if(parent[node] != node)\n        {\n            parent[node] = find(parent[node]);\n        }\n        return parent[node];\n    }\n\n    int unionSet(int nodeX, int nodeY)\n    {\n        int rootX = find(nodeX);\n        int rootY = find(nodeY);\n        if(rootX != rootY)\n        {\n            parent[rootX] = rootY;\n        }\n        return rootY;\n    }\n\n    vector<int> parent;\n    vector<vector<int>> minimumSpanningTree;\n};",
    "output": "#include <bits/stdc++.h>\nclass DistanceLimitedPathsExist\n{\n  public:\n    DistanceLimitedPathsExist(int nodeCount, const std::vector<std::vector<int>> &edgeList)\n    {\n        parent.resize(nodeCount);\n        for(int index= 0; index < nodeCount; ++index)\n        {\n            parent[index]= index;\n        }\n        std::sort(edgeList.begin(), edgeList.end(), [](const auto &a, const auto &b)\n                  { return a[2] < b[2]; });\n        for(const auto &edge : edgeList)\n        {\n            int rootA= find(edge[0]);\n            int rootB= find(edge[1]);\n            if(rootA != rootB)\n            {\n                parent[rootA]= rootB;\n                minimumSpanningTree.emplace_back(edge);\n            }\n        }\n    }\n\n    bool query(int nodeA, int nodeB, int limit)\n    {\n        for(const auto &edge : minimumSpanningTree)\n        {\n            if(edge[2] >= limit)\n                break;\n            nodeA= unionSet(edge[0], nodeA);\n            nodeB= unionSet(edge[1], nodeB);\n            if(nodeA == nodeB)\n                return true;\n        }\n        return false;\n    }\n\n  private:\n    int find(int node)\n    {\n        if(parent[node] != node)\n        {\n            parent[node]= find(parent[node]);\n        }\n        return parent[node];\n    }\n\n    int unionSet(int nodeX, int nodeY)\n    {\n        int rootX= find(nodeX);\n        int rootY= find(nodeY);\n        if(rootX != rootY)\n        {\n            parent[rootX]= rootY;\n        }\n        return rootY;\n    }\n\n    std::vector<int> parent;\n    std::vector<std::vector<int>> minimumSpanningTree;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateNumberOfSets(int totalElements, int setSize)\n{\n    long long modulo= 1e9 + 7;\n    vector<vector<long long>> dynamicProgramming(totalElements, vector<long long>(setSize + 1, 0));\n    vector<long long> prefixSum(totalElements, 1);\n\n    for(int currentSetSize= 1; currentSetSize <= setSize; ++currentSetSize)\n    {\n        for(int elementIndex= 0; elementIndex < totalElements; ++elementIndex)\n        {\n            dynamicProgramming[elementIndex][currentSetSize]= prefixSum[elementIndex];\n            if(elementIndex)\n            {\n                dynamicProgramming[elementIndex][currentSetSize]+= dynamicProgramming[elementIndex - 1][currentSetSize];\n            }\n            dynamicProgramming[elementIndex][currentSetSize]%= modulo;\n            prefixSum[elementIndex]= (prefixSum[elementIndex] + dynamicProgramming[elementIndex][currentSetSize - 1]) % modulo;\n        }\n    }\n\n    return dynamicProgramming[totalElements - 1][setSize];\n}",
    "output": "#include <bits/stdc++.h>\nint calculateNumberOfSets(int totalElements, int setSize)\n{\n    long long modulo= 1e9 + 7;\n    std::vector<std::vector<long long>> dynamicProgramming(totalElements, std::vector<long long>(setSize + 1, 0));\n    std::vector<long long> prefixSum(totalElements, 1);\n\n    for(int currentSetSize= 1; currentSetSize <= setSize; ++currentSetSize)\n    {\n        for(int elementIndex= 0; elementIndex < totalElements; ++elementIndex)\n        {\n            dynamicProgramming[elementIndex][currentSetSize]= prefixSum[elementIndex];\n            if(elementIndex)\n            {\n                dynamicProgramming[elementIndex][currentSetSize]+= dynamicProgramming[elementIndex - 1][currentSetSize];\n            }\n            dynamicProgramming[elementIndex][currentSetSize]%= modulo;\n            prefixSum[elementIndex]= (prefixSum[elementIndex] + dynamicProgramming[elementIndex][currentSetSize - 1]) % modulo;\n        }\n    }\n\n    return dynamicProgramming[totalElements - 1][setSize];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> bestCoordinate(vector<vector<int>> &towerCoordinates, int radius)\n{\n    int maxQuality = 0, bestX = 0, bestY = 0;\n\n    for (int coordinateX = 0; coordinateX <= 50; ++coordinateX)\n    {\n        for (int coordinateY = 0; coordinateY <= 50; ++coordinateY)\n        {\n            int sumQuality = 0;\n            for (int i = 0; i < towerCoordinates.size(); ++i)\n            {\n                const auto &tower = towerCoordinates[i];\n                double distance = sqrt(pow(coordinateX - tower[0], 2) + pow(coordinateY - tower[1], 2));\n                if (distance <= radius)\n                {\n                    sumQuality += tower[2] / (1 + distance);\n                }\n            }\n            if (sumQuality > maxQuality)\n            {\n                maxQuality = sumQuality;\n                bestX = coordinateX;\n                bestY = coordinateY;\n            }\n        }\n    }\n\n    return {bestX, bestY};\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> bestCoordinate(std::vector<std::vector<int>> &towerCoordinates, int radius)\n{\n    int maxQuality= 0, bestX= 0, bestY= 0;\n\n    for(int coordinateX= 0; coordinateX <= 50; ++coordinateX)\n    {\n        for(int coordinateY= 0; coordinateY <= 50; ++coordinateY)\n        {\n            int sumQuality= 0;\n            for(const auto &tower : towerCoordinates)\n            {\n                double distance= std::sqrt(std::pow(coordinateX - tower[0], 2) + std::pow(coordinateY - tower[1], 2));\n                if(distance <= radius)\n                {\n                    sumQuality+= tower[2] / (1 + distance);\n                }\n            }\n            if(sumQuality > maxQuality)\n            {\n                maxQuality= sumQuality;\n                bestX= coordinateX;\n                bestY= coordinateY;\n            }\n        }\n    }\n\n    return {bestX, bestY};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For abs\nusing namespace std;\n\nbool canMouseWin(vector<vector<char>> &gameGrid, int catJumpDistance, int mouseJumpDistance)\n{\n    int gridRows= gameGrid.size();\n    int gridCols= gameGrid[0].size();\n    int catRow, catCol, mouseRow, mouseCol, stepCount= 0;\n\n    for(int row= 0; row < gridRows; ++row)\n        for(int col= 0; col < gridCols; ++col)\n        {\n            if(gameGrid[row][col] == 'C')\n            {\n                catRow= row;\n                catCol= col;\n            }\n            else if(gameGrid[row][col] == 'M')\n            {\n                mouseRow= row;\n                mouseCol= col;\n            }\n        }\n\n    vector<int> directions= {-1, 0, 1, 0, -1};\n    function<bool(int, int, int, int, int, int)> depthFirstSearch= [&](int currentMouseRow, int currentMouseCol, int currentCatRow, int currentCatCol, int currentCount, int destinationMouseCat)\n    {\n        if(currentCount >= 100) // The game is taking more than 100 steps\n            return false;\n        if(currentMouseRow < 0 || currentMouseRow >= gridRows || currentMouseCol < 0 || currentMouseCol >= gridCols) // Mouse out of bounds\n            return false;\n        if(currentCatRow < 0 || currentCatRow >= gridRows || currentCatCol < 0 || currentCatCol >= gridCols) // Cat out of bounds\n            return true;\n        if(gameGrid[currentMouseRow][currentMouseCol] == 'F' || currentCount != destinationMouseCat)\n        { // Mouse reached food or cell is odd steps away from food\n            return true;\n        }\n        else if(gameGrid[currentMouseRow][currentMouseCol] == '#' || currentCount + 1 == destinationMouseCat)\n        { // Wall or cell is even steps away from food\n            return false;\n        }\n\n        bool result= false;\n        for(int i= 0; i < 4; i++)\n        {\n            int jumpDistance= (destinationMouseCat == currentCount) ? catJumpDistance : mouseJumpDistance;\n            result|= !depthFirstSearch(currentMouseRow + jumpDistance * directions[i], currentMouseCol + jumpDistance * directions[i + 1], currentCatRow + directions[i] * directions[(i + 2) % 4], currentCatCol + directions[i + 1] * directions[(i + 3) % 4], currentCount + 1, destinationMouseCat);\n            if(jumpDistance == 1)\n                break;\n        }\n        return result;\n    };\n\n    return depthFirstSearch(mouseRow, mouseCol, catRow, catCol, 0, abs(catRow - mouseRow) + abs(catCol - mouseCol));\n}",
    "output": "#include <bits/stdc++.h>\nbool canMouseWin(std::vector<std::vector<char>> &gameGrid, int catJumpDistance, int mouseJumpDistance)\n{\n    int gridRows= gameGrid.size();\n    int gridCols= gameGrid[0].size();\n    int catRow, catCol, mouseRow, mouseCol, stepCount= 0;\n\n    for(int row= 0; row < gridRows; ++row)\n        for(int col= 0; col < gridCols; ++col)\n        {\n            if(gameGrid[row][col] == 'C')\n            {\n                catRow= row;\n                catCol= col;\n            }\n            else if(gameGrid[row][col] == 'M')\n            {\n                mouseRow= row;\n                mouseCol= col;\n            }\n        }\n\n    std::vector<int> directions= {-1, 0, 1, 0, -1};\n    std::function<bool(int, int, int, int, int, int)> depthFirstSearch= [&](int currentMouseRow, int currentMouseCol, int currentCatRow, int currentCatCol, int currentCount, int destinationMouseCat)\n    {\n        if(currentCount >= 100) // The game is taking more than 100 steps\n            return false;\n        if(currentMouseRow < 0 || currentMouseRow >= gridRows || currentMouseCol < 0 || currentMouseCol >= gridCols) // Mouse out of bounds\n            return false;\n        if(currentCatRow < 0 || currentCatRow >= gridRows || currentCatCol < 0 || currentCatCol >= gridCols) // Cat out of bounds\n            return true;\n        if(gameGrid[currentMouseRow][currentMouseCol] == 'F' || currentCount != destinationMouseCat)\n        { // Mouse reached food or cell is odd steps away from food\n            return true;\n        }\n        else if(gameGrid[currentMouseRow][currentMouseCol] == '#' || currentCount + 1 == destinationMouseCat)\n        { // Wall or cell is even steps away from food\n            return false;\n        }\n\n        bool result= false;\n        for(int i= 0; i < 4; i++)\n        {\n            int jumpDistance= (destinationMouseCat == currentCount) ? catJumpDistance : mouseJumpDistance;\n            result|= !depthFirstSearch(currentMouseRow + jumpDistance * directions[i], currentMouseCol + jumpDistance * directions[i + 1], currentCatRow + directions[i] * directions[(i + 2) % 4], currentCatCol + directions[i + 1] * directions[(i + 3) % 4], currentCount + 1, destinationMouseCat);\n            if(jumpDistance == 1)\n                break;\n        }\n        return result;\n    };\n\n    return depthFirstSearch(mouseRow, mouseCol, catRow, catCol, 0, std::abs(catRow - mouseRow) + std::abs(catCol - mouseCol));\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Fancy\n{\n  public:\n    Fancy() {}\n\n    void append(int value)\n    {\n        numberSequence.push_back(value);\n    }\n\n    void addAll(int increment)\n    {\n        for (int i = 0; i < numberSequence.size(); ++i)\n        {\n            numberSequence[i] += increment;\n        }\n    }\n\n    void multAll(int multiplier)\n    {\n        for (int i = 0; i < numberSequence.size(); ++i)\n        {\n            numberSequence[i] *= multiplier;\n        }\n    }\n\n    int getIndex(int index)\n    {\n        if (index >= numberSequence.size())\n            return -1;\n        return numberSequence[index];\n    }\n\n  private:\n    vector<int> numberSequence;\n};",
    "output": "#include <bits/stdc++.h>\nclass Fancy\n{\n  public:\n    Fancy() {}\n\n    void append(int value)\n    {\n        numberSequence.push_back(value);\n    }\n\n    void addAll(int increment)\n    {\n        for(auto &currentNumber : numberSequence)\n        {\n            currentNumber += increment;\n        }\n    }\n\n    void multAll(int multiplier)\n    {\n        for(auto &currentNumber : numberSequence)\n        {\n            currentNumber *= multiplier;\n        }\n    }\n\n    int getIndex(int index)\n    {\n        if(index >= numberSequence.size())\n            return -1;\n        return numberSequence[index];\n    }\n\n  private:\n    std::vector<int> numberSequence;\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findSpecialInteger(const vector<int> &numbers)\n{\n    for(int threshold = 1; threshold <= numbers.size(); ++threshold)\n    {\n        int occurrences = 0;\n        for(int j = 0; j < numbers.size(); ++j)\n        {\n            int number = numbers[j];\n            if(number >= threshold)\n            {\n                ++occurrences;\n            }\n        }\n        if(occurrences == threshold)\n        {\n            return threshold;\n        }\n    }\n    return -1;\n}",
    "output": "int findSpecialInteger(const std::vector<int> &numbers)\n{\n    for(int threshold= 1; threshold <= numbers.size(); ++threshold)\n    {\n        int occurrences= 0;\n        for(int number : numbers)\n        {\n            if(number >= threshold)\n            {\n                ++occurrences;\n            }\n        }\n        if(occurrences == threshold)\n        {\n            return threshold;\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int minOperations(int number)\n{\n    int operationCount= 0;\n    while(number > 0)\n    {\n        if(number % 2 == 0)\n        {\n            number/= 2;\n        }\n        else\n        {\n            number--;\n        }\n        operationCount++;\n    }\n    return operationCount;\n}",
    "output": "int minOperations(int number)\n{\n    int operationCount= 0;\n    while(number > 0)\n    {\n        if(number % 2 == 0)\n        {\n            number/= 2;\n        }\n        else\n        {\n            number--;\n        }\n        operationCount++;\n    }\n    return operationCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateAngle(int pointX, int pointY, int locationX, int locationY)\n{\n    return atan2(pointY - locationY, pointX - locationX) * 180 / M_PI;\n}\n\nint countVisiblePoints(vector<vector<int>> &pointsList, int fieldOfView, vector<int> &observerLocation)\n{\n    vector<double> angleList;\n    for (int i = 0; i < pointsList.size(); ++i)\n    {\n        const auto &point = pointsList[i];\n        if (point != observerLocation)\n        {\n            angleList.push_back(calculateAngle(point[0], point[1], observerLocation[0], observerLocation[1]));\n        }\n    }\n    sort(angleList.begin(), angleList.end());\n    int numberOfPoints = angleList.size();\n    for (int i = 0; i < numberOfPoints; i++)\n    {\n        angleList.push_back(angleList[i] + 360);\n    }\n    int maxVisiblePoints = 0;\n    int j = 0;\n    for (int i = 0; i < 2 * numberOfPoints; i++)\n    {\n        while (angleList[i] - angleList[j] > fieldOfView)\n        {\n            j++;\n        }\n        maxVisiblePoints = max(maxVisiblePoints, i - j + 1);\n    }\n    return maxVisiblePoints + count(pointsList.begin(), pointsList.end(), observerLocation);\n}",
    "output": "#include <bits/stdc++.h>\ndouble calculateAngle(int pointX, int pointY, int locationX, int locationY)\n{\n    return std::atan2(pointY - locationY, pointX - locationX) * 180 / M_PI;\n}\n\nint countVisiblePoints(std::vector<std::vector<int>> &pointsList, int fieldOfView, std::vector<int> &observerLocation)\n{\n    std::vector<double> angleList;\n    for(const auto &point : pointsList)\n    {\n        if(point != observerLocation)\n        {\n            angleList.push_back(calculateAngle(point[0], point[1], observerLocation[0], observerLocation[1]));\n        }\n    }\n    std::sort(angleList.begin(), angleList.end());\n    int numberOfPoints = angleList.size();\n    for(int i = 0; i < numberOfPoints; i++)\n    {\n        angleList.push_back(angleList[i] + 360);\n    }\n    int maxVisiblePoints = 0;\n    int j = 0;\n    for(int i = 0; i < 2 * numberOfPoints; i++)\n    {\n        while(angleList[i] - angleList[j] > fieldOfView)\n        {\n            j++;\n        }\n        maxVisiblePoints = std::max(maxVisiblePoints, i - j + 1);\n    }\n    return maxVisiblePoints + std::count(pointsList.begin(), pointsList.end(), observerLocation);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> decode(vector<int> &encodedArray)\n{\n    int arraySize = encodedArray.size() + 1;\n    int totalXor = 0;\n    for(int i = 1; i <= arraySize; i++)\n    {\n        totalXor ^= i;\n    }\n\n    int nonFirstXor = 0;\n    for(int i = 1; i < arraySize - 1; i += 2)\n    {\n        nonFirstXor ^= encodedArray[i];\n    }\n\n    vector<int> permutationArray(arraySize);\n    permutationArray[0] = totalXor ^ nonFirstXor;\n\n    for(int i = 1; i < arraySize; i++)\n    {\n        permutationArray[i] = permutationArray[i - 1] ^ encodedArray[i - 1];\n    }\n\n    return permutationArray;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> decode(std::vector<int> &encodedArray)\n{\n    int arraySize= encodedArray.size() + 1;\n    int totalXor= 0;\n    for(int i= 1; i <= arraySize; i++)\n    {\n        totalXor^= i;\n    }\n\n    int nonFirstXor= 0;\n    for(int i= 1; i < arraySize - 1; i+= 2)\n    {\n        nonFirstXor^= encodedArray[i];\n    }\n\n    std::vector<int> permutationArray(arraySize);\n    permutationArray[0]= totalXor ^ nonFirstXor;\n\n    for(int i= 1; i < arraySize; i++)\n    {\n        permutationArray[i]= permutationArray[i - 1] ^ encodedArray[i - 1];\n    }\n\n    return permutationArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo = 1e9 + 7;\n\nint multiply(int firstNumber, int secondNumber)\n{\n    return (1LL * firstNumber * secondNumber) % modulo;\n}\n\nint powerModulo(int base, int exponent)\n{\n    int result = 1;\n    while (exponent)\n    {\n        if (exponent & 1)\n            result = multiply(result, base);\n        base = multiply(base, base);\n        exponent >>= 1;\n    }\n    return result;\n}\n\nint calculateWays(int totalElements, int distinctElements, unordered_map<int, int> &memoization)\n{\n    if (totalElements == 1)\n        return distinctElements;\n    int &result = memoization[totalElements * 50000 + distinctElements];\n    if (result)\n        return result;\n\n    if (distinctElements == 1)\n    {\n        return result = 1;\n    }\n    if (totalElements > distinctElements)\n    {\n        return result = 0;\n    }\n\n    result = multiply(calculateWays(totalElements, distinctElements - 1, memoization), totalElements);\n    result = (result - multiply(totalElements - 1, calculateWays(totalElements - 1, distinctElements - 1, memoization)) + modulo) % modulo;\n\n    return result;\n}\n\nvector<int> waysToFillArray(vector<vector<int>> &queries)\n{\n    unordered_map<int, int> memoization;\n    vector<int> answers;\n    for (size_t i = 0; i < queries.size(); ++i)\n    {\n        answers.push_back(calculateWays(queries[i][0], queries[i][1], memoization));\n    }\n    return answers;\n}",
    "output": "#include <bits/stdc++.h>\nconst int modulo= 1e9 + 7;\n\nint multiply(int firstNumber, int secondNumber)\n{\n    return (1LL * firstNumber * secondNumber) % modulo;\n}\n\nint powerModulo(int base, int exponent)\n{\n    int result= 1;\n    while(exponent)\n    {\n        if(exponent & 1)\n            result= multiply(result, base);\n        base= multiply(base, base);\n        exponent>>= 1;\n    }\n    return result;\n}\n\nint calculateWays(int totalElements, int distinctElements, std::unordered_map<int, int> &memoization)\n{\n    if(totalElements == 1)\n        return distinctElements;\n    int &result= memoization[totalElements * 50000 + distinctElements];\n    if(result)\n        return result;\n\n    if(distinctElements == 1)\n    {\n        return result= 1;\n    }\n    if(totalElements > distinctElements)\n    {\n        return result= 0;\n    }\n\n    result= multiply(calculateWays(totalElements, distinctElements - 1, memoization), totalElements);\n    result= (result - multiply(totalElements - 1, calculateWays(totalElements - 1, distinctElements - 1, memoization)) + modulo) % modulo;\n\n    return result;\n}\n\nstd::vector<int> waysToFillArray(std::vector<std::vector<int>> &queries)\n{\n    std::unordered_map<int, int> memoization;\n    std::vector<int> answers;\n    for(auto &query : queries)\n    {\n        answers.push_back(calculateWays(query[0], query[1], memoization));\n    }\n    return answers;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring getMaximumTime(string inputTime)\n{\n    if(inputTime[0] == '?')\n    {\n        inputTime[0]= (inputTime[1] <= '3' || inputTime[1] == '?') ? '2' : '1';\n    }\n    if(inputTime[1] == '?')\n    {\n        inputTime[1]= (inputTime[0] == '2') ? '3' : '9';\n    }\n    if(inputTime[3] == '?')\n    {\n        inputTime[3]= '5';\n    }\n    if(inputTime[4] == '?')\n    {\n        inputTime[4]= '9';\n    }\n    return inputTime;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string getMaximumTime(std::string inputTime)\n{\n    if(inputTime[0] == '?')\n    {\n        inputTime[0]= (inputTime[1] <= '3' || inputTime[1] == '?') ? '2' : '1';\n    }\n    if(inputTime[1] == '?')\n    {\n        inputTime[1]= (inputTime[0] == '2') ? '3' : '9';\n    }\n    if(inputTime[3] == '?')\n    {\n        inputTime[3]= '5';\n    }\n    if(inputTime[4] == '?')\n    {\n        inputTime[4]= '9';\n    }\n    return inputTime;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxDepth(string inputString)\n{\n    int currentDepth = 0, maximumDepth = 0;\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        const char character = inputString[i];\n        if (character == '(')\n            ++currentDepth;\n        else if (character == ')')\n            --currentDepth;\n        maximumDepth = max(maximumDepth, currentDepth);\n    }\n    return maximumDepth;\n}",
    "output": "#include <bits/stdc++.h>\nint maxDepth(std::string inputString)\n{\n    int currentDepth= 0, maximumDepth= 0;\n    for(const char character : inputString)\n    {\n        if(character == '(')\n            ++currentDepth;\n        else if(character == ')')\n            --currentDepth;\n        maximumDepth= std::max(maximumDepth, currentDepth);\n    }\n    return maximumDepth;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For std::pair\nusing namespace std;\n\nint maximalNetworkRank(int cityCount, vector<vector<int>> &roadConnections)\n{\n    vector<int> cityDegree(cityCount, 0);\n    set<pair<int, int>> uniqueRoads;\n\n    for (auto &road : roadConnections)\n    {\n        cityDegree[road[0]]++;\n        cityDegree[road[1]]++;\n        uniqueRoads.insert({min(road[0], road[1]), max(road[0], road[1])});\n    }\n\n    int maxRank = 0;\n    for (int firstCity = 0; firstCity < cityCount; firstCity++)\n    {\n        for (int secondCity = firstCity + 1; secondCity < cityCount; secondCity++)\n        {\n            maxRank = max(maxRank, cityDegree[firstCity] + cityDegree[secondCity] - (uniqueRoads.count({firstCity, secondCity}) ? 1 : 0));\n        }\n    }\n    return maxRank;\n}",
    "output": "#include <bits/stdc++.h>\n// for std::pair\n\nint maximalNetworkRank(int cityCount, std::vector<std::vector<int>> &roadConnections)\n{\n    std::vector<int> cityDegree(cityCount, 0);\n    std::set<std::pair<int, int>> uniqueRoads;\n\n    for(auto &road : roadConnections)\n    {\n        cityDegree[road[0]]++;\n        cityDegree[road[1]]++;\n        uniqueRoads.insert({std::min(road[0], road[1]), std::max(road[0], road[1])});\n    }\n\n    int maxRank= 0;\n    for(int firstCity= 0; firstCity < cityCount; firstCity++)\n    {\n        for(int secondCity= firstCity + 1; secondCity < cityCount; secondCity++)\n        {\n            maxRank= std::max(maxRank, cityDegree[firstCity] + cityDegree[secondCity] - (uniqueRoads.count({firstCity, secondCity}) ? 1 : 0));\n        }\n    }\n    return maxRank;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool checkPalindromeFormation(string firstString, string secondString)\n{\n    auto isPalindrome = [](const string &stringToCheck, int leftIndex, int rightIndex)\n    {\n        while(leftIndex < rightIndex)\n        {\n            if(stringToCheck[leftIndex++] != stringToCheck[rightIndex--])\n                return false;\n        }\n        return true;\n    };\n\n    for(int leftPointer = 0, rightPointer = firstString.size() - 1; leftPointer < rightPointer; ++leftPointer, --rightPointer)\n    {\n        if(firstString[leftPointer] != secondString[rightPointer])\n            return isPalindrome(firstString, leftPointer, rightPointer) || isPalindrome(secondString, leftPointer, rightPointer);\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool checkPalindromeFormation(std::string firstString, std::string secondString)\n{\n    auto isPalindrome= [](const std::string &stringToCheck, int leftIndex, int rightIndex)\n    {\n        while(leftIndex < rightIndex)\n        {\n            if(stringToCheck[leftIndex++] != stringToCheck[rightIndex--])\n                return false;\n        }\n        return true;\n    };\n\n    for(int leftPointer= 0, rightPointer= firstString.size() - 1; leftPointer < rightPointer; ++leftPointer, --rightPointer)\n    {\n        if(firstString[leftPointer] != secondString[rightPointer])\n            return isPalindrome(firstString, leftPointer, rightPointer) || isPalindrome(secondString, leftPointer, rightPointer);\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countSubgraphsForEachD(int numNodes, vector<pair<int, int>> &edges)\n{\n    vector<vector<int>> adjacencyList(numNodes + 1);\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        auto &edge = edges[i];\n        adjacencyList[edge.first].push_back(edge.second);\n        adjacencyList[edge.second].push_back(edge.first);\n    }\n\n    function<int(int, int)> depthFirstSearch = [&](int currentNode, int parentNode)\n    {\n        int maxDepth = 0;\n        for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n        {\n            int childNode = adjacencyList[currentNode][i];\n            if (childNode != parentNode)\n                maxDepth = max(maxDepth, 1 + depthFirstSearch(childNode, currentNode));\n        }\n        return maxDepth;\n    };\n\n    vector<int> result(numNodes - 1);\n    for (int nodeIndex = 1; nodeIndex <= numNodes; ++nodeIndex)\n    {\n        int maxDepthFromNode = depthFirstSearch(nodeIndex, 0);\n        if (maxDepthFromNode > 0)\n            result[maxDepthFromNode - 1]++;\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> countSubgraphsForEachD(int numNodes, std::vector<std::pair<int, int>> &edges)\n{\n    std::vector<std::vector<int>> adjacencyList(numNodes + 1);\n    for(auto &edge : edges)\n    {\n        adjacencyList[edge.first].push_back(edge.second);\n        adjacencyList[edge.second].push_back(edge.first);\n    }\n\n    std::function<int(int, int)> depthFirstSearch= [&](int currentNode, int parentNode)\n    {\n        int maxDepth= 0;\n        for(int childNode : adjacencyList[currentNode])\n        {\n            if(childNode != parentNode)\n                maxDepth= std::max(maxDepth, 1 + depthFirstSearch(childNode, currentNode));\n        }\n        return maxDepth;\n    };\n\n    std::vector<int> result(numNodes - 1);\n    for(int nodeIndex= 1; nodeIndex <= numNodes; ++nodeIndex)\n    {\n        int maxDepthFromNode= depthFirstSearch(nodeIndex, 0);\n        if(maxDepthFromNode > 0)\n            result[maxDepthFromNode - 1]++;\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxWidthOfVerticalArea(vector<vector<int>> &points)\n{\n    vector<int> xCoordinates;\n    for (size_t i = 0; i < points.size(); ++i)\n    {\n        xCoordinates.push_back(points[i][0]);\n    }\n    sort(xCoordinates.begin(), xCoordinates.end());\n\n    int maxWidth = 0;\n    for (size_t index = 1; index < xCoordinates.size(); ++index)\n    {\n        maxWidth = max(maxWidth, xCoordinates[index] - xCoordinates[index - 1]);\n    }\n\n    return maxWidth;\n}",
    "output": "#include <bits/stdc++.h>\nint maxWidthOfVerticalArea(std::vector<std::vector<int>> &points)\n{\n    std::vector<int> xCoordinates;\n    for(const auto &point : points)\n    {\n        xCoordinates.push_back(point[0]);\n    }\n    std::sort(xCoordinates.begin(), xCoordinates.end());\n\n    int maxWidth= 0;\n    for(size_t index= 1; index < xCoordinates.size(); ++index)\n    {\n        maxWidth= std::max(maxWidth, xCoordinates[index] - xCoordinates[index - 1]);\n    }\n\n    return maxWidth;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countSubstringsWithOneDifference(const string &sourceString, const string &targetString)\n{\n    int substringCount = 0;\n    for(int sourceIndex = 0; sourceIndex < sourceString.size(); sourceIndex++)\n    {\n        for(int targetIndex = 0; targetIndex < targetString.size(); targetIndex++)\n        {\n            int differenceCount = 0;\n            for(int offset = 0; sourceIndex + offset < sourceString.size() && targetIndex + offset < targetString.size(); offset++)\n            {\n                if(sourceString[sourceIndex + offset] != targetString[targetIndex + offset])\n                {\n                    differenceCount++;\n                }\n                if(differenceCount == 2)\n                {\n                    break;\n                }\n                if(differenceCount == 1)\n                {\n                    substringCount++;\n                }\n            }\n        }\n    }\n    return substringCount;\n}",
    "output": "int countSubstringsWithOneDifference(const std::string &sourceString, const std::string &targetString)\n{\n    int substringCount= 0;\n    for(int sourceIndex= 0; sourceIndex < sourceString.size(); sourceIndex++)\n    {\n        for(int targetIndex= 0; targetIndex < targetString.size(); targetIndex++)\n        {\n            int differenceCount= 0;\n            for(int offset= 0; sourceIndex + offset < sourceString.size() && targetIndex + offset < targetString.size(); offset++)\n            {\n                if(sourceString[sourceIndex + offset] != targetString[targetIndex + offset])\n                {\n                    differenceCount++;\n                }\n                if(differenceCount == 2)\n                {\n                    break;\n                }\n                if(differenceCount == 1)\n                {\n                    substringCount++;\n                }\n            }\n        }\n    }\n    return substringCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulus = 1e9 + 7;\n\nint numWays(vector<string> &wordList, string &target)\n{\n    int wordCount = wordList.size(), targetLength = target.size();\n    vector<int> characterCount(26);\n    for (int i = 0; i < wordCount; ++i)\n    {\n        const string &word = wordList[i];\n        for (int j = 0; j < word.size(); ++j)\n        {\n            char character = word[j];\n            characterCount[character - 'a']++;\n        }\n    }\n    vector<long long> dynamicProgramming(targetLength + 1);\n    dynamicProgramming[0] = 1;\n    for (int i = 0; i < targetLength; ++i)\n    {\n        char character = target[i];\n        for (int index = targetLength - 1; index >= 0; index--)\n        {\n            dynamicProgramming[index + 1] += dynamicProgramming[index] * characterCount[character - 'a'];\n            dynamicProgramming[index + 1] %= modulus;\n        }\n    }\n    return dynamicProgramming[targetLength];\n}",
    "output": "#include <bits/stdc++.h>\nconst int modulus= 1e9 + 7;\n\nint numWays(std::vector<std::string> &wordList, std::string &target)\n{\n    int wordCount= wordList.size(), targetLength= target.size();\n    std::vector<int> characterCount(26);\n    for(const std::string &word : wordList)\n    {\n        for(char character : word)\n        {\n            characterCount[character - 'a']++;\n        }\n    }\n    std::vector<long long> dynamicProgramming(targetLength + 1);\n    dynamicProgramming[0]= 1;\n    for(char character : target)\n    {\n        for(int index= targetLength - 1; index >= 0; index--)\n        {\n            dynamicProgramming[index + 1]+= dynamicProgramming[index] * characterCount[character - 'a'];\n            dynamicProgramming[index + 1]%= modulus;\n        }\n    }\n    return dynamicProgramming[targetLength];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPalindrome(const string &inputString, int startIndex, int endIndex)\n{\n    while(startIndex < endIndex)\n    {\n        if(inputString[startIndex] != inputString[endIndex])\n            return false;\n        startIndex++;\n        endIndex--;\n    }\n    return true;\n}\n\nbool checkPartitioning(const string &inputString)\n{\n    int stringLength= inputString.length();\n    for(int firstPartitionEndIndex= 0; firstPartitionEndIndex < stringLength - 2; ++firstPartitionEndIndex)\n    {\n        if(isPalindrome(inputString, 0, firstPartitionEndIndex))\n        {\n            for(int secondPartitionEndIndex= firstPartitionEndIndex + 1; secondPartitionEndIndex < stringLength - 1; ++secondPartitionEndIndex)\n            {\n                if(isPalindrome(inputString, firstPartitionEndIndex + 1, secondPartitionEndIndex) && isPalindrome(inputString, secondPartitionEndIndex + 1, stringLength - 1))\n                    return true;\n            }\n        }\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool isPalindrome(const std::string &inputString, int startIndex, int endIndex)\n{\n    while(startIndex < endIndex)\n    {\n        if(inputString[startIndex] != inputString[endIndex])\n            return false;\n        startIndex++;\n        endIndex--;\n    }\n    return true;\n}\n\nbool checkPartitioning(const std::string &inputString)\n{\n    int stringLength= inputString.length();\n    for(int firstPartitionEndIndex= 0; firstPartitionEndIndex < stringLength - 2; ++firstPartitionEndIndex)\n    {\n        if(isPalindrome(inputString, 0, firstPartitionEndIndex))\n        {\n            for(int secondPartitionEndIndex= firstPartitionEndIndex + 1; secondPartitionEndIndex < stringLength - 1; ++secondPartitionEndIndex)\n            {\n                if(isPalindrome(inputString, firstPartitionEndIndex + 1, secondPartitionEndIndex) && isPalindrome(inputString, secondPartitionEndIndex + 1, stringLength - 1))\n                    return true;\n            }\n        }\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxLengthBetweenEqualCharacters(string inputString)\n{\n    int maximumLength= -1;\n    unordered_map<char, int> characterIndexMap;\n\n    for(int index= 0; index < inputString.length(); index++)\n    {\n        if(characterIndexMap.count(inputString[index]))\n        {\n            maximumLength= max(maximumLength, index - characterIndexMap[inputString[index]] - 1);\n        }\n        else\n        {\n            characterIndexMap[inputString[index]]= index;\n        }\n    }\n\n    return maximumLength;\n}",
    "output": "int maxLengthBetweenEqualCharacters(std::string inputString)\n{\n    int maximumLength= -1;\n    std::unordered_map<char, int> characterIndexMap;\n\n    for(int index= 0; index < inputString.length(); index++)\n    {\n        if(characterIndexMap.count(inputString[index]))\n        {\n            maximumLength= std::max(maximumLength, index - characterIndexMap[inputString[index]] - 1);\n        }\n        else\n        {\n            characterIndexMap[inputString[index]]= index;\n        }\n    }\n\n    return maximumLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint bestTeamScore(vector<int> &playerScores, vector<int> &playerAges)\n{\n    int numberOfPlayers= playerScores.size();\n    vector<pair<int, int>> players(numberOfPlayers);\n\n    for(int index= 0; index < numberOfPlayers; ++index)\n    {\n        players[index]= {playerAges[index], playerScores[index]};\n    }\n\n    sort(players.begin(), players.end());\n\n    vector<int> dynamicProgramming(numberOfPlayers);\n    int maximumScore= 0;\n\n    for(int index= 0; index < numberOfPlayers; ++index)\n    {\n        dynamicProgramming[index]= players[index].second;\n        for(int j= 0; j < index; ++j)\n        {\n            if(players[index].second >= players[j].second)\n            {\n                dynamicProgramming[index]= max(dynamicProgramming[index], dynamicProgramming[j] + players[index].second);\n            }\n        }\n        maximumScore= max(maximumScore, dynamicProgramming[index]);\n    }\n\n    return maximumScore;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> bestTeamScore(std::vector<int> &playerScores, std::vector<int> &playerAges)\n{\n    int numberOfPlayers = playerScores.size();\n    std::vector<std::pair<int, int>> players(numberOfPlayers);\n\n    for(int index = 0; index < numberOfPlayers; ++index)\n    {\n        players[index] = {playerAges[index], playerScores[index]};\n    }\n\n    std::sort(players.begin(), players.end());\n\n    std::vector<int> dynamicProgramming(numberOfPlayers);\n    int maximumScore = 0;\n\n    for(int index = 0; index < numberOfPlayers; ++index)\n    {\n        dynamicProgramming[index] = players[index].second;\n        for(int j = 0; j < index; ++j)\n        {\n            if(players[index].second >= players[j].second)\n            {\n                dynamicProgramming[index] = std::max(dynamicProgramming[index], dynamicProgramming[j] + players[index].second);\n            }\n        }\n        maximumScore = std::max(maximumScore, dynamicProgramming[index]);\n    }\n\n    return maximumScore;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAbsoluteSum(vector<int> &numbers)\n{\n    int maxSum = 0, minSum = 0, maxEndingHere = 0, minEndingHere = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        maxEndingHere = max(maxEndingHere + currentNumber, currentNumber);\n        minEndingHere = min(minEndingHere + currentNumber, currentNumber);\n        maxSum = max(maxSum, maxEndingHere);\n        minSum = min(minSum, minEndingHere);\n    }\n    return max(maxSum, -minSum);\n}",
    "output": "#include <bits/stdc++.h>\nint maxAbsoluteSum(std::vector<int> &numbers)\n{\n    int maxSum= 0, minSum= 0, maxEndingHere= 0, minEndingHere= 0;\n    for(int currentNumber : numbers)\n    {\n        maxEndingHere= std::max(maxEndingHere + currentNumber, currentNumber);\n        minEndingHere= std::min(minEndingHere + currentNumber, currentNumber);\n        maxSum= std::max(maxSum, maxEndingHere);\n        minSum= std::min(minSum, minEndingHere);\n    }\n    return std::max(maxSum, -minSum);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumLength(string inputString)\n{\n    if(inputString.empty())\n        return 0;\n    int leftIndex= 0, rightIndex= inputString.length() - 1;\n    while(leftIndex < rightIndex)\n    {\n        if(inputString[leftIndex] != inputString[rightIndex])\n            break;\n        char characterToRemove= inputString[leftIndex];\n        while(leftIndex < inputString.length() && inputString[leftIndex] == characterToRemove)\n            leftIndex++;\n        while(rightIndex >= 0 && inputString[rightIndex] == characterToRemove)\n            rightIndex--;\n    }\n    return max(0, rightIndex - leftIndex + 1);\n}",
    "output": "#include <bits/stdc++.h>\nint minimumLength(std::string inputString)\n{\n    if(inputString.empty())\n        return 0;\n    int leftIndex= 0, rightIndex= inputString.length() - 1;\n    while(leftIndex < rightIndex)\n    {\n        if(inputString[leftIndex] != inputString[rightIndex])\n            break;\n        char characterToRemove= inputString[leftIndex];\n        while(leftIndex < inputString.length() && inputString[leftIndex] == characterToRemove)\n            leftIndex++;\n        while(rightIndex >= 0 && inputString[rightIndex] == characterToRemove)\n            rightIndex--;\n    }\n    return std::max(0, rightIndex - leftIndex + 1);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar findSlowestKey(vector<int> &releaseTimes, string keysPressed)\n{\n    char maxKey= keysPressed[0];\n    int maxDuration= releaseTimes[0];\n    for(int i= 1; i < releaseTimes.size(); i++)\n    {\n        int duration= releaseTimes[i] - releaseTimes[i - 1];\n        if(duration > maxDuration || (duration == maxDuration && keysPressed[i] > maxKey))\n        {\n            maxKey= keysPressed[i];\n            maxDuration= duration;\n        }\n    }\n    return maxKey;\n}",
    "output": "#include <bits/stdc++.h>\nchar findSlowestKey(std::vector<int> &releaseTimes, std::string keysPressed)\n{\n    char maxKey = keysPressed[0];\n    int maxDuration = releaseTimes[0];\n    for(int i = 1; i < releaseTimes.size(); i++)\n    {\n        int duration = releaseTimes[i] - releaseTimes[i - 1];\n        if(duration > maxDuration || (duration == maxDuration && keysPressed[i] > maxKey))\n        {\n            maxKey = keysPressed[i];\n            maxDuration = duration;\n        }\n    }\n    return maxKey;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<bool> checkArithmeticSubarrays(vector<int> &numbers, vector<int> &leftIndices, vector<int> &rightIndices)\n{\n    vector<bool> arithmeticResults;\n    for(int index= 0; index < leftIndices.size(); index++)\n    {\n        vector<int> subarray(numbers.begin() + leftIndices[index], numbers.begin() + rightIndices[index] + 1);\n        sort(subarray.begin(), subarray.end());\n        bool isArithmetic= true;\n        int difference= subarray[1] - subarray[0];\n        for(int subIndex= 1; subIndex < subarray.size() - 1; subIndex++)\n        {\n            if(subarray[subIndex + 1] - subarray[subIndex] != difference)\n            {\n                isArithmetic= false;\n                break;\n            }\n        }\n        arithmeticResults.push_back(isArithmetic);\n    }\n    return arithmeticResults;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<bool> checkArithmeticSubarrays(std::vector<int> &numbers, std::vector<int> &leftIndices, std::vector<int> &rightIndices)\n{\n    std::vector<bool> arithmeticResults;\n    for(int index= 0; index < leftIndices.size(); index++)\n    {\n        std::vector<int> subarray(numbers.begin() + leftIndices[index], numbers.begin() + rightIndices[index] + 1);\n        std::sort(subarray.begin(), subarray.end());\n        bool isArithmetic= true;\n        int difference= subarray[1] - subarray[0];\n        for(int subIndex= 1; subIndex < subarray.size() - 1; subIndex++)\n        {\n            if(subarray[subIndex + 1] - subarray[subIndex] != difference)\n            {\n                isArithmetic= false;\n                break;\n            }\n        }\n        arithmeticResults.push_back(isArithmetic);\n    }\n    return arithmeticResults;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumEffortPath(vector<vector<int>> &heightMap)\n{\n    const vector<pair<int, int>> directionVectors = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n    int rowCount = heightMap.size();\n    int columnCount = heightMap[0].size();\n    vector<vector<int>> effortMatrix(rowCount, vector<int>(columnCount, INT_MAX));\n    priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, std::greater<>> priorityQueue;\n\n    effortMatrix[0][0] = 0;\n    priorityQueue.push({0, {0, 0}});\n\n    while (!priorityQueue.empty())\n    {\n        auto [currentEffort, currentPosition] = priorityQueue.top();\n        priorityQueue.pop();\n        int currentX = currentPosition.first, currentY = currentPosition.second;\n\n        if (currentX == rowCount - 1 && currentY == columnCount - 1)\n        {\n            return currentEffort;\n        }\n\n        for (int i = 0; i < directionVectors.size(); ++i) // Changed to traditional for loop\n        {\n            const auto &direction = directionVectors[i];\n            int nextX = currentX + direction.first;\n            int nextY = currentY + direction.second;\n            if (nextX >= 0 && nextX < rowCount && nextY >= 0 && nextY < columnCount)\n            {\n                int newEffort = std::max(currentEffort, std::abs(heightMap[nextX][nextY] - heightMap[currentX][currentY]));\n                if (newEffort < effortMatrix[nextX][nextY])\n                {\n                    effortMatrix[nextX][nextY] = newEffort;\n                    priorityQueue.push({newEffort, {nextX, nextY}});\n                }\n            }\n        }\n    }\n\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint minimumEffortPath(std::vector<std::vector<int>> &heightMap)\n{\n    const std::vector<std::pair<int, int>> directionVectors= {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n    int rowCount= heightMap.size();\n    int columnCount= heightMap[0].size();\n    std::vector<std::vector<int>> effortMatrix(rowCount, std::vector<int>(columnCount, INT_MAX));\n    std::priority_queue<std::pair<int, std::pair<int, int>>, std::vector<std::pair<int, std::pair<int, int>>>, std::greater<>> priorityQueue;\n\n    effortMatrix[0][0]= 0;\n    priorityQueue.push({0, {0, 0}});\n\n    while(!priorityQueue.empty())\n    {\n        auto [currentEffort, currentPosition]= priorityQueue.top();\n        priorityQueue.pop();\n        int currentX= currentPosition.first, currentY= currentPosition.second;\n\n        if(currentX == rowCount - 1 && currentY == columnCount - 1)\n        {\n            return currentEffort;\n        }\n\n        for(const auto &direction : directionVectors)\n        {\n            int nextX= currentX + direction.first;\n            int nextY= currentY + direction.second;\n            if(nextX >= 0 && nextX < rowCount && nextY >= 0 && nextY < columnCount)\n            {\n                int newEffort= std::max(currentEffort, std::abs(heightMap[nextX][nextY] - heightMap[currentX][currentY]));\n                if(newEffort < effortMatrix[nextX][nextY])\n                {\n                    effortMatrix[nextX][nextY]= newEffort;\n                    priorityQueue.push({newEffort, {nextX, nextY}});\n                }\n            }\n        }\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestMerge(string firstWord, string secondWord)\n{\n    string mergedResult;\n    while(!firstWord.empty() || !secondWord.empty())\n    {\n        if(firstWord > secondWord)\n        {\n            mergedResult += firstWord[0];\n            firstWord.erase(firstWord.begin());\n        }\n        else\n        {\n            mergedResult += secondWord[0];\n            secondWord.erase(secondWord.begin());\n        }\n    }\n    return mergedResult;\n}",
    "output": "std::string largestMerge(std::string firstWord, std::string secondWord)\n{\n    std::string mergedResult;\n    while(!firstWord.empty() || !secondWord.empty())\n    {\n        if(firstWord > secondWord)\n        {\n            mergedResult+= firstWord[0];\n            firstWord.erase(firstWord.begin());\n        }\n        else\n        {\n            mergedResult+= secondWord[0];\n            secondWord.erase(secondWord.begin());\n        }\n    }\n    return mergedResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> decrypt(vector<int> &code, int shift)\n{\n    int size= code.size();\n    vector<int> result(size);\n    if(shift == 0)\n        return vector<int>(size, 0);\n\n    for(int index= 0; index < size; index++)\n    {\n        int sum= 0;\n        for(int offset= 1; offset <= abs(shift); offset++)\n        {\n            sum+= shift > 0 ? code[(index + offset) % size] : code[(index - offset + size) % size];\n        }\n        result[index]= sum;\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\n// Include cmath for std::abs\n\nstd::vector<int> decrypt(std::vector<int> &code, int shift)\n{\n    int size= code.size();\n    std::vector<int> result(size);\n    if(shift == 0)\n        return std::vector<int>(size, 0);\n\n    for(int index= 0; index < size; index++)\n    {\n        int sum= 0;\n        for(int offset= 1; offset <= std::abs(shift); offset++)\n        {\n            sum += shift > 0 ? code[(index + offset) % size] : code[(index - offset + size) % size];\n        }\n        result[index]= sum;\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minDeletions(string inputString)\n{\n    int aCharacterCount = 0, bCharacterCount = 0, deletionCount = 0;\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentCharacter = inputString[i];\n        if (currentCharacter == 'a')\n        {\n            aCharacterCount++;\n        }\n        else\n        {\n            if (aCharacterCount > 0)\n            {\n                aCharacterCount--;\n            }\n            else\n            {\n                deletionCount++;\n            }\n        }\n    }\n    return deletionCount;\n}",
    "output": "#include <bits/stdc++.h>\nint minDeletions(std::string inputString)\n{\n    int aCharacterCount= 0, bCharacterCount= 0, deletionCount= 0;\n    for(char currentCharacter : inputString)\n    {\n        if(currentCharacter == 'a')\n        {\n            aCharacterCount++;\n        }\n        else\n        {\n            if(aCharacterCount > 0)\n            {\n                aCharacterCount--;\n            }\n            else\n            {\n                deletionCount++;\n            }\n        }\n    }\n    return deletionCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canDistribute(vector<int> &itemCounts, vector<int> &desiredQuantities)\n{\n    vector<int> availableCounts(51, 0);\n    for(int item : itemCounts)\n    {\n        availableCounts[item]++;\n    }\n\n    sort(desiredQuantities.rbegin(), desiredQuantities.rend());\n\n    function<bool(int)> depthFirstSearch = [&](int currentIndex)\n    {\n        if(currentIndex == desiredQuantities.size())\n        {\n            return true;\n        }\n        for(int i = 1; i <= 50; ++i)\n        {\n            if(availableCounts[i] >= desiredQuantities[currentIndex])\n            {\n                availableCounts[i] -= desiredQuantities[currentIndex];\n                if(depthFirstSearch(currentIndex + 1))\n                {\n                    return true;\n                }\n                availableCounts[i] += desiredQuantities[currentIndex];\n            }\n        }\n        return false;\n    };\n\n    return depthFirstSearch(0);\n}",
    "output": "#include <bits/stdc++.h>\nbool canDistribute(std::vector<int> &itemCounts, std::vector<int> &desiredQuantities)\n{\n    std::vector<int> availableCounts(51, 0);\n    for(int item : itemCounts)\n    {\n        availableCounts[item]++;\n    }\n\n    std::sort(desiredQuantities.rbegin(), desiredQuantities.rend());\n\n    std::function<bool(int)> depthFirstSearch = [&](int currentIndex)\n    {\n        if(currentIndex == desiredQuantities.size())\n        {\n            return true;\n        }\n        for(int i= 1; i <= 50; ++i)\n        {\n            if(availableCounts[i] >= desiredQuantities[currentIndex])\n            {\n                availableCounts[i] -= desiredQuantities[currentIndex];\n                if(depthFirstSearch(currentIndex + 1))\n                {\n                    return true;\n                }\n                availableCounts[i] += desiredQuantities[currentIndex];\n            }\n        }\n        return false;\n    };\n\n    return depthFirstSearch(0);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countHomogenous(string inputString)\n{\n    const int modulo= 1e9 + 7;\n    long long consecutiveCount= 1, totalCount= 0;\n    for(int index= 1; index < inputString.size(); ++index)\n    {\n        consecutiveCount= (inputString[index] == inputString[index - 1]) ? consecutiveCount + 1 : 1;\n        totalCount= (totalCount + consecutiveCount) % modulo;\n    }\n    return totalCount + consecutiveCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countHomogenous(std::string inputString)\n{\n    const int modulo= 1e9 + 7;\n    long long consecutiveCount= 1, totalCount= 0;\n    for(int index= 1; index < inputString.size(); ++index)\n    {\n        consecutiveCount= (inputString[index] == inputString[index - 1]) ? consecutiveCount + 1 : 1;\n        totalCount= (totalCount + consecutiveCount) % modulo;\n    }\n    return totalCount + consecutiveCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canFormArray(vector<int> &inputArray, vector<vector<int>> &pieces)\n{\n    unordered_map<int, vector<int>> pieceMap;\n    for(auto &piece : pieces)\n        pieceMap[piece[0]] = piece;\n\n    int currentIndex = 0;\n    while(currentIndex < inputArray.size())\n    {\n        if(!pieceMap.count(inputArray[currentIndex]))\n            return false;\n\n        vector<int> piece = pieceMap[inputArray[currentIndex]];\n        for(int j = 0; j < piece.size(); ++j)\n        {\n            if(inputArray[currentIndex++] != piece[j])\n                return false;\n        }\n    }\n\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool canFormArray(std::vector<int> &inputArray, std::vector<std::vector<int>> &pieces)\n{\n    std::unordered_map<int, std::vector<int>> pieceMap;\n    for(auto &piece : pieces)\n        pieceMap[piece[0]]= piece;\n\n    int currentIndex= 0;\n    while(currentIndex < inputArray.size())\n    {\n        if(!pieceMap.count(inputArray[currentIndex]))\n            return false;\n\n        for(int number : pieceMap[inputArray[currentIndex]])\n        {\n            if(inputArray[currentIndex++] != number)\n                return false;\n        }\n    }\n\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int countVowelStrings(int length)\n{\n    int vowelCount[5]= {1, 1, 1, 1, 1};\n\n    for(int currentLength= 1; currentLength < length; currentLength++)\n    {\n        for(int index= 3; index >= 0; index--)\n        {\n            vowelCount[index]+= vowelCount[index + 1];\n        }\n    }\n\n    return vowelCount[0] + vowelCount[1] + vowelCount[2] + vowelCount[3] + vowelCount[4];\n}",
    "output": "int countVowelStrings(int length)\n{\n    int vowelCount[5]= {1, 1, 1, 1, 1};\n\n    for(int currentLength= 1; currentLength < length; currentLength++)\n    {\n        for(int index= 3; index >= 0; index--)\n        {\n            vowelCount[index]+= vowelCount[index + 1];\n        }\n    }\n\n    return vowelCount[0] + vowelCount[1] + vowelCount[2] + vowelCount[3] + vowelCount[4];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint furthestBuilding(vector<int> &buildingHeights, int availableBricks, int availableLadders)\n{\n    priority_queue<int, vector<int>, greater<int>> minHeap;\n    for(int currentIndex= 0; currentIndex < buildingHeights.size() - 1; ++currentIndex)\n    {\n        int heightDifference= buildingHeights[currentIndex + 1] - buildingHeights[currentIndex];\n        if(heightDifference > 0)\n        {\n            minHeap.push(heightDifference);\n            if(minHeap.size() > availableLadders)\n            {\n                availableBricks-= minHeap.top();\n                minHeap.pop();\n                if(availableBricks < 0)\n                {\n                    return currentIndex;\n                }\n            }\n        }\n    }\n    return buildingHeights.size() - 1;\n}",
    "output": "#include <bits/stdc++.h>\nint furthestBuilding(std::vector<int> &buildingHeights, int availableBricks, int availableLadders)\n{\n    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;\n    for(int currentIndex= 0; currentIndex < buildingHeights.size() - 1; ++currentIndex)\n    {\n        int heightDifference= buildingHeights[currentIndex + 1] - buildingHeights[currentIndex];\n        if(heightDifference > 0)\n        {\n            minHeap.push(heightDifference);\n            if(minHeap.size() > availableLadders)\n            {\n                availableBricks-= minHeap.top();\n                minHeap.pop();\n                if(availableBricks < 0)\n                {\n                    return currentIndex;\n                }\n            }\n        }\n    }\n    return buildingHeights.size() - 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring longestNiceSubstring(string inputString)\n{\n    int stringLength= inputString.length();\n    string longestSubstring= \"\";\n    for(int startIndex= 0; startIndex < stringLength; startIndex++)\n    {\n        for(int endIndex= startIndex + 1; endIndex < stringLength; ++endIndex)\n        {\n            bool isNice= true;\n            for(char uppercaseChar= 'A'; uppercaseChar <= 'Z'; ++uppercaseChar)\n            {\n                bool hasUppercase= false, hasLowercase= false;\n                for(int currentIndex= startIndex; currentIndex <= endIndex; ++currentIndex)\n                {\n                    if(inputString[currentIndex] == uppercaseChar)\n                        hasUppercase= true;\n                    if(inputString[currentIndex] == (uppercaseChar + 32))\n                        hasLowercase= true;\n                }\n                if((hasUppercase && !hasLowercase) || (!hasUppercase && hasLowercase))\n                {\n                    isNice= false;\n                    break;\n                }\n            }\n            if(isNice && endIndex - startIndex + 1 > longestSubstring.length())\n            {\n                longestSubstring= inputString.substr(startIndex, endIndex - startIndex + 1);\n            }\n        }\n    }\n    return longestSubstring;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string longestNiceSubstring(std::string inputString)\n{\n    int stringLength = inputString.length();\n    std::string longestSubstring = \"\";\n    for(int startIndex = 0; startIndex < stringLength; startIndex++)\n    {\n        for(int endIndex = startIndex + 1; endIndex < stringLength; ++endIndex)\n        {\n            bool isNice = true;\n            for(char uppercaseChar = 'A'; uppercaseChar <= 'Z'; ++uppercaseChar)\n            {\n                bool hasUppercase = false, hasLowercase = false;\n                for(int currentIndex = startIndex; currentIndex <= endIndex; ++currentIndex)\n                {\n                    if(inputString[currentIndex] == uppercaseChar)\n                        hasUppercase = true;\n                    if(inputString[currentIndex] == (uppercaseChar + 32))\n                        hasLowercase = true;\n                }\n                if((hasUppercase && !hasLowercase) || (!hasUppercase && hasLowercase))\n                {\n                    isNice = false;\n                    break;\n                }\n            }\n            if(isNice && endIndex - startIndex + 1 > longestSubstring.length())\n            {\n                longestSubstring = inputString.substr(startIndex, endIndex - startIndex + 1);\n            }\n        }\n    }\n    return longestSubstring;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxKRepeating(string sequence, string word)\n{\n    int maxK= 0;\n    int sequenceLength= sequence.length();\n    int wordLength= word.length();\n    for(int index= 0; index <= sequenceLength - wordLength; index++)\n    {\n        int countK= 0;\n        while(sequence.compare(index, wordLength * (countK + 1), word.repeat(countK + 1)) == 0)\n        {\n            countK++;\n        }\n        if(countK > maxK)\n        {\n            maxK= countK;\n        }\n    }\n    return maxK;\n}",
    "output": "#include <bits/stdc++.h>\nint maxKRepeating(std::string sequence, std::string word)\n{\n    int maxK= 0;\n    int sequenceLength= sequence.length();\n    int wordLength= word.length();\n    for(int index= 0; index <= sequenceLength - wordLength; index++)\n    {\n        int countK= 0;\n        while(sequence.compare(index, wordLength * (countK + 1), word.repeat(countK + 1)) == 0)\n        {\n            countK++;\n        }\n        if(countK > maxK)\n        {\n            maxK= countK;\n        }\n    }\n    return maxK;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode() : value(0), next(NULL) {}\n    ListNode(int x) : value(x), next(NULL) {}\n    ListNode(int x, ListNode *next) : value(x), next(next) {}\n};\n\nListNode *mergeInBetween(ListNode *firstList, int startIndex, int endIndex, ListNode *secondList)\n{\n    ListNode *previousNode= NULL;\n    ListNode *currentNode= firstList;\n    int currentIndex= 0;\n\n    while(currentNode != NULL)\n    {\n        if(currentIndex == startIndex)\n        {\n            ListNode *tempNode= currentNode;\n            currentNode= currentNode->next;\n            ListNode *lastNode= secondList;\n            while(lastNode->next != NULL)\n            {\n                lastNode= lastNode->next;\n            }\n            previousNode->next= secondList;\n            lastNode->next= currentNode;\n\n            delete tempNode;\n        }\n        else if(currentIndex > startIndex && currentIndex < endIndex)\n        {\n            ListNode *tempNode= currentNode;\n            currentNode= currentNode->next;\n            delete tempNode;\n        }\n        else\n        {\n            previousNode= currentNode;\n            currentNode= currentNode->next;\n        }\n        currentIndex++;\n    }\n    return firstList;\n}",
    "output": "struct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode() : value(0), next(NULL) {}\n    ListNode(int x) : value(x), next(NULL) {}\n    ListNode(int x, ListNode *next) : value(x), next(next) {}\n};\n\nListNode *mergeInBetween(ListNode *firstList, int startIndex, int endIndex, ListNode *secondList)\n{\n    ListNode *previousNode= NULL;\n    ListNode *currentNode= firstList;\n    int currentIndex= 0;\n\n    while(currentNode != NULL)\n    {\n        if(currentIndex == startIndex)\n        {\n            ListNode *tempNode= currentNode;\n            currentNode= currentNode->next;\n            ListNode *lastNode= secondList;\n            while(lastNode->next != NULL)\n            {\n                lastNode= lastNode->next;\n            }\n            previousNode->next= secondList;\n            lastNode->next= currentNode;\n\n            delete tempNode;\n        }\n        else if(currentIndex > startIndex && currentIndex < endIndex)\n        {\n            ListNode *tempNode= currentNode;\n            currentNode= currentNode->next;\n            delete tempNode;\n        }\n        else\n        {\n            previousNode= currentNode;\n            currentNode= currentNode->next;\n        }\n        currentIndex++;\n    }\n    return firstList;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumMountainRemovals(vector<int> &heights)\n{\n    int totalElements= heights.size();\n    vector<int> leftLIS(totalElements), rightLIS(totalElements);\n    for(int i= 0; i < totalElements; ++i)\n    {\n        leftLIS[i]= lower_bound(leftLIS.begin(), leftLIS.begin() + i, heights[i]) - leftLIS.begin();\n        rightLIS[totalElements - 1 - i]= lower_bound(rightLIS.rbegin(), rightLIS.rend() - i, heights[totalElements - 1 - i]) - rightLIS.rbegin();\n    }\n    int minimumRemovals= totalElements;\n    for(int i= 1; i < totalElements - 1; ++i)\n        minimumRemovals= min(minimumRemovals, totalElements - (leftLIS[i] + 1) - (rightLIS[i] + 1));\n\n    return minimumRemovals;\n}",
    "output": "#include <bits/stdc++.h>\nint minimumMountainRemovals(std::vector<int> &heights)\n{\n    int totalElements= heights.size();\n    std::vector<int> leftLIS(totalElements), rightLIS(totalElements);\n    for(int i= 0; i < totalElements; ++i)\n    {\n        leftLIS[i]= std::lower_bound(leftLIS.begin(), leftLIS.begin() + i, heights[i]) - leftLIS.begin();\n        rightLIS[totalElements - 1 - i]= std::lower_bound(rightLIS.rbegin(), rightLIS.rend() - i, heights[totalElements - 1 - i]) - rightLIS.rbegin();\n    }\n    int minimumRemovals= totalElements;\n    for(int i= 1; i < totalElements - 1; ++i)\n        minimumRemovals= std::min(minimumRemovals, totalElements - (leftLIS[i] + 1) - (rightLIS[i] + 1));\n\n    return minimumRemovals;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring mergeAlternately(string firstWord, string secondWord)\n{\n    string mergedResult= \"\";\n    int firstIndex= 0, secondIndex= 0;\n    while(firstIndex < firstWord.length() && secondIndex < secondWord.length())\n    {\n        mergedResult+= firstWord[firstIndex++];\n        mergedResult+= secondWord[secondIndex++];\n    }\n    while(firstIndex < firstWord.length())\n        mergedResult+= firstWord[firstIndex++];\n    while(secondIndex < secondWord.length())\n        mergedResult+= secondWord[secondIndex++];\n    return mergedResult;\n}",
    "output": "std::string mergeAlternately(std::string firstWord, std::string secondWord)\n{\n    std::string mergedResult= \"\";\n    int firstIndex= 0, secondIndex= 0;\n    while(firstIndex < firstWord.length() && secondIndex < secondWord.length())\n    {\n        mergedResult+= firstWord[firstIndex++];\n        mergedResult+= secondWord[secondIndex++];\n    }\n    while(firstIndex < firstWord.length())\n        mergedResult+= firstWord[firstIndex++];\n    while(secondIndex < secondWord.length())\n        mergedResult+= secondWord[secondIndex++];\n    return mergedResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maximumGenerated(int size)\n{\n    if(size == 0)\n    {\n        return 0;\n    }\n    vector<int> generatedNumbers(size + 1);\n    generatedNumbers[1]= 1;\n    for(int index= 2; index <= size; ++index)\n    {\n        generatedNumbers[index]= index % 2 == 0 ? generatedNumbers[index / 2] : generatedNumbers[index / 2] + generatedNumbers[index / 2 + 1];\n    }\n    return *max_element(generatedNumbers.begin(), generatedNumbers.end());\n}",
    "output": "#include <bits/stdc++.h>\nint maximumGenerated(int size)\n{\n    if(size == 0)\n    {\n        return 0;\n    }\n    std::vector<int> generatedNumbers(size + 1);\n    generatedNumbers[1]= 1;\n    for(int index= 2; index <= size; ++index)\n    {\n        generatedNumbers[index]= index % 2 == 0 ? generatedNumbers[index / 2] : generatedNumbers[index / 2] + generatedNumbers[index / 2 + 1];\n    }\n    return *std::max_element(generatedNumbers.begin(), generatedNumbers.end());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minDeletions(string inputString)\n{\n    unordered_map<char, int> characterFrequency;\n    unordered_set<int> usedFrequencies;\n    int totalDeletions = 0;\n\n    for (char currentChar : inputString)\n    {\n        characterFrequency[currentChar]++;\n    }\n\n    for (auto const &pair : characterFrequency)\n    {\n        char character = pair.first;\n        int frequencyCount = pair.second;\n        int count = frequencyCount; // Create a mutable copy for modification\n        while (usedFrequencies.find(count) != usedFrequencies.end() && count > 0)\n        {\n            totalDeletions++;\n            count--;\n        }\n        usedFrequencies.insert(count);\n    }\n\n    return totalDeletions;\n}",
    "output": "#include <bits/stdc++.h>\nint minDeletions(std::string inputString)\n{\n    std::unordered_map<char, int> characterFrequency;\n    std::unordered_set<int> usedFrequencies;\n    int totalDeletions= 0;\n\n    for(char currentChar : inputString)\n    {\n        characterFrequency[currentChar]++;\n    }\n\n    for(auto const &[character, frequencyCount] : characterFrequency)\n    {\n        int count= frequencyCount; // Create a mutable copy for modification\n        while(usedFrequencies.find(count) != usedFrequencies.end() && count > 0)\n        {\n            totalDeletions++;\n            count--;\n        }\n        usedFrequencies.insert(count);\n    }\n\n    return totalDeletions;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxProfit(vector<int> &inventory, int orders)\n{\n    long long modulo= 1e9 + 7;\n    sort(inventory.begin(), inventory.end(), greater<>());\n    inventory.push_back(0);\n    long long size= inventory.size(), totalProfit= 0, count= 1;\n    for(int i= 0; i < size - 1; ++i, ++count)\n    {\n        long long difference= inventory[i] - inventory[i + 1];\n        if(count * difference < orders)\n        {\n            orders-= count * difference;\n            totalProfit = (totalProfit + (((inventory[i] + inventory[i + 1] + 1) * difference) / 2) % modulo * count) % modulo);\n        }\n        else\n        {\n            long long quotient= orders / count;\n            long long remainder= orders % count;\n            totalProfit = (totalProfit + (((inventory[i] + inventory[i] - quotient + 1) * quotient) / 2) % modulo * count) % modulo);\n            totalProfit= (totalProfit + remainder * (inventory[i] - quotient)) % modulo;\n            break;\n        }\n    }\n    return totalProfit;\n}",
    "output": "#include <bits/stdc++.h>\nint maxProfit(std::vector<int> &inventory, int orders)\n{\n    long long modulo= 1e9 + 7;\n    std::sort(inventory.begin(), inventory.end(), std::greater<>());\n    inventory.push_back(0);\n    long long size= inventory.size(), totalProfit= 0, count= 1;\n    for(int i= 0; i < size - 1; ++i, ++count)\n    {\n        long long difference= inventory[i] - inventory[i + 1];\n        if(count * difference < orders)\n        {\n            orders-= count * difference;\n            totalProfit = (totalProfit + (((inventory[i] + inventory[i + 1] + 1) * difference) / 2) % modulo * count) % modulo);\n        }\n        else\n        {\n            long long quotient= orders / count;\n            long long remainder= orders % count;\n            totalProfit = (totalProfit + (((inventory[i] + inventory[i] - quotient + 1) * quotient) / 2) % modulo * count) % modulo);\n            totalProfit= (totalProfit + remainder * (inventory[i] - quotient)) % modulo;\n            break;\n        }\n    }\n    return totalProfit;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo = 1e9 + 7;\n\nint createSortedArray(vector<int> &instructionList)\n{\n    multiset<int> sortedElements;\n    int totalCost = 0;\n\n    for (int i = 0; i < instructionList.size(); ++i)\n    {\n        int instruction = instructionList[i];\n        sortedElements.insert(instruction);\n        int countLessThan = distance(sortedElements.begin(), sortedElements.lower_bound(instruction));\n        int countGreaterThan = distance(sortedElements.upper_bound(instruction), sortedElements.end());\n        totalCost = (totalCost + min(countLessThan, countGreaterThan)) % modulo;\n    }\n\n    return totalCost;\n}",
    "output": "#include <bits/stdc++.h>\nconst int modulo= 1e9 + 7;\n\nint createSortedArray(std::vector<int> &instructionList)\n{\n    std::multiset<int> sortedElements;\n    int totalCost= 0;\n\n    for(int instruction : instructionList)\n    {\n        sortedElements.insert(instruction);\n        int countLessThan= std::distance(sortedElements.begin(), sortedElements.lower_bound(instruction));\n        int countGreaterThan= std::distance(sortedElements.upper_bound(instruction), sortedElements.end());\n        totalCost= (totalCost + std::min(countLessThan, countGreaterThan)) % modulo;\n    }\n\n    return totalCost;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countMatches(vector<vector<string>> &items, string ruleKey, string ruleValue)\n{\n    int matchCount = 0;\n    int ruleIndex = (ruleKey == \"type\" ? 0 : (ruleKey == \"color\" ? 1 : 2));\n    \n    for (int i = 0; i < items.size(); ++i)\n    {\n        const auto &item = items[i];\n        if (item[ruleIndex] == ruleValue)\n            matchCount++;\n    }\n    return matchCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countMatches(std::vector<std::vector<std::string>> &items, std::string ruleKey, std::string ruleValue)\n{\n    int matchCount= 0;\n    int ruleIndex= (ruleKey == \"type\" ? 0 : (ruleKey == \"color\" ? 1 : 2));\n    for(const auto &item : items)\n    {\n        if(item[ruleIndex] == ruleValue)\n            matchCount++;\n    }\n    return matchCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint closestCost(vector<int> &baseCosts, vector<int> &toppingCosts, int target)\n{\n    int closestDifference = numeric_limits<int>::max();\n    sort(toppingCosts.begin(), toppingCosts.end());\n\n    for (int i = 0; i < baseCosts.size(); ++i)\n    {\n        const int &baseCost = baseCosts[i];\n        int difference = abs(target - baseCost);\n        if (difference < closestDifference)\n        {\n            closestDifference = difference;\n        }\n        if (difference == 0)\n        {\n            return target;\n        }\n        for (int toppingCount1 = 0; toppingCount1 <= 2; ++toppingCount1)\n        {\n            int currentCost1 = baseCost + toppingCount1 * toppingCosts[0];\n            int difference1 = abs(target - currentCost1);\n            if (difference1 < closestDifference)\n            {\n                closestDifference = difference1;\n            }\n            if (difference1 == 0)\n            {\n                return target;\n            }\n            for (int toppingCount2 = 0; toppingCount2 <= 2; ++toppingCount2)\n            {\n                int currentCost2 = currentCost1 + toppingCount2 * toppingCosts[1];\n                int difference2 = abs(target - currentCost2);\n                if (difference2 < closestDifference)\n                {\n                    closestDifference = difference2;\n                }\n                if (difference2 == 0)\n                {\n                    return target;\n                }\n            }\n        }\n    }\n    return target - closestDifference;\n}",
    "output": "#include <bits/stdc++.h>\nint closestCost(std::vector<int> &baseCosts, std::vector<int> &toppingCosts, int target)\n{\n    int closestDifference= std::numeric_limits<int>::max();\n    std::sort(toppingCosts.begin(), toppingCosts.end());\n\n    for(const int &baseCost : baseCosts)\n    {\n        int difference= abs(target - baseCost);\n        if(difference < closestDifference)\n        {\n            closestDifference= difference;\n        }\n        if(difference == 0)\n        {\n            return target;\n        }\n        for(int toppingCount1= 0; toppingCount1 <= 2; ++toppingCount1)\n        {\n            int currentCost1= baseCost + toppingCount1 * toppingCosts[0];\n            int difference1= abs(target - currentCost1);\n            if(difference1 < closestDifference)\n            {\n                closestDifference= difference1;\n            }\n            if(difference1 == 0)\n            {\n                return target;\n            }\n            for(int toppingCount2= 0; toppingCount2 <= 2; ++toppingCount2)\n            {\n                int currentCost2= currentCost1 + toppingCount2 * toppingCosts[1];\n                int difference2= abs(target - currentCost2);\n                if(difference2 < closestDifference)\n                {\n                    closestDifference= difference2;\n                }\n                if(difference2 == 0)\n                {\n                    return target;\n                }\n            }\n        }\n    }\n    return target - closestDifference;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass OrderedStream\n{\n  public:\n    int pointer;\n    unordered_map<int, string> dataMap;\n\n    OrderedStream(int size)\n    {\n        pointer= 1;\n    }\n\n    vector<string> insert(int id, string value)\n    {\n        dataMap[id]= value;\n        vector<string> result;\n        while(dataMap.find(pointer) != dataMap.end())\n        {\n            result.push_back(dataMap[pointer]);\n            pointer++;\n        }\n        return result;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass OrderedStream\n{\n  public:\n    int pointer;\n    std::unordered_map<int, std::string> dataMap;\n\n    OrderedStream(int size)\n    {\n        pointer = 1;\n    }\n\n    std::vector<std::string> insert(int id, std::string value)\n    {\n        dataMap[id] = value;\n        std::vector<std::string> result;\n        while(dataMap.find(pointer) != dataMap.end())\n        {\n            result.push_back(dataMap[pointer]);\n            pointer++;\n        }\n        return result;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers, int targetValue)\n{\n    int totalSum= accumulate(numbers.begin(), numbers.end(), 0);\n    int desiredSum= totalSum - targetValue;\n    if(desiredSum < 0)\n        return -1;\n\n    int maxLength= -1;\n    int leftIndex= 0, currentSum= 0;\n    for(int rightIndex= 0; rightIndex < numbers.size(); ++rightIndex)\n    {\n        currentSum+= numbers[rightIndex];\n\n        while(currentSum > desiredSum)\n        {\n            currentSum-= numbers[leftIndex++];\n        }\n\n        if(currentSum == desiredSum)\n        {\n            maxLength= max(maxLength, rightIndex - leftIndex + 1);\n        }\n    }\n\n    return maxLength == -1 ? -1 : numbers.size() - maxLength;\n}",
    "output": "#include <bits/stdc++.h>\nint minOperations(std::vector<int> &numbers, int targetValue)\n{\n    int totalSum = std::accumulate(numbers.begin(), numbers.end(), 0);\n    int desiredSum = totalSum - targetValue;\n    if (desiredSum < 0)\n        return -1;\n\n    int maxLength = -1;\n    int leftIndex = 0, currentSum = 0;\n    for (int rightIndex = 0; rightIndex < numbers.size(); ++rightIndex)\n    {\n        currentSum += numbers[rightIndex];\n\n        while (currentSum > desiredSum)\n        {\n            currentSum -= numbers[leftIndex++];\n        }\n\n        if (currentSum == desiredSum)\n        {\n            maxLength = std::max(maxLength, rightIndex - leftIndex + 1);\n        }\n    }\n\n    return maxLength == -1 ? -1 : numbers.size() - maxLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int calculateMaxHappiness(int gridWidth, int gridHeight, int introvertsCount, int extrovertsCount, int currentRow= 0, int occupiedMask= 0)\n{\n    if(currentRow == gridHeight)\n        return 0;\n\n    static int happinessDP[6][6][6 * 6][1 << 6];\n    static bool isSeen[6][6][6 * 6][1 << 6]= {};\n    if(isSeen[gridWidth][gridHeight][introvertsCount][occupiedMask])\n        return happinessDP[gridWidth][gridHeight][introvertsCount][occupiedMask];\n    isSeen[gridWidth][gridHeight][introvertsCount][occupiedMask]= true;\n\n    int currentHappiness= currentRow * gridWidth, maxHappiness= 0;\n    for(int column= 0; column <= gridWidth; ++column)\n    {\n        int happinessChange= 0;\n        if((occupiedMask >> column) & 1)\n        {\n            happinessChange-= 30;\n            if(column > 0 && (occupiedMask & 1))\n                happinessChange-= 30;\n            else\n                happinessChange+= 20;\n        }\n        maxHappiness= max(maxHappiness, happinessChange + calculateMaxHappiness(gridWidth, gridHeight, introvertsCount, extrovertsCount, currentRow + 1, (occupiedMask | (1 << column)) >> 1));\n    }\n\n    return happinessDP[gridWidth][gridHeight][introvertsCount][occupiedMask]= maxHappiness;\n}\n\nint getMaxGridHappiness(int gridWidth, int gridHeight, int introvertsCount, int extrovertsCount)\n{\n    return calculateMaxHappiness(gridWidth, gridHeight, introvertsCount, extrovertsCount);\n}",
    "output": "int calculateMaxHappiness(int gridWidth, int gridHeight, int introvertsCount, int extrovertsCount, int currentRow= 0, int occupiedMask= 0)\n{\n    if(currentRow == gridHeight)\n        return 0;\n\n    static int happinessDP[6][6][6 * 6][1 << 6];\n    static bool isSeen[6][6][6 * 6][1 << 6]= {};\n    if(isSeen[gridWidth][gridHeight][introvertsCount][occupiedMask])\n        return happinessDP[gridWidth][gridHeight][introvertsCount][occupiedMask];\n    isSeen[gridWidth][gridHeight][introvertsCount][occupiedMask]= true;\n\n    int currentHappiness= currentRow * gridWidth, maxHappiness= 0;\n    for(int column= 0; column <= gridWidth; ++column)\n    {\n        int happinessChange= 0;\n        if((occupiedMask >> column) & 1)\n        {\n            happinessChange-= 30;\n            if(column > 0 && (occupiedMask & 1))\n                happinessChange-= 30;\n            else\n                happinessChange+= 20;\n        }\n        maxHappiness= max(maxHappiness, happinessChange + calculateMaxHappiness(gridWidth, gridHeight, introvertsCount, extrovertsCount, currentRow + 1, (occupiedMask | (1 << column)) >> 1));\n    }\n\n    return happinessDP[gridWidth][gridHeight][introvertsCount][occupiedMask]= maxHappiness;\n}\n\nint getMaxGridHappiness(int gridWidth, int gridHeight, int introvertsCount, int extrovertsCount)\n{\n    return calculateMaxHappiness(gridWidth, gridHeight, introvertsCount, extrovertsCount);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint nearestValidPoint(int inputX, int inputY, vector<vector<int>> &points)\n{\n    int minimumDistance= INT_MAX, nearestIndex= -1;\n    for(int index= 0; index < points.size(); index++)\n    {\n        if(inputX == points[index][0] || inputY == points[index][1])\n        {\n            int currentDistance= abs(inputX - points[index][0]) + abs(inputY - points[index][1]);\n            if(currentDistance < minimumDistance)\n            {\n                minimumDistance= currentDistance;\n                nearestIndex= index;\n            }\n        }\n    }\n    return nearestIndex;\n}",
    "output": "#include <bits/stdc++.h>\nint nearestValidPoint(int inputX, int inputY, std::vector<std::vector<int>> &points)\n{\n    int minimumDistance= std::numeric_limits<int>::max(), nearestIndex= -1;\n    for(int index= 0; index < points.size(); index++)\n    {\n        if(inputX == points[index][0] || inputY == points[index][1])\n        {\n            int currentDistance= std::abs(inputX - points[index][0]) + std::abs(inputY - points[index][1]);\n            if(currentDistance < minimumDistance)\n            {\n                minimumDistance= currentDistance;\n                nearestIndex= index;\n            }\n        }\n    }\n    return nearestIndex;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "bool checkPowersOfThree(int number)\n{\n    while(number > 0)\n    {\n        if(number % 3 == 2)\n            return false;\n        number/= 3;\n    }\n    return true;\n}",
    "output": "bool checkPowersOfThree(int number)\n{\n    while(number > 0)\n    {\n        if(number % 3 == 2)\n            return false;\n        number/= 3;\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool arrayStringsAreEqual(vector<string> &firstWordArray, vector<string> &secondWordArray)\n{\n    string concatenatedFirstWord, concatenatedSecondWord;\n    for (int i = 0; i < firstWordArray.size(); ++i)\n        concatenatedFirstWord += firstWordArray[i];\n    for (int i = 0; i < secondWordArray.size(); ++i)\n        concatenatedSecondWord += secondWordArray[i];\n    return concatenatedFirstWord == concatenatedSecondWord;\n}",
    "output": "bool arrayStringsAreEqual(std::vector<std::string> &firstWordArray, std::vector<std::string> &secondWordArray)\n{\n    std::string concatenatedFirstWord, concatenatedSecondWord;\n    for(auto &word : firstWordArray)\n        concatenatedFirstWord+= word;\n    for(auto &word : secondWordArray)\n        concatenatedSecondWord+= word;\n    return concatenatedFirstWord == concatenatedSecondWord;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring getSmallestString(int length, int adjustValue)\n{\n    string result(length, 'a');\n    adjustValue-= length;\n    for(int index= length - 1; index >= 0; --index)\n    {\n        int incrementValue= min(adjustValue, 25);\n        result[index]+= incrementValue;\n        adjustValue-= incrementValue;\n        if(adjustValue == 0)\n            break;\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\n// for std::min\n\nstd::string getSmallestString(int length, int adjustValue)\n{\n    std::string result(length, 'a');\n    adjustValue -= length;\n    for(int index = length - 1; index >= 0; --index)\n    {\n        int incrementValue = std::min(adjustValue, 25);\n        result[index] += incrementValue;\n        adjustValue -= incrementValue;\n        if(adjustValue == 0)\n            break;\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumEnergy(vector<vector<int>> &taskList)\n{\n    sort(taskList.begin(), taskList.end(), [](const vector<int> &taskA, const vector<int> &taskB)\n              { return taskA[1] - taskA[0] > taskB[1] - taskB[0]; });\n\n    int totalEnergy = 0;\n    for (int i = 0; i < taskList.size(); ++i)\n    {\n        const auto &task = taskList[i];\n        totalEnergy = max(totalEnergy + task[0], task[1]);\n    }\n    return totalEnergy;\n}",
    "output": "#include <bits/stdc++.h>\nint minimumEnergy(std::vector<std::vector<int>> &taskList)\n{\n    std::sort(taskList.begin(), taskList.end(), [](const std::vector<int> &taskA, const std::vector<int> &taskB)\n              { return taskA[1] - taskA[0] > taskB[1] - taskB[0]; });\n\n    int totalEnergy= 0;\n    for(const auto &task : taskList)\n    {\n        totalEnergy= std::max(totalEnergy + task[0], task[1]);\n    }\n    return totalEnergy;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For abs function\nusing namespace std;\n\nint minElements(vector<int> &numbers, int limit, int goal)\n{\n    long long totalSum = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n        totalSum += numbers[i];\n    long long difference = abs(goal - totalSum);\n\n    return (difference + limit - 1) / limit;\n}",
    "output": "#include <bits/stdc++.h>\n// for std::abs\n\nint minElements(std::vector<int> &numbers, int limit, int goal)\n{\n    long long totalSum= 0;\n    for(int number : numbers)\n        totalSum+= number;\n    long long difference= std::abs(goal - totalSum);\n\n    return (difference + limit - 1) / limit;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countConsistentStrings(string allowedCharacters, vector<string> &words)\n{\n    unordered_set<char> allowedSet(allowedCharacters.begin(), allowedCharacters.end());\n    int validStringCount = 0;\n    for (int i = 0; i < words.size(); ++i)\n    {\n        const string &currentWord = words[i];\n        bool isValidWord = true;\n        for (int j = 0; j < currentWord.size(); ++j)\n        {\n            char currentChar = currentWord[j];\n            if (allowedSet.count(currentChar) == 0)\n            {\n                isValidWord = false;\n                break;\n            }\n        }\n        if (isValidWord)\n        {\n            validStringCount++;\n        }\n    }\n    return validStringCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countConsistentStrings(std::string allowedCharacters, std::vector<std::string> &words)\n{\n    std::unordered_set<char> allowedSet(allowedCharacters.begin(), allowedCharacters.end());\n    int validStringCount = 0;\n    for(const std::string &currentWord : words)\n    {\n        bool isValidWord = true;\n        for(char currentChar : currentWord)\n        {\n            if(allowedSet.count(currentChar) == 0)\n            {\n                isValidWord = false;\n                break;\n            }\n        }\n        if(isValidWord)\n        {\n            validStringCount++;\n        }\n    }\n    return validStringCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> calculateSummationOfAbsoluteDifferences(const vector<int> &inputNumbers)\n{\n    int numberOfElements = inputNumbers.size();\n    vector<int> absoluteDifferenceSummation(numberOfElements, 0);\n\n    for(int currentIndex = 0; currentIndex < numberOfElements; currentIndex++)\n    {\n        for(int comparisonIndex = 0; comparisonIndex < numberOfElements; comparisonIndex++)\n        {\n            if(currentIndex != comparisonIndex)\n            {\n                absoluteDifferenceSummation[currentIndex] += abs(inputNumbers[currentIndex] - inputNumbers[comparisonIndex]);\n            }\n        }\n    }\n\n    return absoluteDifferenceSummation;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> calculateSummationOfAbsoluteDifferences(const std::vector<int> &inputNumbers)\n{\n    int numberOfElements= inputNumbers.size();\n    std::vector<int> absoluteDifferenceSummation(numberOfElements, 0);\n\n    for(int currentIndex= 0; currentIndex < numberOfElements; currentIndex++)\n    {\n        for(int comparisonIndex= 0; comparisonIndex < numberOfElements; comparisonIndex++)\n        {\n            if(currentIndex != comparisonIndex)\n            {\n                absoluteDifferenceSummation[currentIndex]+= std::abs(inputNumbers[currentIndex] - inputNumbers[comparisonIndex]);\n            }\n        }\n    }\n\n    return absoluteDifferenceSummation;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint stoneGameVI(vector<int> &aliceValues, vector<int> &bobValues)\n{\n    int numberOfStones= aliceValues.size();\n    vector<pair<int, int>> totalSums;\n\n    for(int i= 0; i < numberOfStones; ++i)\n    {\n        totalSums.push_back({aliceValues[i] + bobValues[i], i});\n    }\n\n    sort(totalSums.rbegin(), totalSums.rend());\n\n    int aliceScore= 0, bobScore= 0;\n    for(int i= 0; i < numberOfStones; ++i)\n    {\n        if(i % 2 == 0)\n            aliceScore+= aliceValues[totalSums[i].second];\n        else\n            bobScore+= bobValues[totalSums[i].second];\n    }\n\n    return (aliceScore == bobScore) ? 0 : (aliceScore > bobScore) ? 1\n                                                                  : -1;\n}",
    "output": "#include <bits/stdc++.h>\nint stoneGameVI(std::vector<int> &aliceValues, std::vector<int> &bobValues)\n{\n    int numberOfStones= aliceValues.size();\n    std::vector<std::pair<int, int>> totalSums;\n\n    for(int i= 0; i < numberOfStones; ++i)\n    {\n        totalSums.push_back({aliceValues[i] + bobValues[i], i});\n    }\n\n    std::sort(totalSums.rbegin(), totalSums.rend());\n\n    int aliceScore= 0, bobScore= 0;\n    for(int i= 0; i < numberOfStones; ++i)\n    {\n        if(i % 2 == 0)\n            aliceScore+= aliceValues[totalSums[i].second];\n        else\n            bobScore+= bobValues[totalSums[i].second];\n    }\n\n    return (aliceScore == bobScore) ? 0 : (aliceScore > bobScore) ? 1\n                                                                  : -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool areAlmostEqual(string firstString, string secondString)\n{\n    if(firstString == secondString)\n        return true;\n    vector<int> differenceIndices;\n    for(int i= 0; i < firstString.length(); i++)\n    {\n        if(firstString[i] != secondString[i])\n        {\n            differenceIndices.push_back(i);\n        }\n    }\n    return differenceIndices.size() == 2 && firstString[differenceIndices[0]] == secondString[differenceIndices[1]] && firstString[differenceIndices[1]] == secondString[differenceIndices[0]];\n}",
    "output": "#include <bits/stdc++.h>\nbool areAlmostEqual(std::string firstString, std::string secondString)\n{\n    if(firstString == secondString)\n        return true;\n    std::vector<int> differenceIndices;\n    for(int i= 0; i < firstString.length(); i++)\n    {\n        if(firstString[i] != secondString[i])\n        {\n            differenceIndices.push_back(i);\n        }\n    }\n    return differenceIndices.size() == 2 && firstString[differenceIndices[0]] == secondString[differenceIndices[1]] && firstString[differenceIndices[1]] == secondString[differenceIndices[0]];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maximumWealth(vector<vector<int>> &accounts)\n{\n    int maxWealth = 0;\n    for (int i = 0; i < accounts.size(); ++i)\n    {\n        const auto &customer = accounts[i];\n        maxWealth = max(maxWealth, accumulate(customer.begin(), customer.end(), 0));\n    }\n    return maxWealth;\n}",
    "output": "#include <bits/stdc++.h>\nint maximumWealth(std::vector<std::vector<int>> &accounts)\n{\n    int maxWealth= 0;\n    for(const auto &customer : accounts)\n    {\n        maxWealth= std::max(maxWealth, std::accumulate(customer.begin(), customer.end(), 0));\n    }\n    return maxWealth;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> mostCompetitive(vector<int> &inputNumbers, int desiredSize)\n{\n    stack<int> numberStack;\n    int totalNumbers = inputNumbers.size();\n\n    for(int currentIndex = 0; currentIndex < totalNumbers; currentIndex++)\n    {\n        while(!numberStack.empty() && inputNumbers[currentIndex] < numberStack.top() && numberStack.size() + totalNumbers - currentIndex > desiredSize)\n        {\n            numberStack.pop();\n        }\n        if(numberStack.size() < desiredSize)\n        {\n            numberStack.push(inputNumbers[currentIndex]);\n        }\n    }\n\n    vector<int> result(desiredSize);\n    for(int resultIndex = desiredSize - 1; resultIndex >= 0; resultIndex--)\n    {\n        result[resultIndex] = numberStack.top();\n        numberStack.pop();\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> mostCompetitive(std::vector<int> &inputNumbers, int desiredSize)\n{\n    std::stack<int> numberStack;\n    int totalNumbers= inputNumbers.size();\n\n    for(int currentIndex= 0; currentIndex < totalNumbers; currentIndex++)\n    {\n        while(!numberStack.empty() && inputNumbers[currentIndex] < numberStack.top() && numberStack.size() + totalNumbers - currentIndex > desiredSize)\n        {\n            numberStack.pop();\n        }\n        if(numberStack.size() < desiredSize)\n        {\n            numberStack.push(inputNumbers[currentIndex]);\n        }\n    }\n\n    std::vector<int> result(desiredSize);\n    for(int resultIndex= desiredSize - 1; resultIndex >= 0; resultIndex--)\n    {\n        result[resultIndex]= numberStack.top();\n        numberStack.pop();\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minMoves(vector<int> &numberList, int limit)\n{\n    int size= numberList.size();\n    vector<int> delta(2 * limit + 2, 0);\n\n    for(int index= 0; index < size / 2; index++)\n    {\n        int lowerBound= min(numberList[index], numberList[size - 1 - index]) + 1;\n        int upperBound= max(numberList[index], numberList[size - 1 - index]) + limit;\n        delta[lowerBound]--;\n        delta[numberList[index] + numberList[size - 1 - index]]--;\n        delta[upperBound + 1]++;\n    }\n\n    int minimumMoves= size, currentMoves= size;\n    for(int i= 2; i <= 2 * limit; i++)\n    {\n        currentMoves+= delta[i];\n        minimumMoves= min(minimumMoves, currentMoves);\n    }\n    return minimumMoves;\n}",
    "output": "#include <bits/stdc++.h>\nint minMoves(std::vector<int> &numberList, int limit)\n{\n    int size= numberList.size();\n    std::vector<int> delta(2 * limit + 2, 0);\n\n    for(int index= 0; index < size / 2; index++)\n    {\n        int lowerBound= std::min(numberList[index], numberList[size - 1 - index]) + 1;\n        int upperBound= std::max(numberList[index], numberList[size - 1 - index]) + limit;\n        delta[lowerBound]--;\n        delta[numberList[index] + numberList[size - 1 - index]]--;\n        delta[upperBound + 1]++;\n    }\n\n    int minimumMoves= size, currentMoves= size;\n    for(int i= 2; i <= 2 * limit; i++)\n    {\n        currentMoves+= delta[i];\n        minimumMoves= std::min(minimumMoves, currentMoves);\n    }\n    return minimumMoves;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumDeviation(vector<int> &inputNumbers)\n{\n    priority_queue<int> maxHeap;\n    int minimumValue = INT_MAX;\n    int size = inputNumbers.size();\n\n    for (int i = 0; i < size; ++i)\n    {\n        int number = inputNumbers[i];\n        if (number % 2 == 0)\n        {\n            maxHeap.push(number);\n        }\n        else\n        {\n            maxHeap.push(number * 2);\n        }\n        minimumValue = min(minimumValue, number);\n    }\n\n    int minimumDeviationResult = INT_MAX;\n    while (true)\n    {\n        int topValue = maxHeap.top();\n        maxHeap.pop();\n        minimumDeviationResult = min(minimumDeviationResult, topValue - minimumValue);\n\n        if (topValue % 2 == 1)\n            break;\n        maxHeap.push(topValue / 2);\n        minimumValue = min(minimumValue, topValue / 2);\n    }\n    return minimumDeviationResult;\n}",
    "output": "#include <bits/stdc++.h>\nint minimumDeviation(std::vector<int> &inputNumbers)\n{\n    std::priority_queue<int> maxHeap;\n    int minimumValue= INT_MAX;\n    int size= inputNumbers.size();\n\n    for(int number : inputNumbers)\n    {\n        if(number % 2 == 0)\n        {\n            maxHeap.push(number);\n        }\n        else\n        {\n            maxHeap.push(number * 2);\n        }\n        minimumValue= std::min(minimumValue, number);\n    }\n\n    int minimumDeviationResult= INT_MAX;\n    while(true)\n    {\n        int topValue= maxHeap.top();\n        maxHeap.pop();\n        minimumDeviationResult= std::min(minimumDeviationResult, topValue - minimumValue);\n\n        if(topValue % 2 == 1)\n            break;\n        maxHeap.push(topValue / 2);\n        minimumValue= std::min(minimumValue, topValue / 2);\n    }\n    return minimumDeviationResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// for isdigit\nusing namespace std;\n\nint findSecondHighestDigit(string inputString)\n{\n    int largestDigit = -1, secondLargestDigit = -1;\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentChar = inputString[i];\n        if (isdigit(currentChar))\n        {\n            int currentDigit = currentChar - '0';\n            if (currentDigit > largestDigit)\n            {\n                secondLargestDigit = largestDigit;\n                largestDigit = currentDigit;\n            }\n            else if (currentDigit < largestDigit && currentDigit > secondLargestDigit)\n            {\n                secondLargestDigit = currentDigit;\n            }\n        }\n    }\n    return secondLargestDigit;\n}",
    "output": "#include <bits/stdc++.h>\nint findSecondHighestDigit(std::string inputString)\n{\n    int largestDigit= -1, secondLargestDigit= -1;\n    for(char currentChar : inputString)\n    {\n        if(std::isdigit(currentChar))\n        {\n            int currentDigit= currentChar - '0';\n            if(currentDigit > largestDigit)\n            {\n                secondLargestDigit= largestDigit;\n                largestDigit= currentDigit;\n            }\n            else if(currentDigit < largestDigit && currentDigit > secondLargestDigit)\n            {\n                secondLargestDigit= currentDigit;\n            }\n        }\n    }\n    return secondLargestDigit;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring interpret(string command)\n{\n    string result;\n    for(int index= 0; index < command.size(); ++index)\n    {\n        if(command[index] == 'G')\n            result+= 'G';\n        else if(command[index] == '(' && command[index + 1] == ')')\n        {\n            result+= 'o';\n            index++;\n        }\n        else\n        {\n            result+= \"al\";\n            index+= 3;\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string interpret(std::string command)\n{\n    std::string result;\n    for(int index= 0; index < command.size(); ++index)\n    {\n        if(command[index] == 'G')\n            result+= 'G';\n        else if(command[index] == '(' && command[index + 1] == ')')\n        {\n            result+= 'o';\n            index++;\n        }\n        else\n        {\n            result+= \"al\";\n            index+= 3;\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxOperations(vector<int> &numbers, int targetSum)\n{\n    unordered_map<int, int> numberCount;\n    int totalOperations = 0;\n\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        if (numberCount[targetSum - currentNumber] > 0)\n        {\n            --numberCount[targetSum - currentNumber];\n            ++totalOperations;\n        }\n        else\n        {\n            ++numberCount[currentNumber];\n        }\n    }\n\n    return totalOperations;\n}",
    "output": "#include <bits/stdc++.h>\nint maxOperations(std::vector<int> &numbers, int targetSum)\n{\n    std::unordered_map<int, int> numberCount;\n    int totalOperations= 0;\n\n    for(int currentNumber : numbers)\n    {\n        if(numberCount[targetSum - currentNumber] > 0)\n        {\n            --numberCount[targetSum - currentNumber];\n            ++totalOperations;\n        }\n        else\n        {\n            ++numberCount[currentNumber];\n        }\n    }\n\n    return totalOperations;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumIncompatibility(vector<int> &numbers, int groups)\n{\n    int totalNumbers= numbers.size();\n    if(totalNumbers % groups != 0)\n        return -1;\n\n    sort(numbers.begin(), numbers.end());\n    multiset<int> incompatibilities;\n    for(int groupIndex= 0; groupIndex < groups; ++groupIndex)\n    {\n        incompatibilities.insert(numbers[groupIndex * (totalNumbers / groups)] - numbers[(groupIndex + 1) * (totalNumbers / groups) - 1]);\n    }\n\n    return accumulate(incompatibilities.begin(), incompatibilities.end(), 0);\n}",
    "output": "#include <bits/stdc++.h>\nint minimumIncompatibility(std::vector<int> &numbers, int groups)\n{\n    int totalNumbers = numbers.size();\n    if(totalNumbers % groups != 0)\n        return -1;\n\n    std::sort(numbers.begin(), numbers.end());\n    std::multiset<int> incompatibilities;\n    for(int groupIndex = 0; groupIndex < groups; ++groupIndex)\n    {\n        incompatibilities.insert(numbers[groupIndex * (totalNumbers / groups)] - numbers[(groupIndex + 1) * (totalNumbers / groups) - 1]);\n    }\n\n    return std::accumulate(incompatibilities.begin(), incompatibilities.end(), 0);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint concatenatedBinary(int upperLimit)\n{\n    long long concatenatedResult= 0;\n    for(int currentNumber= 1; currentNumber <= upperLimit; ++currentNumber)\n    {\n        int binaryLength= log2(currentNumber) + 1;\n        concatenatedResult= ((concatenatedResult << binaryLength) % 1000000007 + currentNumber) % 1000000007;\n    }\n    return concatenatedResult;\n}",
    "output": "#include <bits/stdc++.h>\nint concatenatedBinary(int upperLimit)\n{\n    long long concatenatedResult= 0;\n    for(int currentNumber= 1; currentNumber <= upperLimit; ++currentNumber)\n    {\n        int binaryLength= std::log2(currentNumber) + 1;\n        concatenatedResult= ((concatenatedResult << binaryLength) % 1000000007 + currentNumber) % 1000000007;\n    }\n    return concatenatedResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint getNumberOfBacklogOrders(vector<vector<int>> &orders)\n{\n    priority_queue<vector<int>> buyOrders;\n    priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> sellOrders;\n    int totalOrders = 0, modulo = 1e9 + 7;\n\n    for (int i = 0; i < orders.size(); ++i)\n    {\n        auto &order = orders[i];\n        int price = order[0];\n        int amount = order[1];\n        if (order[2] == 0)\n        { // buy order\n            while (amount > 0 && !sellOrders.empty() && sellOrders.top()[0] <= price)\n            {\n                int quantity = min(amount, sellOrders.top()[1]);\n                amount -= quantity;\n                sellOrders.top()[1] -= quantity;\n                if (sellOrders.top()[1] == 0)\n                {\n                    sellOrders.pop();\n                }\n            }\n            if (amount > 0)\n            {\n                buyOrders.push({price, amount});\n            }\n        }\n        else\n        { // sell order\n            while (amount > 0 && !buyOrders.empty() && buyOrders.top()[0] >= price)\n            {\n                int quantity = min(amount, buyOrders.top()[1]);\n                amount -= quantity;\n                buyOrders.top()[1] -= quantity;\n                if (buyOrders.top()[1] == 0)\n                {\n                    buyOrders.pop();\n                }\n            }\n            if (amount > 0)\n            {\n                sellOrders.push({price, amount});\n            }\n        }\n    }\n\n    while (!buyOrders.empty())\n    {\n        totalOrders = (totalOrders + buyOrders.top()[1]) % modulo;\n        buyOrders.pop();\n    }\n\n    while (!sellOrders.empty())\n    {\n        totalOrders = (totalOrders + sellOrders.top()[1]) % modulo;\n        sellOrders.pop();\n    }\n\n    return totalOrders;\n}",
    "output": "#include <bits/stdc++.h>\nint getNumberOfBacklogOrders(std::vector<std::vector<int>> &orders)\n{\n    std::priority_queue<std::vector<int>> buyOrders;\n    std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, std::greater<std::vector<int>>> sellOrders;\n    int totalOrders = 0, modulo = 1e9 + 7;\n\n    for(auto &order : orders)\n    {\n        int price = order[0];\n        int amount = order[1];\n        if(order[2] == 0)\n        { // buy order\n            while(amount > 0 && !sellOrders.empty() && sellOrders.top()[0] <= price)\n            {\n                int quantity = std::min(amount, sellOrders.top()[1]);\n                amount -= quantity;\n                sellOrders.top()[1] -= quantity;\n                if(sellOrders.top()[1] == 0)\n                {\n                    sellOrders.pop();\n                }\n            }\n            if(amount > 0)\n            {\n                buyOrders.push({price, amount});\n            }\n        }\n        else\n        { // sell order\n            while(amount > 0 && !buyOrders.empty() && buyOrders.top()[0] >= price)\n            {\n                int quantity = std::min(amount, buyOrders.top()[1]);\n                amount -= quantity;\n                buyOrders.top()[1] -= quantity;\n                if(buyOrders.top()[1] == 0)\n                {\n                    buyOrders.pop();\n                }\n            }\n            if(amount > 0)\n            {\n                sellOrders.push({price, amount});\n            }\n        }\n    }\n\n    while(!buyOrders.empty())\n    {\n        totalOrders = (totalOrders + buyOrders.top()[1]) % modulo;\n        buyOrders.pop();\n    }\n\n    while(!sellOrders.empty())\n    {\n        totalOrders = (totalOrders + sellOrders.top()[1]) % modulo;\n        sellOrders.pop();\n    }\n\n    return totalOrders;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countStudents(vector<int> &studentPreferences, vector<int> &sandwiches)\n{\n    queue<int> studentQueue;\n    for (int i = 0; i < studentPreferences.size(); ++i)\n        studentQueue.push(studentPreferences[i]);\n\n    int sandwichIndex = 0, attemptCount = 0;\n    while (!studentQueue.empty())\n    {\n        int currentStudent = studentQueue.front();\n        if (currentStudent == sandwiches[sandwichIndex])\n        {\n            studentQueue.pop();\n            sandwichIndex++;\n            attemptCount = 0;\n        }\n        else\n        {\n            studentQueue.pop();\n            studentQueue.push(currentStudent);\n            attemptCount++;\n        }\n        if (attemptCount == studentQueue.size())\n            break;\n    }\n\n    return studentQueue.size();\n}",
    "output": "#include <bits/stdc++.h>\nint countStudents(std::vector<int> &studentPreferences, std::vector<int> &sandwiches)\n{\n    std::queue<int> studentQueue;\n    for(int preference : studentPreferences)\n        studentQueue.push(preference);\n\n    int sandwichIndex = 0, attemptCount = 0;\n    while(!studentQueue.empty())\n    {\n        int currentStudent = studentQueue.front();\n        if(currentStudent == sandwiches[sandwichIndex])\n        {\n            studentQueue.pop();\n            sandwichIndex++;\n            attemptCount = 0;\n        }\n        else\n        {\n            studentQueue.pop();\n            studentQueue.push(currentStudent);\n            attemptCount++;\n        }\n        if(attemptCount == studentQueue.size())\n            break;\n    }\n\n    return studentQueue.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble averageWaitingTime(vector<vector<int>> &customerData)\n{\n    double totalWaitTime = 0;\n    int currentTime = 0;\n\n    for (int i = 0; i < customerData.size(); ++i)\n    {\n        auto &customer = customerData[i];\n        currentTime = max(currentTime, customer[0]) + customer[1];\n        totalWaitTime += currentTime - customer[0];\n    }\n\n    return totalWaitTime / customerData.size();\n}",
    "output": "#include <bits/stdc++.h>\ndouble averageWaitingTime(std::vector<std::vector<int>> &customerData)\n{\n    double totalWaitTime= 0;\n    int currentTime= 0;\n\n    for(auto &customer : customerData)\n    {\n        currentTime= std::max(currentTime, customer[0]) + customer[1];\n        totalWaitTime+= currentTime - customer[0];\n    }\n\n    return totalWaitTime / customerData.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minMoves(vector<int> &binaryArray, int subarraySize)\n{\n    int arraySize= binaryArray.size();\n    vector<int> oneIndices;\n    for(int index= 0; index < arraySize; ++index)\n    {\n        if(binaryArray[index] == 1)\n        {\n            oneIndices.push_back(index - oneIndices.size());\n        }\n    }\n\n    int totalMoves= 0;\n    for(int index= 0; index < subarraySize; ++index)\n    {\n        totalMoves+= (oneIndices[index] - oneIndices[subarraySize / 2]);\n    }\n\n    int minimumMoves= totalMoves;\n    for(int index= subarraySize; index < oneIndices.size(); ++index)\n    {\n        totalMoves+= oneIndices[index] - oneIndices[index - subarraySize] - subarraySize;\n        minimumMoves= min(minimumMoves, totalMoves);\n    }\n\n    return minimumMoves;\n}",
    "output": "#include <bits/stdc++.h>\nint minMoves(std::vector<int> &binaryArray, int subarraySize)\n{\n    int arraySize= binaryArray.size();\n    std::vector<int> oneIndices;\n    for(int index= 0; index < arraySize; ++index)\n    {\n        if(binaryArray[index] == 1)\n        {\n            oneIndices.push_back(index - oneIndices.size());\n        }\n    }\n\n    int totalMoves= 0;\n    for(int index= 0; index < subarraySize; ++index)\n    {\n        totalMoves+= (oneIndices[index] - oneIndices[subarraySize / 2]);\n    }\n\n    int minimumMoves= totalMoves;\n    for(int index= subarraySize; index < oneIndices.size(); ++index)\n    {\n        totalMoves+= oneIndices[index] - oneIndices[index - subarraySize] - subarraySize;\n        minimumMoves= std::min(minimumMoves, totalMoves);\n    }\n\n    return minimumMoves;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int calculateNumberOfMatches(int numberOfPlayers)\n{\n    return numberOfPlayers - 1;\n}",
    "output": "int calculateNumberOfMatches(int numberOfPlayers)\n{\n    return numberOfPlayers - 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minPartitions(string numberString)\n{\n    int maximumDigit = 0;\n    for (int i = 0; i < numberString.size(); ++i)\n    {\n        char digitChar = numberString[i];\n        maximumDigit = max(maximumDigit, digitChar - '0');\n        if (maximumDigit == 9)\n            break;\n    }\n    return maximumDigit;\n}",
    "output": "#include <bits/stdc++.h>\nint minPartitions(std::string numberString)\n{\n    int maximumDigit= 0;\n    for(char digitChar : numberString)\n    {\n        maximumDigit= std::max(maximumDigit, digitChar - '0');\n        if(maximumDigit == 9)\n            break;\n    }\n    return maximumDigit;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint stoneGame(vector<int> &stonePiles)\n{\n    int numberOfStones= stonePiles.size();\n    vector<vector<int>> dynamicProgramming(numberOfStones, vector<int>(numberOfStones, 0));\n\n    for(int startIndex= numberOfStones - 1; startIndex >= 0; --startIndex)\n    {\n        for(int endIndex= startIndex + 1; endIndex < numberOfStones; ++endIndex)\n        {\n            dynamicProgramming[startIndex][endIndex]= max(stonePiles[endIndex] - dynamicProgramming[startIndex][endIndex - 1], stonePiles[startIndex] - dynamicProgramming[startIndex + 1][endIndex]);\n        }\n    }\n\n    return dynamicProgramming[0][numberOfStones - 1];\n}",
    "output": "#include <bits/stdc++.h>\nint stoneGame(std::vector<int> &stonePiles)\n{\n    int numberOfStones= stonePiles.size();\n    std::vector<std::vector<int>> dynamicProgramming(numberOfStones, std::vector<int>(numberOfStones, 0));\n\n    for(int startIndex= numberOfStones - 1; startIndex >= 0; --startIndex)\n    {\n        for(int endIndex= startIndex + 1; endIndex < numberOfStones; ++endIndex)\n        {\n            dynamicProgramming[startIndex][endIndex]= std::max(stonePiles[endIndex] - dynamicProgramming[startIndex][endIndex - 1], stonePiles[startIndex] - dynamicProgramming[startIndex + 1][endIndex]);\n        }\n    }\n\n    return dynamicProgramming[0][numberOfStones - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution\n{\n  public:\n    int findShortestPath(GridMaster &gridMaster)\n    {\n        depthFirstSearch(gridMaster, 0, 0);\n        if(targetPosition.first == INT_MAX)\n        {\n            return -1;\n        }\n        return breadthFirstSearch();\n    }\n\n  private:\n    map<pair<int, int>, int> costGrid;\n    pair<int, int> targetPosition= {INT_MAX, INT_MAX};\n    int directionOffsets[5]= {-1, 0, 1, 0, -1};\n\n    char directionCharacters[4]= {'U', 'R', 'D', 'L'};\n    char oppositeDirectionCharacters[4]= {'D', 'L', 'U', 'R'};\n\n    void depthFirstSearch(GridMaster &gridMaster, int currentX, int currentY)\n    {\n        if(gridMaster.isTarget())\n        {\n            targetPosition= {currentX, currentY};\n        }\n        for(int i= 0; i < 4; i++)\n        {\n            int nextX= currentX + directionOffsets[i], nextY= currentY + directionOffsets[i + 1];\n            if(costGrid.count({nextX, nextY}))\n                continue;\n            if(gridMaster.canMove(directionCharacters[i]))\n            {\n                int movementCost= gridMaster.move(directionCharacters[i]);\n                costGrid[{nextX, nextY}]= movementCost;\n                depthFirstSearch(gridMaster, nextX, nextY);\n                gridMaster.move(oppositeDirectionCharacters[i]);\n            }\n        }\n    }\n\n    int breadthFirstSearch()\n    {\n        queue<pair<int, int>> positionQueue;\n        positionQueue.push({0, 0});\n        costGrid[{0, 0}]= 0;\n        while(!positionQueue.empty())\n        {\n            auto [currentX, currentY]= positionQueue.front();\n            positionQueue.pop();\n            for(int i= 0; i < 4; i++)\n            {\n                int nextX= currentX + directionOffsets[i], nextY= currentY + directionOffsets[i + 1];\n                int newCost= costGrid[{currentX, currentY}] + costGrid[{nextX, nextY}];\n                if(costGrid.count({nextX, nextY}) && costGrid[{nextX, nextY}] > newCost)\n                {\n                    costGrid[{nextX, nextY}]= newCost;\n                    if(nextX != targetPosition.first || nextY != targetPosition.second)\n                    {\n                        positionQueue.push({nextX, nextY});\n                    }\n                }\n            }\n        }\n        return costGrid[targetPosition];\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Solution\n{\n  public:\n    int findShortestPath(GridMaster &gridMaster)\n    {\n        depthFirstSearch(gridMaster, 0, 0);\n        if(targetPosition.first == std::numeric_limits<int>::max())\n        {\n            return -1;\n        }\n        return breadthFirstSearch();\n    }\n\n  private:\n    std::map<std::pair<int, int>, int> costGrid;\n    std::pair<int, int> targetPosition= {std::numeric_limits<int>::max(), std::numeric_limits<int>::max()};\n    int directionOffsets[5]= {-1, 0, 1, 0, -1};\n\n    void depthFirstSearch(GridMaster &gridMaster, int currentX, int currentY)\n    {\n        if(gridMaster.isTarget())\n        {\n            targetPosition= {currentX, currentY};\n        }\n        for(int i= 0; i < 4; i++)\n        {\n            int nextX= currentX + directionOffsets[i], nextY= currentY + directionOffsets[i + 1];\n            if(costGrid.count({nextX, nextY}))\n                continue;\n            if(gridMaster.canMove(directionCharacters[i]))\n            {\n                int movementCost= gridMaster.move(directionCharacters[i]);\n                costGrid[{nextX, nextY}]= movementCost;\n                depthFirstSearch(gridMaster, nextX, nextY);\n                gridMaster.move(oppositeDirectionCharacters[i]);\n            }\n        }\n    }\n\n    int breadthFirstSearch()\n    {\n        std::queue<std::pair<int, int>> positionQueue;\n        positionQueue.push({0, 0});\n        costGrid[{0, 0}]= 0;\n        while(!positionQueue.empty())\n        {\n            auto [currentX, currentY]= positionQueue.front();\n            positionQueue.pop();\n            for(int i= 0; i < 4; i++)\n            {\n                int nextX= currentX + directionOffsets[i], nextY= currentY + directionOffsets[i + 1];\n                int newCost= costGrid[{currentX, currentY}] + costGrid[{nextX, nextY}];\n                if(costGrid.count({nextX, nextY}) && costGrid[{nextX, nextY}] > newCost)\n                {\n                    costGrid[{nextX, nextY}]= newCost;\n                    if(nextX != targetPosition.first || nextY != targetPosition.second)\n                    {\n                        positionQueue.push({nextX, nextY});\n                    }\n                }\n            }\n        }\n        return costGrid[targetPosition];\n    }\n\n    char directionCharacters[4]= {'U', 'R', 'D', 'L'};\n    char oppositeDirectionCharacters[4]= {'D', 'L', 'U', 'R'};\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring reformatNumber(string phoneNumber)\n{\n    string cleanedNumber;\n    for (int i = 0; i < phoneNumber.size(); ++i)\n    {\n        char digit = phoneNumber[i];\n        if (isdigit(digit))\n            cleanedNumber.push_back(digit);\n    }\n\n    vector<string> numberBlocks;\n    int totalDigits = cleanedNumber.size();\n    int index = 0;\n    while (index < totalDigits)\n    {\n        if (totalDigits - index == 2 || totalDigits - index == 4)\n        {\n            numberBlocks.push_back(cleanedNumber.substr(index, 2));\n            index += 2;\n        }\n        else\n        {\n            numberBlocks.push_back(cleanedNumber.substr(index, 3));\n            index += 3;\n        }\n    }\n\n    string formattedNumber = numberBlocks[0];\n    for (int blockIndex = 1; blockIndex < numberBlocks.size(); blockIndex++)\n    {\n        formattedNumber += '-' + numberBlocks[blockIndex];\n    }\n    return formattedNumber;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string reformatNumber(std::string phoneNumber)\n{\n    std::string cleanedNumber;\n    for(char digit : phoneNumber)\n    {\n        if(isdigit(digit))\n            cleanedNumber.push_back(digit);\n    }\n\n    std::vector<std::string> numberBlocks;\n    int totalDigits= cleanedNumber.size();\n    int index= 0;\n    while(index < totalDigits)\n    {\n        if(totalDigits - index == 2 || totalDigits - index == 4)\n        {\n            numberBlocks.push_back(cleanedNumber.substr(index, 2));\n            index+= 2;\n        }\n        else\n        {\n            numberBlocks.push_back(cleanedNumber.substr(index, 3));\n            index+= 3;\n        }\n    }\n\n    std::string formattedNumber= numberBlocks[0];\n    for(int blockIndex= 1; blockIndex < numberBlocks.size(); blockIndex++)\n    {\n        formattedNumber+= '-' + numberBlocks[blockIndex];\n    }\n    return formattedNumber;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maximumUniqueSubarray(vector<int> &numberArray)\n{\n    int maximumSum = 0, currentSum = 0, leftIndex = 0;\n    unordered_set<int> uniqueElements;\n\n    for(int rightIndex = 0; rightIndex < numberArray.size(); ++rightIndex)\n    {\n        while(uniqueElements.count(numberArray[rightIndex]))\n        {\n            uniqueElements.erase(numberArray[leftIndex]);\n            currentSum -= numberArray[leftIndex++];\n        }\n\n        uniqueElements.insert(numberArray[rightIndex]);\n        currentSum += numberArray[rightIndex];\n        maximumSum = max(maximumSum, currentSum);\n    }\n\n    return maximumSum;\n}",
    "output": "#include <bits/stdc++.h>\nint maximumUniqueSubarray(std::vector<int> &numberArray)\n{\n    int maximumSum= 0, currentSum= 0, leftIndex= 0;\n    std::unordered_set<int> uniqueElements;\n\n    for(int rightIndex= 0; rightIndex < numberArray.size(); ++rightIndex)\n    {\n        while(uniqueElements.count(numberArray[rightIndex]))\n        {\n            uniqueElements.erase(numberArray[leftIndex]);\n            currentSum-= numberArray[leftIndex++];\n        }\n\n        uniqueElements.insert(numberArray[rightIndex]);\n        currentSum+= numberArray[rightIndex];\n        maximumSum= std::max(maximumSum, currentSum);\n    }\n\n    return maximumSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxResult(vector<int> &numArray, int maxJump)\n{\n    int arraySize= numArray.size();\n    deque<int> indexDeque;\n    vector<int> dp(arraySize);\n\n    dp[0]= numArray[0];\n    indexDeque.push_back(0);\n\n    for(int i= 1; i < arraySize; ++i)\n    {\n        while(!indexDeque.empty() && indexDeque.front() < i - maxJump)\n        {\n            indexDeque.pop_front();\n        }\n\n        dp[i]= numArray[i] + dp[indexDeque.front()];\n\n        while(!indexDeque.empty() && dp[i] >= dp[indexDeque.back()])\n        {\n            indexDeque.pop_back();\n        }\n\n        indexDeque.push_back(i);\n    }\n\n    return dp.back();\n}",
    "output": "#include <bits/stdc++.h>\nint maxResult(std::vector<int> &numArray, int maxJump)\n{\n    int arraySize= numArray.size();\n    std::deque<int> indexDeque;\n    std::vector<int> dp(arraySize);\n\n    dp[0]= numArray[0];\n    indexDeque.push_back(0);\n\n    for(int i= 1; i < arraySize; ++i)\n    {\n        while(!indexDeque.empty() && indexDeque.front() < i - maxJump)\n        {\n            indexDeque.pop_front();\n        }\n\n        dp[i]= numArray[i] + dp[indexDeque.front()];\n\n        while(!indexDeque.empty() && dp[i] >= dp[indexDeque.back()])\n        {\n            indexDeque.pop_back();\n        }\n\n        indexDeque.push_back(i);\n    }\n\n    return dp.back();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<bool> distanceLimitedPathsExist(int nodeCount, vector<vector<int>> &edgeList, vector<vector<int>> &queries)\n{\n    for(int queryIndex = 0; queryIndex < queries.size(); ++queryIndex)\n    {\n        queries[queryIndex].push_back(queryIndex);\n    }\n    sort(queries.begin(), queries.end(), [](const vector<int> &a, const vector<int> &b)\n         { return a[2] < b[2]; });\n    sort(edgeList.begin(), edgeList.end(), [](const vector<int> &a, const vector<int> &b)\n         { return a[2] < b[2]; });\n\n    vector<int> parent(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        parent[i] = i;\n    }\n\n    function<int(int)> findParent = [&](int node)\n    {\n        return node == parent[node] ? node : parent[node] = findParent(parent[node]);\n    };\n\n    vector<bool> result(queries.size());\n    int edgeIndex = 0;\n    for (int queryIndex = 0; queryIndex < queries.size(); ++queryIndex)\n    {\n        const auto &query = queries[queryIndex];\n        int sourceNode = query[0], destinationNode = query[1], distanceLimit = query[2], queryId = query[3];\n        while(edgeIndex < edgeList.size() && edgeList[edgeIndex][2] < distanceLimit)\n        {\n            int u = edgeList[edgeIndex][0], v = edgeList[edgeIndex][1];\n            int rootU = findParent(u), rootV = findParent(v);\n            if(rootU != rootV)\n            {\n                parent[rootU] = rootV;\n            }\n            edgeIndex++;\n        }\n        result[queryId] = findParent(sourceNode) == findParent(destinationNode);\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<bool> distanceLimitedPathsExist(int nodeCount, std::vector<std::vector<int>> &edgeList, std::vector<std::vector<int>> &queries)\n{\n    for(int queryIndex= 0; queryIndex < queries.size(); ++queryIndex)\n    {\n        queries[queryIndex].push_back(queryIndex);\n    }\n    std::sort(queries.begin(), queries.end(), [](const std::vector<int> &a, const std::vector<int> &b)\n         { return a[2] < b[2]; });\n    std::sort(edgeList.begin(), edgeList.end(), [](const std::vector<int> &a, const std::vector<int> &b)\n         { return a[2] < b[2]; });\n\n    std::vector<int> parent(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        parent[i]= i;\n    }\n\n    std::function<int(int)> findParent= [&](int node)\n    {\n        return node == parent[node] ? node : parent[node]= findParent(parent[node]);\n    };\n\n    std::vector<bool> result(queries.size());\n    int edgeIndex= 0;\n    for(const auto &query : queries)\n    {\n        int sourceNode= query[0], destinationNode= query[1], distanceLimit= query[2], queryId= query[3];\n        while(edgeIndex < edgeList.size() && edgeList[edgeIndex][2] < distanceLimit)\n        {\n            int u= edgeList[edgeIndex][0], v= edgeList[edgeIndex][1];\n            int rootU= findParent(u), rootV= findParent(v);\n            if(rootU != rootV)\n            {\n                parent[rootU]= rootV;\n            }\n            edgeIndex++;\n        }\n        result[queryId]= findParent(sourceNode) == findParent(destinationNode);\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring truncateSentence(string sentence, int wordCount)\n{\n    istringstream inputStream(sentence);\n    string result, temporaryWord;\n    while(wordCount--)\n    {\n        inputStream >> temporaryWord;\n        result+= temporaryWord + \" \";\n    }\n    result.pop_back();\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string truncateSentence(std::string sentence, int wordCount)\n{\n    std::istringstream inputStream(sentence);\n    std::string result, temporaryWord;\n    while(wordCount--)\n    {\n        inputStream >> temporaryWord;\n        result += temporaryWord + \" \";\n    }\n    result.pop_back();\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int calculateTotalMoney(int totalDays)\n{\n    int totalWeeks= totalDays / 7;\n    int remainingDays= totalDays % 7;\n    return 28 * totalWeeks + 7 * totalWeeks * (totalWeeks - 1) / 2 + (totalWeeks + 1) * remainingDays + remainingDays * (remainingDays - 1) / 2;\n}",
    "output": "int calculateTotalMoney(int totalDays)\n{\n    int totalWeeks= totalDays / 7;\n    int remainingDays= totalDays % 7;\n    return 28 * totalWeeks + 7 * totalWeeks * (totalWeeks - 1) / 2 + (totalWeeks + 1) * remainingDays + remainingDays * (remainingDays - 1) / 2;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPoints(string inputString, int scoreForPair, int scoreForDifferent)\n{\n    int totalPoints= 0;\n    for(int currentIndex= 1; currentIndex < inputString.length(); ++currentIndex)\n    {\n        if(inputString[currentIndex] == inputString[currentIndex - 1])\n        {\n            totalPoints+= max(scoreForPair, scoreForDifferent);\n            inputString[currentIndex]= '#';\n        }\n    }\n    return totalPoints;\n}",
    "output": "#include <bits/stdc++.h>\nint maxPoints(std::string inputString, int scoreForPair, int scoreForDifferent)\n{\n    int totalPoints= 0;\n    for(int currentIndex= 1; currentIndex < inputString.length(); ++currentIndex)\n    {\n        if(inputString[currentIndex] == inputString[currentIndex - 1])\n        {\n            totalPoints+= std::max(scoreForPair, scoreForDifferent);\n            inputString[currentIndex]= '#';\n        }\n    }\n    return totalPoints;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> generateLargestLexicographicSequence(int sequenceLength)\n{\n    vector<int> lexicographicSequence(sequenceLength);\n    for(int index= 0; index < sequenceLength; ++index)\n    {\n        lexicographicSequence[index]= index % 2;\n    }\n    return lexicographicSequence;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> generateLargestLexicographicSequence(int sequenceLength)\n{\n    std::vector<int> lexicographicSequence(sequenceLength);\n    for(int index= 0; index < sequenceLength; ++index)\n    {\n        lexicographicSequence[index]= index % 2;\n    }\n    return lexicographicSequence;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countTrees(vector<vector<int>> &treePairs)\n{\n    int totalNodes = treePairs.size() + 1;\n    vector<int> inDegrees(totalNodes, 0);\n    for (int i = 0; i < treePairs.size(); ++i)\n    {\n        inDegrees[treePairs[i][1]]++;\n    }\n\n    int result = 1;\n    for (int index = 1; index < totalNodes; index++)\n    {\n        result *= inDegrees[index];\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nint countTrees(std::vector<std::vector<int>> &treePairs)\n{\n    int totalNodes = treePairs.size() + 1;\n    std::vector<int> inDegrees(totalNodes, 0);\n    for(std::vector<int> &treePair : treePairs)\n    {\n        inDegrees[treePair[1]]++;\n    }\n\n    int result = 1;\n    for(int index = 1; index < totalNodes; index++)\n    {\n        result *= inDegrees[index];\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint signFunction(int inputValue)\n{\n    if(inputValue > 0)\n        return 1;\n    if(inputValue < 0)\n        return -1;\n    return 0;\n}\n\nint arraySign(vector<int> &numberList)\n{\n    int productSign= 1;\n    for(int index= 0; index < numberList.size(); index++)\n    {\n        productSign*= signFunction(numberList[index]);\n    }\n    return productSign;\n}",
    "output": "#include <bits/stdc++.h>\nint signFunction(int inputValue)\n{\n    if(inputValue > 0)\n        return 1;\n    if(inputValue < 0)\n        return -1;\n    return 0;\n}\n\nint arraySign(std::vector<int> &numberList)\n{\n    int productSign= 1;\n    for(int index= 0; index < numberList.size(); index++)\n    {\n        productSign*= signFunction(numberList[index]);\n    }\n    return productSign;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool halvesAreAlike(const string &inputString)\n{\n    int halfLength = inputString.length() / 2;\n    int vowelCountFirstHalf = 0, vowelCountSecondHalf = 0;\n\n    for(int index = 0; index < halfLength; ++index)\n    {\n        if(strchr(\"aeiouAEIOU\", inputString[index]))\n            vowelCountFirstHalf++;\n    }\n\n    for(int index = halfLength; index < inputString.length(); ++index)\n    {\n        if(strchr(\"aeiouAEIOU\", inputString[index]))\n            vowelCountSecondHalf++;\n    }\n\n    return vowelCountFirstHalf == vowelCountSecondHalf;\n}",
    "output": "#include <bits/stdc++.h>\nbool halvesAreAlike(const std::string &inputString)\n{\n    int halfLength= inputString.length() / 2;\n    int vowelCountFirstHalf= 0, vowelCountSecondHalf= 0;\n\n    for(int index= 0; index < halfLength; ++index)\n    {\n        if(strchr(\"aeiouAEIOU\", inputString[index]))\n            vowelCountFirstHalf++;\n    }\n\n    for(int index= halfLength; index < inputString.length(); ++index)\n    {\n        if(strchr(\"aeiouAEIOU\", inputString[index]))\n            vowelCountSecondHalf++;\n    }\n\n    return vowelCountFirstHalf == vowelCountSecondHalf;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint eatenApples(vector<int> &appleCounts, vector<int> &expirationDays)\n{\n    int totalDays= appleCounts.size();\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> expiringApplesQueue;\n    int eatenApplesCount= 0;\n\n    for(int day= 0; day < totalDays || !expiringApplesQueue.empty(); ++day)\n    {\n        if(day < totalDays && appleCounts[day] > 0)\n        {\n            expiringApplesQueue.push({day + expirationDays[day], appleCounts[day]});\n        }\n\n        while(!expiringApplesQueue.empty() && expiringApplesQueue.top().first <= day)\n        {\n            expiringApplesQueue.pop();\n        }\n\n        if(!expiringApplesQueue.empty())\n        {\n            eatenApplesCount++;\n            auto currentApple= expiringApplesQueue.top();\n            expiringApplesQueue.pop();\n            if(currentApple.second > 1)\n            {\n                currentApple.second--;\n                expiringApplesQueue.push(currentApple);\n            }\n        }\n    }\n\n    return eatenApplesCount;\n}",
    "output": "#include <bits/stdc++.h>\nint eatenApples(std::vector<int> &appleCounts, std::vector<int> &expirationDays)\n{\n    int totalDays = appleCounts.size();\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> expiringApplesQueue;\n    int eatenApplesCount = 0;\n\n    for(int day = 0; day < totalDays || !expiringApplesQueue.empty(); ++day)\n    {\n        if(day < totalDays && appleCounts[day] > 0)\n        {\n            expiringApplesQueue.push({day + expirationDays[day], appleCounts[day]});\n        }\n\n        while(!expiringApplesQueue.empty() && expiringApplesQueue.top().first <= day)\n        {\n            expiringApplesQueue.pop();\n        }\n\n        if(!expiringApplesQueue.empty())\n        {\n            eatenApplesCount++;\n            auto currentApple = expiringApplesQueue.top();\n            expiringApplesQueue.pop();\n            if(currentApple.second > 1)\n            {\n                currentApple.second--;\n                expiringApplesQueue.push(currentApple);\n            }\n        }\n    }\n\n    return eatenApplesCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumWorkingTime(vector<int> &jobDurations, int workerCount)\n{\n    int maxJobDuration = *max_element(jobDurations.begin(), jobDurations.end());\n    int totalJobDuration = accumulate(jobDurations.begin(), jobDurations.end(), 0);\n\n    int leftBoundary = maxJobDuration, rightBoundary = totalJobDuration;\n    while(leftBoundary < rightBoundary)\n    {\n        int midPoint = leftBoundary + (rightBoundary - leftBoundary) / 2;\n        int workerAssignedCount = 1, currentJobSum = 0;\n\n        for(int i = 0; i < jobDurations.size(); ++i)\n        {\n            int jobDuration = jobDurations[i];\n            if(currentJobSum + jobDuration > midPoint)\n            {\n                workerAssignedCount++;\n                currentJobSum = 0;\n            }\n            currentJobSum += jobDuration;\n        }\n\n        if(workerAssignedCount <= workerCount)\n        {\n            rightBoundary = midPoint;\n        }\n        else\n        {\n            leftBoundary = midPoint + 1;\n        }\n    }\n\n    return leftBoundary;\n}",
    "output": "#include <bits/stdc++.h>\nint minimumWorkingTime(std::vector<int> &jobDurations, int workerCount)\n{\n    int maxJobDuration= *std::max_element(jobDurations.begin(), jobDurations.end());\n    int totalJobDuration= std::accumulate(jobDurations.begin(), jobDurations.end(), 0);\n\n    int leftBoundary= maxJobDuration, rightBoundary= totalJobDuration;\n    while(leftBoundary < rightBoundary)\n    {\n        int midPoint= leftBoundary + (rightBoundary - leftBoundary) / 2;\n        int workerAssignedCount= 1, currentJobSum= 0;\n\n        for(int jobDuration : jobDurations)\n        {\n            if(currentJobSum + jobDuration > midPoint)\n            {\n                workerAssignedCount++;\n                currentJobSum= 0;\n            }\n            currentJobSum+= jobDuration;\n        }\n\n        if(workerAssignedCount <= workerCount)\n        {\n            rightBoundary= midPoint;\n        }\n        else\n        {\n            leftBoundary= midPoint + 1;\n        }\n    }\n\n    return leftBoundary;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> maximizeXor(vector<int> &numbers, vector<vector<int>> &queries)\n{\n    sort(numbers.begin(), numbers.end());\n    for(int i = 0; i < queries.size(); ++i)\n    {\n        queries[i].push_back(i);\n    }\n    sort(queries.begin(), queries.end(), [](vector<int> &a, vector<int> &b)\n         { return a[1] < b[1]; });\n\n    vector<int> result(queries.size());\n    int currentIndex = 0, trie[200010][2] = {}, countArray[200010] = {1}, nodeCount = 0;\n    for(int i = 0; i < queries.size(); ++i) // Modified loop to traditional for loop\n    {\n        const auto &query = queries[i];\n        int xValue = query[0], maxValue = query[1], originalIndex = query[2], currentNode = 0;\n        while(currentIndex < numbers.size() && numbers[currentIndex] <= maxValue)\n        {\n            int currentTrieNode = 0, currentNumber = numbers[currentIndex++];\n            for(int j = 31; j >= 0; --j)\n            {\n                int bit = ((currentNumber >> j) & 1);\n                if(!trie[currentTrieNode][bit])\n                {\n                    trie[currentTrieNode][bit] = ++nodeCount;\n                }\n                currentTrieNode = trie[currentTrieNode][bit];\n            }\n            countArray[currentTrieNode]++;\n        }\n        if(!nodeCount)\n        {\n            result[originalIndex] = -1;\n            continue;\n        }\n        int currentTrieNode = 0, answer = 0;\n        for(int j = 31; j >= 0; --j)\n        {\n            int bit = ((xValue >> j) & 1);\n            if(trie[currentTrieNode][bit ^ 1])\n            {\n                currentTrieNode = trie[currentTrieNode][bit ^ 1];\n                answer |= (1 << j);\n            }\n            else\n            {\n                currentTrieNode = trie[currentTrieNode][bit];\n            }\n        }\n        result[originalIndex] = answer;\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> maximizeXor(std::vector<int> &numbers, std::vector<std::vector<int>> &queries)\n{\n    std::sort(numbers.begin(), numbers.end());\n    for(int i= 0; i < queries.size(); ++i)\n    {\n        queries[i].push_back(i);\n    }\n    std::sort(queries.begin(), queries.end(), [](std::vector<int> &a, std::vector<int> &b)\n         { return a[1] < b[1]; });\n\n    std::vector<int> result(queries.size());\n    int currentIndex= 0, trie[200010][2]= {}, countArray[200010]= {1}, nodeCount= 0;\n    for(const auto &query : queries)\n    {\n        int xValue= query[0], maxValue= query[1], originalIndex= query[2], currentNode= 0;\n        while(currentIndex < numbers.size() && numbers[currentIndex] <= maxValue)\n        {\n            int currentTrieNode= 0, currentNumber= numbers[currentIndex++];\n            for(int i= 31; i >= 0; --i)\n            {\n                int bit= ((currentNumber >> i) & 1);\n                if(!trie[currentTrieNode][bit])\n                {\n                    trie[currentTrieNode][bit]= ++nodeCount;\n                }\n                currentTrieNode= trie[currentTrieNode][bit];\n            }\n            countArray[currentTrieNode]++;\n        }\n        if(!nodeCount)\n        {\n            result[originalIndex]= -1;\n            continue;\n        }\n        int currentTrieNode= 0, answer= 0;\n        for(int i= 31; i >= 0; --i)\n        {\n            int bit= ((xValue >> i) & 1);\n            if(trie[currentTrieNode][bit ^ 1])\n            {\n                currentTrieNode= trie[currentTrieNode][bit ^ 1];\n                answer|= (1 << i);\n            }\n            else\n            {\n                currentTrieNode= trie[currentTrieNode][bit];\n            }\n        }\n        result[originalIndex]= answer;\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numberList)\n{\n    int totalOperations= 0;\n    for(int index= 1; index < numberList.size(); index++)\n    {\n        if(numberList[index] <= numberList[index - 1])\n        {\n            totalOperations+= (numberList[index - 1] - numberList[index]) + 1;\n            numberList[index]= numberList[index - 1] + 1;\n        }\n    }\n    return totalOperations;\n}",
    "output": "#include <bits/stdc++.h>\nint minOperations(std::vector<int> &numberList)\n{\n    int totalOperations= 0;\n    for(int index= 1; index < numberList.size(); index++)\n    {\n        if(numberList[index] <= numberList[index - 1])\n        {\n            totalOperations+= (numberList[index - 1] - numberList[index]) + 1;\n            numberList[index]= numberList[index - 1] + 1;\n        }\n    }\n    return totalOperations;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPoints(vector<vector<int>> &points, vector<vector<int>> &queries)\n{\n    vector<int> pointCounts;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        auto &query = queries[i];\n        int insideCount = 0;\n        for (int j = 0; j < points.size(); ++j)\n        {\n            auto &point = points[j];\n            int deltaX = point[0] - query[0];\n            int deltaY = point[1] - query[1];\n            if (deltaX * deltaX + deltaY * deltaY <= query[2] * query[2])\n            {\n                insideCount++;\n            }\n        }\n        pointCounts.push_back(insideCount);\n    }\n    return pointCounts;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> countPoints(std::vector<std::vector<int>> &points, std::vector<std::vector<int>> &queries)\n{\n    std::vector<int> pointCounts;\n    for(auto &query : queries)\n    {\n        int insideCount= 0;\n        for(auto &point : points)\n        {\n            int deltaX= point[0] - query[0];\n            int deltaY= point[1] - query[1];\n            if(deltaX * deltaX + deltaY * deltaY <= query[2] * query[2])\n            {\n                insideCount++;\n            }\n        }\n        pointCounts.push_back(insideCount);\n    }\n    return pointCounts;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool compareBoxTypes(vector<int> &boxTypeA, vector<int> &boxTypeB)\n{\n    return boxTypeA[1] > boxTypeB[1];\n}\n\nint maximumUnits(vector<vector<int>> &boxTypes, int truckCapacity)\n{\n    sort(boxTypes.begin(), boxTypes.end(), compareBoxTypes);\n\n    int totalUnits = 0;\n    for (int i = 0; i < boxTypes.size(); ++i)\n    {\n        auto &boxType = boxTypes[i];\n        int boxCount = min(truckCapacity, boxType[0]);\n        totalUnits += boxCount * boxType[1];\n        truckCapacity -= boxCount;\n        if (truckCapacity == 0)\n        {\n            break;\n        }\n    }\n\n    return totalUnits;\n}",
    "output": "#include <bits/stdc++.h>\nbool compareBoxTypes(std::vector<int> &boxTypeA, std::vector<int> &boxTypeB)\n{\n    return boxTypeA[1] > boxTypeB[1];\n}\n\nint maximumUnits(std::vector<std::vector<int>> &boxTypes, int truckCapacity)\n{\n    std::sort(boxTypes.begin(), boxTypes.end(), compareBoxTypes);\n\n    int totalUnits= 0;\n    for(auto &boxType : boxTypes)\n    {\n        int boxCount= std::min(truckCapacity, boxType[0]);\n        totalUnits+= boxCount * boxType[1];\n        truckCapacity-= boxCount;\n        if(truckCapacity == 0)\n        {\n            break;\n        }\n    }\n\n    return totalUnits;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// for max_element\nusing namespace std;\n\nint countPairs(vector<int> &deliciousness)\n{\n    const int modulus = 1e9 + 7;\n    unordered_map<int, int> frequencyMap;\n    int maxValue = *max_element(deliciousness.begin(), deliciousness.end());\n    int maxSum = maxValue * 2;\n\n    int pairCount = 0;\n    for (int i = 0; i < deliciousness.size(); ++i)\n    {\n        int currentValue = deliciousness[i];\n        for (int powerOfTwoSum = 1; powerOfTwoSum <= maxSum; powerOfTwoSum <<= 1)\n        {\n            pairCount = (pairCount + frequencyMap[powerOfTwoSum - currentValue]) % modulus;\n        }\n        frequencyMap[currentValue]++;\n    }\n\n    return pairCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countPairs(std::vector<int> &deliciousness)\n{\n    const int modulus= 1e9 + 7;\n    std::unordered_map<int, int> frequencyMap;\n    int maxValue= *std::max_element(deliciousness.begin(), deliciousness.end());\n    int maxSum= maxValue * 2;\n\n    int pairCount= 0;\n    for(int currentValue : deliciousness)\n    {\n        for(int powerOfTwoSum= 1; powerOfTwoSum <= maxSum; powerOfTwoSum <<= 1)\n        {\n            pairCount= (pairCount + frequencyMap[powerOfTwoSum - currentValue]) % modulus;\n        }\n        frequencyMap[currentValue]++;\n    }\n\n    return pairCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &targetArray, vector<int> &sourceArray)\n{\n    unordered_map<int, int> indexMap;\n    for(int index = 0; index < targetArray.size(); ++index)\n    {\n        indexMap[targetArray[index]] = index;\n    }\n\n    vector<int> longestIncreasingSubsequence;\n    for(int i = 0; i < sourceArray.size(); ++i)\n    {\n        int number = sourceArray[i];\n        if(indexMap.count(number))\n        {\n            int position = lower_bound(longestIncreasingSubsequence.begin(), longestIncreasingSubsequence.end(), indexMap[number]) - longestIncreasingSubsequence.begin();\n            if(position == longestIncreasingSubsequence.size())\n            {\n                longestIncreasingSubsequence.push_back(indexMap[number]);\n            }\n            else\n            {\n                longestIncreasingSubsequence[position] = indexMap[number];\n            }\n        }\n    }\n\n    return targetArray.size() - longestIncreasingSubsequence.size();\n}",
    "output": "#include <bits/stdc++.h>\nint minOperations(std::vector<int> &targetArray, std::vector<int> &sourceArray)\n{\n    std::unordered_map<int, int> indexMap;\n    for(int index= 0; index < targetArray.size(); ++index)\n    {\n        indexMap[targetArray[index]]= index;\n    }\n\n    std::vector<int> longestIncreasingSubsequence;\n    for(int number : sourceArray)\n    {\n        if(indexMap.count(number))\n        {\n            int position= std::lower_bound(longestIncreasingSubsequence.begin(), longestIncreasingSubsequence.end(), indexMap[number]) - longestIncreasingSubsequence.begin();\n            if(position == longestIncreasingSubsequence.size())\n            {\n                longestIncreasingSubsequence.push_back(indexMap[number]);\n            }\n            else\n            {\n                longestIncreasingSubsequence[position]= indexMap[number];\n            }\n        }\n    }\n\n    return targetArray.size() - longestIncreasingSubsequence.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint largestAltitude(vector<int> &altitudeGain)\n{\n    int maxAltitude= 0, currentAltitude= 0;\n    for(int index= 0; index < altitudeGain.size(); ++index)\n    {\n        currentAltitude+= altitudeGain[index];\n        maxAltitude= max(maxAltitude, currentAltitude);\n    }\n    return maxAltitude;\n}",
    "output": "#include <bits/stdc++.h>\nint largestAltitude(std::vector<int> &altitudeGain)\n{\n    int maxAltitude= 0, currentAltitude= 0;\n    for(int index= 0; index < altitudeGain.size(); ++index)\n    {\n        currentAltitude+= altitudeGain[index];\n        maxAltitude= std::max(maxAltitude, currentAltitude);\n    }\n    return maxAltitude;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTeachings(int totalUsers, vector<vector<int>> &userLanguages, vector<vector<int>> &userFriendships)\n{\n    unordered_map<int, unordered_set<int>> languageToUsers;\n    unordered_set<int> usersWithoutCommonLanguage;\n\n    for (const auto &friendship : userFriendships)\n    {\n        int userA = friendship[0], userB = friendship[1];\n        bool canCommunicate = false;\n\n        for (int language : userLanguages[userA - 1])\n        {\n            if (userLanguages[userB - 1].find(language) != userLanguages[userB - 1].end())\n            {\n                canCommunicate = true;\n                break;\n            }\n        }\n\n        if (!canCommunicate)\n        {\n            usersWithoutCommonLanguage.insert(userA);\n            usersWithoutCommonLanguage.insert(userB);\n        }\n    }\n\n    int minimumLanguagesToTeach = usersWithoutCommonLanguage.size();\n    for (int lang = 1; lang <= totalUsers; ++lang)\n    {\n        int count = 0;\n        for (auto it = usersWithoutCommonLanguage.begin(); it != usersWithoutCommonLanguage.end(); ++it)\n        {\n            int user = *it;\n            if (userLanguages[user - 1].find(lang) == userLanguages[user - 1].end())\n            {\n                count++;\n            }\n        }\n        minimumLanguagesToTeach = min(minimumLanguagesToTeach, count);\n    }\n\n    return minimumLanguagesToTeach;\n}",
    "output": "#include <bits/stdc++.h>\nint minimumTeachings(int totalUsers, std::vector<std::vector<int>> &userLanguages, std::vector<std::vector<int>> &userFriendships)\n{\n    std::unordered_map<int, std::unordered_set<int>> languageToUsers;\n    std::unordered_set<int> usersWithoutCommonLanguage;\n\n    for(const auto &friendship : userFriendships)\n    {\n        int userA= friendship[0], userB= friendship[1];\n        bool canCommunicate= false;\n\n        for(int language : userLanguages[userA - 1])\n        {\n            if(userLanguages[userB - 1].find(language) != userLanguages[userB - 1].end())\n            {\n                canCommunicate= true;\n                break;\n            }\n        }\n\n        if(!canCommunicate)\n        {\n            usersWithoutCommonLanguage.insert(userA);\n            usersWithoutCommonLanguage.insert(userB);\n        }\n    }\n\n    int minimumLanguagesToTeach= usersWithoutCommonLanguage.size();\n    for(int lang= 1; lang <= totalUsers; ++lang)\n    {\n        int count= 0;\n        for(int user : usersWithoutCommonLanguage)\n        {\n            if(userLanguages[user - 1].find(lang) == userLanguages[user - 1].end())\n            {\n                count++;\n            }\n        }\n        minimumLanguagesToTeach= std::min(minimumLanguagesToTeach, count);\n    }\n\n    return minimumLanguagesToTeach;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> decode(vector<int> &encodedArray)\n{\n    int totalElements = encodedArray.size() + 1;\n    int totalXor = 0;\n    for(int index = 1; index <= totalElements; ++index)\n    {\n        totalXor ^= index;\n    }\n    int encodedXor = 0;\n    for(int index = 1; index < totalElements - 1; index += 2)\n    {\n        encodedXor ^= encodedArray[index];\n    }\n    vector<int> permutation(totalElements);\n    permutation[0] = totalXor ^ encodedXor;\n    for(int index = 1; index < totalElements; ++index)\n    {\n        permutation[index] = permutation[index - 1] ^ encodedArray[index - 1];\n    }\n    return permutation;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> decode(std::vector<int> &encodedArray)\n{\n    int totalElements= encodedArray.size() + 1;\n    int totalXor= 0;\n    for(int index= 1; index <= totalElements; ++index)\n    {\n        totalXor^= index;\n    }\n    int encodedXor= 0;\n    for(int index= 1; index < totalElements - 1; index+= 2)\n    {\n        encodedXor^= encodedArray[index];\n    }\n    std::vector<int> permutation(totalElements);\n    permutation[0]= totalXor ^ encodedXor;\n    for(int index= 1; index < totalElements; ++index)\n    {\n        permutation[index]= permutation[index - 1] ^ encodedArray[index - 1];\n    }\n    return permutation;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo = 1e9 + 7;\n\nvector<int> calculateProductWays(vector<vector<int>> &queries)\n{\n    vector<int> results;\n    for (auto &query : queries)\n    {\n        int numberOfFactors = query[0], targetProduct = query[1];\n\n        vector<int> primeFactorCounts;\n        map<int, int> primeFactorMap;\n        for (int i = 2; i * i <= targetProduct; ++i)\n        {\n            int count = 0;\n            while (targetProduct % i == 0)\n            {\n                count++;\n                targetProduct /= i;\n            }\n            if (count)\n            {\n                primeFactorCounts.push_back(count);\n                primeFactorMap[count]++;\n            }\n        }\n\n        if (targetProduct > 1)\n        {\n            primeFactorMap[targetProduct]++;\n            primeFactorCounts.push_back(1);\n        }\n\n        long long totalWays = 1;\n        for (int j = 0; j < primeFactorCounts.size(); ++j)\n        {\n            int primeCount = primeFactorCounts[j];\n            totalWays = (totalWays * (primeCount * (numberOfFactors - 1) + 1)) % modulo;\n        }\n\n        results.push_back(totalWays);\n    }\n    return results;\n}",
    "output": "#include <bits/stdc++.h>\nconst int modulo= 1e9 + 7;\n\nstd::vector<int> calculateProductWays(std::vector<std::vector<int>> &queries)\n{\n    std::vector<int> results;\n    for(auto &query : queries)\n    {\n        int numberOfFactors= query[0], targetProduct= query[1];\n\n        std::vector<int> primeFactorCounts;\n        std::map<int, int> primeFactorMap;\n        for(int i= 2; i * i <= targetProduct; ++i)\n        {\n            int count= 0;\n            while(targetProduct % i == 0)\n            {\n                count++;\n                targetProduct/= i;\n            }\n            if(count)\n            {\n                primeFactorCounts.push_back(count);\n                primeFactorMap[count]++;\n            }\n        }\n\n        if(targetProduct > 1)\n        {\n            primeFactorMap[targetProduct]++;\n            primeFactorCounts.push_back(1);\n        }\n\n        long long totalWays= 1;\n        for(int primeCount : primeFactorCounts)\n        {\n            totalWays= (totalWays * (primeCount * (numberOfFactors - 1) + 1)) % modulo;\n        }\n\n        results.push_back(totalWays);\n    }\n    return results;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int sumBase(int number, int base)\n{\n    int digitSum= 0;\n    while(number > 0)\n    {\n        digitSum+= number % base;\n        number/= base;\n    }\n    return digitSum;\n}",
    "output": "int sumBase(int number, int base)\n{\n    int digitSum= 0;\n    while(number > 0)\n    {\n        digitSum+= number % base;\n        number/= base;\n    }\n    return digitSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxFrequency(vector<int> &numberList, int allowedIncrement)\n{\n    sort(numberList.begin(), numberList.end());\n    int totalNumbers= numberList.size(), startIndex= 0;\n    long long currentSum= 0;\n    int maximumFrequency= 0;\n\n    for(int endIndex= 0; endIndex < totalNumbers; endIndex++)\n    {\n        currentSum+= numberList[endIndex];\n        while(currentSum + allowedIncrement < static_cast<long long>(numberList[endIndex]) * (endIndex - startIndex + 1))\n        {\n            currentSum-= numberList[startIndex++];\n        }\n        maximumFrequency= max(maximumFrequency, endIndex - startIndex + 1);\n    }\n\n    return maximumFrequency;\n}",
    "output": "#include <bits/stdc++.h>\nint maxFrequency(std::vector<int> &numberList, int allowedIncrement)\n{\n    std::sort(numberList.begin(), numberList.end());\n    int totalNumbers= numberList.size(), startIndex= 0;\n    long long currentSum= 0;\n    int maximumFrequency= 0;\n\n    for(int endIndex= 0; endIndex < totalNumbers; endIndex++)\n    {\n        currentSum+= numberList[endIndex];\n        while(currentSum + allowedIncrement < static_cast<long long>(numberList[endIndex]) * (endIndex - startIndex + 1))\n        {\n            currentSum-= numberList[startIndex++];\n        }\n        maximumFrequency= std::max(maximumFrequency, endIndex - startIndex + 1);\n    }\n\n    return maximumFrequency;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> decode(vector<int> &encodedData, int firstElement)\n{\n    vector<int> decodedArray(encodedData.size() + 1);\n    decodedArray[0] = firstElement;\n    for(int index = 0; index < encodedData.size(); index++)\n    {\n        decodedArray[index + 1] = decodedArray[index] ^ encodedData[index];\n    }\n    return decodedArray;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> decode(std::vector<int> &encodedData, int firstElement)\n{\n    std::vector<int> decodedArray(encodedData.size() + 1);\n    decodedArray[0]= firstElement;\n    for(int index= 0; index < encodedData.size(); index++)\n    {\n        decodedArray[index + 1]= decodedArray[index] ^ encodedData[index];\n    }\n    return decodedArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(int currentNode, vector<int> &visitedNodes, unordered_map<int, vector<int>> &adjacencyList, vector<int> &connectedGroup)\n{\n    if(visitedNodes[currentNode])\n        return;\n    visitedNodes[currentNode]= 1;\n    connectedGroup.push_back(currentNode);\n    for(int i = 0; i < adjacencyList[currentNode].size(); ++i)\n    {\n        int neighbor = adjacencyList[currentNode][i];\n        depthFirstSearch(neighbor, visitedNodes, adjacencyList, connectedGroup);\n    }\n}\n\nint minimumHammingDistance(vector<int> &sourceArray, vector<int> &targetArray, vector<vector<int>> &allowedSwaps)\n{\n    int arraySize= sourceArray.size();\n    unordered_map<int, vector<int>> adjacencyList;\n    for(auto &swapPair : allowedSwaps)\n    {\n        adjacencyList[swapPair[0]].push_back(swapPair[1]);\n        adjacencyList[swapPair[1]].push_back(swapPair[0]);\n    }\n\n    int result= 0;\n    vector<int> visitedNodes(arraySize, 0);\n    for(int index= 0; index < arraySize; ++index)\n    {\n        if(!visitedNodes[index])\n        {\n            vector<int> connectedGroup;\n            depthFirstSearch(index, visitedNodes, adjacencyList, connectedGroup);\n            unordered_map<int, int> countMap;\n\n            for(int i = 0; i < connectedGroup.size(); ++i)\n                countMap[sourceArray[connectedGroup[i]]]++;\n            for(int i = 0; i < connectedGroup.size(); ++i)\n                if(countMap[targetArray[connectedGroup[i]]]-- > 0)\n                    result++;\n        }\n    }\n\n    return arraySize - result;\n}",
    "output": "#include <bits/stdc++.h>\nvoid depthFirstSearch(int currentNode, std::vector<int> &visitedNodes, std::unordered_map<int, std::vector<int>> &adjacencyList, std::vector<int> &connectedGroup)\n{\n    if(visitedNodes[currentNode])\n        return;\n    visitedNodes[currentNode]= 1;\n    connectedGroup.push_back(currentNode);\n    for(int neighbor : adjacencyList[currentNode])\n        depthFirstSearch(neighbor, visitedNodes, adjacencyList, connectedGroup);\n}\n\nint minimumHammingDistance(std::vector<int> &sourceArray, std::vector<int> &targetArray, std::vector<std::vector<int>> &allowedSwaps)\n{\n    int arraySize= sourceArray.size();\n    std::unordered_map<int, std::vector<int>> adjacencyList;\n    for(auto &swapPair : allowedSwaps)\n    {\n        adjacencyList[swapPair[0]].push_back(swapPair[1]);\n        adjacencyList[swapPair[1]].push_back(swapPair[0]);\n    }\n\n    int result= 0;\n    std::vector<int> visitedNodes(arraySize, 0);\n    for(int index= 0; index < arraySize; ++index)\n    {\n        if(!visitedNodes[index])\n        {\n            std::vector<int> connectedGroup;\n            depthFirstSearch(index, visitedNodes, adjacencyList, connectedGroup);\n            std::unordered_map<int, int> countMap;\n\n            for(int node : connectedGroup)\n                countMap[sourceArray[node]]++;\n            for(int node : connectedGroup)\n                if(countMap[targetArray[node]]-- > 0)\n                    result++;\n        }\n    }\n\n    return arraySize - result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring nextPalindrome(string originalNumber)\n{\n    int length= originalNumber.size();\n    string firstHalf= originalNumber.substr(0, (length + 1) / 2);\n    next_permutation(firstHalf.begin(), firstHalf.end());\n\n    if(firstHalf > originalNumber.substr(0, (length + 1) / 2))\n    {\n        string secondHalf= firstHalf;\n        reverse(secondHalf.begin(), secondHalf.end());\n        if(length % 2 == 1)\n            secondHalf= secondHalf.substr(1);\n        return firstHalf + secondHalf;\n    }\n\n    return \"\";\n}",
    "output": "#include <bits/stdc++.h>\nstd::string nextPalindrome(std::string originalNumber)\n{\n    int length = originalNumber.size();\n    std::string firstHalf = originalNumber.substr(0, (length + 1) / 2);\n    std::next_permutation(firstHalf.begin(), firstHalf.end());\n\n    if(firstHalf > originalNumber.substr(0, (length + 1) / 2))\n    {\n        std::string secondHalf = firstHalf;\n        std::reverse(secondHalf.begin(), secondHalf.end());\n        if(length % 2 == 1)\n            secondHalf = secondHalf.substr(1);\n        return firstHalf + secondHalf;\n    }\n\n    return \"\";\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countBalls(int lowLimit, int highLimit)\n{\n    vector<int> boxCounts(46, 0);\n    for(int currentNumber= lowLimit; currentNumber <= highLimit; currentNumber++)\n    {\n        int boxNumberSum= 0;\n        int currentDigit= currentNumber;\n        while(currentDigit)\n        {\n            boxNumberSum+= currentDigit % 10;\n            currentDigit/= 10;\n        }\n        boxCounts[boxNumberSum]++;\n    }\n    return *max_element(boxCounts.begin(), boxCounts.end());\n}",
    "output": "int countBalls(int lowLimit, int highLimit)\n{\n    std::vector<int> boxCounts(46, 0);\n    for(int currentNumber= lowLimit; currentNumber <= highLimit; currentNumber++)\n    {\n        int boxNumberSum= 0;\n        int currentDigit= currentNumber;\n        while(currentDigit)\n        {\n            boxNumberSum+= currentDigit % 10;\n            currentDigit/= 10;\n        }\n        boxCounts[boxNumberSum]++;\n    }\n    return *std::max_element(boxCounts.begin(), boxCounts.end());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint largestSubmatrix(vector<vector<int>> &binaryMatrix)\n{\n    int rowCount= binaryMatrix.size(), columnCount= binaryMatrix[0].size();\n    vector<int> height(columnCount, 0);\n    int maxArea= 0;\n\n    for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n    {\n        for(int columnIndex= 0; columnIndex < columnCount; ++columnIndex)\n        {\n            if(binaryMatrix[rowIndex][columnIndex] == 1)\n                height[columnIndex]++;\n            else\n                height[columnIndex]= 0;\n        }\n        vector<int> sortedHeight(height);\n        sort(sortedHeight.begin(), sortedHeight.end());\n        for(int columnIndex= 0; columnIndex < columnCount; ++columnIndex)\n        {\n            maxArea= max(maxArea, sortedHeight[columnIndex] * (columnCount - columnIndex));\n        }\n    }\n    return maxArea;\n}",
    "output": "#include <bits/stdc++.h>\nint largestSubmatrix(std::vector<std::vector<int>> &binaryMatrix)\n{\n    int rowCount = binaryMatrix.size(), columnCount = binaryMatrix[0].size();\n    std::vector<int> height(columnCount, 0);\n    int maxArea = 0;\n\n    for(int rowIndex = 0; rowIndex < rowCount; ++rowIndex)\n    {\n        for(int columnIndex = 0; columnIndex < columnCount; ++columnIndex)\n        {\n            if(binaryMatrix[rowIndex][columnIndex] == 1)\n                height[columnIndex]++;\n            else\n                height[columnIndex] = 0;\n        }\n        std::vector<int> sortedHeight(height);\n        std::sort(sortedHeight.begin(), sortedHeight.end());\n        for(int columnIndex = 0; columnIndex < columnCount; ++columnIndex)\n        {\n            maxArea = std::max(maxArea, sortedHeight[columnIndex] * (columnCount - columnIndex));\n        }\n    }\n    return maxArea;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maximumElementAfterDecrementingAndRearranging(vector<int> &sortedArray)\n{\n    sort(sortedArray.begin(), sortedArray.end());\n    sortedArray[0]= 1;\n    for(int currentIndex= 1; currentIndex < sortedArray.size(); currentIndex++)\n    {\n        sortedArray[currentIndex]= min(sortedArray[currentIndex], sortedArray[currentIndex - 1] + 1);\n    }\n    return sortedArray[sortedArray.size() - 1];\n}",
    "output": "#include <bits/stdc++.h>\nint maximumElementAfterDecrementingAndRearranging(std::vector<int> &sortedArray)\n{\n    std::sort(sortedArray.begin(), sortedArray.end());\n    sortedArray[0] = 1;\n    for(int currentIndex = 1; currentIndex < sortedArray.size(); currentIndex++)\n    {\n        sortedArray[currentIndex] = std::min(sortedArray[currentIndex], sortedArray[currentIndex - 1] + 1);\n    }\n    return sortedArray[sortedArray.size() - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> closestRoom(vector<vector<int>> &rooms, vector<vector<int>> &queries)\n{\n    sort(rooms.begin(), rooms.end(), [](const vector<int> &a, const vector<int> &b)\n         { return a[1] > b[1]; });\n\n    vector<int> result(queries.size());\n    for(int i = 0; i < queries.size(); ++i)\n    {\n        queries[i].push_back(i);\n    }\n\n    sort(queries.begin(), queries.end(), [](const vector<int> &a, const vector<int> &b)\n         { return a[1] > b[1]; });\n\n    set<int> roomIds;\n    int roomIndex = 0;\n    for(int i = 0; i < queries.size(); ++i)\n    {\n        const auto &query = queries[i];\n        while(roomIndex < rooms.size() && rooms[roomIndex][1] >= query[1])\n        {\n            roomIds.insert(rooms[roomIndex++][0]);\n        }\n        if(roomIds.empty())\n        {\n            result[query[2]] = -1;\n        }\n        else\n        {\n            int closestDifference = numeric_limits<int>::max();\n            int closestRoomId = -1;\n            for(int id : {query[0], \n                          (roomIds.upper_bound(query[0]) != roomIds.end() ? *roomIds.upper_bound(query[0]) : -1), \n                          (roomIds.upper_bound(query[0]) != roomIds.begin() ? *prev(roomIds.upper_bound(query[0])) : -1)})\n            {\n                if(id != -1 && roomIds.count(id))\n                {\n                    int difference = abs(id - query[0]);\n                    if(difference < closestDifference)\n                    {\n                        closestDifference = difference;\n                        closestRoomId = id;\n                    }\n                }\n            }\n            result[query[2]] = closestRoomId;\n        }\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> closestRoom(std::vector<std::vector<int>> &rooms, std::vector<std::vector<int>> &queries)\n{\n    std::sort(rooms.begin(), rooms.end(), [](const std::vector<int> &a, const std::vector<int> &b)\n         { return a[1] > b[1]; });\n\n    std::vector<int> result(queries.size());\n    for(int i= 0; i < queries.size(); ++i)\n    {\n        queries[i].push_back(i);\n    }\n\n    std::sort(queries.begin(), queries.end(), [](const std::vector<int> &a, const std::vector<int> &b)\n         { return a[1] > b[1]; });\n\n    std::set<int> roomIds;\n    int roomIndex= 0;\n    for(const auto &query : queries)\n    {\n        while(roomIndex < rooms.size() && rooms[roomIndex][1] >= query[1])\n        {\n            roomIds.insert(rooms[roomIndex++][0]);\n        }\n        if(roomIds.empty())\n        {\n            result[query[2]]= -1;\n        }\n        else\n        {\n            int closestDifference= std::numeric_limits<int>::max();\n            int closestRoomId= -1;\n            for(int id : {query[0], *roomIds.upper_bound(query[0]), *std::prev(roomIds.upper_bound(query[0]))})\n            {\n                if(roomIds.count(id))\n                {\n                    int difference= std::abs(id - query[0]);\n                    if(difference < closestDifference)\n                    {\n                        closestDifference= difference;\n                        closestRoomId= id;\n                    }\n                }\n            }\n            result[query[2]]= closestRoomId;\n        }\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint sumOfUniqueElements(const vector<int> &numbers)\n{\n    unordered_map<int, int> elementCount;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        elementCount[currentNumber]++;\n    }\n    int uniqueSum = 0;\n    for (auto it = elementCount.begin(); it != elementCount.end(); ++it)\n    {\n        const int element = it->first;\n        const int count = it->second;\n        if (count == 1)\n        {\n            uniqueSum += element;\n        }\n    }\n    return uniqueSum;\n}",
    "output": "int sumOfUniqueElements(const std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> elementCount;\n    for(const int currentNumber : numbers)\n    {\n        elementCount[currentNumber]++;\n    }\n    int uniqueSum= 0;\n    for(const auto &[element, count] : elementCount)\n    {\n        if(count == 1)\n        {\n            uniqueSum+= element;\n        }\n    }\n    return uniqueSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAbsoluteSum(vector<int> &numArray)\n{\n    int maxSum = 0, minSum = 0, maxSoFar = 0, minSoFar = 0;\n    for (int i = 0; i < numArray.size(); ++i)\n    {\n        int currentNum = numArray[i];\n        maxSoFar = max(currentNum, maxSoFar + currentNum);\n        maxSum = max(maxSum, maxSoFar);\n\n        minSoFar = min(currentNum, minSoFar + currentNum);\n        minSum = min(minSum, minSoFar);\n    }\n    return max(maxSum, abs(minSum));\n}",
    "output": "#include <bits/stdc++.h>\nint maxAbsoluteSum(std::vector<int> &numArray)\n{\n    int maxSum= 0, minSum= 0, maxSoFar= 0, minSoFar= 0;\n    for(int currentNum : numArray)\n    {\n        maxSoFar= std::max(currentNum, maxSoFar + currentNum);\n        maxSum= std::max(maxSum, maxSoFar);\n\n        minSoFar= std::min(currentNum, minSoFar + currentNum);\n        minSum= std::min(minSum, minSoFar);\n    }\n    return std::max(maxSum, std::abs(minSum));\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minLengthAfterOperations(const string &inputString)\n{\n    int countA = count(inputString.begin(), inputString.end(), 'a');\n    int countB = count(inputString.begin(), inputString.end(), 'b');\n    int countC = count(inputString.begin(), inputString.end(), 'c');\n\n    if(countA % 2 == countB % 2 && countB % 2 == countC % 2)\n    {\n        return inputString.length() % 2;\n    }\n    return (inputString.length() + 1) % 2;\n}",
    "output": "#include <bits/stdc++.h>\nint minLengthAfterOperations(const std::string &inputString)\n{\n    int countA= std::count(inputString.begin(), inputString.end(), 'a');\n    int countB= std::count(inputString.begin(), inputString.end(), 'b');\n    int countC= std::count(inputString.begin(), inputString.end(), 'c');\n\n    if(countA % 2 == countB % 2 && countB % 2 == countC % 2)\n    {\n        return inputString.length() % 2;\n    }\n    return (inputString.length() + 1) % 2;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool compareEvents(vector<int> &eventA, vector<int> &eventB)\n{\n    return eventA[1] < eventB[1];\n}\n\nint maxValue(vector<vector<int>> &events, int maxEvents)\n{\n    sort(events.begin(), events.end(), compareEvents);\n    int totalEvents= events.size();\n    vector<vector<int>> dynamicProgramming(totalEvents + 1, vector<int>(maxEvents + 1, 0));\n\n    for(int eventIndex= 1; eventIndex <= totalEvents; eventIndex++)\n    {\n        int lastNonConflictingEventIndex= -1;\n        for(int j= eventIndex - 1; j >= 1; j--)\n        {\n            if(events[j - 1][1] < events[eventIndex - 1][0])\n            {\n                lastNonConflictingEventIndex= j;\n                break;\n            }\n        }\n\n        for(int eventCount= 1; eventCount <= maxEvents; eventCount++)\n        {\n            if(lastNonConflictingEventIndex == -1)\n            {\n                dynamicProgramming[eventIndex][eventCount]= max(dynamicProgramming[eventIndex - 1][eventCount], events[eventIndex - 1][2]);\n            }\n            else\n            {\n                dynamicProgramming[eventIndex][eventCount]= max(dynamicProgramming[eventIndex - 1][eventCount], dynamicProgramming[lastNonConflictingEventIndex][eventCount - 1] + events[eventIndex - 1][2]);\n            }\n        }\n    }\n\n    return dynamicProgramming[totalEvents][maxEvents];\n}",
    "output": "#include <bits/stdc++.h>\nbool compareEvents(std::vector<int> &eventA, std::vector<int> &eventB)\n{\n    return eventA[1] < eventB[1];\n}\n\nint maxValue(std::vector<std::vector<int>> &events, int maxEvents)\n{\n    std::sort(events.begin(), events.end(), compareEvents);\n    int totalEvents = events.size();\n    std::vector<std::vector<int>> dynamicProgramming(totalEvents + 1, std::vector<int>(maxEvents + 1, 0));\n\n    for(int eventIndex = 1; eventIndex <= totalEvents; eventIndex++)\n    {\n        int lastNonConflictingEventIndex = -1;\n        for(int j = eventIndex - 1; j >= 1; j--)\n        {\n            if(events[j - 1][1] < events[eventIndex - 1][0])\n            {\n                lastNonConflictingEventIndex = j;\n                break;\n            }\n        }\n\n        for(int eventCount = 1; eventCount <= maxEvents; eventCount++)\n        {\n            if(lastNonConflictingEventIndex == -1)\n            {\n                dynamicProgramming[eventIndex][eventCount] = std::max(dynamicProgramming[eventIndex - 1][eventCount], events[eventIndex - 1][2]);\n            }\n            else\n            {\n                dynamicProgramming[eventIndex][eventCount] = std::max(dynamicProgramming[eventIndex - 1][eventCount], dynamicProgramming[lastNonConflictingEventIndex][eventCount - 1] + events[eventIndex - 1][2]);\n            }\n        }\n    }\n\n    return dynamicProgramming[totalEvents][maxEvents];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> distinctNumbersInSubarrays(vector<int> &inputNumbers, int subarraySize)\n{\n    unordered_map<int, int> numberCounts;\n    vector<int> distinctCountResults;\n    for(int currentIndex= 0; currentIndex < inputNumbers.size(); currentIndex++)\n    {\n        numberCounts[inputNumbers[currentIndex]]++;\n        if(currentIndex >= subarraySize)\n        {\n            numberCounts[inputNumbers[currentIndex - subarraySize]]--;\n            if(numberCounts[inputNumbers[currentIndex - subarraySize]] == 0)\n            {\n                numberCounts.erase(inputNumbers[currentIndex - subarraySize]);\n            }\n        }\n        if(currentIndex >= subarraySize - 1)\n        {\n            distinctCountResults.push_back(numberCounts.size());\n        }\n    }\n    return distinctCountResults;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> distinctNumbersInSubarrays(std::vector<int> &inputNumbers, int subarraySize)\n{\n    std::unordered_map<int, int> numberCounts;\n    std::vector<int> distinctCountResults;\n    for(int currentIndex= 0; currentIndex < inputNumbers.size(); currentIndex++)\n    {\n        numberCounts[inputNumbers[currentIndex]]++;\n        if(currentIndex >= subarraySize)\n        {\n            numberCounts[inputNumbers[currentIndex - subarraySize]]--;\n            if(numberCounts[inputNumbers[currentIndex - subarraySize]] == 0)\n            {\n                numberCounts.erase(inputNumbers[currentIndex - subarraySize]);\n            }\n        }\n        if(currentIndex >= subarraySize - 1)\n        {\n            distinctCountResults.push_back(numberCounts.size());\n        }\n    }\n    return distinctCountResults;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxAliveYear(vector<vector<int>> &birthDeathLogs)\n{\n    vector<int> populationYears(101, 0);\n    for (int i = 0; i < birthDeathLogs.size(); ++i)\n    {\n        vector<int> log = birthDeathLogs[i];\n        populationYears[log[0] - 1950]++;\n        populationYears[log[1] - 1950]--;\n    }\n    int maxPopulation = populationYears[0];\n    int maxYear = 1950;\n    for (int yearIndex = 1; yearIndex < 101; yearIndex++)\n    {\n        populationYears[yearIndex] += populationYears[yearIndex - 1];\n        if (populationYears[yearIndex] > maxPopulation)\n        {\n            maxPopulation = populationYears[yearIndex];\n            maxYear = yearIndex + 1950;\n        }\n    }\n    return maxYear;\n}",
    "output": "#include <bits/stdc++.h>\nint getMaxAliveYear(std::vector<std::vector<int>> &birthDeathLogs)\n{\n    std::vector<int> populationYears(101, 0);\n    for(std::vector<int> log : birthDeathLogs)\n    {\n        populationYears[log[0] - 1950]++;\n        populationYears[log[1] - 1950]--;\n    }\n    int maxPopulation= populationYears[0];\n    int maxYear= 1950;\n    for(int yearIndex= 1; yearIndex < 101; yearIndex++)\n    {\n        populationYears[yearIndex]+= populationYears[yearIndex - 1];\n        if(populationYears[yearIndex] > maxPopulation)\n        {\n            maxPopulation= populationYears[yearIndex];\n            maxYear= yearIndex + 1950;\n        }\n    }\n    return maxYear;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxDistance(vector<int> &firstArray, vector<int> &secondArray)\n{\n    int firstIndex= 0, secondIndex= 0, maximumDistance= 0;\n    while(firstIndex < firstArray.size() && secondIndex < secondArray.size())\n    {\n        if(firstArray[firstIndex] > secondArray[secondIndex])\n        {\n            ++firstIndex;\n        }\n        else\n        {\n            maximumDistance= max(maximumDistance, secondIndex - firstIndex);\n            ++secondIndex;\n        }\n    }\n    return maximumDistance;\n}",
    "output": "#include <bits/stdc++.h>\nint maxDistance(std::vector<int> &firstArray, std::vector<int> &secondArray)\n{\n    int firstIndex= 0, secondIndex= 0, maximumDistance= 0;\n    while(firstIndex < firstArray.size() && secondIndex < secondArray.size())\n    {\n        if(firstArray[firstIndex] > secondArray[secondIndex])\n        {\n            ++firstIndex;\n        }\n        else\n        {\n            maximumDistance= std::max(maximumDistance, secondIndex - firstIndex);\n            ++secondIndex;\n        }\n    }\n    return maximumDistance;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int mod= 1e9 + 7;\n\nint maxSumMinProduct(vector<int> &nums)\n{\n    long long maxProduct= 0;\n    stack<int> indexStack;\n    vector<long long> prefixSum(nums.size() + 1);\n\n    for(int i= 0; i < nums.size(); i++)\n    {\n        prefixSum[i + 1]= prefixSum[i] + nums[i];\n    }\n\n    for(int i= 0; i < nums.size(); i++)\n    {\n        while(!indexStack.empty() && nums[indexStack.top()] > nums[i])\n        {\n            int minValue= nums[indexStack.top()];\n            indexStack.pop();\n            maxProduct= max(maxProduct, minValue * (prefixSum[i] - prefixSum[indexStack.empty() ? 0 : indexStack.top() + 1]));\n        }\n        indexStack.push(i);\n    }\n\n    while(!indexStack.empty())\n    {\n        int minValue= nums[indexStack.top()];\n        indexStack.pop();\n        maxProduct= max(maxProduct, minValue * (prefixSum[nums.size()] - prefixSum[indexStack.empty() ? 0 : indexStack.top() + 1]));\n    }\n\n    return maxProduct % mod;\n}",
    "output": "#include <bits/stdc++.h>\nconstexpr int mod = 1e9 + 7;\n\nint maxSumMinProduct(std::vector<int> &nums)\n{\n    long long maxProduct = 0;\n    std::stack<int> indexStack;\n    std::vector<long long> prefixSum(nums.size() + 1);\n\n    for(int i = 0; i < nums.size(); i++)\n    {\n        prefixSum[i + 1] = prefixSum[i] + nums[i];\n    }\n\n    for(int i = 0; i < nums.size(); i++)\n    {\n        while(!indexStack.empty() && nums[indexStack.top()] > nums[i])\n        {\n            int minValue = nums[indexStack.top()];\n            indexStack.pop();\n            maxProduct = std::max(maxProduct, minValue * (prefixSum[i] - prefixSum[indexStack.empty() ? 0 : indexStack.top() + 1]));\n        }\n        indexStack.push(i);\n    }\n\n    while(!indexStack.empty())\n    {\n        int minValue = nums[indexStack.top()];\n        indexStack.pop();\n        maxProduct = std::max(maxProduct, minValue * (prefixSum[nums.size()] - prefixSum[indexStack.empty() ? 0 : indexStack.top() + 1]));\n    }\n\n    return maxProduct % mod;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint largestPathValue(string colorString, vector<vector<int>> &edges)\n{\n    int nodeCount = colorString.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n    vector<int> inDegrees(nodeCount, 0);\n\n    for (auto &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        inDegrees[edge[1]]++;\n    }\n\n    vector<vector<int>> colorCounts(nodeCount, vector<int>(26, 0));\n    vector<int> processingQueue;\n    for (int i = 0; i < nodeCount; i++)\n    {\n        if (inDegrees[i] == 0)\n        {\n            processingQueue.push_back(i);\n        }\n    }\n\n    int visitedNodes = 0;\n    int maxColorValue = 0;\n\n    while (!processingQueue.empty())\n    {\n        int currentNode = processingQueue.back();\n        processingQueue.pop_back();\n        int currentColor = colorString[currentNode] - 'a';\n        visitedNodes++;\n\n        for (int neighbor : adjacencyList[currentNode])\n        {\n            for (int colorIndex = 0; colorIndex < 26; colorIndex++)\n            {\n                int count = colorCounts[currentNode][colorIndex] + (colorIndex == currentColor);\n                colorCounts[neighbor][colorIndex] = max(colorCounts[neighbor][colorIndex], count);\n                maxColorValue = max(maxColorValue, count);\n            }\n            if (--inDegrees[neighbor] == 0)\n            {\n                processingQueue.push_back(neighbor);\n            }\n        }\n    }\n\n    return visitedNodes == nodeCount ? maxColorValue : -1;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string largestPathValue(std::string colorString, std::vector<std::vector<int>> &edges)\n{\n    int nodeCount= colorString.size();\n    std::vector<std::vector<int>> adjacencyList(nodeCount);\n    std::vector<int> inDegrees(nodeCount, 0);\n\n    for(auto &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        inDegrees[edge[1]]++;\n    }\n\n    std::vector<std::vector<int>> colorCounts(nodeCount, std::vector<int>(26, 0));\n    std::vector<int> processingQueue;\n    for(int i= 0; i < nodeCount; i++)\n    {\n        if(inDegrees[i] == 0)\n        {\n            processingQueue.push_back(i);\n        }\n    }\n\n    int visitedNodes= 0;\n    int maxColorValue= 0;\n\n    while(!processingQueue.empty())\n    {\n        int currentNode= processingQueue.back();\n        processingQueue.pop_back();\n        int currentColor= colorString[currentNode] - 'a';\n        visitedNodes++;\n\n        for(int neighbor : adjacencyList[currentNode])\n        {\n            for(int colorIndex= 0; colorIndex < 26; colorIndex++)\n            {\n                int count= colorCounts[currentNode][colorIndex] + (colorIndex == currentColor);\n                colorCounts[neighbor][colorIndex]= std::max(colorCounts[neighbor][colorIndex], count);\n                maxColorValue= std::max(maxColorValue, count);\n            }\n            if(--inDegrees[neighbor] == 0)\n            {\n                processingQueue.push_back(neighbor);\n            }\n        }\n    }\n\n    return visitedNodes == nodeCount ? maxColorValue : -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring maximumTime(string time)\n{\n    if(time[0] == '?')\n    {\n        time[0]= (time[1] == '?' || time[1] - '0' < 4) ? '2' : '1';\n    }\n    if(time[1] == '?')\n    {\n        time[1]= (time[0] == '2') ? '3' : '9';\n    }\n    if(time[3] == '?')\n    {\n        time[3]= '5';\n    }\n    if(time[4] == '?')\n    {\n        time[4]= '9';\n    }\n    return time;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string maximumTime(std::string time)\n{\n    if(time[0] == '?')\n    {\n        time[0]= (time[1] == '?' || time[1] - '0' < 4) ? '2' : '1';\n    }\n    if(time[1] == '?')\n    {\n        time[1]= (time[0] == '2') ? '3' : '9';\n    }\n    if(time[3] == '?')\n    {\n        time[3]= '5';\n    }\n    if(time[4] == '?')\n    {\n        time[4]= '9';\n    }\n    return time;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperationsToSatisfyConditions(string sourceString, string targetString)\n{\n    int countSame= 0, countLess= 0, countGreater= 0;\n\n    for(size_t index= 0; index < sourceString.length(); ++index)\n    {\n        if(sourceString[index] == targetString[index])\n            countSame++;\n        else if(sourceString[index] < targetString[index])\n            countLess++;\n        else\n            countGreater++;\n    }\n\n    return min({countSame + max(countLess, countGreater), countLess, countGreater});\n}",
    "output": "int minOperationsToSatisfyConditions(std::string sourceString, std::string targetString)\n{\n    int countSame= 0, countLess= 0, countGreater= 0;\n\n    for(size_t index= 0; index < sourceString.length(); ++index)\n    {\n        if(sourceString[index] == targetString[index])\n            countSame++;\n        else if(sourceString[index] < targetString[index])\n            countLess++;\n        else\n            countGreater++;\n    }\n\n    return std::min({countSame + std::max(countLess, countGreater), countLess, countGreater});\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint kthLargestValue(vector<vector<int>> &inputMatrix, int k)\n{\n    int rowCount= inputMatrix.size(), columnCount= inputMatrix[0].size();\n    vector<vector<int>> prefixXOR(rowCount + 1, vector<int>(columnCount + 1, 0));\n    priority_queue<int, vector<int>, greater<int>> minHeap;\n\n    for(int rowIndex= 1; rowIndex <= rowCount; ++rowIndex)\n    {\n        for(int columnIndex= 1; columnIndex <= columnCount; ++columnIndex)\n        {\n            prefixXOR[rowIndex][columnIndex]= inputMatrix[rowIndex - 1][columnIndex - 1] ^ prefixXOR[rowIndex - 1][columnIndex] ^ prefixXOR[rowIndex][columnIndex - 1] ^ prefixXOR[rowIndex - 1][columnIndex - 1];\n            minHeap.push(prefixXOR[rowIndex][columnIndex]);\n            if(minHeap.size() > k)\n            {\n                minHeap.pop();\n            }\n        }\n    }\n    return minHeap.top();\n}",
    "output": "#include <bits/stdc++.h>\nint kthLargestValue(std::vector<std::vector<int>> &inputMatrix, int k)\n{\n    int rowCount= inputMatrix.size(), columnCount= inputMatrix[0].size();\n    std::vector<std::vector<int>> prefixXOR(rowCount + 1, std::vector<int>(columnCount + 1, 0));\n    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;\n\n    for(int rowIndex= 1; rowIndex <= rowCount; ++rowIndex)\n    {\n        for(int columnIndex= 1; columnIndex <= columnCount; ++columnIndex)\n        {\n            prefixXOR[rowIndex][columnIndex]= inputMatrix[rowIndex - 1][columnIndex - 1] ^ prefixXOR[rowIndex - 1][columnIndex] ^ prefixXOR[rowIndex][columnIndex - 1] ^ prefixXOR[rowIndex - 1][columnIndex - 1];\n            minHeap.push(prefixXOR[rowIndex][columnIndex]);\n            if(minHeap.size() > k)\n            {\n                minHeap.pop();\n            }\n        }\n    }\n    return minHeap.top();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int calculateMinBoxesTouchingFloor(int numberOfBoxes)\n{\n    return (numberOfBoxes + 1) / 2;\n}",
    "output": "int calculateMinBoxesTouchingFloor(int numberOfBoxes)\n{\n    return (numberOfBoxes + 1) / 2;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint sumOfFloooredPairs(vector<int> &inputNumbers)\n{\n    const int modulo = 1e9 + 7;\n    int arraySize = inputNumbers.size();\n    int maximumValue = *max_element(inputNumbers.begin(), inputNumbers.end());\n    vector<long long> count(maximumValue + 1, 0);\n\n    for (int number : inputNumbers)\n        count[number]++;\n\n    for (int i = 1; i <= maximumValue; i++)\n        count[i] += count[i - 1];\n\n    long long result = 0;\n    for (int i = 0; i < arraySize; i++)  // Modified to traditional for loop\n    {\n        int number = inputNumbers[i];\n        for (int multiplier = 1, k = 1; k <= maximumValue; multiplier++, k += number)\n        {\n            result += multiplier * (count[min(k + number - 1, maximumValue)] - count[k - 1]);\n            result %= modulo;\n        }\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nint sumOfFloooredPairs(std::vector<int> &inputNumbers)\n{\n    const int modulo= 1e9 + 7;\n    int arraySize= inputNumbers.size();\n    int maximumValue= *std::max_element(inputNumbers.begin(), inputNumbers.end());\n    std::vector<long long> count(maximumValue + 1, 0);\n\n    for(int number : inputNumbers)\n        count[number]++;\n\n    for(int i= 1; i <= maximumValue; i++)\n        count[i]+= count[i - 1];\n\n    long long result= 0;\n    for(int number : inputNumbers)\n    {\n        for(int multiplier= 1, k= 1; k <= maximumValue; multiplier++, k+= number)\n        {\n            result+= multiplier * (count[std::min(k + number - 1, maximumValue)] - count[k - 1]);\n            result%= modulo;\n        }\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint subsetXORSum(vector<int> &numList)\n{\n    int totalXORSum= 0, numCount= numList.size(), maxValue= 1 << numCount;\n    for(int subsetIndex= 1; subsetIndex < maxValue; subsetIndex++)\n    {\n        int xorTotal= 0;\n        for(int elementIndex= 0; elementIndex < numCount; ++elementIndex)\n        {\n            if(subsetIndex & (1 << elementIndex))\n            {\n                xorTotal^= numList[elementIndex];\n            }\n        }\n        totalXORSum+= xorTotal;\n    }\n    return totalXORSum;\n}",
    "output": "#include <bits/stdc++.h>\nint subsetXORSum(std::vector<int> &numList)\n{\n    int totalXORSum= 0, numCount= numList.size(), maxValue= 1 << numCount;\n    for(int subsetIndex= 1; subsetIndex < maxValue; subsetIndex++)\n    {\n        int xorTotal= 0;\n        for(int elementIndex= 0; elementIndex < numCount; ++elementIndex)\n        {\n            if(subsetIndex & (1 << elementIndex))\n            {\n                xorTotal^= numList[elementIndex];\n            }\n        }\n        totalXORSum+= xorTotal;\n    }\n    return totalXORSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minSwaps(string binaryString)\n{\n    int zeroCount = 0, oneCount = 0;\n    for (int index = 0; index < binaryString.length(); index++)\n    {\n        char character = binaryString[index];\n        (character == '0') ? zeroCount++ : oneCount++;\n    }\n\n    if (abs(zeroCount - oneCount) > 1)\n    {\n        return -1;\n    }\n\n    int evenIndexSwaps = 0, oddIndexSwaps = 0;\n    for (int index = 0; index < binaryString.length(); index++)\n    {\n        if (index % 2 == 0 && binaryString[index] != '0')\n        {\n            evenIndexSwaps++;\n        }\n        if (index % 2 == 1 && binaryString[index] != '1')\n        {\n            evenIndexSwaps++;\n        }\n    }\n    evenIndexSwaps = evenIndexSwaps / 2;\n\n    for (int index = 0; index < binaryString.length(); index++)\n    {\n        if (index % 2 == 0 && binaryString[index] != '1')\n        {\n            oddIndexSwaps++;\n        }\n        if (index % 2 == 1 && binaryString[index] != '0')\n        {\n            oddIndexSwaps++;\n        }\n    }\n    oddIndexSwaps = oddIndexSwaps / 2;\n\n    if (zeroCount == oneCount)\n    {\n        return min(evenIndexSwaps, oddIndexSwaps);\n    }\n    return (zeroCount > oneCount) ? oddIndexSwaps : evenIndexSwaps;\n}",
    "output": "#include <bits/stdc++.h>\nint minSwaps(std::string binaryString)\n{\n    int zeroCount= 0, oneCount= 0;\n    for(char character : binaryString)\n    {\n        (character == '0') ? zeroCount++ : oneCount++;\n    }\n\n    if(std::abs(zeroCount - oneCount) > 1)\n    {\n        return -1;\n    }\n\n    int evenIndexSwaps= 0, oddIndexSwaps= 0;\n    for(int index= 0; index < binaryString.length(); index++)\n    {\n        if(index % 2 == 0 && binaryString[index] != '0')\n        {\n            evenIndexSwaps++;\n        }\n        if(index % 2 == 1 && binaryString[index] != '1')\n        {\n            evenIndexSwaps++;\n        }\n    }\n    evenIndexSwaps= evenIndexSwaps / 2;\n\n    for(int index= 0; index < binaryString.length(); index++)\n    {\n        if(index % 2 == 0 && binaryString[index] != '1')\n        {\n            oddIndexSwaps++;\n        }\n        if(index % 2 == 1 && binaryString[index] != '0')\n        {\n            oddIndexSwaps++;\n        }\n    }\n    oddIndexSwaps= oddIndexSwaps / 2;\n\n    if(zeroCount == oneCount)\n    {\n        return std::min(evenIndexSwaps, oddIndexSwaps);\n    }\n    return (zeroCount > oneCount) ? oddIndexSwaps : evenIndexSwaps;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass FindSumPairs\n{\n  public:\n    vector<int> firstArray;\n    vector<int> secondArray;\n    unordered_map<int, int> secondArrayMap;\n\n    FindSumPairs(vector<int> &nums1, vector<int> &nums2) : firstArray(nums1), secondArray(nums2)\n    {\n        for (int i = 0; i < secondArray.size(); ++i)\n        {\n            secondArrayMap[secondArray[i]]++;\n        }\n    }\n\n    void add(int index, int value)\n    {\n        secondArrayMap[secondArray[index]]--;\n        secondArray[index] += value;\n        secondArrayMap[secondArray[index]]++;\n    }\n\n    int count(int targetSum)\n    {\n        int pairCount = 0;\n        for (int i = 0; i < firstArray.size(); ++i)\n        {\n            int num = firstArray[i];\n            pairCount += secondArrayMap[targetSum - num];\n        }\n        return pairCount;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass FindSumPairs\n{\n  public:\n    std::vector<int> firstArray;\n    std::vector<int> secondArray;\n    std::unordered_map<int, int> secondArrayMap;\n\n    FindSumPairs(std::vector<int> &nums1, std::vector<int> &nums2) : firstArray(nums1), secondArray(nums2)\n    {\n        for(int num : secondArray)\n        {\n            secondArrayMap[num]++;\n        }\n    }\n\n    void add(int index, int value)\n    {\n        secondArrayMap[secondArray[index]]--;\n        secondArray[index]+= value;\n        secondArrayMap[secondArray[index]]++;\n    }\n\n    int count(int targetSum)\n    {\n        int pairCount= 0;\n        for(int num : firstArray)\n        {\n            pairCount+= secondArrayMap[targetSum - num];\n        }\n        return pairCount;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> restoreArray(vector<vector<int>> &adjacentPairs)\n{\n    unordered_map<int, vector<int>> graph;\n    for (int i = 0; i < adjacentPairs.size(); ++i)\n    {\n        graph[adjacentPairs[i][0]].push_back(adjacentPairs[i][1]);\n        graph[adjacentPairs[i][1]].push_back(adjacentPairs[i][0]);\n    }\n    vector<int> restoredNumbers;\n    for (auto it = graph.begin(); it != graph.end(); ++it)\n    {\n        if (it->second.size() == 1)\n        {\n            restoredNumbers.push_back(it->first);\n            break;\n        }\n    }\n    restoredNumbers.push_back(graph[restoredNumbers[0]][0]);\n    for (int index = 2; index < graph.size(); ++index)\n    {\n        int neighborsCount = graph[restoredNumbers.back()].size();\n        restoredNumbers.push_back(restoredNumbers.back() == graph[restoredNumbers[index - 2]][0] ? graph[restoredNumbers[index - 2]][1] : graph[restoredNumbers[index - 2]][0]);\n    }\n    return restoredNumbers;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> restoreArray(std::vector<std::vector<int>> &adjacentPairs)\n{\n    std::unordered_map<int, std::vector<int>> graph;\n    for(const auto &pair : adjacentPairs)\n    {\n        graph[pair[0]].push_back(pair[1]);\n        graph[pair[1]].push_back(pair[0]);\n    }\n    std::vector<int> restoredNumbers;\n    for(const auto &entry : graph)\n    {\n        if(entry.second.size() == 1)\n        {\n            restoredNumbers.push_back(entry.first);\n            break;\n        }\n    }\n    restoredNumbers.push_back(graph[restoredNumbers[0]][0]);\n    for(int index= 2; index < graph.size(); ++index)\n    {\n        int neighborsCount= graph[restoredNumbers.back()].size();\n        restoredNumbers.push_back(restoredNumbers.back() == graph[restoredNumbers[index - 2]][0] ? graph[restoredNumbers[index - 2]][1] : graph[restoredNumbers[index - 2]][0]);\n    }\n    return restoredNumbers;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> findRleProduct(vector<vector<int>> &encodedRle1, vector<vector<int>> &encodedRle2)\n{\n    vector<vector<int>> rleProductResult;\n    int indexRle1= 0, indexRle2= 0, countRle1= 0, countRle2= 0;\n\n    while(indexRle1 < encodedRle1.size() && indexRle2 < encodedRle2.size())\n    {\n        int productValue= encodedRle1[indexRle1][0] * encodedRle2[indexRle2][0];\n        int count= min(encodedRle1[indexRle1][1] - countRle1, encodedRle2[indexRle2][1] - countRle2);\n        countRle1+= count;\n        countRle2+= count;\n\n        if(!rleProductResult.empty() && rleProductResult.back()[0] == productValue)\n        {\n            rleProductResult.back()[1]+= count;\n        }\n        else\n        {\n            rleProductResult.push_back({productValue, count});\n        }\n\n        if(countRle1 == encodedRle1[indexRle1][1])\n        {\n            indexRle1++;\n            countRle1= 0;\n        }\n\n        if(countRle2 == encodedRle2[indexRle2][1])\n        {\n            indexRle2++;\n            countRle2= 0;\n        }\n    }\n\n    return rleProductResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> findRleProduct(std::vector<std::vector<int>> &encodedRle1, std::vector<std::vector<int>> &encodedRle2)\n{\n    std::vector<std::vector<int>> rleProductResult;\n    int indexRle1= 0, indexRle2= 0, countRle1= 0, countRle2= 0;\n\n    while(indexRle1 < encodedRle1.size() && indexRle2 < encodedRle2.size())\n    {\n        int productValue= encodedRle1[indexRle1][0] * encodedRle2[indexRle2][0];\n        int count= std::min(encodedRle1[indexRle1][1] - countRle1, encodedRle2[indexRle2][1] - countRle2);\n        countRle1+= count;\n        countRle2+= count;\n\n        if(!rleProductResult.empty() && rleProductResult.back()[0] == productValue)\n        {\n            rleProductResult.back()[1]+= count;\n        }\n        else\n        {\n            rleProductResult.push_back({productValue, count});\n        }\n\n        if(countRle1 == encodedRle1[indexRle1][1])\n        {\n            indexRle1++;\n            countRle1= 0;\n        }\n\n        if(countRle2 == encodedRle2[indexRle2][1])\n        {\n            indexRle2++;\n            countRle2= 0;\n        }\n    }\n\n    return rleProductResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool checkZeroOnes(string binaryString)\n{\n    int maxConsecutiveOnes = 0, maxConsecutiveZeros = 0, currentOnesCount = 0, currentZerosCount = 0;\n    for (int i = 0; i < binaryString.size(); ++i)\n    {\n        char currentCharacter = binaryString[i];\n        if (currentCharacter == '1')\n        {\n            currentOnesCount++;\n            currentZerosCount = 0;\n        }\n        else\n        {\n            currentZerosCount++;\n            currentOnesCount = 0;\n        }\n        maxConsecutiveOnes = max(maxConsecutiveOnes, currentOnesCount);\n        maxConsecutiveZeros = max(maxConsecutiveZeros, currentZerosCount);\n    }\n    return maxConsecutiveOnes > maxConsecutiveZeros;\n}",
    "output": "#include <bits/stdc++.h>\nbool checkZeroOnes(std::string binaryString)\n{\n    int maxConsecutiveOnes= 0, maxConsecutiveZeros= 0, currentOnesCount= 0, currentZerosCount= 0;\n    for(char currentCharacter : binaryString)\n    {\n        if(currentCharacter == '1')\n        {\n            currentOnesCount++;\n            currentZerosCount= 0;\n        }\n        else\n        {\n            currentZerosCount++;\n            currentOnesCount= 0;\n        }\n        maxConsecutiveOnes= std::max(maxConsecutiveOnes, currentOnesCount);\n        maxConsecutiveZeros= std::max(maxConsecutiveZeros, currentZerosCount);\n    }\n    return maxConsecutiveOnes > maxConsecutiveZeros;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumSpeed(vector<int> &distances, double totalTime)\n{\n    double maxAllowedTime= totalTime - distances.size() + 1;\n    double lowerBound= 1.0, upperBound= 1e7;\n    while(upperBound - lowerBound >= 1e-9)\n    {\n        double midSpeed= (lowerBound + upperBound) / 2;\n        double timeSpent= 0.0;\n        for(int index= 0; index < distances.size(); ++index)\n        {\n            timeSpent+= ceil(distances[index] / midSpeed) - (index == distances.size() - 1 ? 0 : 1);\n        }\n        if(timeSpent <= maxAllowedTime)\n        {\n            upperBound= midSpeed;\n        }\n        else\n        {\n            lowerBound= midSpeed;\n        }\n    }\n    return (lowerBound <= 1e7) ? int(ceil(lowerBound)) : -1;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMinimumSpeed(std::vector<int> &distances, double totalTime)\n{\n    double maxAllowedTime= totalTime - distances.size() + 1;\n    double lowerBound= 1.0, upperBound= 1e7;\n    while(upperBound - lowerBound >= 1e-9)\n    {\n        double midSpeed= (lowerBound + upperBound) / 2;\n        double timeSpent= 0.0;\n        for(int index= 0; index < distances.size(); ++index)\n        {\n            timeSpent+= std::ceil(distances[index] / midSpeed) - (index == distances.size() - 1 ? 0 : 1);\n        }\n        if(timeSpent <= maxAllowedTime)\n        {\n            upperBound= midSpeed;\n        }\n        else\n        {\n            lowerBound= midSpeed;\n        }\n    }\n    return (lowerBound <= 1e7) ? int(std::ceil(lowerBound)) : -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPalindrome(const string &inputString, int leftIndex, int rightIndex)\n{\n    while(leftIndex < rightIndex)\n    {\n        if(inputString[leftIndex++] != inputString[rightIndex--])\n            return false;\n    }\n    return true;\n}\n\nbool checkPartitioning(string inputString)\n{\n    int stringLength = inputString.length();\n    for(int firstIndex = 0; firstIndex < stringLength - 2; ++firstIndex)\n    {\n        if(isPalindrome(inputString, 0, firstIndex))\n        {\n            for(int secondIndex = firstIndex + 1; secondIndex < stringLength - 1; ++secondIndex)\n            {\n                if(isPalindrome(inputString, firstIndex + 1, secondIndex) && isPalindrome(inputString, secondIndex + 1, stringLength - 1))\n                {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}",
    "output": "bool isPalindrome(const std::string &inputString, int leftIndex, int rightIndex)\n{\n    while(leftIndex < rightIndex)\n    {\n        if(inputString[leftIndex++] != inputString[rightIndex--])\n            return false;\n    }\n    return true;\n}\n\nbool checkPartitioning(std::string inputString)\n{\n    int stringLength= inputString.length();\n    for(int firstIndex= 0; firstIndex < stringLength - 2; ++firstIndex)\n    {\n        if(isPalindrome(inputString, 0, firstIndex))\n        {\n            for(int secondIndex= firstIndex + 1; secondIndex < stringLength - 1; ++secondIndex)\n            {\n                if(isPalindrome(inputString, firstIndex + 1, secondIndex) && isPalindrome(inputString, secondIndex + 1, stringLength - 1))\n                {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<bool> canEat(vector<int> &candiesCount, vector<vector<int>> &queries)\n{\n    vector<long long> prefixSum(candiesCount.size() + 1);\n    for(int index= 0; index < candiesCount.size(); ++index)\n    {\n        prefixSum[index + 1]= prefixSum[index] + candiesCount[index];\n    }\n\n    vector<bool> canEatResults(queries.size());\n    for(int queryIndex= 0; queryIndex < queries.size(); ++queryIndex)\n    {\n        int favoriteCandyType= queries[queryIndex][0], favoriteDay= queries[queryIndex][1], dailyLimit= queries[queryIndex][2];\n        long long x1= favoriteDay + 1;\n        long long y1= (favoriteDay + 1LL) * dailyLimit;\n\n        long long x2= prefixSum[favoriteCandyType] + 1;\n        long long y2= prefixSum[favoriteCandyType + 1];\n\n        canEatResults[queryIndex]= !(x1 > y2 || y1 < x2);\n    }\n\n    return canEatResults;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<bool> canEat(std::vector<int> &candiesCount, std::vector<std::vector<int>> &queries)\n{\n    std::vector<long long> prefixSum(candiesCount.size() + 1);\n    for(int index= 0; index < candiesCount.size(); ++index)\n    {\n        prefixSum[index + 1]= prefixSum[index] + candiesCount[index];\n    }\n\n    std::vector<bool> canEatResults(queries.size());\n    for(int queryIndex= 0; queryIndex < queries.size(); ++queryIndex)\n    {\n        int favoriteCandyType= queries[queryIndex][0], favoriteDay= queries[queryIndex][1], dailyLimit= queries[queryIndex][2];\n        long long x1= favoriteDay + 1;\n        long long y1= (favoriteDay + 1LL) * dailyLimit;\n\n        long long x2= prefixSum[favoriteCandyType] + 1;\n        long long y2= prefixSum[favoriteCandyType + 1];\n\n        canEatResults[queryIndex]= !(x1 > y2 || y1 < x2);\n    }\n\n    return canEatResults;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canChoose(const vector<vector<int>> &groups, const vector<int> &numbers)\n{\n    int groupIndex = 0, numberIndex = 0;\n    while(groupIndex < groups.size() && numberIndex + groups[groupIndex].size() <= numbers.size())\n    {\n        bool isMatch = true;\n        for(int i = 0; i < groups[groupIndex].size(); ++i)\n        {\n            if(groups[groupIndex][i] != numbers[numberIndex + i])\n            {\n                isMatch = false;\n                break;\n            }\n        }\n        if(isMatch)\n        {\n            numberIndex += groups[groupIndex].size();\n            groupIndex++;\n        }\n        else\n        {\n            numberIndex++;\n        }\n    }\n    return groupIndex == groups.size();\n}",
    "output": "#include <bits/stdc++.h>\nbool canChoose(const std::vector<std::vector<int>> &groups, const std::vector<int> &numbers)\n{\n    int groupIndex= 0, numberIndex= 0;\n    while(groupIndex < groups.size() && numberIndex + groups[groupIndex].size() <= numbers.size())\n    {\n        bool isMatch= true;\n        for(int i= 0; i < groups[groupIndex].size(); ++i)\n        {\n            if(groups[groupIndex][i] != numbers[numberIndex + i])\n            {\n                isMatch= false;\n                break;\n            }\n        }\n        if(isMatch)\n        {\n            numberIndex+= groups[groupIndex].size();\n            groupIndex++;\n        }\n        else\n        {\n            numberIndex++;\n        }\n    }\n    return groupIndex == groups.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> highestIsland(vector<vector<int>> &isWater)\n{\n    int numRows= isWater.size();\n    int numCols= isWater[0].size();\n    vector<vector<int>> islandHeight(numRows, vector<int>(numCols, -1));\n    queue<pair<int, int>> positionQueue;\n\n    for(int row= 0; row < numRows; row++)\n    {\n        for(int col= 0; col < numCols; col++)\n        {\n            if(isWater[row][col] == 1)\n            {\n                islandHeight[row][col]= 0;\n                positionQueue.push({row, col});\n            }\n        }\n    }\n\n    vector<int> deltaX= {-1, 0, 1, 0};\n    vector<int> deltaY= {0, 1, 0, -1};\n\n    while(!positionQueue.empty())\n    {\n        int currentX= positionQueue.front().first;\n        int currentY= positionQueue.front().second;\n        positionQueue.pop();\n\n        for(int direction= 0; direction < 4; direction++)\n        {\n            int newX= currentX + deltaX[direction];\n            int newY= currentY + deltaY[direction];\n\n            if(newX >= 0 && newX < numRows && newY >= 0 && newY < numCols && islandHeight[newX][newY] == -1)\n            {\n                islandHeight[newX][newY]= islandHeight[currentX][currentY] + 1;\n                positionQueue.push({newX, newY});\n            }\n        }\n    }\n\n    return islandHeight;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> highestIsland(std::vector<std::vector<int>> &isWater)\n{\n    int numRows = isWater.size();\n    int numCols = isWater[0].size();\n    std::vector<std::vector<int>> islandHeight(numRows, std::vector<int>(numCols, -1));\n    std::queue<std::pair<int, int>> positionQueue;\n\n    for(int row = 0; row < numRows; row++)\n    {\n        for(int col = 0; col < numCols; col++)\n        {\n            if(isWater[row][col] == 1)\n            {\n                islandHeight[row][col] = 0;\n                positionQueue.push({row, col});\n            }\n        }\n    }\n\n    std::vector<int> deltaX = {-1, 0, 1, 0};\n    std::vector<int> deltaY = {0, 1, 0, -1};\n\n    while(!positionQueue.empty())\n    {\n        int currentX = positionQueue.front().first;\n        int currentY = positionQueue.front().second;\n        positionQueue.pop();\n\n        for(int direction = 0; direction < 4; direction++)\n        {\n            int newX = currentX + deltaX[direction];\n            int newY = currentY + deltaY[direction];\n\n            if(newX >= 0 && newX < numRows && newY >= 0 && newY < numCols && islandHeight[newX][newY] == -1)\n            {\n                islandHeight[newX][newY] = islandHeight[currentX][currentY] + 1;\n                positionQueue.push({newX, newY});\n            }\n        }\n    }\n\n    return islandHeight;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minPairSum(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end());\n    int maxSum= 0;\n    for(int index= 0; index < numbers.size() / 2; ++index)\n        maxSum= max(maxSum, numbers[index] + numbers[numbers.size() - 1 - index]);\n    return maxSum;\n}",
    "output": "#include <bits/stdc++.h>\nint minPairSum(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end());\n    int maxSum= 0;\n    for(int index= 0; index < numbers.size() / 2; ++index)\n        maxSum= std::max(maxSum, numbers[index] + numbers[numbers.size() - 1 - index]);\n    return maxSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool check(vector<int> &numbers)\n{\n    int decreaseCount= 0;\n    for(int index= 1; index < numbers.size(); ++index)\n    {\n        if(numbers[index] < numbers[index - 1])\n        {\n            ++decreaseCount;\n        }\n        if(decreaseCount > 1)\n        {\n            return false;\n        }\n    }\n    return (decreaseCount == 1) || (numbers.front() >= numbers.back());\n}",
    "output": "#include <bits/stdc++.h>\nbool check(std::vector<int> &numbers)\n{\n    int decreaseCount= 0;\n    for(int index= 1; index < numbers.size(); ++index)\n    {\n        if(numbers[index] < numbers[index - 1])\n        {\n            ++decreaseCount;\n        }\n        if(decreaseCount > 1)\n        {\n            return false;\n        }\n    }\n    return (decreaseCount == 1) || (numbers.front() >= numbers.back());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxScore(int scoreA, int scoreB, int scoreC)\n{\n    return (scoreA + scoreB + scoreC - max({scoreA, scoreB, scoreC})) / 2;\n}",
    "output": "int calculateMaxScore(int scoreA, int scoreB, int scoreC)\n{\n    return (scoreA + scoreB + scoreC - std::max({scoreA, scoreB, scoreC})) / 2;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestMerge(string firstWord, string secondWord)\n{\n    string mergedString = \"\";\n    while (!firstWord.empty() || !secondWord.empty())\n    {\n        if (firstWord > secondWord)\n        {\n            mergedString += firstWord[0];\n            firstWord = firstWord.substr(1);\n        }\n        else\n        {\n            mergedString += secondWord[0];\n            secondWord = secondWord.substr(1);\n        }\n    }\n    return mergedString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string largestMerge(std::string firstWord, std::string secondWord)\n{\n    std::string mergedString= \"\";\n    while(!firstWord.empty() || !secondWord.empty())\n    {\n        if(firstWord > secondWord)\n        {\n            mergedString+= firstWord[0];\n            firstWord= firstWord.substr(1);\n        }\n        else\n        {\n            mergedString+= secondWord[0];\n            secondWord= secondWord.substr(1);\n        }\n    }\n    return mergedString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minAbsoluteDifference(vector<int> &numbers, int target)\n{\n    int numberCount = numbers.size();\n    vector<int> leftHalf(numbers.begin(), numbers.begin() + numberCount / 2);\n    vector<int> rightHalf(numbers.begin() + numberCount / 2, numbers.end());\n    set<int> possibleSums;\n\n    for(int mask = 0; mask < (1 << leftHalf.size()); ++mask)\n    {\n        int currentSum = 0;\n        for(int index = 0; index < leftHalf.size(); ++index)\n        {\n            if(mask & (1 << index))\n            {\n                currentSum += leftHalf[index];\n            }\n        }\n        possibleSums.insert(currentSum);\n    }\n\n    int minimumDifference = abs(target);\n\n    for(int mask = 0; mask < (1 << rightHalf.size()); ++mask)\n    {\n        int currentSum = 0;\n        for(int index = 0; index < rightHalf.size(); ++index)\n        {\n            if(mask & (1 << index))\n            {\n                currentSum += rightHalf[index];\n            }\n        }\n        auto iterator = possibleSums.lower_bound(target - currentSum);\n        if(iterator != possibleSums.end())\n        {\n            minimumDifference = min(minimumDifference, abs((*iterator) + currentSum - target));\n        }\n        if(iterator != possibleSums.begin())\n        {\n            minimumDifference = min(minimumDifference, abs((*prev(iterator)) + currentSum - target));\n        }\n    }\n\n    return minimumDifference;\n}",
    "output": "#include <bits/stdc++.h>\nint minAbsoluteDifference(std::vector<int> &numbers, int target)\n{\n    int numberCount= numbers.size();\n    std::vector<int> leftHalf(numbers.begin(), numbers.begin() + numberCount / 2);\n    std::vector<int> rightHalf(numbers.begin() + numberCount / 2, numbers.end());\n    std::set<int> possibleSums;\n\n    for(int mask= 0; mask < (1 << leftHalf.size()); ++mask)\n    {\n        int currentSum= 0;\n        for(int index= 0; index < leftHalf.size(); ++index)\n        {\n            if(mask & (1 << index))\n            {\n                currentSum+= leftHalf[index];\n            }\n        }\n        possibleSums.insert(currentSum);\n    }\n\n    int minimumDifference= std::abs(target);\n\n    for(int mask= 0; mask < (1 << rightHalf.size()); ++mask)\n    {\n        int currentSum= 0;\n        for(int index= 0; index < rightHalf.size(); ++index)\n        {\n            if(mask & (1 << index))\n            {\n                currentSum+= rightHalf[index];\n            }\n        }\n        auto iterator= possibleSums.lower_bound(target - currentSum);\n        if(iterator != possibleSums.end())\n        {\n            minimumDifference= std::min(minimumDifference, std::abs((*iterator) + currentSum - target));\n        }\n        if(iterator != possibleSums.begin())\n        {\n            minimumDifference= std::min(minimumDifference, std::abs((*std::prev(iterator)) + currentSum - target));\n        }\n    }\n\n    return minimumDifference;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> assignTasks(vector<int> &serverWeights, vector<int> &taskDurations)\n{\n    vector<int> taskAssignments(taskDurations.size());\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> availableServers;\n    priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> occupiedServers;\n\n    for(int serverIndex= 0; serverIndex < serverWeights.size(); ++serverIndex)\n    {\n        availableServers.push({serverWeights[serverIndex], serverIndex});\n    }\n\n    for(int currentTime= 0, taskIndex= 0; taskIndex < taskDurations.size(); ++currentTime)\n    {\n        while(!occupiedServers.empty() && occupiedServers.top().first == currentTime)\n        {\n            auto [serverWeight, serverIndex]= occupiedServers.top().second;\n            availableServers.push({serverWeight, serverIndex});\n            occupiedServers.pop();\n        }\n        if(taskIndex < taskDurations.size() && !availableServers.empty())\n        {\n            taskAssignments[taskIndex]= availableServers.top().second;\n            occupiedServers.push({currentTime + taskDurations[taskIndex], {serverWeights[taskAssignments[taskIndex]], taskAssignments[taskIndex]}});\n            availableServers.pop();\n            ++taskIndex;\n        }\n    }\n\n    return taskAssignments;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> assignTasks(std::vector<int> &serverWeights, std::vector<int> &taskDurations)\n{\n    std::vector<int> taskAssignments(taskDurations.size());\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> availableServers;\n    std::priority_queue<std::pair<int, std::pair<int, int>>, std::vector<std::pair<int, std::pair<int, int>>>, std::greater<std::pair<int, std::pair<int, int>>>> occupiedServers;\n\n    for(int serverIndex= 0; serverIndex < serverWeights.size(); ++serverIndex)\n    {\n        availableServers.push({serverWeights[serverIndex], serverIndex});\n    }\n\n    for(int currentTime= 0, taskIndex= 0; taskIndex < taskDurations.size(); ++currentTime)\n    {\n        while(!occupiedServers.empty() && occupiedServers.top().first == currentTime)\n        {\n            auto [serverWeight, serverIndex]= occupiedServers.top().second;\n            availableServers.push({serverWeight, serverIndex});\n            occupiedServers.pop();\n        }\n        if(taskIndex < taskDurations.size() && !availableServers.empty())\n        {\n            taskAssignments[taskIndex]= availableServers.top().second;\n            occupiedServers.push({currentTime + taskDurations[taskIndex], {serverWeights[taskAssignments[taskIndex]], taskAssignments[taskIndex]}});\n            availableServers.pop();\n            ++taskIndex;\n        }\n    }\n\n    return taskAssignments;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minSkips(vector<int> &distance, int speed, int hoursBefore)\n{\n    int numberOfSegments= distance.size();\n    vector<vector<double>> dynamicProgramming(numberOfSegments + 1, vector<double>(numberOfSegments + 1, 1e9));\n    dynamicProgramming[0][0]= 0;\n\n    for(int segmentIndex= 0; segmentIndex < numberOfSegments; ++segmentIndex)\n    {\n        for(int skips= -1; skips < segmentIndex; ++skips)\n        {\n            double time= distance[segmentIndex] / double(speed) + (skips != -1);\n            dynamicProgramming[segmentIndex + 1][skips + 1]= min(dynamicProgramming[segmentIndex + 1][skips + 1], dynamicProgramming[segmentIndex][skips] + time);\n            double skippedTime= ceil(dynamicProgramming[segmentIndex][skips] + distance[segmentIndex] / double(speed)) - dynamicProgramming[segmentIndex][skips];\n            dynamicProgramming[segmentIndex + 1][skips]= min(dynamicProgramming[segmentIndex + 1][skips], dynamicProgramming[segmentIndex][skips] + skippedTime);\n        }\n    }\n\n    for(int i= 0; i <= numberOfSegments; ++i)\n    {\n        if(dynamicProgramming[numberOfSegments][i] <= hoursBefore)\n            return i;\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint minSkips(std::vector<int> &distance, int speed, int hoursBefore)\n{\n    int numberOfSegments = distance.size();\n    std::vector<std::vector<double>> dynamicProgramming(numberOfSegments + 1, std::vector<double>(numberOfSegments + 1, 1e9));\n    dynamicProgramming[0][0] = 0;\n\n    for(int segmentIndex = 0; segmentIndex < numberOfSegments; ++segmentIndex)\n    {\n        for(int skips = -1; skips < segmentIndex; ++skips)\n        {\n            double time = distance[segmentIndex] / double(speed) + (skips != -1);\n            dynamicProgramming[segmentIndex + 1][skips + 1] = std::min(dynamicProgramming[segmentIndex + 1][skips + 1], dynamicProgramming[segmentIndex][skips] + time);\n            double skippedTime = std::ceil(dynamicProgramming[segmentIndex][skips] + distance[segmentIndex] / double(speed)) - dynamicProgramming[segmentIndex][skips];\n            dynamicProgramming[segmentIndex + 1][skips] = std::min(dynamicProgramming[segmentIndex + 1][skips], dynamicProgramming[segmentIndex][skips] + skippedTime);\n        }\n    }\n\n    for(int i = 0; i <= numberOfSegments; ++i)\n    {\n        if(dynamicProgramming[numberOfSegments][i] <= hoursBefore)\n            return i;\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperationsToAlternate(const string &inputString)\n{\n    int evenCountZeros= 0, oddCountZeros= 0;\n    for(size_t index= 0; index < inputString.size(); ++index)\n    {\n        if(index % 2 == 0)\n        {\n            if(inputString[index] == '0')\n                evenCountZeros++;\n            else\n                oddCountZeros++;\n        }\n        else\n        {\n            if(inputString[index] == '0')\n                oddCountZeros++;\n            else\n                evenCountZeros++;\n        }\n    }\n    return min(evenCountZeros, oddCountZeros);\n}",
    "output": "int minOperationsToAlternate(const std::string &inputString)\n{\n    int evenCountZeros= 0, oddCountZeros= 0;\n    for(std::size_t index= 0; index < inputString.size(); ++index)\n    {\n        if(index % 2 == 0)\n        {\n            if(inputString[index] == '0')\n                evenCountZeros++;\n            else\n                oddCountZeros++;\n        }\n        else\n        {\n            if(inputString[index] == '0')\n                oddCountZeros++;\n            else\n                evenCountZeros++;\n        }\n    }\n    return std::min(evenCountZeros, oddCountZeros);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countHomogenous(string inputString)\n{\n    int totalHomogenousCount= 0, consecutiveCount= 1, modulo= 1e9 + 7;\n    for(int currentIndex= 1; currentIndex < inputString.size(); ++currentIndex)\n    {\n        consecutiveCount= (inputString[currentIndex] == inputString[currentIndex - 1]) ? consecutiveCount + 1 : 1;\n        totalHomogenousCount= (totalHomogenousCount + consecutiveCount) % modulo;\n    }\n    return totalHomogenousCount;\n}",
    "output": "int countHomogenous(std::string inputString)\n{\n    int totalHomogenousCount= 0, consecutiveCount= 1, modulo= 1e9 + 7;\n    for(int currentIndex= 1; currentIndex < inputString.size(); ++currentIndex)\n    {\n        consecutiveCount= (inputString[currentIndex] == inputString[currentIndex - 1]) ? consecutiveCount + 1 : 1;\n        totalHomogenousCount= (totalHomogenousCount + consecutiveCount) % modulo;\n    }\n    return totalHomogenousCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumSize(vector<int> &ballSizes, int maxOperations)\n{\n    priority_queue<int> sizeQueue(ballSizes.begin(), ballSizes.end());\n    while(maxOperations > 0)\n    {\n        int largestBallSize = sizeQueue.top();\n        sizeQueue.pop();\n        sizeQueue.push(largestBallSize / 2);\n        sizeQueue.push(largestBallSize - (largestBallSize / 2));\n        maxOperations--;\n    }\n    return sizeQueue.top();\n}",
    "output": "#include <bits/stdc++.h>\nint minimumSize(std::vector<int> &ballSizes, int maxOperations)\n{\n    std::priority_queue<int> sizeQueue(ballSizes.begin(), ballSizes.end());\n    while(maxOperations > 0)\n    {\n        int largestBallSize= sizeQueue.top();\n        sizeQueue.pop();\n        sizeQueue.push(largestBallSize / 2);\n        sizeQueue.push(largestBallSize - (largestBallSize / 2));\n        maxOperations--;\n    }\n    return sizeQueue.top();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minTrioDegree(int nodeCount, vector<vector<int>> &edges)\n{\n    unordered_map<int, unordered_map<int, bool>> adjacencyList;\n    vector<int> nodeDegree(nodeCount + 1, 0);\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        adjacencyList[edges[i][0]][edges[i][1]] = adjacencyList[edges[i][1]][edges[i][0]] = true;\n        nodeDegree[edges[i][0]]++;\n        nodeDegree[edges[i][1]]++;\n    }\n\n    int minimumDegree = INT_MAX;\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        int firstNode = edges[i][0], secondNode = edges[i][1];\n        for (int thirdNode = 1; thirdNode <= nodeCount; ++thirdNode)\n        {\n            if (adjacencyList[firstNode][thirdNode] && adjacencyList[secondNode][thirdNode])\n            {\n                minimumDegree = min(minimumDegree, nodeDegree[firstNode] + nodeDegree[secondNode] + nodeDegree[thirdNode] - 6);\n            }\n        }\n    }\n\n    return minimumDegree == INT_MAX ? -1 : minimumDegree;\n}",
    "output": "#include <bits/stdc++.h>\nint minTrioDegree(int nodeCount, std::vector<std::vector<int>> &edges)\n{\n    std::unordered_map<int, std::unordered_map<int, bool>> adjacencyList;\n    std::vector<int> nodeDegree(nodeCount + 1, 0);\n\n    for(auto &edge : edges)\n    {\n        adjacencyList[edge[0]][edge[1]]= adjacencyList[edge[1]][edge[0]]= true;\n        nodeDegree[edge[0]]++;\n        nodeDegree[edge[1]]++;\n    }\n\n    int minimumDegree= INT_MAX;\n    for(auto &edge : edges)\n    {\n        int firstNode= edge[0], secondNode= edge[1];\n        for(int thirdNode= 1; thirdNode <= nodeCount; ++thirdNode)\n        {\n            if(adjacencyList[firstNode][thirdNode] && adjacencyList[secondNode][thirdNode])\n            {\n                minimumDegree= std::min(minimumDegree, nodeDegree[firstNode] + nodeDegree[secondNode] + nodeDegree[thirdNode] - 6);\n            }\n        }\n    }\n\n    return minimumDegree == INT_MAX ? -1 : minimumDegree;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint nearestValidPoint(int currentX, int currentY, vector<vector<int>> &points)\n{\n    int minimumDistance = numeric_limits<int>::max();\n    int nearestIndex = -1;\n\n    for(int pointIndex = 0; pointIndex < points.size(); ++pointIndex)\n    {\n        if(currentX == points[pointIndex][0] || currentY == points[pointIndex][1])\n        {\n            int distance = abs(currentX - points[pointIndex][0]) + abs(currentY - points[pointIndex][1]);\n            if(distance < minimumDistance)\n            {\n                minimumDistance = distance;\n                nearestIndex = pointIndex;\n            }\n        }\n    }\n\n    return nearestIndex;\n}",
    "output": "#include <bits/stdc++.h>\nint nearestValidPoint(int currentX, int currentY, std::vector<std::vector<int>> &points)\n{\n    int minimumDistance= std::numeric_limits<int>::max();\n    int nearestIndex= -1;\n\n    for(int pointIndex= 0; pointIndex < points.size(); ++pointIndex)\n    {\n        if(currentX == points[pointIndex][0] || currentY == points[pointIndex][1])\n        {\n            int distance= std::abs(currentX - points[pointIndex][0]) + std::abs(currentY - points[pointIndex][1]);\n            if(distance < minimumDistance)\n            {\n                minimumDistance= distance;\n                nearestIndex= pointIndex;\n            }\n        }\n    }\n\n    return nearestIndex;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "bool checkPowersOfThree(int number)\n{\n    while(number > 0)\n    {\n        if(number % 3 == 2)\n            return false;\n        number/= 3;\n    }\n    return true;\n}",
    "output": "bool checkPowersOfThree(int number)\n{\n    while(number > 0)\n    {\n        if(number % 3 == 2)\n            return false;\n        number/= 3;\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isCovered(vector<vector<int>> &ranges, int left, int right)\n{\n    for(int current = left; current <= right; current++)\n    {\n        bool isFound = false;\n        for(int i = 0; i < ranges.size(); i++)\n        {\n            const auto &range = ranges[i];\n            if(current >= range[0] && current <= range[1])\n            {\n                isFound = true;\n                break;\n            }\n        }\n        if(!isFound)\n            return false;\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isCovered(std::vector<std::vector<int>> &ranges, int left, int right)\n{\n    for(int current= left; current <= right; current++)\n    {\n        bool isFound= false;\n        for(const auto &range : ranges)\n        {\n            if(current >= range[0] && current <= range[1])\n            {\n                isFound= true;\n                break;\n            }\n        }\n        if(!isFound)\n            return false;\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring mergeAlternately(string firstWord, string secondWord)\n{\n    string mergedResult = \"\";\n    int firstIndex = 0, secondIndex = 0;\n    while(firstIndex < firstWord.size() || secondIndex < secondWord.size())\n    {\n        if(firstIndex < firstWord.size())\n            mergedResult += firstWord[firstIndex++];\n        if(secondIndex < secondWord.size())\n            mergedResult += secondWord[secondIndex++];\n    }\n    return mergedResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string mergeAlternately(std::string firstWord, std::string secondWord)\n{\n    std::string mergedResult= \"\";\n    int firstIndex= 0, secondIndex= 0;\n    while(firstIndex < firstWord.size() || secondIndex < secondWord.size())\n    {\n        if(firstIndex < firstWord.size())\n            mergedResult+= firstWord[firstIndex++];\n        if(secondIndex < secondWord.size())\n            mergedResult+= secondWord[secondIndex++];\n    }\n    return mergedResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> minOperations(string boxes)\n{\n    vector<int> operationsResult(boxes.size(), 0);\n    int ballCount= 0, totalOperations= 0;\n\n    for(int index= 0; index < boxes.size(); index++)\n    {\n        totalOperations+= ballCount;\n        operationsResult[index]= totalOperations;\n        if(boxes[index] == '1')\n            ballCount++;\n    }\n\n    ballCount= 0;\n    totalOperations= 0;\n    for(int index= boxes.size() - 1; index >= 0; index--)\n    {\n        totalOperations+= ballCount;\n        operationsResult[index]+= totalOperations;\n        if(boxes[index] == '1')\n            ballCount++;\n    }\n\n    return operationsResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> minOperations(std::string boxes)\n{\n    std::vector<int> operationsResult(boxes.size(), 0);\n    int ballCount= 0, totalOperations= 0;\n\n    for(int index= 0; index < boxes.size(); index++)\n    {\n        totalOperations+= ballCount;\n        operationsResult[index]= totalOperations;\n        if(boxes[index] == '1')\n            ballCount++;\n    }\n\n    ballCount= 0;\n    totalOperations= 0;\n    for(int index= boxes.size() - 1; index >= 0; index--)\n    {\n        totalOperations+= ballCount;\n        operationsResult[index]+= totalOperations;\n        if(boxes[index] == '1')\n            ballCount++;\n    }\n\n    return operationsResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maximumScore(vector<int> &numbers, vector<int> &multipliers)\n{\n    int numbersCount= numbers.size(), multipliersCount= multipliers.size();\n    vector<vector<int>> dynamicProgramming(multipliersCount + 1, vector<int>(multipliersCount + 1, 0));\n    int maximumScore= INT_MIN;\n\n    for(int i= 0; i <= multipliersCount; ++i)\n    {\n        for(int j= 0; i + j <= multipliersCount; ++j)\n        {\n            if(i == 0 && j == 0)\n                continue;\n            int currentScore= 0;\n            if(i == 0)\n            {\n                currentScore= dynamicProgramming[i][j - 1] + numbers[numbersCount - j] * multipliers[i + j - 1];\n            }\n            else if(j == 0)\n            {\n                currentScore= dynamicProgramming[i - 1][j] + numbers[i - 1] * multipliers[i + j - 1];\n            }\n            else\n            {\n                currentScore= max(dynamicProgramming[i - 1][j] + numbers[i - 1] * multipliers[i + j - 1],\n                                  dynamicProgramming[i][j - 1] + numbers[numbersCount - j] * multipliers[i + j - 1]);\n            }\n            dynamicProgramming[i][j]= currentScore;\n            if(i + j == multipliersCount)\n            {\n                maximumScore= max(maximumScore, currentScore);\n            }\n        }\n    }\n\n    return maximumScore;\n}",
    "output": "#include <bits/stdc++.h>\nint maximumScore(std::vector<int> &numbers, std::vector<int> &multipliers)\n{\n    int numbersCount = numbers.size(), multipliersCount = multipliers.size();\n    std::vector<std::vector<int>> dynamicProgramming(multipliersCount + 1, std::vector<int>(multipliersCount + 1, 0));\n    int maximumScore = INT_MIN;\n\n    for(int i = 0; i <= multipliersCount; ++i)\n    {\n        for(int j = 0; i + j <= multipliersCount; ++j)\n        {\n            if(i == 0 && j == 0)\n                continue;\n            int currentScore = 0;\n            if(i == 0)\n            {\n                currentScore = dynamicProgramming[i][j - 1] + numbers[numbersCount - j] * multipliers[i + j - 1];\n            }\n            else if(j == 0)\n            {\n                currentScore = dynamicProgramming[i - 1][j] + numbers[i - 1] * multipliers[i + j - 1];\n            }\n            else\n            {\n                currentScore = std::max(dynamicProgramming[i - 1][j] + numbers[i - 1] * multipliers[i + j - 1],\n                                  dynamicProgramming[i][j - 1] + numbers[numbersCount - j] * multipliers[i + j - 1]);\n            }\n            dynamicProgramming[i][j] = currentScore;\n            if(i + j == multipliersCount)\n            {\n                maximumScore = std::max(maximumScore, currentScore);\n            }\n        }\n    }\n\n    return maximumScore;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint longestPalindromeSubseq(string firstWord, string secondWord)\n{\n    int firstWordLength= firstWord.length();\n    int secondWordLength= secondWord.length();\n\n    int dynamicProgrammingTable[1001][1001]= {0};\n\n    for(int rowIndex= 0; rowIndex < firstWordLength; rowIndex++)\n    {\n        for(int columnIndex= 0; columnIndex < secondWordLength; columnIndex++)\n        {\n            if(firstWord[rowIndex] == secondWord[columnIndex])\n            {\n                dynamicProgrammingTable[rowIndex + 1][columnIndex + 1]= dynamicProgrammingTable[rowIndex][columnIndex] + 1;\n            }\n            else\n            {\n                dynamicProgrammingTable[rowIndex + 1][columnIndex + 1]= max(dynamicProgrammingTable[rowIndex][columnIndex + 1], dynamicProgrammingTable[rowIndex + 1][columnIndex]);\n            }\n        }\n    }\n\n    return dynamicProgrammingTable[firstWordLength][secondWordLength];\n}",
    "output": "#include <bits/stdc++.h>\nint longestPalindromeSubseq(std::string firstWord, std::string secondWord)\n{\n    int firstWordLength= firstWord.length();\n    int secondWordLength= secondWord.length();\n\n    int dynamicProgrammingTable[1001][1001]= {0};\n\n    for(int rowIndex= 0; rowIndex < firstWordLength; rowIndex++)\n    {\n        for(int columnIndex= 0; columnIndex < secondWordLength; columnIndex++)\n        {\n            if(firstWord[rowIndex] == secondWord[columnIndex])\n            {\n                dynamicProgrammingTable[rowIndex + 1][columnIndex + 1]= dynamicProgrammingTable[rowIndex][columnIndex] + 1;\n            }\n            else\n            {\n                dynamicProgrammingTable[rowIndex + 1][columnIndex + 1]= std::max(dynamicProgrammingTable[rowIndex][columnIndex + 1], dynamicProgrammingTable[rowIndex + 1][columnIndex]);\n            }\n        }\n    }\n\n    return dynamicProgrammingTable[firstWordLength][secondWordLength];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maximumRemovals(string sourceString, string targetString, vector<int> &removableIndices)\n{\n    int lowerBound= 0, upperBound= removableIndices.size();\n    while(lowerBound < upperBound)\n    {\n        int midPoint= (lowerBound + upperBound + 1) / 2;\n        string tempString= sourceString;\n        for(int i= 0; i < midPoint; i++)\n        {\n            tempString[removableIndices[i]]= '-';\n        }\n        int sourceIndex= 0, targetIndex= 0;\n        while(sourceIndex < tempString.size() && targetIndex < targetString.size())\n        {\n            if(tempString[sourceIndex] == targetString[targetIndex])\n            {\n                targetIndex++;\n            }\n            sourceIndex++;\n        }\n        if(targetIndex == targetString.size())\n        {\n            lowerBound= midPoint;\n        }\n        else\n        {\n            upperBound= midPoint - 1;\n        }\n    }\n    return lowerBound;\n}",
    "output": "#include <bits/stdc++.h>\nint maximumRemovals(std::string sourceString, std::string targetString, std::vector<int> &removableIndices)\n{\n    int lowerBound= 0, upperBound= removableIndices.size();\n    while(lowerBound < upperBound)\n    {\n        int midPoint= (lowerBound + upperBound + 1) / 2;\n        std::string tempString= sourceString;\n        for(int i= 0; i < midPoint; i++)\n        {\n            tempString[removableIndices[i]]= '-';\n        }\n        int sourceIndex= 0, targetIndex= 0;\n        while(sourceIndex < tempString.size() && targetIndex < targetString.size())\n        {\n            if(tempString[sourceIndex] == targetString[targetIndex])\n            {\n                targetIndex++;\n            }\n            sourceIndex++;\n        }\n        if(targetIndex == targetString.size())\n        {\n            lowerBound= midPoint;\n        }\n        else\n        {\n            upperBound= midPoint - 1;\n        }\n    }\n    return lowerBound;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countMatches(vector<vector<string>> &itemList, string ruleKey, string ruleValue)\n{\n    unordered_map<string, int> ruleIndex = {{\"type\", 0}, {\"color\", 1}, {\"name\", 2}};\n    int matchCount = 0;\n\n    for (int i = 0; i < itemList.size(); ++i)\n    {\n        const auto &item = itemList[i];\n        if (item[ruleIndex[ruleKey]] == ruleValue)\n        {\n            matchCount++;\n        }\n    }\n\n    return matchCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countMatches(std::vector<std::vector<std::string>> &itemList, std::string ruleKey, std::string ruleValue)\n{\n    std::unordered_map<std::string, int> ruleIndex= {{\"type\", 0}, {\"color\", 1}, {\"name\", 2}};\n    int matchCount= 0;\n\n    for(const auto &item : itemList)\n    {\n        if(item[ruleIndex[ruleKey]] == ruleValue)\n        {\n            matchCount++;\n        }\n    }\n\n    return matchCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint closestCost(vector<int> &baseCosts, vector<int> &toppingCosts, int target)\n{\n    int closestCost = baseCosts[0];\n    for (int i = 0; i < baseCosts.size(); ++i)\n    {\n        int baseCost = baseCosts[i];\n        int currentCost = baseCost;\n        for (int i = 0; i < 1 << (toppingCosts.size() * 2); ++i)\n        {\n            int bitMask = i;\n            for (int j = 0; j < toppingCosts.size(); ++j, bitMask >>= 2)\n            {\n                currentCost += (bitMask & 3) * toppingCosts[j];\n            }\n\n            if (abs(target - currentCost) < abs(target - closestCost))\n            {\n                closestCost = currentCost;\n            }\n            else if (abs(target - currentCost) == abs(target - closestCost) && currentCost < closestCost)\n            {\n                closestCost = currentCost;\n            }\n\n            currentCost = baseCost;\n        }\n    }\n    return closestCost;\n}",
    "output": "#include <bits/stdc++.h>\nint closestCost(std::vector<int> &baseCosts, std::vector<int> &toppingCosts, int target)\n{\n    int closestCost= baseCosts[0];\n    for(int baseCost : baseCosts)\n    {\n        int currentCost= baseCost;\n        for(int i= 0; i < 1 << (toppingCosts.size() * 2); ++i)\n        {\n            int bitMask= i;\n            for(int j= 0; j < toppingCosts.size(); ++j, bitMask>>= 2)\n            {\n                currentCost+= (bitMask & 3) * toppingCosts[j];\n            }\n\n            if(abs(target - currentCost) < abs(target - closestCost))\n            {\n                closestCost= currentCost;\n            }\n            else if(abs(target - currentCost) == abs(target - closestCost) && currentCost < closestCost)\n            {\n                closestCost= currentCost;\n            }\n\n            currentCost= baseCost;\n        }\n    }\n    return closestCost;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &firstArray, vector<int> &secondArray)\n{\n    int firstArraySum= accumulate(firstArray.begin(), firstArray.end(), 0);\n    int secondArraySum= accumulate(secondArray.begin(), secondArray.end(), 0);\n    if(firstArraySum == secondArraySum)\n        return 0;\n    if(firstArraySum < secondArraySum)\n        swap(firstArray, secondArray);\n    sort(firstArray.begin(), firstArray.end(), greater<int>());\n    sort(secondArray.begin(), secondArray.end());\n    int difference= abs(firstArraySum - secondArraySum), operationCount= 0;\n    int indexFirst= 0, indexSecond= 0;\n    while(difference > 0 && (indexFirst < firstArray.size() || indexSecond < secondArray.size()))\n    {\n        int optionDecreaseFirst= indexFirst < firstArray.size() ? firstArray[indexFirst] - 1 : 0;\n        int optionIncreaseSecond= indexSecond < secondArray.size() ? 6 - secondArray[indexSecond] : 0;\n        if(optionDecreaseFirst > optionIncreaseSecond)\n        {\n            difference-= optionDecreaseFirst;\n            indexFirst++;\n        }\n        else\n        {\n            difference-= optionIncreaseSecond;\n            indexSecond++;\n        }\n        operationCount++;\n    }\n    return difference == 0 ? operationCount : -1;\n}",
    "output": "#include <bits/stdc++.h>\nint minOperations(std::vector<int> &firstArray, std::vector<int> &secondArray)\n{\n    int firstArraySum = std::accumulate(firstArray.begin(), firstArray.end(), 0);\n    int secondArraySum = std::accumulate(secondArray.begin(), secondArray.end(), 0);\n    if (firstArraySum == secondArraySum)\n        return 0;\n    if (firstArraySum < secondArraySum)\n        std::swap(firstArray, secondArray);\n    std::sort(firstArray.begin(), firstArray.end(), std::greater<int>());\n    std::sort(secondArray.begin(), secondArray.end());\n    int difference = std::abs(firstArraySum - secondArraySum), operationCount = 0;\n    int indexFirst = 0, indexSecond = 0;\n    while (difference > 0 && (indexFirst < firstArray.size() || indexSecond < secondArray.size()))\n    {\n        int optionDecreaseFirst = indexFirst < firstArray.size() ? firstArray[indexFirst] - 1 : 0;\n        int optionIncreaseSecond = indexSecond < secondArray.size() ? 6 - secondArray[indexSecond] : 0;\n        if (optionDecreaseFirst > optionIncreaseSecond)\n        {\n            difference -= optionDecreaseFirst;\n            indexFirst++;\n        }\n        else\n        {\n            difference -= optionIncreaseSecond;\n            indexSecond++;\n        }\n        operationCount++;\n    }\n    return difference == 0 ? operationCount : -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<double> getCollisionTimes(vector<vector<int>> &cars)\n{\n    vector<double> collisionTimes(cars.size(), -1);\n    for(int carIndex= cars.size() - 1; carIndex >= 0; --carIndex)\n    {\n        double timeToCollision= 1e9;\n        for(int nextCarIndex= carIndex + 1; nextCarIndex < cars.size(); ++nextCarIndex)\n        {\n            if(cars[nextCarIndex][1] > cars[carIndex][1])\n                continue;\n            double currentCollisionTime= (double)(cars[nextCarIndex][0] - cars[carIndex][0]) / (cars[carIndex][1] - cars[nextCarIndex][1]);\n            if(currentCollisionTime < timeToCollision)\n            {\n                timeToCollision= min(timeToCollision, min(collisionTimes[nextCarIndex], currentCollisionTime));\n            }\n        }\n        collisionTimes[carIndex]= timeToCollision == 1e9 ? -1.0 : timeToCollision;\n    }\n    return collisionTimes;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<double> getCollisionTimes(std::vector<std::vector<int>> &cars)\n{\n    std::vector<double> collisionTimes(cars.size(), -1);\n    for(int carIndex = cars.size() - 1; carIndex >= 0; --carIndex)\n    {\n        double timeToCollision = 1e9;\n        for(int nextCarIndex = carIndex + 1; nextCarIndex < cars.size(); ++nextCarIndex)\n        {\n            if(cars[nextCarIndex][1] > cars[carIndex][1])\n                continue;\n            double currentCollisionTime = (double)(cars[nextCarIndex][0] - cars[carIndex][0]) / (cars[carIndex][1] - cars[nextCarIndex][1]);\n            if(currentCollisionTime < timeToCollision)\n            {\n                timeToCollision = std::min(timeToCollision, std::min(collisionTimes[nextCarIndex], currentCollisionTime));\n            }\n        }\n        collisionTimes[carIndex] = timeToCollision == 1e9 ? -1.0 : timeToCollision;\n    }\n    return collisionTimes;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring getLargestOddNumber(string number)\n{\n    for(int index= number.length() - 1; index >= 0; index--)\n    {\n        if((number[index] - '0') % 2 != 0)\n        {\n            return number.substr(0, index + 1);\n        }\n    }\n    return \"\";\n}",
    "output": "std::string getLargestOddNumber(std::string number)\n{\n    for(int index= number.length() - 1; index >= 0; index--)\n    {\n        if((number[index] - '0') % 2 != 0)\n        {\n            return number.substr(0, index + 1);\n        }\n    }\n    return \"\";\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For isdigit\nusing namespace std;\n\nint findSecondLargestDigit(string inputString)\n{\n    int largestDigit = -1, secondLargestDigit = -1;\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char character = inputString[i];\n        if (isdigit(character))\n        {\n            int currentDigit = character - '0';\n            if (currentDigit > largestDigit)\n            {\n                secondLargestDigit = largestDigit;\n                largestDigit = currentDigit;\n            }\n            else if (currentDigit != largestDigit && currentDigit > secondLargestDigit)\n            {\n                secondLargestDigit = currentDigit;\n            }\n        }\n    }\n    return secondLargestDigit;\n}",
    "output": "#include <bits/stdc++.h>\nint findSecondLargestDigit(std::string inputString)\n{\n    int largestDigit= -1, secondLargestDigit= -1;\n    for(char character : inputString)\n    {\n        if(std::isdigit(character))\n        {\n            int currentDigit= character - '0';\n            if(currentDigit > largestDigit)\n            {\n                secondLargestDigit= largestDigit;\n                largestDigit= currentDigit;\n            }\n            else if(currentDigit != largestDigit && currentDigit > secondLargestDigit)\n            {\n                secondLargestDigit= currentDigit;\n            }\n        }\n    }\n    return secondLargestDigit;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass AuthenticationManager\n{\n  public:\n    int timeToLive;\n    unordered_map<string, int> tokenExpiryTimes;\n\n    AuthenticationManager(int timeToLive)\n    {\n        this->timeToLive = timeToLive;\n    }\n\n    void generate(string tokenId, int currentTime)\n    {\n        tokenExpiryTimes[tokenId] = currentTime + timeToLive;\n    }\n\n    void renew(string tokenId, int currentTime)\n    {\n        if (tokenExpiryTimes.find(tokenId) != tokenExpiryTimes.end() && tokenExpiryTimes[tokenId] > currentTime)\n        {\n            tokenExpiryTimes[tokenId] = currentTime + timeToLive;\n        }\n    }\n\n    int countUnexpiredTokens(int currentTime)\n    {\n        int unexpiredTokenCount = 0;\n        for (auto it = tokenExpiryTimes.begin(); it != tokenExpiryTimes.end(); ++it)\n        {\n            if (it->second > currentTime)\n                unexpiredTokenCount++;\n        }\n        return unexpiredTokenCount;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass AuthenticationManager\n{\n  public:\n    int timeToLive;\n    std::unordered_map<std::string, int> tokenExpiryTimes;\n\n    AuthenticationManager(int timeToLive)\n    {\n        this->timeToLive= timeToLive;\n    }\n\n    void generate(std::string tokenId, int currentTime)\n    {\n        tokenExpiryTimes[tokenId]= currentTime + timeToLive;\n    }\n\n    void renew(std::string tokenId, int currentTime)\n    {\n        if(tokenExpiryTimes.find(tokenId) != tokenExpiryTimes.end() && tokenExpiryTimes[tokenId] > currentTime)\n        {\n            tokenExpiryTimes[tokenId]= currentTime + timeToLive;\n        }\n    }\n\n    int countUnexpiredTokens(int currentTime)\n    {\n        int unexpiredTokenCount= 0;\n        for(const auto &token : tokenExpiryTimes)\n        {\n            if(token.second > currentTime)\n                unexpiredTokenCount++;\n        }\n        return unexpiredTokenCount;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(vector<int> &numbers)\n{\n    int totalNumbers = numbers.size(), maximumScore = 0;\n    vector<vector<int>> dynamicProgramming(totalNumbers + 1, vector<int>(totalNumbers * 2 + 1, -1));\n\n    function<int(int, int)> calculateGCD = [&](int firstNumber, int secondNumber)\n    {\n        if (secondNumber == 0)\n            return firstNumber;\n        return calculateGCD(secondNumber, firstNumber % secondNumber);\n    };\n\n    function<int(int, int)> depthFirstSearch = [&](int currentIndex, int previousIndex)\n    {\n        if (currentIndex > totalNumbers)\n            return 0;\n        if (dynamicProgramming[currentIndex][previousIndex] != -1)\n            return dynamicProgramming[currentIndex][previousIndex];\n        for (int nextIndex = previousIndex + 1; nextIndex < totalNumbers * 2; ++nextIndex)\n        {\n            maximumScore = max(maximumScore, depthFirstSearch(currentIndex + 1, nextIndex) + currentIndex * calculateGCD(numbers[previousIndex], numbers[nextIndex]));\n        }\n        return dynamicProgramming[currentIndex][previousIndex] = maximumScore;\n    };\n\n    return depthFirstSearch(1, 0);\n}",
    "output": "#include <bits/stdc++.h>\nint maxScore(std::vector<int> &numbers)\n{\n    int totalNumbers= numbers.size(), maximumScore= 0;\n    std::vector<std::vector<int>> dynamicProgramming(totalNumbers + 1, std::vector<int>(totalNumbers * 2 + 1, -1));\n\n    std::function<int(int, int)> calculateGCD= [&](int firstNumber, int secondNumber)\n    {\n        if(secondNumber == 0)\n            return firstNumber;\n        return calculateGCD(secondNumber, firstNumber % secondNumber);\n    };\n\n    std::function<int(int, int)> depthFirstSearch= [&](int currentIndex, int previousIndex)\n    {\n        if(currentIndex > totalNumbers)\n            return 0;\n        if(dynamicProgramming[currentIndex][previousIndex] != -1)\n            return dynamicProgramming[currentIndex][previousIndex];\n        for(int nextIndex= previousIndex + 1; nextIndex < totalNumbers * 2; ++nextIndex)\n        {\n            maximumScore= std::max(maximumScore, depthFirstSearch(currentIndex + 1, nextIndex) + currentIndex * calculateGCD(numbers[previousIndex], numbers[nextIndex]));\n        }\n        return dynamicProgramming[currentIndex][previousIndex]= maximumScore;\n    };\n\n    return depthFirstSearch(1, 0);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool aliceWins(vector<int> &pileSizes)\n{\n    int xorSum = 0;\n    for (int i = 0; i < pileSizes.size(); ++i)\n    {\n        int pile = pileSizes[i];\n        xorSum ^= pile;\n    }\n    return xorSum != 0;\n}",
    "output": "#include <bits/stdc++.h>\nbool aliceWins(std::vector<int> &pileSizes)\n{\n    int xorSum= 0;\n    for(int pile : pileSizes)\n    {\n        xorSum^= pile;\n    }\n    return xorSum != 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canBeIncreasing(vector<int> &numberSequence)\n{\n    int modificationCount= 0;\n    for(int currentIndex= 1; currentIndex < numberSequence.size(); ++currentIndex)\n    {\n        if(numberSequence[currentIndex - 1] >= numberSequence[currentIndex])\n        {\n            modificationCount++;\n            if(modificationCount > 1)\n                return false;\n            if(currentIndex > 1 && numberSequence[currentIndex - 2] >= numberSequence[currentIndex] && currentIndex < numberSequence.size() - 1 && numberSequence[currentIndex - 1] >= numberSequence[currentIndex + 1])\n                return false;\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool canBeIncreasing(std::vector<int> &numberSequence)\n{\n    int modificationCount= 0;\n    for(int currentIndex= 1; currentIndex < numberSequence.size(); ++currentIndex)\n    {\n        if(numberSequence[currentIndex - 1] >= numberSequence[currentIndex])\n        {\n            modificationCount++;\n            if(modificationCount > 1)\n                return false;\n            if(currentIndex > 1 && numberSequence[currentIndex - 2] >= numberSequence[currentIndex] && currentIndex < numberSequence.size() - 1 && numberSequence[currentIndex - 1] >= numberSequence[currentIndex + 1])\n                return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool checkOnesSegment(string binaryString)\n{\n    int segmentCount = 0;\n    for(int currentIndex = 0; currentIndex < binaryString.length(); ++currentIndex)\n    {\n        if(binaryString[currentIndex] == '1')\n        {\n            if(currentIndex > 0 && binaryString[currentIndex - 1] == '0')\n            {\n                segmentCount++;\n            }\n        }\n    }\n    return segmentCount <= 1;\n}",
    "output": "bool checkOnesSegment(std::string binaryString)\n{\n    int segmentCount= 0;\n    for(int currentIndex= 0; currentIndex < binaryString.length(); ++currentIndex)\n    {\n        if(binaryString[currentIndex] == '1')\n        {\n            if(currentIndex > 0 && binaryString[currentIndex - 1] == '0')\n            {\n                segmentCount++;\n            }\n        }\n    }\n    return segmentCount <= 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// for abs\nusing namespace std;\n\nint minElements(vector<int> &numbers, int limit, int goal)\n{\n    long long totalSum = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n        totalSum += numbers[i];\n    long long difference = abs(goal - totalSum);\n    return (difference + limit - 1) / limit;\n}",
    "output": "int minElements(std::vector<int> &numbers, int limit, int goal)\n{\n    long long totalSum= 0;\n    for(int number : numbers)\n        totalSum+= number;\n    long long difference= abs(goal - totalSum);\n    return (difference + limit - 1) / limit;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo = 1e9 + 7;\n\nint countRestrictedPaths(int nodeCount, vector<vector<int>> &edges)\n{\n    vector<vector<pair<int, int>>> graph(nodeCount + 1);\n    vector<long long> distance(nodeCount + 1, 1e18);\n\n    for (const auto &edge : edges)\n    {\n        int fromNode = edge[0], toNode = edge[1], edgeWeight = edge[2];\n        graph[fromNode].push_back({toNode, edgeWeight});\n        graph[toNode].push_back({fromNode, edgeWeight});\n    }\n\n    priority_queue<pair<long long, int>> priorityQueue;\n    priorityQueue.push({0, nodeCount});\n    distance[nodeCount] = 0;\n\n    while (!priorityQueue.empty())\n    {\n        int currentNode = priorityQueue.top().second;\n        long long currentDistance = -priorityQueue.top().first;\n        priorityQueue.pop();\n\n        if (currentDistance != distance[currentNode])\n            continue;\n\n        for (const auto &neighbor : graph[currentNode])\n        {\n            int nextNode = neighbor.first, weight = neighbor.second;\n            if (distance[currentNode] + weight < distance[nextNode])\n            {\n                distance[nextNode] = distance[currentNode] + weight;\n                priorityQueue.push({-distance[nextNode], nextNode});\n            }\n        }\n    }\n\n    vector<int> dynamicProgramming(nodeCount + 1, -1);\n    function<int(int)> depthFirstSearch = [&](int currentNode)\n    {\n        if (currentNode == nodeCount)\n            return 1;\n        if (dynamicProgramming[currentNode] != -1)\n            return dynamicProgramming[currentNode];\n        int totalPaths = 0;\n        for (const auto &neighbor : graph[currentNode])\n        {\n            int nextNode = neighbor.first;\n            if (distance[nextNode] < distance[currentNode])\n            {\n                totalPaths = (totalPaths + depthFirstSearch(nextNode)) % modulo;\n            }\n        }\n        return dynamicProgramming[currentNode] = totalPaths;\n    };\n\n    return depthFirstSearch(1);\n}",
    "output": "#include <bits/stdc++.h>\nconst int modulo = 1e9 + 7;\n\nint countRestrictedPaths(int nodeCount, std::vector<std::vector<int>> &edges)\n{\n    std::vector<std::vector<std::pair<int, int>>> graph(nodeCount + 1);\n    std::vector<long long> distance(nodeCount + 1, 1e18);\n\n    for(auto &edge : edges)\n    {\n        int fromNode = edge[0], toNode = edge[1], edgeWeight = edge[2];\n        graph[fromNode].push_back({toNode, edgeWeight});\n        graph[toNode].push_back({fromNode, edgeWeight});\n    }\n\n    std::priority_queue<std::pair<long long, int>> priorityQueue;\n    priorityQueue.push({0, nodeCount});\n    distance[nodeCount] = 0;\n\n    while(!priorityQueue.empty())\n    {\n        int currentNode = priorityQueue.top().second;\n        long long currentDistance = -priorityQueue.top().first;\n        priorityQueue.pop();\n\n        if(currentDistance != distance[currentNode])\n            continue;\n\n        for(auto &neighbor : graph[currentNode])\n        {\n            int nextNode = neighbor.first, weight = neighbor.second;\n            if(distance[currentNode] + weight < distance[nextNode])\n            {\n                distance[nextNode] = distance[currentNode] + weight;\n                priorityQueue.push({-distance[nextNode], nextNode});\n            }\n        }\n    }\n\n    std::vector<int> dynamicProgramming(nodeCount + 1, -1);\n    std::function<int(int)> depthFirstSearch = [&](int currentNode)\n    {\n        if(currentNode == nodeCount)\n            return 1;\n        if(dynamicProgramming[currentNode] != -1)\n            return dynamicProgramming[currentNode];\n        int totalPaths = 0;\n        for(auto &neighbor : graph[currentNode])\n        {\n            int nextNode = neighbor.first;\n            if(distance[nextNode] < distance[currentNode])\n            {\n                totalPaths = (totalPaths + depthFirstSearch(nextNode)) % modulo;\n            }\n        }\n        return dynamicProgramming[currentNode] = totalPaths;\n    };\n\n    return depthFirstSearch(1);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minChanges(vector<int> &numbers, int segmentLength)\n{\n    int arraySize= numbers.size();\n    vector<int> xorPrefix(arraySize + 1);\n    for(int index= 1; index <= arraySize; ++index)\n    {\n        xorPrefix[index]= xorPrefix[index - 1] ^ numbers[index - 1];\n    }\n\n    vector<unordered_map<int, int>> changeCount(segmentLength);\n    vector<int> minChangeCount(segmentLength, arraySize);\n\n    for(int index= 1; index <= arraySize; ++index)\n    {\n        int xorValue= xorPrefix[index] ^ xorPrefix[index - segmentLength];\n\n        if(index >= segmentLength)\n        {\n            changeCount[0][xorValue]++;\n        }\n\n        for(int segmentIndex= 1; index - segmentIndex * segmentLength >= 0; ++segmentIndex)\n        {\n            changeCount[segmentIndex][xorValue]++;\n            minChangeCount[segmentIndex]= min(minChangeCount[segmentIndex], changeCount[segmentIndex - 1][xorValue] - changeCount[segmentIndex][xorValue]);\n        }\n    }\n\n    int finalAnswer= arraySize;\n    for(int segmentIndex= 0; segmentIndex < segmentLength; ++segmentIndex)\n    {\n        finalAnswer= min(finalAnswer, minChangeCount[segmentIndex] + segmentIndex);\n    }\n    return finalAnswer;\n}",
    "output": "#include <bits/stdc++.h>\nint minChanges(std::vector<int> &numbers, int segmentLength)\n{\n    int arraySize= numbers.size();\n    std::vector<int> xorPrefix(arraySize + 1);\n    for(int index= 1; index <= arraySize; ++index)\n    {\n        xorPrefix[index]= xorPrefix[index - 1] ^ numbers[index - 1];\n    }\n\n    std::vector<std::unordered_map<int, int>> changeCount(segmentLength);\n    std::vector<int> minChangeCount(segmentLength, arraySize);\n\n    for(int index= 1; index <= arraySize; ++index)\n    {\n        int xorValue= xorPrefix[index] ^ xorPrefix[index - segmentLength];\n\n        if(index >= segmentLength)\n        {\n            changeCount[0][xorValue]++;\n        }\n\n        for(int segmentIndex= 1; index - segmentIndex * segmentLength >= 0; ++segmentIndex)\n        {\n            changeCount[segmentIndex][xorValue]++;\n            minChangeCount[segmentIndex]= std::min(minChangeCount[segmentIndex], changeCount[segmentIndex - 1][xorValue] - changeCount[segmentIndex][xorValue]);\n        }\n    }\n\n    int finalAnswer= arraySize;\n    for(int segmentIndex= 0; segmentIndex < segmentLength; ++segmentIndex)\n    {\n        finalAnswer= std::min(finalAnswer, minChangeCount[segmentIndex] + segmentIndex);\n    }\n    return finalAnswer;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> rotateGrid(vector<vector<int>> &grid, int rotationCount)\n{\n    if(grid.empty())\n        return grid;\n\n    int rowCount= grid.size();       // number of rows\n    int columnCount= grid[0].size(); // number of columns\n    int layerCount= min(rowCount, columnCount) / 2;\n\n    for(int currentLayer= 0; currentLayer < layerCount; ++currentLayer)\n    {\n        int elementsToRotate= (rowCount - 2 * currentLayer) * 2 + (columnCount - 2 * currentLayer - 2) * 2; // number of elements in the outer ring\n        int effectiveRotationCount= rotationCount % elementsToRotate;                                       // effective number of rotations\n\n        while(effectiveRotationCount--)\n        {\n            int tempValue= grid[currentLayer][currentLayer];\n            for(int i= currentLayer + 1; i < rowCount - currentLayer; ++i)\n                swap(tempValue, grid[i][currentLayer]);\n            for(int j= currentLayer + 1; j < columnCount - currentLayer; ++j)\n                swap(tempValue, grid[rowCount - currentLayer - 1][j]);\n            for(int i= rowCount - currentLayer - 2; i >= currentLayer; --i)\n                swap(tempValue, grid[i][columnCount - currentLayer - 1]);\n            for(int j= columnCount - currentLayer - 2; j > currentLayer; --j)\n                swap(tempValue, grid[currentLayer][j]);\n        }\n    }\n\n    return grid;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> rotateGrid(std::vector<std::vector<int>> &grid, int rotationCount)\n{\n    if(grid.empty())\n        return grid;\n\n    int rowCount= grid.size();       // number of rows\n    int columnCount= grid[0].size(); // number of columns\n    int layerCount= std::min(rowCount, columnCount) / 2;\n\n    for(int currentLayer= 0; currentLayer < layerCount; ++currentLayer)\n    {\n        int elementsToRotate= (rowCount - 2 * currentLayer) * 2 + (columnCount - 2 * currentLayer - 2) * 2; // number of elements in the outer ring\n        int effectiveRotationCount= rotationCount % elementsToRotate;                                       // effective number of rotations\n\n        while(effectiveRotationCount--)\n        {\n            int tempValue= grid[currentLayer][currentLayer];\n            for(int i= currentLayer + 1; i < rowCount - currentLayer; ++i)\n                std::swap(tempValue, grid[i][currentLayer]);\n            for(int j= currentLayer + 1; j < columnCount - currentLayer; ++j)\n                std::swap(tempValue, grid[rowCount - currentLayer - 1][j]);\n            for(int i= rowCount - currentLayer - 2; i >= currentLayer; --i)\n                std::swap(tempValue, grid[i][columnCount - currentLayer - 1]);\n            for(int j= columnCount - currentLayer - 2; j > currentLayer; --j)\n                std::swap(tempValue, grid[currentLayer][j]);\n        }\n    }\n\n    return grid;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "using namespace std;\n\nbool areAlmostEqual(string firstString, string secondString)\n{\n    int differenceCount= 0;\n    int firstDifferenceIndex= -1;\n    int secondDifferenceIndex= -1;\n    for(int index= 0; index < firstString.length(); ++index)\n    {\n        if(firstString[index] != secondString[index])\n        {\n            differenceCount++;\n            if(differenceCount == 1)\n                firstDifferenceIndex= index;\n            else if(differenceCount == 2)\n                secondDifferenceIndex= index;\n            else\n                return false;\n        }\n    }\n    return differenceCount == 0 || (differenceCount == 2 && firstString[firstDifferenceIndex] == secondString[secondDifferenceIndex] && firstString[secondDifferenceIndex] == secondString[firstDifferenceIndex]);\n}",
    "output": "bool areAlmostEqual(std::string firstString, std::string secondString)\n{\n    int differenceCount= 0;\n    int firstDifferenceIndex= -1;\n    int secondDifferenceIndex= -1;\n    for(int index= 0; index < firstString.length(); ++index)\n    {\n        if(firstString[index] != secondString[index])\n        {\n            differenceCount++;\n            if(differenceCount == 1)\n                firstDifferenceIndex= index;\n            else if(differenceCount == 2)\n                secondDifferenceIndex= index;\n            else\n                return false;\n        }\n    }\n    return differenceCount == 0 || (differenceCount == 2 && firstString[firstDifferenceIndex] == secondString[secondDifferenceIndex] && firstString[secondDifferenceIndex] == secondString[firstDifferenceIndex]);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findCenter(vector<vector<int>> &edgeList)\n{\n    if(edgeList[0][0] == edgeList[1][0] || edgeList[0][0] == edgeList[1][1])\n    {\n        return edgeList[0][0];\n    }\n    return edgeList[0][1];\n}",
    "output": "#include <bits/stdc++.h>\nint findCenter(std::vector<std::vector<int>> &edgeList)\n{\n    if(edgeList[0][0] == edgeList[1][0] || edgeList[0][0] == edgeList[1][1])\n    {\n        return edgeList[0][0];\n    }\n    return edgeList[0][1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxScore(vector<int> &scores, int k)\n{\n    int size= scores.size();\n    int maxResult= 0;\n    for(int leftIndex= k; leftIndex >= 0; leftIndex--)\n    {\n        for(int rightIndex= k; rightIndex < size; rightIndex++)\n        {\n            int minimumValue= scores[leftIndex];\n            for(int currentIndex= leftIndex; currentIndex <= rightIndex; currentIndex++)\n                minimumValue= min(minimumValue, scores[currentIndex]);\n            maxResult= max(maxResult, minimumValue * (rightIndex - leftIndex + 1));\n        }\n    }\n    return maxResult;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMaxScore(std::vector<int> &scores, int k)\n{\n    int size= scores.size();\n    int maxResult= 0;\n    for(int leftIndex= k; leftIndex >= 0; leftIndex--)\n    {\n        for(int rightIndex= k; rightIndex < size; rightIndex++)\n        {\n            int minimumValue= scores[leftIndex];\n            for(int currentIndex= leftIndex; currentIndex <= rightIndex; currentIndex++)\n                minimumValue= std::min(minimumValue, scores[currentIndex]);\n            maxResult= std::max(maxResult, minimumValue * (rightIndex - leftIndex + 1));\n        }\n    }\n    return maxResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "using namespace std;\n\nbool squareIsWhite(string chessCoordinates)\n{\n    return (chessCoordinates[0] - 'a' + chessCoordinates[1] - '1') % 2 == 0;\n}",
    "output": "bool squareIsWhite(std::string chessCoordinates)\n{\n    return (chessCoordinates[0] - 'a' + chessCoordinates[1] - '1') % 2 == 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint eliminateMaximum(vector<int> &distances, vector<int> &speeds)\n{\n    int numberOfCities= distances.size();\n    vector<int> timeToReachCity(numberOfCities);\n    for(int i= 0; i < numberOfCities; i++)\n    {\n        timeToReachCity[i]= (distances[i] + speeds[i] - 1) / speeds[i];\n    }\n    sort(timeToReachCity.begin(), timeToReachCity.end());\n    int eliminatedCount= 0;\n    for(int i= 0; i < numberOfCities && timeToReachCity[i] > i; i++)\n    {\n        eliminatedCount++;\n    }\n    return eliminatedCount;\n}",
    "output": "#include <bits/stdc++.h>\nint eliminateMaximum(std::vector<int> &distances, std::vector<int> &speeds)\n{\n    int numberOfCities= distances.size();\n    std::vector<int> timeToReachCity(numberOfCities);\n    for(int i= 0; i < numberOfCities; i++)\n    {\n        timeToReachCity[i]= (distances[i] + speeds[i] - 1) / speeds[i];\n    }\n    std::sort(timeToReachCity.begin(), timeToReachCity.end());\n    int eliminatedCount= 0;\n    for(int i= 0; i < numberOfCities && timeToReachCity[i] > i; i++)\n    {\n        eliminatedCount++;\n    }\n    return eliminatedCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long calculateGoodDigitStrings(int stringLength)\n{\n    const int modulus= 1000000007;\n    long long evenDigitCount= 1, primeDigitCount= 1;\n    for(int index= 0; index < stringLength; ++index)\n    {\n        if(index % 2 == 0)\n            evenDigitCount= (evenDigitCount * 5) % modulus;\n        else\n            primeDigitCount= (primeDigitCount * 4) % modulus;\n    }\n    return (evenDigitCount * primeDigitCount) % modulus;\n}",
    "output": "long long calculateGoodDigitStrings(int stringLength)\n{\n    const int modulus= 1000000007;\n    long long evenDigitCount= 1, primeDigitCount= 1;\n    for(int index= 0; index < stringLength; ++index)\n    {\n        if(index % 2 == 0)\n            evenDigitCount= (evenDigitCount * 5) % modulus;\n        else\n            primeDigitCount= (primeDigitCount * 4) % modulus;\n    }\n    return (evenDigitCount * primeDigitCount) % modulus;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool areSentencesSimilar(string firstSentence, string secondSentence)\n{\n    vector<string> firstSentenceWords, secondSentenceWords;\n    stringstream firstSentenceStream(firstSentence), secondSentenceStream(secondSentence);\n    string currentWord;\n\n    while(firstSentenceStream >> currentWord)\n        firstSentenceWords.push_back(currentWord);\n    while(secondSentenceStream >> currentWord)\n        secondSentenceWords.push_back(currentWord);\n\n    while(\n        !firstSentenceWords.empty() && !secondSentenceWords.empty() &&\n        firstSentenceWords.front() == secondSentenceWords.front())\n    {\n        firstSentenceWords.erase(firstSentenceWords.begin());\n        secondSentenceWords.erase(secondSentenceWords.begin());\n    }\n\n    while(\n        !firstSentenceWords.empty() && !secondSentenceWords.empty() &&\n        firstSentenceWords.back() == secondSentenceWords.back())\n    {\n        firstSentenceWords.pop_back();\n        secondSentenceWords.pop_back();\n    }\n\n    return firstSentenceWords.empty() || secondSentenceWords.empty();\n}",
    "output": "#include <bits/stdc++.h>\nbool areSentencesSimilar(std::string firstSentence, std::string secondSentence)\n{\n    std::vector<std::string> firstSentenceWords, secondSentenceWords;\n    std::stringstream firstSentenceStream(firstSentence), secondSentenceStream(secondSentence);\n    std::string currentWord;\n\n    while(firstSentenceStream >> currentWord)\n        firstSentenceWords.push_back(currentWord);\n    while(secondSentenceStream >> currentWord)\n        secondSentenceWords.push_back(currentWord);\n\n    while(\n        !firstSentenceWords.empty() && !secondSentenceWords.empty() &&\n        firstSentenceWords.front() == secondSentenceWords.front())\n    {\n        firstSentenceWords.erase(firstSentenceWords.begin());\n        secondSentenceWords.erase(secondSentenceWords.begin());\n    }\n\n    while(\n        !firstSentenceWords.empty() && !secondSentenceWords.empty() &&\n        firstSentenceWords.back() == secondSentenceWords.back())\n    {\n        firstSentenceWords.pop_back();\n        secondSentenceWords.pop_back();\n    }\n\n    return firstSentenceWords.empty() || secondSentenceWords.empty();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxHappyGroups(int batchSize, vector<int> &groups)\n{\n    vector<int> remainders(batchSize, 0);\n    for (int i = 0; i < groups.size(); ++i)\n    {\n        int group = groups[i];\n        remainders[group % batchSize]++;\n    }\n\n    int totalHappyGroups = remainders[0];\n    int leftIndex = 1, rightIndex = batchSize - 1;\n\n    while (leftIndex < rightIndex)\n    {\n        totalHappyGroups += min(remainders[leftIndex], remainders[rightIndex]);\n        leftIndex++;\n        rightIndex--;\n    }\n    if (leftIndex == rightIndex)\n    {\n        totalHappyGroups += remainders[leftIndex] / 2;\n    }\n\n    return totalHappyGroups;\n}",
    "output": "#include <bits/stdc++.h>\nint maxHappyGroups(int batchSize, std::vector<int> &groups)\n{\n    std::vector<int> remainders(batchSize, 0);\n    for(int group : groups)\n    {\n        remainders[group % batchSize]++;\n    }\n\n    int totalHappyGroups= remainders[0];\n    int leftIndex= 1, rightIndex= batchSize - 1;\n\n    while(leftIndex < rightIndex)\n    {\n        totalHappyGroups+= std::min(remainders[leftIndex], remainders[rightIndex]);\n        leftIndex++;\n        rightIndex--;\n    }\n    if(leftIndex == rightIndex)\n    {\n        totalHappyGroups+= remainders[leftIndex] / 2;\n    }\n\n    return totalHappyGroups;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint reverseInteger(int originalNumber)\n{\n    int reversedNumber = 0;\n    while(originalNumber != 0)\n    {\n        reversedNumber = reversedNumber * 10 + originalNumber % 10;\n        originalNumber = originalNumber / 10;\n    }\n    return reversedNumber;\n}\n\nint countNicePairs(vector<int> &numberList)\n{\n    const int moduloValue = 1e9 + 7;\n    unordered_map<int, int> differenceCount;\n    int nicePairCount = 0;\n\n    for (int i = 0; i < numberList.size(); ++i)\n    {\n        int currentNumber = numberList[i];\n        int difference = currentNumber - reverseInteger(currentNumber);\n        differenceCount[difference]++;\n    }\n\n    for (auto &[_, frequency] : differenceCount)\n    {\n        nicePairCount = (nicePairCount + ((frequency * (frequency - 1LL)) / 2) % moduloValue) % moduloValue;\n    }\n\n    return nicePairCount;\n}",
    "output": "#include <bits/stdc++.h>\nint reverseInteger(int originalNumber)\n{\n    int reversedNumber= 0;\n    while(originalNumber != 0)\n    {\n        reversedNumber= reversedNumber * 10 + originalNumber % 10;\n        originalNumber= originalNumber / 10;\n    }\n    return reversedNumber;\n}\n\nint countNicePairs(std::vector<int> &numberList)\n{\n    const int moduloValue= 1e9 + 7;\n    std::unordered_map<int, int> differenceCount;\n    int nicePairCount= 0;\n\n    for(int currentNumber : numberList)\n    {\n        int difference= currentNumber - reverseInteger(currentNumber);\n        differenceCount[difference]++;\n    }\n\n    for(auto &[_, frequency] : differenceCount)\n    {\n        nicePairCount= (nicePairCount + ((frequency * (frequency - 1LL)) / 2) % moduloValue) % moduloValue;\n    }\n\n    return nicePairCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint nearestExit(vector<vector<char>> &maze, vector<int> entrance)\n{\n    int rowCount = maze.size();\n    int columnCount = maze[0].size();\n    vector<vector<int>> directionVectors = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    queue<pair<int, int>> positionQueue;\n    positionQueue.push({entrance[0], entrance[1]});\n\n    int stepCount = -1;\n    while (!positionQueue.empty())\n    {\n        stepCount++;\n        int currentLevelSize = positionQueue.size();\n        for (int i = 0; i < currentLevelSize; ++i)\n        {\n            auto [currentRow, currentColumn] = positionQueue.front();\n            positionQueue.pop();\n            if (maze[currentRow][currentColumn] == '+')\n                continue;\n            if (currentRow == 0 || currentRow == rowCount - 1 || currentColumn == 0 || currentColumn == columnCount - 1)\n            {\n                if (currentRow != entrance[0] || currentColumn != entrance[1])\n                    return stepCount;\n            }\n            maze[currentRow][currentColumn] = '+';\n            for (int j = 0; j < directionVectors.size(); ++j)\n            {\n                int newRow = currentRow + directionVectors[j][0];\n                int newColumn = currentColumn + directionVectors[j][1];\n                if (newRow >= 0 && newRow < rowCount && newColumn >= 0 && newColumn < columnCount)\n                {\n                    positionQueue.push({newRow, newColumn});\n                }\n            }\n        }\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<char>> nearestExit(std::vector<std::vector<char>> &maze, std::vector<int> entrance)\n{\n    int rowCount= maze.size();\n    int columnCount= maze[0].size();\n    std::vector<std::vector<int>> directionVectors= {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    std::queue<std::pair<int, int>> positionQueue;\n    positionQueue.push({entrance[0], entrance[1]});\n\n    int stepCount= -1;\n    while(!positionQueue.empty())\n    {\n        stepCount++;\n        int currentLevelSize= positionQueue.size();\n        for(int i= 0; i < currentLevelSize; ++i)\n        {\n            auto [currentRow, currentColumn]= positionQueue.front();\n            positionQueue.pop();\n            if(maze[currentRow][currentColumn] == '+')\n                continue;\n            if(currentRow == 0 || currentRow == rowCount - 1 || currentColumn == 0 || currentColumn == columnCount - 1)\n            {\n                if(currentRow != entrance[0] || currentColumn != entrance[1])\n                    return stepCount;\n            }\n            maze[currentRow][currentColumn]= '+';\n            for(const auto &direction : directionVectors)\n            {\n                int newRow= currentRow + direction[0];\n                int newColumn= currentColumn + direction[1];\n                if(newRow >= 0 && newRow < rowCount && newColumn >= 0 && newColumn < columnCount)\n                {\n                    positionQueue.push({newRow, newColumn});\n                }\n            }\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAscendingSum(vector<int> &numberList)\n{\n    int maxSum= 0, currentSum= numberList[0];\n\n    for(int index= 1; index < numberList.size(); ++index)\n    {\n        if(numberList[index] > numberList[index - 1])\n        {\n            currentSum+= numberList[index];\n        }\n        else\n        {\n            maxSum= max(maxSum, currentSum);\n            currentSum= numberList[index];\n        }\n    }\n\n    return max(maxSum, currentSum);\n}",
    "output": "#include <bits/stdc++.h>\nint maxAscendingSum(std::vector<int> &numberList)\n{\n    int maxSum= 0, currentSum= numberList[0];\n\n    for(int index= 1; index < numberList.size(); ++index)\n    {\n        if(numberList[index] > numberList[index - 1])\n        {\n            currentSum+= numberList[index];\n        }\n        else\n        {\n            maxSum= std::max(maxSum, currentSum);\n            currentSum= numberList[index];\n        }\n    }\n\n    return std::max(maxSum, currentSum);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint getNumberOfBacklogOrders(vector<vector<int>> &orders)\n{\n    auto compareSellOrder = [](vector<int> &a, vector<int> &b)\n    {\n        return a[0] > b[0];\n    };\n    auto compareBuyOrder = [](vector<int> &a, vector<int> &b)\n    {\n        return a[0] < b[0];\n    };\n\n    priority_queue<vector<int>, vector<vector<int>>, decltype(compareSellOrder)> sellOrders(compareSellOrder);\n    priority_queue<vector<int>, vector<vector<int>>, decltype(compareBuyOrder)> buyOrders(compareBuyOrder);\n\n    for (size_t i = 0; i < orders.size(); ++i)\n    {\n        vector<int> &currentOrder = orders[i];\n        if (currentOrder[2] == 0)\n        { // Sell order\n            while (!sellOrders.empty() && currentOrder[1] > 0 && sellOrders.top()[0] <= currentOrder[0])\n            {\n                vector<int> &topSellOrder = sellOrders.top();\n                int executedAmount = min(currentOrder[1], topSellOrder[1]);\n                currentOrder[1] -= executedAmount;\n                topSellOrder[1] -= executedAmount;\n                if (topSellOrder[1] == 0)\n                {\n                    sellOrders.pop();\n                }\n            }\n            if (currentOrder[1] > 0)\n            {\n                buyOrders.push(currentOrder);\n            }\n        }\n        else\n        { // Buy order\n            while (!buyOrders.empty() && currentOrder[1] > 0 && buyOrders.top()[0] >= currentOrder[0])\n            {\n                vector<int> &topBuyOrder = buyOrders.top();\n                int executedAmount = min(currentOrder[1], topBuyOrder[1]);\n                currentOrder[1] -= executedAmount;\n                topBuyOrder[1] -= executedAmount;\n                if (topBuyOrder[1] == 0)\n                {\n                    buyOrders.pop();\n                }\n            }\n            if (currentOrder[1] > 0)\n            {\n                sellOrders.push(currentOrder);\n            }\n        }\n    }\n\n    int64_t totalBacklog = 0;\n    while (!buyOrders.empty())\n    {\n        totalBacklog += buyOrders.top()[1];\n        buyOrders.pop();\n    }\n    while (!sellOrders.empty())\n    {\n        totalBacklog += sellOrders.top()[1];\n        sellOrders.pop();\n    }\n\n    totalBacklog %= 1000000007;\n    return static_cast<int>(totalBacklog);\n}",
    "output": "#include <bits/stdc++.h>\nint getNumberOfBacklogOrders(std::vector<std::vector<int>> &orders)\n{\n    auto compareSellOrder= [](std::vector<int> &a, std::vector<int> &b)\n    {\n        return a[0] > b[0];\n    };\n    auto compareBuyOrder= [](std::vector<int> &a, std::vector<int> &b)\n    {\n        return a[0] < b[0];\n    };\n\n    std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, decltype(compareSellOrder)> sellOrders(compareSellOrder);\n    std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, decltype(compareBuyOrder)> buyOrders(compareBuyOrder);\n\n    for(auto &currentOrder : orders)\n    {\n        if(currentOrder[2] == 0)\n        { // Sell order\n            while(!sellOrders.empty() && currentOrder[1] > 0 && sellOrders.top()[0] <= currentOrder[0])\n            {\n                std::vector<int> &topSellOrder= sellOrders.top();\n                int executedAmount= std::min(currentOrder[1], topSellOrder[1]);\n                currentOrder[1]-= executedAmount;\n                topSellOrder[1]-= executedAmount;\n                if(topSellOrder[1] == 0)\n                {\n                    sellOrders.pop();\n                }\n            }\n            if(currentOrder[1] > 0)\n            {\n                buyOrders.push(currentOrder);\n            }\n        }\n        else\n        { // Buy order\n            while(!buyOrders.empty() && currentOrder[1] > 0 && buyOrders.top()[0] >= currentOrder[0])\n            {\n                std::vector<int> &topBuyOrder= buyOrders.top();\n                int executedAmount= std::min(currentOrder[1], topBuyOrder[1]);\n                currentOrder[1]-= executedAmount;\n                topBuyOrder[1]-= executedAmount;\n                if(topBuyOrder[1] == 0)\n                {\n                    buyOrders.pop();\n                }\n            }\n            if(currentOrder[1] > 0)\n            {\n                sellOrders.push(currentOrder);\n            }\n        }\n    }\n\n    int64_t totalBacklog= 0;\n    while(!buyOrders.empty())\n    {\n        totalBacklog+= buyOrders.top()[1];\n        buyOrders.pop();\n    }\n    while(!sellOrders.empty())\n    {\n        totalBacklog+= sellOrders.top()[1];\n        sellOrders.pop();\n    }\n\n    totalBacklog%= 1000000007;\n    return static_cast<int>(totalBacklog);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int findMaxValue(int totalElements, int targetIndex, int remainingSum)\n{\n    remainingSum-= totalElements;\n    int leftBoundary= 0, rightBoundary= remainingSum, result= 0;\n    while(leftBoundary <= rightBoundary)\n    {\n        int middle= leftBoundary + (rightBoundary - leftBoundary) / 2;\n        long long currentSum= min(middle, targetIndex) * (min(middle, targetIndex) + 1LL) / 2 +\n                              min(middle, totalElements - targetIndex - 1) * (min(middle, totalElements - targetIndex) + 1LL) / 2;\n        if(middle > targetIndex)\n        {\n            currentSum+= (middle - targetIndex - 1LL) * (middle - targetIndex) / 2;\n        }\n        if(middle > totalElements - targetIndex)\n        {\n            currentSum+= (middle - totalElements + targetIndex) * (middle - totalElements + targetIndex + 1) / 2;\n        }\n        if(currentSum <= remainingSum)\n        {\n            result= middle;\n            leftBoundary= middle + 1;\n        }\n        else\n        {\n            rightBoundary= middle - 1;\n        }\n    }\n    return result + 1;\n}",
    "output": "int findMaxValue(int totalElements, int targetIndex, int remainingSum)\n{\n    remainingSum-= totalElements;\n    int leftBoundary= 0, rightBoundary= remainingSum, result= 0;\n    while(leftBoundary <= rightBoundary)\n    {\n        int middle= leftBoundary + (rightBoundary - leftBoundary) / 2;\n        long long currentSum= min(middle, targetIndex) * (min(middle, targetIndex) + 1LL) / 2 +\n                              min(middle, totalElements - targetIndex - 1) * (min(middle, totalElements - targetIndex) + 1LL) / 2;\n        if(middle > targetIndex)\n        {\n            currentSum+= (middle - targetIndex - 1LL) * (middle - targetIndex) / 2;\n        }\n        if(middle > totalElements - targetIndex)\n        {\n            currentSum+= (middle - totalElements + targetIndex) * (middle - totalElements + targetIndex + 1) / 2;\n        }\n        if(currentSum <= remainingSum)\n        {\n            result= middle;\n            leftBoundary= middle + 1;\n        }\n        else\n        {\n            rightBoundary= middle - 1;\n        }\n    }\n    return result + 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxConsecutiveValues(vector<int> &coinValues)\n{\n    sort(coinValues.begin(), coinValues.end());\n    int maximumValue = 0;\n    for (int i = 0; i < coinValues.size(); ++i)\n    {\n        int coin = coinValues[i];\n        if (coin <= maximumValue + 1)\n        {\n            maximumValue += coin;\n        }\n        else\n        {\n            break;\n        }\n    }\n    return maximumValue + 1;\n}",
    "output": "#include <bits/stdc++.h>\nint maxConsecutiveValues(std::vector<int> &coinValues)\n{\n    std::sort(coinValues.begin(), coinValues.end());\n    int maximumValue= 0;\n    for(int coin : coinValues)\n    {\n        if(coin <= maximumValue + 1)\n        {\n            maximumValue+= coin;\n        }\n        else\n        {\n            break;\n        }\n    }\n    return maximumValue + 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int calculateNumberOfWays(int numRows, int numColumns)\n{\n    long mod= 1e9 + 7;\n    long currentWays= 6, previousWays= 6, currentAdjacentWays= 3, previousAdjacentWays= 3;\n    while(--numColumns)\n    {\n        long tempCurrentWays= currentWays, tempCurrentAdjacentWays= currentAdjacentWays;\n        currentWays= (currentWays * 3 + previousWays * 2) % mod;\n        previousWays= (tempCurrentWays * 2 + previousWays * 2) % mod;\n        currentAdjacentWays= (currentAdjacentWays * 3 + previousAdjacentWays * 2) % mod;\n        previousAdjacentWays= (tempCurrentAdjacentWays * 2 + previousAdjacentWays * 2) % mod;\n    }\n    return numRows == 1 ? previousWays : (currentWays + currentAdjacentWays) % mod;\n}",
    "output": "int calculateNumberOfWays(int numRows, int numColumns)\n{\n    long mod= 1e9 + 7;\n    long currentWays= 6, previousWays= 6, currentAdjacentWays= 3, previousAdjacentWays= 3;\n    while(--numColumns)\n    {\n        long tempCurrentWays= currentWays, tempCurrentAdjacentWays= currentAdjacentWays;\n        currentWays= (currentWays * 3 + previousWays * 2) % mod;\n        previousWays= (tempCurrentWays * 2 + previousWays * 2) % mod;\n        currentAdjacentWays= (currentAdjacentWays * 3 + previousAdjacentWays * 2) % mod;\n        previousAdjacentWays= (tempCurrentAdjacentWays * 2 + previousAdjacentWays * 2) % mod;\n    }\n    return numRows == 1 ? previousWays : (currentWays + currentAdjacentWays) % mod;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nTreeNode *canMerge(vector<TreeNode *> &forest)\n{\n    unordered_map<int, int> leafCount;\n    unordered_map<int, TreeNode *> rootMap;\n    \n    for (int i = 0; i < forest.size(); ++i)\n    {\n        TreeNode *tree = forest[i];\n        if (tree->leftChild)\n        {\n            leafCount[tree->leftChild->value]++;\n        }\n        if (tree->rightChild)\n        {\n            leafCount[tree->rightChild->value]++;\n        }\n        rootMap[tree->value] = tree;\n    }\n\n    function<bool(TreeNode *, int, int)> isValidBST = [&](TreeNode *currentNode, int minValue, int maxValue)\n    {\n        if (!currentNode)\n        {\n            return true;\n        }\n        if (currentNode->value <= minValue || currentNode->value >= maxValue)\n        {\n            return false;\n        }\n        return isValidBST(currentNode->leftChild, minValue, currentNode->value) && isValidBST(currentNode->rightChild, currentNode->value, maxValue);\n    };\n\n    for (int i = 0; i < forest.size(); ++i)\n    {\n        TreeNode *tree = forest[i];\n        if (leafCount[tree->value] == 0)\n        {\n            if (isValidBST(tree, 0, 5e4 + 1))\n            {\n                return tree;\n            }\n            break;\n        }\n    }\n    return NULL;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nTreeNode *canMerge(std::vector<TreeNode *> &forest)\n{\n    std::unordered_map<int, int> leafCount;\n    std::unordered_map<int, TreeNode *> rootMap;\n\n    for(TreeNode *tree : forest)\n    {\n        if(tree->leftChild)\n        {\n            leafCount[tree->leftChild->value]++;\n        }\n        if(tree->rightChild)\n        {\n            leafCount[tree->rightChild->value]++;\n        }\n        rootMap[tree->value]= tree;\n    }\n\n    std::function<bool(TreeNode *, int, int)> isValidBST= [&](TreeNode *currentNode, int minValue, int maxValue)\n    {\n        if(!currentNode)\n        {\n            return true;\n        }\n        if(currentNode->value <= minValue || currentNode->value >= maxValue)\n        {\n            return false;\n        }\n        return isValidBST(currentNode->leftChild, minValue, currentNode->value) && isValidBST(currentNode->rightChild, currentNode->value, maxValue);\n    };\n\n    for(TreeNode *tree : forest)\n    {\n        if(leafCount[tree->value] == 0)\n        {\n            if(isValidBST(tree, 0, 5e4 + 1))\n            {\n                return tree;\n            }\n            break;\n        }\n    }\n    return NULL;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// Include this header for std::istringstream\nusing namespace std;\n\nint numDifferentIntegers(string inputWord)\n{\n    for (int i = 0; i < inputWord.size(); ++i)\n    {\n        char &character = inputWord[i];\n        if (character < '0' || character > '9')\n        {\n            character = ' ';\n        }\n    }\n    istringstream inputStream(inputWord);\n    string currentNumber;\n    unordered_set<string> uniqueNumbers;\n    while (inputStream >> currentNumber)\n    {\n        currentNumber.erase(0, currentNumber.find_first_not_of('0'));\n        uniqueNumbers.insert(currentNumber);\n    }\n    return uniqueNumbers.size();\n}",
    "output": "#include <bits/stdc++.h>\nint numDifferentIntegers(std::string inputWord)\n{\n    for(char &character : inputWord)\n    {\n        if(character < '0' || character > '9')\n        {\n            character= ' ';\n        }\n    }\n    std::istringstream inputStream(inputWord);\n    std::string currentNumber;\n    std::unordered_set<std::string> uniqueNumbers;\n    while(inputStream >> currentNumber)\n    {\n        currentNumber.erase(0, currentNumber.find_first_not_of('0'));\n        uniqueNumbers.insert(currentNumber);\n    }\n    return uniqueNumbers.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int minOperations(int divisor)\n{\n    int operationCount= 1;\n    int currentValue= 1;\n\n    while(currentValue % divisor != 0)\n    {\n        currentValue= (currentValue * 2) % divisor;\n        operationCount++;\n    }\n\n    return operationCount;\n}",
    "output": "int minOperations(int divisor)\n{\n    int operationCount= 1;\n    int currentValue= 1;\n\n    while(currentValue % divisor != 0)\n    {\n        currentValue= (currentValue * 2) % divisor;\n        operationCount++;\n    }\n\n    return operationCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// Include for general I/O operations (optional depending on use case)\nusing namespace std;\n\nconst int modulus= 1e9 + 7;\n\nint numberOfNiceDivisors(int totalPrimeFactors)\n{\n    long long divisorCount= 1;\n    for(int prime= 2; prime <= totalPrimeFactors; ++prime)\n    {\n        if(totalPrimeFactors % prime == 0)\n        {\n            int primeCount= 0;\n            while(totalPrimeFactors % prime == 0)\n            {\n                totalPrimeFactors/= prime;\n                ++primeCount;\n            }\n            divisorCount= (divisorCount * (primeCount * 2 + 1)) % modulus;\n        }\n    }\n    return divisorCount;\n}",
    "output": "#include <bits/stdc++.h>\nconst int modulus = 1e9 + 7;\n\nint numberOfNiceDivisors(int totalPrimeFactors)\n{\n    long long divisorCount = 1;\n    for(int prime = 2; prime <= totalPrimeFactors; ++prime)\n    {\n        if(totalPrimeFactors % prime == 0)\n        {\n            int primeCount = 0;\n            while(totalPrimeFactors % prime == 0)\n            {\n                totalPrimeFactors /= prime;\n                ++primeCount;\n            }\n            divisorCount = (divisorCount * (primeCount * 2 + 1)) % modulus;\n        }\n    }\n    return divisorCount;\n}\n"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPoints(vector<vector<int>> &points)\n{\n    int rowCount = points.size(), columnCount = points[0].size();\n    vector<long> dynamicProgramming(columnCount, 0);\n    for (int i = 0; i < rowCount; ++i) // Modified to traditional for loop\n    {\n        vector<long> nextDynamicProgramming(columnCount, 0);\n        for (int columnIndex1 = 0; columnIndex1 < columnCount; ++columnIndex1)\n        {\n            long currentScore = dynamicProgramming[columnIndex1] + points[i][columnIndex1] - columnIndex1;\n            for (int columnIndex2 = 0; columnIndex2 < columnCount; ++columnIndex2)\n            {\n                nextDynamicProgramming[columnIndex2] = max(nextDynamicProgramming[columnIndex2], currentScore - points[i][columnIndex1] + columnIndex2);\n            }\n        }\n        dynamicProgramming.swap(nextDynamicProgramming);\n    }\n    return *max_element(dynamicProgramming.begin(), dynamicProgramming.end());\n}",
    "output": "#include <bits/stdc++.h>\nint maxPoints(std::vector<std::vector<int>> &points)\n{\n    int rowCount= points.size(), columnCount= points[0].size();\n    std::vector<long> dynamicProgramming(columnCount, 0);\n    for(auto &currentRow : points)\n    {\n        std::vector<long> nextDynamicProgramming(columnCount, 0);\n        for(int columnIndex1= 0; columnIndex1 < columnCount; ++columnIndex1)\n        {\n            long currentScore= dynamicProgramming[columnIndex1] + currentRow[columnIndex1] - columnIndex1;\n            for(int columnIndex2= 0; columnIndex2 < columnCount; ++columnIndex2)\n            {\n                nextDynamicProgramming[columnIndex2]= std::max(nextDynamicProgramming[columnIndex2], currentScore - currentRow[columnIndex1] + columnIndex2);\n            }\n        }\n        dynamicProgramming.swap(nextDynamicProgramming);\n    }\n    return *std::max_element(dynamicProgramming.begin(), dynamicProgramming.end());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numberList)\n{\n    int totalOperations= 0;\n    for(int index= 1; index < numberList.size(); ++index)\n    {\n        if(numberList[index] <= numberList[index - 1])\n        {\n            totalOperations+= numberList[index - 1] - numberList[index] + 1;\n            numberList[index]= numberList[index - 1] + 1;\n        }\n    }\n    return totalOperations;\n}",
    "output": "#include <bits/stdc++.h>\nint minOperations(std::vector<int> &numberList)\n{\n    int totalOperations= 0;\n    for(int index= 1; index < numberList.size(); ++index)\n    {\n        if(numberList[index] <= numberList[index - 1])\n        {\n            totalOperations+= numberList[index - 1] - numberList[index] + 1;\n            numberList[index]= numberList[index - 1] + 1;\n        }\n    }\n    return totalOperations;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateSortedStringCount(string inputString)\n{\n    const int modulo= 1e9 + 7;\n    int stringLength= inputString.size();\n    vector<int> factorial(stringLength + 1, 1);\n    vector<int> inverse(stringLength + 1, 1);\n\n    for(int index= 1; index <= stringLength; ++index)\n    {\n        factorial[index]= 1LL * factorial[index - 1] * index % modulo;\n        inverse[index]= 1LL * inverse[index - 1] * (modulo - modulo / index) % modulo;\n    }\n\n    int result= 0;\n    for(int index= 0; index < stringLength; ++index)\n    {\n        int countLessThan= 0;\n        for(int j= index + 1; j < stringLength; ++j)\n        {\n            if(inputString[j] < inputString[index])\n                ++countLessThan;\n        }\n        result= (result + 1LL * countLessThan * factorial[stringLength - index - 1] % modulo) % modulo;\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateSortedStringCount(std::string inputString)\n{\n    const int modulo= 1e9 + 7;\n    int stringLength= inputString.size();\n    std::vector<int> factorial(stringLength + 1, 1);\n    std::vector<int> inverse(stringLength + 1, 1);\n\n    for(int index= 1; index <= stringLength; ++index)\n    {\n        factorial[index]= 1LL * factorial[index - 1] * index % modulo;\n        inverse[index]= 1LL * inverse[index - 1] * (modulo - modulo / index) % modulo;\n    }\n\n    int result= 0;\n    for(int index= 0; index < stringLength; ++index)\n    {\n        int countLessThan= 0;\n        for(int j= index + 1; j < stringLength; ++j)\n        {\n            if(inputString[j] < inputString[index])\n                ++countLessThan;\n        }\n        result= (result + 1LL * countLessThan * factorial[stringLength - index - 1] % modulo) % modulo;\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint smallestChair(vector<vector<int>> &arrivalDepartureTimes, int targetFriendIndex)\n{\n    multimap<int, int> eventTimeline;\n    for(int friendIndex= 0; friendIndex < arrivalDepartureTimes.size(); ++friendIndex)\n    {\n        eventTimeline.insert({arrivalDepartureTimes[friendIndex][0], friendIndex});\n        eventTimeline.insert({arrivalDepartureTimes[friendIndex][1], ~friendIndex});\n    }\n\n    set<int> availableChairs;\n    vector<int> assignedChairs(arrivalDepartureTimes.size());\n\n    // Traditional for loop instead of range-based for loop\n    auto it = eventTimeline.begin();\n    for (size_t i = 0; i < eventTimeline.size(); ++i, ++it)\n    {\n        const auto &event = *it;\n        int eventTime = event.first;\n        int index = event.second;\n\n        if(index >= 0)\n        {\n            int chair = *availableChairs.begin();\n            availableChairs.erase(availableChairs.begin());\n            assignedChairs[index] = chair;\n            if(index == targetFriendIndex)\n                return chair;\n        }\n        else\n        {\n            availableChairs.insert(assignedChairs[~index]);\n        }\n    }\n\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint smallestChair(std::vector<std::vector<int>> &arrivalDepartureTimes, int targetFriendIndex)\n{\n    std::multimap<int, int> eventTimeline;\n    for(int friendIndex= 0; friendIndex < arrivalDepartureTimes.size(); ++friendIndex)\n    {\n        eventTimeline.insert({arrivalDepartureTimes[friendIndex][0], friendIndex});\n        eventTimeline.insert({arrivalDepartureTimes[friendIndex][1], ~friendIndex});\n    }\n\n    std::set<int> availableChairs;\n    std::vector<int> assignedChairs(arrivalDepartureTimes.size());\n\n    for(const auto &[eventTime, index] : eventTimeline)\n    {\n        if(index >= 0)\n        {\n            int chair= *availableChairs.begin();\n            availableChairs.erase(availableChairs.begin());\n            assignedChairs[index]= chair;\n            if(index == targetFriendIndex)\n                return chair;\n        }\n        else\n        {\n            availableChairs.insert(assignedChairs[~index]);\n        }\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> splitPainting(vector<vector<int>> &colorSegments)\n{\n    map<int, int> colorLine;\n    for (int i = 0; i < colorSegments.size(); ++i)\n    {\n        const vector<int> &segment = colorSegments[i];\n        int startPoint = segment[0];\n        int endPoint = segment[1];\n        int colorValue = segment[2];\n        colorLine[startPoint] += colorValue;\n        colorLine[endPoint] -= colorValue;\n    }\n    vector<vector<int>> result;\n    int previousPoint = 0, accumulatedColor = 0;\n    for (auto it = colorLine.begin(); it != colorLine.end(); ++it)\n    {\n        if (previousPoint > 0)\n        {\n            if (accumulatedColor > 0)\n            {\n                result.push_back({previousPoint, it->first, accumulatedColor});\n            }\n        }\n        previousPoint = it->first;\n        accumulatedColor += it->second;\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> splitPainting(std::vector<std::vector<int>> &colorSegments)\n{\n    std::map<int, int> colorLine;\n    for(const std::vector<int> &segment : colorSegments)\n    {\n        int startPoint= segment[0];\n        int endPoint= segment[1];\n        int colorValue= segment[2];\n        colorLine[startPoint]+= colorValue;\n        colorLine[endPoint]-= colorValue;\n    }\n    std::vector<std::vector<int>> result;\n    int previousPoint= 0, accumulatedColor= 0;\n    for(auto it= colorLine.begin(); it != colorLine.end(); ++it)\n    {\n        if(previousPoint > 0)\n        {\n            if(accumulatedColor > 0)\n            {\n                result.push_back({previousPoint, it->first, accumulatedColor});\n            }\n        }\n        previousPoint= it->first;\n        accumulatedColor+= it->second;\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring truncateSentence(string sentence, int wordCount)\n{\n    istringstream inputStream(sentence);\n    string currentWord, truncatedResult;\n    while(wordCount > 0 && inputStream >> currentWord)\n    {\n        truncatedResult+= currentWord;\n        wordCount--;\n        if(wordCount > 0)\n            truncatedResult+= \" \";\n    }\n    return truncatedResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string truncateSentence(std::string sentence, int wordCount)\n{\n    std::istringstream inputStream(sentence);\n    std::string currentWord, truncatedResult;\n    while(wordCount > 0 && inputStream >> currentWord)\n    {\n        truncatedResult += currentWord;\n        wordCount--;\n        if(wordCount > 0)\n            truncatedResult += \" \";\n    }\n    return truncatedResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findingUsersActiveMinutes(vector<vector<int>> &activityLogs, int totalMinutes)\n{\n    unordered_map<int, unordered_set<int>> userActiveMinutes;\n    for (int i = 0; i < activityLogs.size(); ++i)\n    {\n        userActiveMinutes[activityLogs[i][0]].insert(activityLogs[i][1]);\n    }\n    vector<int> activeMinutesCount(totalMinutes, 0);\n    for (auto it = userActiveMinutes.begin(); it != userActiveMinutes.end(); ++it)\n    {\n        if (it->second.size() <= totalMinutes)\n        {\n            activeMinutesCount[it->second.size() - 1]++;\n        }\n    }\n    return activeMinutesCount;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findingUsersActiveMinutes(std::vector<std::vector<int>> &activityLogs, int totalMinutes)\n{\n    std::unordered_map<int, std::unordered_set<int>> userActiveMinutes;\n    for(const auto &logEntry : activityLogs)\n    {\n        userActiveMinutes[logEntry[0]].insert(logEntry[1]);\n    }\n    std::vector<int> activeMinutesCount(totalMinutes, 0);\n    for(const auto &userEntry : userActiveMinutes)\n    {\n        if(userEntry.second.size() <= totalMinutes)\n        {\n            activeMinutesCount[userEntry.second.size() - 1]++;\n        }\n    }\n    return activeMinutesCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minAbsoluteSumDiff(vector<int> &sourceArray, vector<int> &targetArray)\n{\n    int arraySize = sourceArray.size();\n    long long totalDifference = 0;\n    int maximumDifference = 0;\n    int modulus = 1e9 + 7;\n    vector<int> sortedSourceArray = sourceArray;\n    sort(sortedSourceArray.begin(), sortedSourceArray.end());\n\n    for(int index = 0; index < arraySize; ++index)\n    {\n        int difference = abs(sourceArray[index] - targetArray[index]);\n        totalDifference += difference;\n\n        int position = lower_bound(sortedSourceArray.begin(), sortedSourceArray.end(), targetArray[index]) - sortedSourceArray.begin();\n        if(position != arraySize)\n        {\n            maximumDifference = max(maximumDifference, difference - abs(sortedSourceArray[position] - targetArray[index]));\n        }\n        if(position != 0)\n        {\n            maximumDifference = max(maximumDifference, difference - abs(sortedSourceArray[position - 1] - targetArray[index]));\n        }\n    }\n    return (totalDifference - maximumDifference + modulus) % modulus;\n}",
    "output": "#include <bits/stdc++.h>\nint minAbsoluteSumDiff(std::vector<int> &sourceArray, std::vector<int> &targetArray)\n{\n    int arraySize= sourceArray.size();\n    long long totalDifference= 0;\n    int maximumDifference= 0;\n    int modulus= 1e9 + 7;\n    std::vector<int> sortedSourceArray= sourceArray;\n    std::sort(sortedSourceArray.begin(), sortedSourceArray.end());\n\n    for(int index= 0; index < arraySize; ++index)\n    {\n        int difference= abs(sourceArray[index] - targetArray[index]);\n        totalDifference+= difference;\n\n        int position= lower_bound(sortedSourceArray.begin(), sortedSourceArray.end(), targetArray[index]) - sortedSourceArray.begin();\n        if(position != arraySize)\n        {\n            maximumDifference= max(maximumDifference, difference - abs(sortedSourceArray[position] - targetArray[index]));\n        }\n        if(position != 0)\n        {\n            maximumDifference= max(maximumDifference, difference - abs(sortedSourceArray[position - 1] - targetArray[index]));\n        }\n    }\n    return (totalDifference - maximumDifference + modulus) % modulus;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countDifferentSubsequenceGCDs(vector<int> &numberList)\n{\n    int maximumValue = *max_element(numberList.begin(), numberList.end());\n    vector<int> gcdCount(maximumValue + 1, 0);\n\n    for (int i = 0; i < numberList.size(); ++i)\n    {\n        int number = numberList[i];\n        for (int divisor = 1; divisor * divisor <= number; divisor++)\n        {\n            if (number % divisor == 0)\n            {\n                gcdCount[divisor]++;\n                if (divisor * divisor != number)\n                {\n                    gcdCount[number / divisor]++;\n                }\n            }\n        }\n    }\n\n    int differentGCDsCount = 0;\n    for (int i = 1; i <= maximumValue; i++)\n    {\n        if (gcdCount[i])\n        {\n            differentGCDsCount++;\n        }\n    }\n\n    return differentGCDsCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countDifferentSubsequenceGCDs(std::vector<int> &numberList)\n{\n    int maximumValue = *std::max_element(numberList.begin(), numberList.end());\n    std::vector<int> gcdCount(maximumValue + 1, 0);\n\n    for(int number : numberList)\n    {\n        for(int divisor = 1; divisor * divisor <= number; divisor++)\n        {\n            if(number % divisor == 0)\n            {\n                gcdCount[divisor]++;\n                if(divisor * divisor != number)\n                {\n                    gcdCount[number / divisor]++;\n                }\n            }\n        }\n    }\n\n    int differentGCDsCount = 0;\n    for(int i = 1; i <= maximumValue; i++)\n    {\n        if(gcdCount[i])\n        {\n            differentGCDsCount++;\n        }\n    }\n\n    return differentGCDsCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<string>> deleteDuplicateFolder(vector<vector<string>> &folderPaths)\n{\n    map<string, int> folderCountMap;\n\n    for (int i = 0; i < folderPaths.size(); ++i)\n    {\n        auto &folderPath = folderPaths[i];\n        string fullPath = \"/\" + folderPath[0];\n        for (int index = 1; index < folderPath.size(); index++)\n        {\n            fullPath += \"/\" + folderPath[index];\n        }\n        folderCountMap[fullPath]++;\n    }\n\n    vector<vector<string>> uniqueFolderPaths;\n\n    for (int i = 0; i < folderPaths.size(); ++i)\n    {\n        auto &folderPath = folderPaths[i];\n        string fullPath = \"/\" + folderPath[0];\n        bool isUnique = folderCountMap[fullPath] == 1;\n        for (int index = 1; isUnique && index < folderPath.size(); index++)\n        {\n            fullPath += \"/\" + folderPath[index];\n            if (folderCountMap[fullPath] > 1)\n            {\n                isUnique = false;\n            }\n        }\n        if (isUnique)\n        {\n            uniqueFolderPaths.push_back(folderPath);\n        }\n    }\n\n    return uniqueFolderPaths;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<std::string>> deleteDuplicateFolder(std::vector<std::vector<std::string>> &folderPaths)\n{\n    std::map<std::string, int> folderCountMap;\n\n    for(auto &folderPath : folderPaths)\n    {\n        std::string fullPath= \"/\" + folderPath[0];\n        for(int index= 1; index < folderPath.size(); index++)\n        {\n            fullPath+= \"/\" + folderPath[index];\n        }\n        folderCountMap[fullPath]++;\n    }\n\n    std::vector<std::vector<std::string>> uniqueFolderPaths;\n\n    for(auto &folderPath : folderPaths)\n    {\n        std::string fullPath= \"/\" + folderPath[0];\n        bool isUnique= folderCountMap[fullPath] == 1;\n        for(int index= 1; isUnique && index < folderPath.size(); index++)\n        {\n            fullPath+= \"/\" + folderPath[index];\n            if(folderCountMap[fullPath] > 1)\n            {\n                isUnique= false;\n            }\n        }\n        if(isUnique)\n        {\n            uniqueFolderPaths.push_back(folderPath);\n        }\n    }\n\n    return uniqueFolderPaths;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint signFunc(int inputNumber)\n{\n    if(inputNumber > 0)\n        return 1;\n    if(inputNumber < 0)\n        return -1;\n    return 0;\n}\n\nint arraySign(vector<int> &numberArray)\n{\n    int productResult = 1;\n    for (int i = 0; i < numberArray.size(); ++i)\n    {\n        int currentNumber = numberArray[i];\n        productResult *= currentNumber;\n    }\n    return signFunc(productResult);\n}",
    "output": "#include <bits/stdc++.h>\nint signFunc(int inputNumber)\n{\n    if(inputNumber > 0)\n        return 1;\n    if(inputNumber < 0)\n        return -1;\n    return 0;\n}\n\nint arraySign(std::vector<int> &numberArray)\n{\n    int productResult= 1;\n    for(int currentNumber : numberArray)\n    {\n        productResult*= currentNumber;\n    }\n    return signFunc(productResult);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minSideJumps(vector<int> &obstacles)\n{\n    vector<vector<int>> dynamicProgramming(obstacles.size(), vector<int>(3, obstacles.size()));\n    dynamicProgramming[0][1]= 0;\n    dynamicProgramming[0][0]= 1;\n    dynamicProgramming[0][2]= 1;\n\n    for(size_t currentIndex= 1; currentIndex < obstacles.size(); ++currentIndex)\n    {\n        if(obstacles[currentIndex] != 1)\n            dynamicProgramming[currentIndex][0]= min(dynamicProgramming[currentIndex - 1][0], min(dynamicProgramming[currentIndex - 1][1] + 1, dynamicProgramming[currentIndex - 1][2] + 1));\n\n        if(obstacles[currentIndex] != 2)\n            dynamicProgramming[currentIndex][1]= min(dynamicProgramming[currentIndex - 1][1], min(dynamicProgramming[currentIndex - 1][0] + 1, dynamicProgramming[currentIndex - 1][2] + 1));\n\n        if(obstacles[currentIndex] != 3)\n            dynamicProgramming[currentIndex][2]= min(dynamicProgramming[currentIndex - 1][2], min(dynamicProgramming[currentIndex - 1][0] + 1, dynamicProgramming[currentIndex - 1][1] + 1));\n    }\n    return min(dynamicProgramming.back()[0], min(dynamicProgramming.back()[1], dynamicProgramming.back()[2]));\n}",
    "output": "#include <bits/stdc++.h>\nint minSideJumps(std::vector<int> &obstacles)\n{\n    std::vector<std::vector<int>> dynamicProgramming(obstacles.size(), std::vector<int>(3, obstacles.size()));\n    dynamicProgramming[0][1] = 0;\n    dynamicProgramming[0][0] = 1;\n    dynamicProgramming[0][2] = 1;\n\n    for(size_t currentIndex = 1; currentIndex < obstacles.size(); ++currentIndex)\n    {\n        if(obstacles[currentIndex] != 1)\n            dynamicProgramming[currentIndex][0] = std::min(dynamicProgramming[currentIndex - 1][0], std::min(dynamicProgramming[currentIndex - 1][1] + 1, dynamicProgramming[currentIndex - 1][2] + 1));\n\n        if(obstacles[currentIndex] != 2)\n            dynamicProgramming[currentIndex][1] = std::min(dynamicProgramming[currentIndex - 1][1], std::min(dynamicProgramming[currentIndex - 1][0] + 1, dynamicProgramming[currentIndex - 1][2] + 1));\n\n        if(obstacles[currentIndex] != 3)\n            dynamicProgramming[currentIndex][2] = std::min(dynamicProgramming[currentIndex - 1][2], std::min(dynamicProgramming[currentIndex - 1][0] + 1, dynamicProgramming[currentIndex - 1][1] + 1));\n    }\n    return std::min(dynamicProgramming.back()[0], std::min(dynamicProgramming.back()[1], dynamicProgramming.back()[2]));\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// Optional: if you need input/output functions\n\nusing namespace std;\n\nclass MKAverage\n{\n  public:\n    int totalElements, elementsToExclude;\n    long long totalSum = 0;\n    multiset<int> minSet, midSet, maxSet;\n    queue<int> elementQueue;\n\n    MKAverage(int m, int k) : totalElements(m), elementsToExclude(k) {}\n\n    void addElement(int newElement)\n    {\n        if (elementQueue.size() == totalElements)\n        {\n            removeElement();\n        }\n\n        minSet.insert(newElement);\n        totalSum += newElement;\n\n        if (minSet.size() > elementsToExclude)\n        {\n            int largestMin = *minSet.rbegin();\n            minSet.erase(minSet.find(largestMin));\n            midSet.insert(largestMin);\n            totalSum += largestMin;\n        }\n\n        if (!midSet.empty() && *minSet.rbegin() > *midSet.begin())\n        {\n            int largestMin = *minSet.rbegin();\n            int smallestMid = *midSet.begin();\n            minSet.erase(minSet.find(largestMin));\n            midSet.erase(midSet.find(smallestMid));\n            minSet.insert(smallestMid);\n            midSet.insert(largestMin);\n            totalSum += smallestMid - largestMin;\n        }\n\n        maxSet.insert(*midSet.rbegin());\n        totalSum -= *midSet.rbegin();\n        midSet.erase(prev(midSet.end()));\n\n        if (maxSet.size() > elementsToExclude)\n        {\n            int smallestMax = *maxSet.begin();\n            maxSet.erase(maxSet.find(smallestMax));\n            midSet.insert(smallestMax);\n            totalSum += smallestMax;\n        }\n\n        elementQueue.push(newElement);\n    }\n\n    int calculateMKAverage()\n    {\n        if (elementQueue.size() < totalElements)\n        {\n            return -1;\n        }\n        return totalSum / (totalElements - 2 * elementsToExclude);\n    }\n\n    void removeElement()\n    {\n        int oldestElement = elementQueue.front();\n        elementQueue.pop();\n\n        if (minSet.count(oldestElement))\n        {\n            minSet.erase(minSet.find(oldestElement));\n        }\n        else if (midSet.count(oldestElement))\n        {\n            midSet.erase(midSet.find(oldestElement));\n            totalSum -= oldestElement;\n        }\n        else\n        {\n            maxSet.erase(maxSet.find(oldestElement));\n        }\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass MKAverage\n{\n  public:\n    int totalElements, elementsToExclude;\n    long long totalSum= 0;\n    std::multiset<int> minSet, midSet, maxSet;\n    std::queue<int> elementQueue;\n\n    MKAverage(int m, int k) : totalElements(m), elementsToExclude(k) {}\n\n    void addElement(int newElement)\n    {\n        if(elementQueue.size() == totalElements)\n        {\n            removeElement();\n        }\n\n        minSet.insert(newElement);\n        totalSum+= newElement;\n\n        if(minSet.size() > elementsToExclude)\n        {\n            int largestMin= *minSet.rbegin();\n            minSet.erase(minSet.find(largestMin));\n            midSet.insert(largestMin);\n            totalSum+= largestMin;\n        }\n\n        if(!midSet.empty() && *minSet.rbegin() > *midSet.begin())\n        {\n            int largestMin= *minSet.rbegin();\n            int smallestMid= *midSet.begin();\n            minSet.erase(minSet.find(largestMin));\n            midSet.erase(midSet.find(smallestMid));\n            minSet.insert(smallestMid);\n            midSet.insert(largestMin);\n            totalSum+= smallestMid - largestMin;\n        }\n\n        maxSet.insert(*midSet.rbegin());\n        totalSum-= *midSet.rbegin();\n        midSet.erase(std::prev(midSet.end()));\n\n        if(maxSet.size() > elementsToExclude)\n        {\n            int smallestMax= *maxSet.begin();\n            maxSet.erase(maxSet.find(smallestMax));\n            midSet.insert(smallestMax);\n            totalSum+= smallestMax;\n        }\n\n        elementQueue.push(newElement);\n    }\n\n    int calculateMKAverage()\n    {\n        if(elementQueue.size() < totalElements)\n        {\n            return -1;\n        }\n        return totalSum / (totalElements - 2 * elementsToExclude);\n    }\n\n    void removeElement()\n    {\n        int oldestElement= elementQueue.front();\n        elementQueue.pop();\n\n        if(minSet.count(oldestElement))\n        {\n            minSet.erase(minSet.find(oldestElement));\n        }\n        else if(midSet.count(oldestElement))\n        {\n            midSet.erase(midSet.find(oldestElement));\n            totalSum-= oldestElement;\n        }\n        else\n        {\n            maxSet.erase(maxSet.find(oldestElement));\n        }\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring replaceDigits(string inputString)\n{\n    for(int index= 1; index < inputString.size(); index+= 2)\n    {\n        inputString[index]= inputString[index - 1] + (inputString[index] - '0');\n    }\n    return inputString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string replaceDigits(std::string inputString)\n{\n    for(int index= 1; index < inputString.size(); index+= 2)\n    {\n        inputString[index]= inputString[index - 1] + (inputString[index] - '0');\n    }\n    return inputString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass SeatManager\n{\n    priority_queue<int, vector<int>, greater<int>> availableSeats;\n\n  public:\n    SeatManager(int totalSeats)\n    {\n        for(int seatNumber= 1; seatNumber <= totalSeats; ++seatNumber)\n        {\n            availableSeats.push(seatNumber);\n        }\n    }\n\n    int reserve()\n    {\n        int reservedSeat= availableSeats.top();\n        availableSeats.pop();\n        return reservedSeat;\n    }\n\n    void unreserve(int seatNumber)\n    {\n        availableSeats.push(seatNumber);\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass SeatManager\n{\n    std::priority_queue<int, std::vector<int>, std::greater<int>> availableSeats;\n\n  public:\n    SeatManager(int totalSeats)\n    {\n        for(int seatNumber= 1; seatNumber <= totalSeats; ++seatNumber)\n        {\n            availableSeats.push(seatNumber);\n        }\n    }\n\n    int reserve()\n    {\n        int reservedSeat= availableSeats.top();\n        availableSeats.pop();\n        return reservedSeat;\n    }\n\n    void unreserve(int seatNumber)\n    {\n        availableSeats.push(seatNumber);\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxElement(vector<int> &numbers)\n{\n    int maximumValue= *max_element(numbers.begin(), numbers.end());\n    return maximumValue / 2;\n}",
    "output": "#include <bits/stdc++.h>\nint maxElement(std::vector<int> &numbers)\n{\n    int maximumValue= *std::max_element(numbers.begin(), numbers.end());\n    return maximumValue / 2;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool compare(const vector<int> &roomA, const vector<int> &roomB)\n{\n    return roomA[0] < roomB[0];\n}\n\nvector<int> smallestDifferenceRoom(vector<vector<int>> &roomDimensions, vector<vector<int>> &queries)\n{\n    int numberOfRooms= roomDimensions.size();\n    int numberOfQueries= queries.size();\n    sort(roomDimensions.begin(), roomDimensions.end(), compare);\n    vector<int> queryResults;\n\n    for(int queryIndex= 0; queryIndex < numberOfQueries; queryIndex++)\n    {\n        int preferredSize= queries[queryIndex][0];\n        int minRoomSize= queries[queryIndex][1];\n        int smallestDiff= INT_MAX;\n        int selectedRoomIndex= -1;\n\n        for(int roomIndex= 0; roomIndex < numberOfRooms; roomIndex++)\n        {\n            if(roomDimensions[roomIndex][1] >= minRoomSize)\n            {\n                int tempDiff= abs(preferredSize - roomDimensions[roomIndex][0]);\n                if(tempDiff < smallestDiff)\n                {\n                    smallestDiff= tempDiff;\n                    selectedRoomIndex= roomDimensions[roomIndex][0];\n                }\n            }\n        }\n        queryResults.push_back(selectedRoomIndex);\n    }\n\n    return queryResults;\n}",
    "output": "#include <bits/stdc++.h>\nbool compare(const std::vector<int> &roomA, const std::vector<int> &roomB)\n{\n    return roomA[0] < roomB[0];\n}\n\nstd::vector<int> smallestDifferenceRoom(std::vector<std::vector<int>> &roomDimensions, std::vector<std::vector<int>> &queries)\n{\n    int numberOfRooms = roomDimensions.size();\n    int numberOfQueries = queries.size();\n    std::sort(roomDimensions.begin(), roomDimensions.end(), compare);\n    std::vector<int> queryResults;\n\n    for(int queryIndex = 0; queryIndex < numberOfQueries; queryIndex++)\n    {\n        int preferredSize = queries[queryIndex][0];\n        int minRoomSize = queries[queryIndex][1];\n        int smallestDiff = INT_MAX;\n        int selectedRoomIndex = -1;\n\n        for(int roomIndex = 0; roomIndex < numberOfRooms; roomIndex++)\n        {\n            if(roomDimensions[roomIndex][1] >= minRoomSize)\n            {\n                int tempDiff = std::abs(preferredSize - roomDimensions[roomIndex][0]);\n                if(tempDiff < smallestDiff)\n                {\n                    smallestDiff = tempDiff;\n                    selectedRoomIndex = roomDimensions[roomIndex][0];\n                }\n            }\n        }\n        queryResults.push_back(selectedRoomIndex);\n    }\n\n    return queryResults;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool checkMove(vector<vector<char>> &gameBoard, int rowMove, int columnMove, char playerColor)\n{\n    int directionOffsets[8][2]= {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {-1, -1}, {-1, 1}, {1, -1}, {1, 1}};\n    char oppositeColor= (playerColor == 'W') ? 'B' : 'W';\n\n    for(int direction= 0; direction < 8; direction++)\n    {\n        int x= rowMove + directionOffsets[direction][0], y= columnMove + directionOffsets[direction][1], count= 0;\n        while(x >= 0 && x < 8 && y >= 0 && y < 8 && gameBoard[x][y] == oppositeColor)\n        {\n            x+= directionOffsets[direction][0];\n            y+= directionOffsets[direction][1];\n            count++;\n        }\n\n        if(count > 0 && x >= 0 && x < 8 && y >= 0 && y < 8 && gameBoard[x][y] == playerColor)\n        {\n            return true;\n        }\n    }\n\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool checkMove(std::vector<std::vector<char>> &gameBoard, int rowMove, int columnMove, char playerColor)\n{\n    int directionOffsets[8][2]= {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {-1, -1}, {-1, 1}, {1, -1}, {1, 1}};\n    char oppositeColor= (playerColor == 'W') ? 'B' : 'W';\n\n    for(int direction= 0; direction < 8; direction++)\n    {\n        int x= rowMove + directionOffsets[direction][0], y= columnMove + directionOffsets[direction][1], count= 0;\n        while(x >= 0 && x < 8 && y >= 0 && y < 8 && gameBoard[x][y] == oppositeColor)\n        {\n            x+= directionOffsets[direction][0];\n            y+= directionOffsets[direction][1];\n            count++;\n        }\n\n        if(count > 0 && x >= 0 && x < 8 && y >= 0 && y < 8 && gameBoard[x][y] == playerColor)\n        {\n            return true;\n        }\n    }\n\n    return false;\n}\n"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minSpaceWastedKResizing(vector<int> &numSizes, int maxResizes)\n{\n    int totalElements= numSizes.size();\n    vector<vector<int>> wasteDP(totalElements + 1, vector<int>(maxResizes + 1, numeric_limits<int>::max() / 3));\n    vector<int> cumulativeSum(totalElements + 1, 0);\n    wasteDP[0][0]= 0;\n\n    for(int currentIndex= 1; currentIndex <= totalElements; currentIndex++)\n    {\n        cumulativeSum[currentIndex]= cumulativeSum[currentIndex - 1] + numSizes[currentIndex - 1];\n        int maxValue= numSizes[currentIndex - 1];\n\n        for(int previousIndex= currentIndex - 1; previousIndex >= 0; previousIndex--)\n        {\n            maxValue= max(maxValue, numSizes[previousIndex]);\n            int waste= maxValue * (currentIndex - previousIndex) - (cumulativeSum[currentIndex] - cumulativeSum[previousIndex]);\n\n            for(int resizeCount= 0; resizeCount < maxResizes; resizeCount++)\n            {\n                wasteDP[currentIndex][resizeCount + 1]= min(wasteDP[currentIndex][resizeCount + 1], wasteDP[previousIndex][resizeCount] + waste);\n            }\n        }\n    }\n\n    return wasteDP[totalElements][maxResizes];\n}",
    "output": "#include <bits/stdc++.h>\nint minSpaceWastedKResizing(std::vector<int> &numSizes, int maxResizes)\n{\n    int totalElements= numSizes.size();\n    std::vector<std::vector<int>> wasteDP(totalElements + 1, std::vector<int>(maxResizes + 1, std::numeric_limits<int>::max() / 3));\n    std::vector<int> cumulativeSum(totalElements + 1, 0);\n    wasteDP[0][0]= 0;\n\n    for(int currentIndex= 1; currentIndex <= totalElements; currentIndex++)\n    {\n        cumulativeSum[currentIndex]= cumulativeSum[currentIndex - 1] + numSizes[currentIndex - 1];\n        int maxValue= numSizes[currentIndex - 1];\n\n        for(int previousIndex= currentIndex - 1; previousIndex >= 0; previousIndex--)\n        {\n            maxValue= std::max(maxValue, numSizes[previousIndex]);\n            int waste= maxValue * (currentIndex - previousIndex) - (cumulativeSum[currentIndex] - cumulativeSum[previousIndex]);\n\n            for(int resizeCount= 0; resizeCount < maxResizes; resizeCount++)\n            {\n                wasteDP[currentIndex][resizeCount + 1]= std::min(wasteDP[currentIndex][resizeCount + 1], wasteDP[previousIndex][resizeCount] + waste);\n            }\n        }\n    }\n\n    return wasteDP[totalElements][maxResizes];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPangram(const string &sentence)\n{\n    vector<bool> alphabet(26, false);\n    for (int i = 0; i < sentence.size(); ++i)\n    {\n        char character = sentence[i];\n        alphabet[character - 'a'] = true;\n    }\n    for (int i = 0; i < alphabet.size(); ++i)\n    {\n        if (!alphabet[i])\n            return false;\n    }\n    return true;\n}",
    "output": "bool isPangram(const std::string &sentence)\n{\n    std::vector<bool> alphabet(26, false);\n    for(const char &character : sentence)\n    {\n        alphabet[character - 'a']= true;\n    }\n    for(bool isPresent : alphabet)\n    {\n        if(!isPresent)\n            return false;\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxIceCream(vector<int> &iceCreamCosts, int totalCoins)\n{\n    sort(iceCreamCosts.begin(), iceCreamCosts.end());\n    int iceCreamCount = 0;\n    for (int i = 0; i < iceCreamCosts.size(); ++i)\n    {\n        int iceCreamCost = iceCreamCosts[i];\n        if (totalCoins >= iceCreamCost)\n        {\n            totalCoins -= iceCreamCost;\n            iceCreamCount++;\n        }\n        else\n        {\n            break;\n        }\n    }\n    return iceCreamCount;\n}",
    "output": "#include <bits/stdc++.h>\nint maxIceCream(std::vector<int> &iceCreamCosts, int totalCoins)\n{\n    std::sort(iceCreamCosts.begin(), iceCreamCosts.end());\n    int iceCreamCount= 0;\n    for(int iceCreamCost : iceCreamCosts)\n    {\n        if(totalCoins >= iceCreamCost)\n        {\n            totalCoins-= iceCreamCost;\n            iceCreamCount++;\n        }\n        else\n        {\n            break;\n        }\n    }\n    return iceCreamCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> getOrder(vector<vector<int>> &taskList)\n{\n    vector<int> taskIndices(taskList.size());\n    for(int i= 0; i < taskList.size(); i++)\n        taskIndices[i]= i;\n\n    sort(taskIndices.begin(), taskIndices.end(), [&](int a, int b)\n         { return taskList[a][0] < taskList[b][0]; });\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> minHeap;\n    long long currentTime= 0;\n    int currentTaskIndex= 0;\n    vector<int> result;\n\n    while(!taskIndices.empty())\n    {\n        while(currentTaskIndex < taskIndices.size() && taskList[taskIndices[currentTaskIndex]][0] <= currentTime)\n        {\n            int index= taskIndices[currentTaskIndex];\n            minHeap.push({taskList[index][1], index});\n            currentTaskIndex++;\n        }\n\n        if(!minHeap.empty())\n        {\n            auto [processingTime, index]= minHeap.top();\n            minHeap.pop();\n            currentTime+= processingTime;\n            result.push_back(index);\n            taskIndices.erase(remove(taskIndices.begin(), taskIndices.end(), index), taskIndices.end());\n        }\n        else if(currentTaskIndex < taskIndices.size())\n        {\n            currentTime= max(currentTime, (long long)taskList[taskIndices[currentTaskIndex]][0]);\n        }\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> getOrder(std::vector<std::vector<int>> &taskList)\n{\n    std::vector<int> taskIndices(taskList.size());\n    for(int i= 0; i < taskList.size(); i++)\n        taskIndices[i]= i;\n\n    std::sort(taskIndices.begin(), taskIndices.end(), [&](int a, int b)\n         { return taskList[a][0] < taskList[b][0]; });\n\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<>> minHeap;\n    long long currentTime= 0;\n    int currentTaskIndex= 0;\n    std::vector<int> result;\n\n    while(!taskIndices.empty())\n    {\n        while(currentTaskIndex < taskIndices.size() && taskList[taskIndices[currentTaskIndex]][0] <= currentTime)\n        {\n            int index= taskIndices[currentTaskIndex];\n            minHeap.push({taskList[index][1], index});\n            currentTaskIndex++;\n        }\n\n        if(!minHeap.empty())\n        {\n            auto [processingTime, index]= minHeap.top();\n            minHeap.pop();\n            currentTime+= processingTime;\n            result.push_back(index);\n            taskIndices.erase(std::remove(taskIndices.begin(), taskIndices.end(), index), taskIndices.end());\n        }\n        else if(currentTaskIndex < taskIndices.size())\n        {\n            currentTime= std::max(currentTime, (long long)taskList[taskIndices[currentTaskIndex]][0]);\n        }\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint getXorSum(vector<int> &firstArray, vector<int> &secondArray)\n{\n    int xorFirstArray = 0, xorSecondArray = 0;\n    for (int i = 0; i < firstArray.size(); ++i)\n        xorFirstArray ^= firstArray[i];\n    for (int i = 0; i < secondArray.size(); ++i)\n        xorSecondArray ^= secondArray[i];\n    return xorFirstArray & xorSecondArray;\n}",
    "output": "int getXorSum(std::vector<int> &firstArray, std::vector<int> &secondArray)\n{\n    int xorFirstArray= 0, xorSecondArray= 0;\n    for(int element : firstArray)\n        xorFirstArray^= element;\n    for(int element : secondArray)\n        xorSecondArray^= element;\n    return xorFirstArray & xorSecondArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> longestObstacleCourse(vector<int> &obstacleHeights)\n{\n    vector<int> dynamicProgrammingArray;\n    vector<int> result(obstacleHeights.size());\n\n    for(int index= 0; index < obstacleHeights.size(); ++index)\n    {\n        auto iterator= lower_bound(dynamicProgrammingArray.begin(), dynamicProgrammingArray.end(), obstacleHeights[index]);\n        result[index]= distance(dynamicProgrammingArray.begin(), iterator) + 1;\n        if(iterator == dynamicProgrammingArray.end())\n        {\n            dynamicProgrammingArray.push_back(obstacleHeights[index]);\n        }\n        else\n        {\n            *iterator= obstacleHeights[index];\n        }\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> longestObstacleCourse(std::vector<int> &obstacleHeights)\n{\n    std::vector<int> dynamicProgrammingArray;\n    std::vector<int> result(obstacleHeights.size());\n\n    for(int index= 0; index < obstacleHeights.size(); ++index)\n    {\n        auto iterator= std::lower_bound(dynamicProgrammingArray.begin(), dynamicProgrammingArray.end(), obstacleHeights[index]);\n        result[index]= std::distance(dynamicProgrammingArray.begin(), iterator) + 1;\n        if(iterator == dynamicProgrammingArray.end())\n        {\n            dynamicProgrammingArray.push_back(obstacleHeights[index]);\n        }\n        else\n        {\n            *iterator= obstacleHeights[index];\n        }\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxFrequency(vector<int> &numbers, int limit)\n{\n    sort(numbers.begin(), numbers.end());\n    int maxFrequencyCount= 1, totalNumbers= numbers.size();\n    long long currentSum= 0;\n    for(int startIndex= 0, endIndex= 0; endIndex < totalNumbers; ++endIndex)\n    {\n        currentSum+= numbers[endIndex];\n        while(currentSum < static_cast<long long>(numbers[endIndex]) * (endIndex - startIndex + 1) - limit)\n        {\n            currentSum-= numbers[startIndex++];\n        }\n        maxFrequencyCount= max(maxFrequencyCount, endIndex - startIndex + 1);\n    }\n    return maxFrequencyCount;\n}",
    "output": "#include <bits/stdc++.h>\nint maxFrequency(std::vector<int> &numbers, int limit)\n{\n    std::sort(numbers.begin(), numbers.end());\n    int maxFrequencyCount= 1, totalNumbers= numbers.size();\n    long long currentSum= 0;\n    for(int startIndex= 0, endIndex= 0; endIndex < totalNumbers; ++endIndex)\n    {\n        currentSum+= numbers[endIndex];\n        while(currentSum < static_cast<long long>(numbers[endIndex]) * (endIndex - startIndex + 1) - limit)\n        {\n            currentSum-= numbers[startIndex++];\n        }\n        maxFrequencyCount= std::max(maxFrequencyCount, endIndex - startIndex + 1);\n    }\n    return maxFrequencyCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint longestBeautifulSubstring(const string &inputWord)\n{\n    if(inputWord.size() < 5)\n        return 0;\n\n    int maxLength= 0, currentLength= 1;\n    string currentVowels= {inputWord[0]};\n\n    for(int index= 1; index < inputWord.size(); ++index)\n    {\n        if(inputWord[index] >= currentVowels.back() && currentVowels.find(inputWord[index]) == string::npos)\n        {\n            currentVowels.push_back(inputWord[index]);\n        }\n        else if(inputWord[index] == currentVowels.back())\n        {\n            // Do nothing\n        }\n        else\n        {\n            currentVowels= inputWord[index];\n            currentLength= 0;\n        }\n\n        currentLength++;\n\n        if(currentVowels == \"aeiou\")\n        {\n            maxLength= max(maxLength, currentLength);\n        }\n    }\n\n    return maxLength;\n}",
    "output": "#include <bits/stdc++.h>\nint longestBeautifulSubstring(const std::string &inputWord)\n{\n    if(inputWord.size() < 5)\n        return 0;\n\n    int maxLength= 0, currentLength= 1;\n    std::string currentVowels= {inputWord[0]};\n\n    for(int index= 1; index < inputWord.size(); ++index)\n    {\n        if(inputWord[index] >= currentVowels.back() && currentVowels.find(inputWord[index]) == std::string::npos)\n        {\n            currentVowels.push_back(inputWord[index]);\n        }\n        else if(inputWord[index] == currentVowels.back())\n        {\n            // Do nothing\n        }\n        else\n        {\n            currentVowels= inputWord[index];\n            currentLength= 0;\n        }\n\n        currentLength++;\n\n        if(currentVowels == \"aeiou\")\n        {\n            maxLength= std::max(maxLength, currentLength);\n        }\n    }\n\n    return maxLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBuilding(int numberOfBuildings, vector<vector<int>> &heightRestrictions)\n{\n    heightRestrictions.push_back({1, 0});\n    heightRestrictions.push_back({numberOfBuildings, numberOfBuildings - 1});\n    sort(heightRestrictions.begin(), heightRestrictions.end());\n\n    int restrictionsCount= heightRestrictions.size();\n    for(int index= 1; index < restrictionsCount; index++)\n        heightRestrictions[index][1]= min(heightRestrictions[index][1], heightRestrictions[index - 1][1] + heightRestrictions[index][0] - heightRestrictions[index - 1][0]);\n\n    for(int index= restrictionsCount - 2; index >= 0; index--)\n        heightRestrictions[index][1]= min(heightRestrictions[index][1], heightRestrictions[index + 1][1] + heightRestrictions[index + 1][0] - heightRestrictions[index][0]);\n\n    int maxHeight= 0;\n    for(int index= 1; index < restrictionsCount; index++)\n    {\n        int possibleHeight= (heightRestrictions[index][1] + heightRestrictions[index - 1][1] + heightRestrictions[index][0] - heightRestrictions[index - 1][0]) / 2;\n        maxHeight= max(maxHeight, possibleHeight);\n    }\n\n    return maxHeight;\n}",
    "output": "#include <bits/stdc++.h>\nint maxBuilding(int numberOfBuildings, std::vector<std::vector<int>> &heightRestrictions)\n{\n    heightRestrictions.push_back({1, 0});\n    heightRestrictions.push_back({numberOfBuildings, numberOfBuildings - 1});\n    std::sort(heightRestrictions.begin(), heightRestrictions.end());\n\n    int restrictionsCount= heightRestrictions.size();\n    for(int index= 1; index < restrictionsCount; index++)\n        heightRestrictions[index][1]= std::min(heightRestrictions[index][1], heightRestrictions[index - 1][1] + heightRestrictions[index][0] - heightRestrictions[index - 1][0]);\n\n    for(int index= restrictionsCount - 2; index >= 0; index--)\n        heightRestrictions[index][1]= std::min(heightRestrictions[index][1], heightRestrictions[index + 1][1] + heightRestrictions[index + 1][0] - heightRestrictions[index][0]);\n\n    int maxHeight= 0;\n    for(int index= 1; index < restrictionsCount; index++)\n    {\n        int possibleHeight= (heightRestrictions[index][1] + heightRestrictions[index - 1][1] + heightRestrictions[index][0] - heightRestrictions[index - 1][0]) / 2;\n        maxHeight= std::max(maxHeight, possibleHeight);\n    }\n\n    return maxHeight;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "long long modularExponentiation(long long base, long long exponent, long long modulo)\n{\n    long long result= 1;\n    while(exponent)\n    {\n        if(exponent & 1)\n            result= result * base % modulo;\n        base= base * base % modulo;\n        exponent>>= 1;\n    }\n    return result;\n}\n\nint minNonZeroProduct(int power)\n{\n    const int modulo= 1e9 + 7;\n    long long maxValue= (1LL << power) - 1;\n    long long secondMaxValue= (1LL << power) - 2;\n    long long exponentiationResult= modularExponentiation(secondMaxValue, maxValue - 1, modulo);\n    return maxValue * exponentiationResult % modulo;\n}",
    "output": "long long modularExponentiation(long long base, long long exponent, long long modulo)\n{\n    long long result= 1;\n    while(exponent)\n    {\n        if(exponent & 1)\n            result= result * base % modulo;\n        base= base * base % modulo;\n        exponent>>= 1;\n    }\n    return result;\n}\n\nint minNonZeroProduct(int power)\n{\n    const int modulo= 1e9 + 7;\n    long long maxValue= (1LL << power) - 1;\n    long long secondMaxValue= (1LL << power) - 2;\n    long long exponentiationResult= modularExponentiation(secondMaxValue, maxValue - 1, modulo);\n    return maxValue * exponentiationResult % modulo;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring sortSentence(const string &inputSentence)\n{\n    istringstream sentenceStream(inputSentence);\n    vector<pair<int, string>> wordPairs;\n    string currentWord;\n\n    while(sentenceStream >> currentWord)\n    {\n        int position = currentWord.back() - '0';\n        currentWord.pop_back();\n        wordPairs.emplace_back(position, currentWord);\n    }\n\n    sort(wordPairs.begin(), wordPairs.end());\n\n    string sortedSentence;\n    for (int i = 0; i < wordPairs.size(); ++i)\n    {\n        if (!sortedSentence.empty())\n        {\n            sortedSentence += \" \";\n        }\n        sortedSentence += wordPairs[i].second;\n    }\n\n    return sortedSentence;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string sortSentence(const std::string &inputSentence)\n{\n    std::istringstream sentenceStream(inputSentence);\n    std::vector<std::pair<int, std::string>> wordPairs;\n    std::string currentWord;\n\n    while(sentenceStream >> currentWord)\n    {\n        int position= currentWord.back() - '0';\n        currentWord.pop_back();\n        wordPairs.emplace_back(position, currentWord);\n    }\n\n    std::sort(wordPairs.begin(), wordPairs.end());\n\n    std::string sortedSentence;\n    for(const auto &wordPair : wordPairs)\n    {\n        if(!sortedSentence.empty())\n        {\n            sortedSentence+= \" \";\n        }\n        sortedSentence+= wordPair.second;\n    }\n\n    return sortedSentence;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> calculateMemorySticksCrash(int memoryStick1, int memoryStick2)\n{\n    int currentCrashTime= 1;\n    while(true)\n    {\n        if(memoryStick1 >= memoryStick2)\n        {\n            if(memoryStick1 >= currentCrashTime)\n            {\n                memoryStick1-= currentCrashTime;\n            }\n            else\n            {\n                break;\n            }\n        }\n        else\n        {\n            if(memoryStick2 >= currentCrashTime)\n            {\n                memoryStick2-= currentCrashTime;\n            }\n            else\n            {\n                break;\n            }\n        }\n        currentCrashTime++;\n    }\n    return {currentCrashTime, memoryStick1, memoryStick2};\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> calculateMemorySticksCrash(int memoryStick1, int memoryStick2)\n{\n    int currentCrashTime= 1;\n    while(true)\n    {\n        if(memoryStick1 >= memoryStick2)\n        {\n            if(memoryStick1 >= currentCrashTime)\n            {\n                memoryStick1-= currentCrashTime;\n            }\n            else\n            {\n                break;\n            }\n        }\n        else\n        {\n            if(memoryStick2 >= currentCrashTime)\n            {\n                memoryStick2-= currentCrashTime;\n            }\n            else\n            {\n                break;\n            }\n        }\n        currentCrashTime++;\n    }\n    return {currentCrashTime, memoryStick1, memoryStick2};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    int depthFirstSearch(TreeNode *currentNode, int &matchCount)\n    {\n        if(!currentNode)\n            return 0;\n        int leftSum= depthFirstSearch(currentNode->leftChild, matchCount);\n        int rightSum= depthFirstSearch(currentNode->rightChild, matchCount);\n        if(currentNode->value == leftSum + rightSum)\n            matchCount++;\n        return currentNode->value + leftSum + rightSum;\n    }\n\n    int equalToDescendants(TreeNode *rootNode)\n    {\n        int matchCount= 0;\n        depthFirstSearch(rootNode, matchCount);\n        return matchCount;\n    }\n};",
    "output": "struct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nclass Solution\n{\n  public:\n    int depthFirstSearch(TreeNode *currentNode, int &matchCount)\n    {\n        if(!currentNode)\n            return 0;\n        int leftSum= depthFirstSearch(currentNode->leftChild, matchCount);\n        int rightSum= depthFirstSearch(currentNode->rightChild, matchCount);\n        if(currentNode->value == leftSum + rightSum)\n            matchCount++;\n        return currentNode->value + leftSum + rightSum;\n    }\n\n    int equalToDescendants(TreeNode *rootNode)\n    {\n        int matchCount= 0;\n        depthFirstSearch(rootNode, matchCount);\n        return matchCount;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeToType(string word)\n{\n    int totalTime = 0, currentPosition = 0;\n    for (int i = 0; i < word.size(); ++i)\n    {\n        char character = word[i];\n        int nextPosition = character - 'a';\n        int difference = abs(nextPosition - currentPosition);\n        totalTime += min(difference, 26 - difference) + 1;\n        currentPosition = nextPosition;\n    }\n    return totalTime;\n}",
    "output": "#include <bits/stdc++.h>\n// For abs\n // For min\n\nint minTimeToType(std::string word)\n{\n    int totalTime= 0, currentPosition= 0;\n    for(char character : word)\n    {\n        int nextPosition= character - 'a';\n        int difference= std::abs(nextPosition - currentPosition);\n        totalTime+= std::min(difference, 26 - difference) + 1;\n        currentPosition= nextPosition;\n    }\n    return totalTime;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// Include for INT_MAX\nusing namespace std;\n\nint findTargetDistance(vector<int> &numbers, int target, int startIndex)\n{\n    int minimumDistance= INT_MAX;\n    for(int index= 0; index < numbers.size(); ++index)\n    {\n        if(numbers[index] == target)\n        {\n            int distance= abs(index - startIndex);\n            minimumDistance= min(minimumDistance, distance);\n        }\n    }\n    return minimumDistance;\n}",
    "output": "#include <bits/stdc++.h>\nint findTargetDistance(std::vector<int> &numbers, int target, int startIndex)\n{\n    int minimumDistance= INT_MAX;\n    for(int index= 0; index < numbers.size(); ++index)\n    {\n        if(numbers[index] == target)\n        {\n            int distance= std::abs(index - startIndex);\n            minimumDistance= std::min(minimumDistance, distance);\n        }\n    }\n    return minimumDistance;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canSplitString(const string &inputString)\n{\n    int digitCount[10] = {0};\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentChar = inputString[i];\n        digitCount[currentChar - '0'] += 1;\n    }\n\n    for (int digit = 1; digit <= 9; ++digit)\n    {\n        if (digitCount[digit] > 0 && digitCount[digit] == digitCount[digit - 1])\n        {\n            return true;\n        }\n    }\n    return false;\n}",
    "output": "bool canSplitString(const std::string &inputString)\n{\n    int digitCount[10]= {0};\n    for(char currentChar : inputString)\n    {\n        digitCount[currentChar - '0']+= 1;\n    }\n\n    for(int digit= 1; digit <= 9; ++digit)\n    {\n        if(digitCount[digit] > 0 && digitCount[digit] == digitCount[digit - 1])\n        {\n            return true;\n        }\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findMinimumIntervalSize(vector<vector<int>> &intervals, vector<int> &queries)\n{\n    sort(intervals.begin(), intervals.end());\n    vector<int> minimumSizes;\n    for (int query : queries)\n    {\n        int minimumSize = INT_MAX;\n        for (int i = 0; i < intervals.size(); ++i)\n        {\n            vector<int> &interval = intervals[i];\n            if (interval[0] <= query && query <= interval[1])\n            {\n                minimumSize = min(minimumSize, interval[1] - interval[0] + 1);\n            }\n        }\n        minimumSizes.push_back(minimumSize == INT_MAX ? -1 : minimumSize);\n    }\n    return minimumSizes;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findMinimumIntervalSize(std::vector<std::vector<int>> &intervals, std::vector<int> &queries)\n{\n    std::sort(intervals.begin(), intervals.end());\n    std::vector<int> minimumSizes;\n    for(int query : queries)\n    {\n        int minimumSize= INT_MAX;\n        for(std::vector<int> &interval : intervals)\n        {\n            if(interval[0] <= query && query <= interval[1])\n            {\n                minimumSize= std::min(minimumSize, interval[1] - interval[0] + 1);\n            }\n        }\n        minimumSizes.push_back(minimumSize == INT_MAX ? -1 : minimumSize);\n    }\n    return minimumSizes;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findGcd(vector<int> &numbers)\n{\n    auto minMaxElements= minmax_element(numbers.begin(), numbers.end());\n    int minimumValue= *minMaxElements.first;\n    int maximumValue= *minMaxElements.second;\n    while(maximumValue % minimumValue != 0)\n    {\n        int tempValue= minimumValue;\n        minimumValue= maximumValue % minimumValue;\n        maximumValue= tempValue;\n    }\n    return minimumValue;\n}",
    "output": "#include <bits/stdc++.h>\nint findGcd(std::vector<int> &numbers)\n{\n    auto minMaxElements = std::minmax_element(numbers.begin(), numbers.end());\n    int minimumValue = *minMaxElements.first;\n    int maximumValue = *minMaxElements.second;\n    while(maximumValue % minimumValue != 0)\n    {\n        int tempValue = minimumValue;\n        minimumValue = maximumValue % minimumValue;\n        maximumValue = tempValue;\n    }\n    return minimumValue;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring findDifferentBinaryString(vector<string> &binaryStrings)\n{\n    unordered_set<string> stringSet(binaryStrings.begin(), binaryStrings.end());\n    int stringCount = binaryStrings.size();\n\n    for(int index = 0; index < (1 << stringCount); ++index)\n    {\n        string candidateString(stringCount, '0');\n        for(int bitPosition = 0; bitPosition < stringCount; ++bitPosition)\n        {\n            if(index & (1 << bitPosition))\n                candidateString[bitPosition] = '1';\n        }\n\n        if(stringSet.find(candidateString) == stringSet.end())\n        {\n            return candidateString;\n        }\n    }\n    return \"\";\n}",
    "output": "#include <bits/stdc++.h>\nstd::string findDifferentBinaryString(std::vector<std::string> &binaryStrings)\n{\n    std::unordered_set<std::string> stringSet(binaryStrings.begin(), binaryStrings.end());\n    int stringCount= binaryStrings.size();\n\n    for(int index= 0; index < (1 << stringCount); ++index)\n    {\n        std::string candidateString(stringCount, '0');\n        for(int bitPosition= 0; bitPosition < stringCount; ++bitPosition)\n        {\n            if(index & (1 << bitPosition))\n                candidateString[bitPosition]= '1';\n        }\n\n        if(stringSet.find(candidateString) == stringSet.end())\n        {\n            return candidateString;\n        }\n    }\n    return \"\";\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimizeTheDifference(vector<vector<int>> &matrix, int targetValue)\n{\n    int rowCount= matrix.size();\n    int columnCount= matrix[0].size();\n    vector<vector<int>> dp(rowCount, vector<int>(800 * 70 + 1, 0));\n    dp[0]= matrix[0];\n\n    for(int currentRow= 1; currentRow < rowCount; currentRow++)\n    {\n        for(int currentCol= 0; currentCol < columnCount; currentCol++)\n        {\n            for(int k= 800 * 70; k > 0; k--)\n            {\n                if(k - matrix[currentRow][currentCol] >= 0 && dp[currentRow - 1][k - matrix[currentRow][currentCol]])\n                {\n                    dp[currentRow][k]= 1;\n                }\n            }\n        }\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int k= 0; k <= 800 * 70; k++)\n    {\n        if(dp[rowCount - 1][k])\n        {\n            minimumDifference= min(minimumDifference, abs(k - targetValue));\n        }\n    }\n\n    return minimumDifference;\n}",
    "output": "#include <bits/stdc++.h>\nint minimizeTheDifference(std::vector<std::vector<int>> &matrix, int targetValue)\n{\n    int rowCount= matrix.size();\n    int columnCount= matrix[0].size();\n    std::vector<std::vector<int>> dp(rowCount, std::vector<int>(800 * 70 + 1, 0));\n    dp[0]= matrix[0];\n\n    for(int currentRow= 1; currentRow < rowCount; currentRow++)\n    {\n        for(int currentCol= 0; currentCol < columnCount; currentCol++)\n        {\n            for(int k= 800 * 70; k > 0; k--)\n            {\n                if(k - matrix[currentRow][currentCol] >= 0 && dp[currentRow - 1][k - matrix[currentRow][currentCol]])\n                {\n                    dp[currentRow][k]= 1;\n                }\n            }\n        }\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int k= 0; k <= 800 * 70; k++)\n    {\n        if(dp[rowCount - 1][k])\n        {\n            minimumDifference= std::min(minimumDifference, std::abs(k - targetValue));\n        }\n    }\n\n    return minimumDifference;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> recoverArray(int targetSize, vector<int> &sums)\n{\n    multiset<int> sumSet(sums.begin(), sums.end());\n    vector<int> recoveredArray;\n\n    while(recoveredArray.size() < targetSize)\n    {\n        sumSet.erase(sumSet.begin());\n        int currentSum = *sumSet.begin();\n        multiset<int> tempSet = sumSet;\n        for (int j = 0; j < recoveredArray.size(); ++j)\n        {\n            int value = recoveredArray[j];\n            tempSet.erase(tempSet.find(currentSum - value));\n        }\n        recoveredArray.push_back(currentSum);\n        sumSet = tempSet;\n    }\n\n    return recoveredArray;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> recoverArray(int targetSize, std::vector<int> &sums)\n{\n    std::multiset<int> sumSet(sums.begin(), sums.end());\n    std::vector<int> recoveredArray;\n\n    while(recoveredArray.size() < targetSize)\n    {\n        sumSet.erase(sumSet.begin());\n        int currentSum= *sumSet.begin();\n        std::multiset<int> tempSet= sumSet;\n        for(int value : recoveredArray)\n        {\n            tempSet.erase(tempSet.find(currentSum - value));\n        }\n        recoveredArray.push_back(currentSum);\n        sumSet= tempSet;\n    }\n\n    return recoveredArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAliveYear(vector<vector<int>> &birthDeathLogs)\n{\n    vector<int> populationChanges(2051, 0);\n\n    for (int i = 0; i < birthDeathLogs.size(); ++i)\n    {\n        populationChanges[birthDeathLogs[i][0]]++;\n        populationChanges[birthDeathLogs[i][1]]--;\n    }\n\n    int maxPopulation = 0;\n    int yearWithMaxPopulation = 0;\n    int currentPopulation = 0;\n    for (int currentYear = 1950; currentYear < 2051; currentYear++)\n    {\n        currentPopulation += populationChanges[currentYear];\n        if (currentPopulation > maxPopulation)\n        {\n            maxPopulation = currentPopulation;\n            yearWithMaxPopulation = currentYear;\n        }\n    }\n\n    return yearWithMaxPopulation;\n}",
    "output": "#include <bits/stdc++.h>\nint maxAliveYear(std::vector<std::vector<int>> &birthDeathLogs)\n{\n    std::vector<int> populationChanges(2051, 0);\n\n    for(auto &logEntry : birthDeathLogs)\n    {\n        populationChanges[logEntry[0]]++;\n        populationChanges[logEntry[1]]--;\n    }\n\n    int maxPopulation= 0;\n    int yearWithMaxPopulation= 0;\n    int currentPopulation= 0;\n    for(int currentYear= 1950; currentYear < 2051; currentYear++)\n    {\n        currentPopulation+= populationChanges[currentYear];\n        if(currentPopulation > maxPopulation)\n        {\n            maxPopulation= currentPopulation;\n            yearWithMaxPopulation= currentYear;\n        }\n    }\n\n    return yearWithMaxPopulation;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxDistance(vector<int> &firstArray, vector<int> &secondArray)\n{\n    int firstIndex= 0, secondIndex= 0, maximumDistance= 0;\n    while(firstIndex < firstArray.size() && secondIndex < secondArray.size())\n    {\n        if(firstIndex <= secondIndex && firstArray[firstIndex] <= secondArray[secondIndex])\n        {\n            maximumDistance= max(maximumDistance, secondIndex - firstIndex);\n            secondIndex++;\n        }\n        else\n        {\n            firstIndex++;\n        }\n    }\n    return maximumDistance;\n}",
    "output": "#include <bits/stdc++.h>\nint maxDistance(std::vector<int> &firstArray, std::vector<int> &secondArray)\n{\n    int firstIndex= 0, secondIndex= 0, maximumDistance= 0;\n    while(firstIndex < firstArray.size() && secondIndex < secondArray.size())\n    {\n        if(firstIndex <= secondIndex && firstArray[firstIndex] <= secondArray[secondIndex])\n        {\n            maximumDistance= std::max(maximumDistance, secondIndex - firstIndex);\n            secondIndex++;\n        }\n        else\n        {\n            firstIndex++;\n        }\n    }\n    return maximumDistance;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxMinProduct(vector<int> &numbers)\n{\n    long long result= 0, modulus= 1e9 + 7;\n    int size= numbers.size();\n    vector<int> prefixSum(size + 1, 0);\n    stack<int> indexStack;\n\n    for(int i= 0; i < size; ++i)\n    {\n        prefixSum[i + 1]= (prefixSum[i] + numbers[i]) % modulus;\n    }\n\n    for(int i= 0; i <= size; ++i)\n    {\n        while(!indexStack.empty() && (i == size || numbers[indexStack.top()] > numbers[i]))\n        {\n            int topIndex= indexStack.top();\n            indexStack.pop();\n            result= max(result, numbers[topIndex] * (prefixSum[i] - prefixSum[indexStack.empty() ? 0 : indexStack.top() + 1]) % modulus);\n        }\n        indexStack.push(i);\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nint maxMinProduct(std::vector<int> &numbers)\n{\n    long long result= 0, modulus= 1e9 + 7;\n    int size= numbers.size();\n    std::vector<int> prefixSum(size + 1, 0);\n    std::stack<int> indexStack;\n\n    for(int i= 0; i < size; ++i)\n    {\n        prefixSum[i + 1]= (prefixSum[i] + numbers[i]) % modulus;\n    }\n\n    for(int i= 0; i <= size; ++i)\n    {\n        while(!indexStack.empty() && (i == size || numbers[indexStack.top()] > numbers[i]))\n        {\n            int topIndex= indexStack.top();\n            indexStack.pop();\n            result= std::max(result, numbers[topIndex] * (prefixSum[i] - prefixSum[indexStack.empty() ? 0 : indexStack.top() + 1]) % modulus);\n        }\n        indexStack.push(i);\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, vector<unordered_set<int>> &graph, string &colors, vector<vector<int>> &cache)\n{\n    if(!cache[currentNode][colors[currentNode] - 'a'])\n    {\n        cache[currentNode][colors[currentNode] - 'a'] = 1;\n        for(int neighbor : graph[currentNode])\n        {\n            cache[currentNode][colors[currentNode] - 'a'] = max(cache[currentNode][colors[currentNode] - 'a'], 1 + depthFirstSearch(neighbor, graph, colors, cache));\n        }\n    }\n    return cache[currentNode][colors[currentNode] - 'a'];\n}\n\nint largestPathValue(string colors, vector<vector<int>> &edges)\n{\n    int nodeCount = colors.size();\n    vector<unordered_set<int>> graph(nodeCount);\n    for (int i = 0; i < edges.size(); ++i) // Modified to traditional for loop\n    {\n        graph[edges[i][0]].insert(edges[i][1]);\n    }\n    vector<vector<int>> cache(nodeCount, vector<int>(26));\n    vector<int> inDegree(nodeCount);\n    for (int i = 0; i < edges.size(); ++i) // Modified to traditional for loop\n    {\n        inDegree[edges[i][1]]++;\n    }\n    int result = -1;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        if(!inDegree[i])\n        {\n            result = max(result, depthFirstSearch(i, graph, colors, cache));\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nint depthFirstSearch(int currentNode, std::vector<std::unordered_set<int>> &graph, std::string &colors, std::vector<std::vector<int>> &cache)\n{\n    if(!cache[currentNode][colors[currentNode] - 'a'])\n    {\n        cache[currentNode][colors[currentNode] - 'a']= 1;\n        for(int neighbor : graph[currentNode])\n        {\n            cache[currentNode][colors[currentNode] - 'a']= std::max(cache[currentNode][colors[currentNode] - 'a'], 1 + depthFirstSearch(neighbor, graph, colors, cache));\n        }\n    }\n    return cache[currentNode][colors[currentNode] - 'a'];\n}\n\nint largestPathValue(std::string colors, std::vector<std::vector<int>> &edges)\n{\n    int nodeCount= colors.size();\n    std::vector<std::unordered_set<int>> graph(nodeCount);\n    for(const auto &edge : edges)\n    {\n        graph[edge[0]].insert(edge[1]);\n    }\n    std::vector<std::vector<int>> cache(nodeCount, std::vector<int>(26));\n    std::vector<int> inDegree(nodeCount);\n    for(const auto &edge : edges)\n    {\n        inDegree[edge[1]]++;\n    }\n    int result= -1;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        if(!inDegree[i])\n        {\n            result= std::max(result, depthFirstSearch(i, graph, colors, cache));\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countGoodSubstrings(const string &inputString)\n{\n    int goodSubstringCount= 0;\n    for(int currentIndex= 0; currentIndex < inputString.length() - 2; currentIndex++)\n    {\n        if(inputString[currentIndex] != inputString[currentIndex + 1] &&\n           inputString[currentIndex] != inputString[currentIndex + 2] &&\n           inputString[currentIndex + 1] != inputString[currentIndex + 2])\n        {\n            goodSubstringCount++;\n        }\n    }\n    return goodSubstringCount;\n}",
    "output": "int countGoodSubstrings(const std::string &inputString)\n{\n    int goodSubstringCount= 0;\n    for(int currentIndex= 0; currentIndex < inputString.length() - 2; currentIndex++)\n    {\n        if(inputString[currentIndex] != inputString[currentIndex + 1] &&\n           inputString[currentIndex] != inputString[currentIndex + 2] &&\n           inputString[currentIndex + 1] != inputString[currentIndex + 2])\n        {\n            goodSubstringCount++;\n        }\n    }\n    return goodSubstringCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumXorSum(vector<int> &firstArray, vector<int> &secondArray)\n{\n    sort(secondArray.begin(), secondArray.end());\n    int totalXorSum= 0;\n    for(int index= 0; index < firstArray.size(); ++index)\n    {\n        totalXorSum+= firstArray[index] ^ secondArray[index];\n    }\n    return totalXorSum;\n}",
    "output": "#include <bits/stdc++.h>\nint minimumXorSum(std::vector<int> &firstArray, std::vector<int> &secondArray)\n{\n    std::sort(secondArray.begin(), secondArray.end());\n    int totalXorSum= 0;\n    for(int index= 0; index < firstArray.size(); ++index)\n    {\n        totalXorSum+= firstArray[index] ^ secondArray[index];\n    }\n    return totalXorSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMiddleIndex(vector<int> &numbers)\n{\n    int totalSum = 0, leftSum = 0;\n\n    for (int number : numbers)\n    {\n        totalSum += number;\n    }\n\n    for (int index = 0; index < numbers.size(); index++)\n    {\n        if (leftSum == totalSum - leftSum - numbers[index])\n        {\n            return index;\n        }\n        leftSum += numbers[index];\n    }\n\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint findMiddleIndex(std::vector<int> &numbers)\n{\n    int totalSum= 0, leftSum= 0;\n\n    for(int number : numbers)\n    {\n        totalSum+= number;\n    }\n\n    for(int index= 0; index < numbers.size(); index++)\n    {\n        if(leftSum == totalSum - leftSum - numbers[index])\n        {\n            return index;\n        }\n        leftSum+= numbers[index];\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> findFarmland(vector<vector<int>> &land)\n{\n    int rowCount= land.size(), colCount= land[0].size();\n    vector<vector<int>> farmlandGroups;\n\n    for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex < colCount; ++colIndex)\n        {\n            if(land[rowIndex][colIndex] == 1)\n            {\n                int startRow= rowIndex, startCol= colIndex;\n                while(colIndex + 1 < colCount && land[rowIndex][colIndex + 1] == 1)\n                    colIndex++;\n                int endRow= rowIndex, endCol= colIndex;\n                while(endRow + 1 < rowCount && land[endRow + 1][colIndex] == 1)\n                    endRow++;\n                for(int r= startRow; r <= endRow; ++r)\n                {\n                    for(int c= startCol; c <= endCol; ++c)\n                    {\n                        land[r][c]= 0;\n                    }\n                }\n                farmlandGroups.push_back({startRow, startCol, endRow, endCol});\n            }\n        }\n    }\n\n    return farmlandGroups;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> findFarmland(std::vector<std::vector<int>> &land)\n{\n    int rowCount= land.size(), colCount= land[0].size();\n    std::vector<std::vector<int>> farmlandGroups;\n\n    for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex < colCount; ++colIndex)\n        {\n            if(land[rowIndex][colIndex] == 1)\n            {\n                int startRow= rowIndex, startCol= colIndex;\n                while(colIndex + 1 < colCount && land[rowIndex][colIndex + 1] == 1)\n                    colIndex++;\n                int endRow= rowIndex, endCol= colIndex;\n                while(endRow + 1 < rowCount && land[endRow + 1][colIndex] == 1)\n                    endRow++;\n                for(int r= startRow; r <= endRow; ++r)\n                {\n                    for(int c= startCol; c <= endCol; ++c)\n                    {\n                        land[r][c]= 0;\n                    }\n                }\n                farmlandGroups.push_back({startRow, startCol, endRow, endCol});\n            }\n        }\n    }\n\n    return farmlandGroups;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint subsetXORSum(vector<int> &numbers)\n{\n    int totalXORSum= 0;\n    int totalNumbers= numbers.size();\n    int totalSubsets= 1 << totalNumbers;\n\n    for(int subsetIndex= 0; subsetIndex < totalSubsets; subsetIndex++)\n    {\n        int currentSubsetXOR= 0;\n        for(int numberIndex= 0; numberIndex < totalNumbers; numberIndex++)\n        {\n            if(subsetIndex & (1 << numberIndex))\n            {\n                currentSubsetXOR^= numbers[numberIndex];\n            }\n        }\n        totalXORSum+= currentSubsetXOR;\n    }\n\n    return totalXORSum;\n}",
    "output": "#include <bits/stdc++.h>\nint subsetXORSum(std::vector<int> &numbers)\n{\n    int totalXORSum= 0;\n    int totalNumbers= numbers.size();\n    int totalSubsets= 1 << totalNumbers;\n\n    for(int subsetIndex= 0; subsetIndex < totalSubsets; subsetIndex++)\n    {\n        int currentSubsetXOR= 0;\n        for(int numberIndex= 0; numberIndex < totalNumbers; numberIndex++)\n        {\n            if(subsetIndex & (1 << numberIndex))\n            {\n                currentSubsetXOR^= numbers[numberIndex];\n            }\n        }\n        totalXORSum+= currentSubsetXOR;\n    }\n\n    return totalXORSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minSwaps(string binaryString)\n{\n    int zeroCount = 0, oneCount = 0;\n    for (int i = 0; i < binaryString.length(); i++)\n    {\n        char currentChar = binaryString[i];\n        if (currentChar == '0')\n        {\n            zeroCount++;\n        }\n        else\n        {\n            oneCount++;\n        }\n    }\n\n    if (abs(zeroCount - oneCount) > 1)\n    {\n        return -1;\n    }\n\n    int mismatchCountPattern1 = 0, mismatchCountPattern2 = 0;\n    for (int index = 0; index < binaryString.length(); index++)\n    {\n        if (index % 2 == 0)\n        {\n            if (binaryString[index] != '0')\n                mismatchCountPattern1++;\n            if (binaryString[index] != '1')\n                mismatchCountPattern2++;\n        }\n        else\n        {\n            if (binaryString[index] != '1')\n                mismatchCountPattern1++;\n            if (binaryString[index] != '0')\n                mismatchCountPattern2++;\n        }\n    }\n\n    return min(mismatchCountPattern1, mismatchCountPattern2) / 2;\n}",
    "output": "int minSwaps(std::string binaryString)\n{\n    int zeroCount= 0, oneCount= 0;\n    for(char currentChar : binaryString)\n    {\n        if(currentChar == '0')\n        {\n            zeroCount++;\n        }\n        else\n        {\n            oneCount++;\n        }\n    }\n\n    if(abs(zeroCount - oneCount) > 1)\n    {\n        return -1;\n    }\n\n    int mismatchCountPattern1= 0, mismatchCountPattern2= 0;\n    for(int index= 0; index < binaryString.length(); index++)\n    {\n        if(index % 2 == 0)\n        {\n            if(binaryString[index] != '0')\n                mismatchCountPattern1++;\n            if(binaryString[index] != '1')\n                mismatchCountPattern2++;\n        }\n        else\n        {\n            if(binaryString[index] != '1')\n                mismatchCountPattern1++;\n            if(binaryString[index] != '0')\n                mismatchCountPattern2++;\n        }\n    }\n\n    return min(mismatchCountPattern1, mismatchCountPattern2) / 2;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateNumberOfSticks(int totalSticks, int selectedSticks)\n{\n    const int modulo= 1e9 + 7;\n    if(totalSticks < selectedSticks)\n        return 0;\n    int dp[totalSticks + 1][totalSticks + 1];\n    memset(dp, 0, sizeof(dp));\n\n    for(int currentSticks= 1; currentSticks <= totalSticks; currentSticks++)\n    {\n        dp[currentSticks][1]= 1;\n        for(int currentSelection= 2; currentSelection <= currentSticks; currentSelection++)\n            dp[currentSticks][currentSelection]= (dp[currentSticks - 1][currentSelection - 1] + (currentSticks - 1) * dp[currentSticks - 1][currentSelection]) % modulo;\n    }\n    return dp[totalSticks][selectedSticks];\n}",
    "output": "#include <bits/stdc++.h>\nint calculateNumberOfSticks(int totalSticks, int selectedSticks)\n{\n    const int modulo= 1e9 + 7;\n    if(totalSticks < selectedSticks)\n        return 0;\n    int dp[totalSticks + 1][totalSticks + 1];\n    std::memset(dp, 0, sizeof(dp));\n\n    for(int currentSticks= 1; currentSticks <= totalSticks; currentSticks++)\n    {\n        dp[currentSticks][1]= 1;\n        for(int currentSelection= 2; currentSelection <= currentSticks; currentSelection++)\n            dp[currentSticks][currentSelection]= (dp[currentSticks - 1][currentSelection - 1] + (currentSticks - 1) * dp[currentSticks - 1][currentSelection]) % modulo;\n    }\n    return dp[totalSticks][selectedSticks];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateFirstDayInAllRooms(vector<int> &nextVisit)\n{\n    int roomCount = nextVisit.size();\n    long long totalDays = 0, mod = 1e9 + 7;\n    vector<long long> daysInRooms(roomCount, 0);\n\n    for(int dayIndex = 1; dayIndex < roomCount; ++dayIndex)\n    {\n        daysInRooms[dayIndex] = (daysInRooms[dayIndex - 1] * 2 - daysInRooms[nextVisit[dayIndex - 1]] + 2) % mod;\n    }\n\n    return daysInRooms[roomCount - 1];\n}",
    "output": "#include <bits/stdc++.h>\nint calculateFirstDayInAllRooms(std::vector<int> &nextVisit)\n{\n    int roomCount= nextVisit.size();\n    long long totalDays= 0, mod= 1e9 + 7;\n    std::vector<long long> daysInRooms(roomCount, 0);\n\n    for(int dayIndex= 1; dayIndex < roomCount; ++dayIndex)\n    {\n        daysInRooms[dayIndex]= (daysInRooms[dayIndex - 1] * 2 - daysInRooms[nextVisit[dayIndex - 1]] + 2) % mod;\n    }\n\n    return daysInRooms[roomCount - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canBeSorted(vector<int> &numberList)\n{\n    vector<int> sortedNumberList = numberList;\n    sort(sortedNumberList.begin(), sortedNumberList.end());\n    for(size_t index = 0; index < numberList.size(); ++index)\n    {\n        if(numberList[index] != sortedNumberList[index] && gcd(numberList[index], sortedNumberList[index]) == 1)\n        {\n            return false;\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool canBeSorted(std::vector<int> &numberList)\n{\n    std::vector<int> sortedNumberList= numberList;\n    sort(sortedNumberList.begin(), sortedNumberList.end());\n    for(size_t index= 0; index < numberList.size(); ++index)\n    {\n        if(numberList[index] != sortedNumberList[index] && std::gcd(numberList[index], sortedNumberList[index]) == 1)\n        {\n            return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool checkZeroOnes(string binaryString)\n{\n    int longestZeroSequence = 0;\n    int longestOneSequence = 0;\n    int currentZeroCount = 0;\n    int currentOneCount = 0;\n\n    for (int i = 0; i < binaryString.size(); ++i)\n    {\n        char currentCharacter = binaryString[i];\n        if (currentCharacter == '0')\n        {\n            currentZeroCount++;\n            longestZeroSequence = max(longestZeroSequence, currentZeroCount);\n            currentOneCount = 0;\n        }\n        else\n        {\n            currentOneCount++;\n            longestOneSequence = max(longestOneSequence, currentOneCount);\n            currentZeroCount = 0;\n        }\n    }\n    return longestOneSequence > longestZeroSequence;\n}",
    "output": "bool checkZeroOnes(std::string binaryString)\n{\n    int longestZeroSequence= 0;\n    int longestOneSequence= 0;\n    int currentZeroCount= 0;\n    int currentOneCount= 0;\n\n    for(char currentCharacter : binaryString)\n    {\n        if(currentCharacter == '0')\n        {\n            currentZeroCount++;\n            longestZeroSequence= std::max(longestZeroSequence, currentZeroCount);\n            currentOneCount= 0;\n        }\n        else\n        {\n            currentOneCount++;\n            longestOneSequence= std::max(longestOneSequence, currentOneCount);\n            currentZeroCount= 0;\n        }\n    }\n    return longestOneSequence > longestZeroSequence;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumSpeed(int numberOfDistances, float availableTime, vector<int> &distances)\n{\n    if(numberOfDistances > ceil(availableTime))\n        return -1;\n    int lowerBound= 1, upperBound= 1e7, midSpeed, minimumSpeedValue;\n\n    while(lowerBound <= upperBound)\n    {\n        midSpeed= lowerBound + (upperBound - lowerBound) / 2;\n        float totalTime= 0;\n        for(int index= 0; index < numberOfDistances; ++index)\n        {\n            totalTime+= ceil(distances[index] * 1.0 / midSpeed);\n        }\n        if(totalTime <= availableTime)\n        {\n            minimumSpeedValue= midSpeed;\n            upperBound= midSpeed - 1;\n        }\n        else\n        {\n            lowerBound= midSpeed + 1;\n        }\n    }\n\n    return minimumSpeedValue;\n}",
    "output": "#include <bits/stdc++.h>\nint minimumSpeed(int numberOfDistances, float availableTime, std::vector<int> &distances)\n{\n    if(numberOfDistances > ceil(availableTime))\n        return -1;\n    int lowerBound= 1, upperBound= 1e7, midSpeed, minimumSpeedValue;\n\n    while(lowerBound <= upperBound)\n    {\n        midSpeed= lowerBound + (upperBound - lowerBound) / 2;\n        float totalTime= 0;\n        for(int index= 0; index < numberOfDistances; ++index)\n        {\n            totalTime+= ceil(distances[index] * 1.0 / midSpeed);\n        }\n        if(totalTime <= availableTime)\n        {\n            minimumSpeedValue= midSpeed;\n            upperBound= midSpeed - 1;\n        }\n        else\n        {\n            lowerBound= midSpeed + 1;\n        }\n    }\n\n    return minimumSpeedValue;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canReach(string binaryString, int minJumpDistance, int maxJumpDistance)\n{\n    int stringLength= binaryString.size();\n    vector<bool> canReachEnd(stringLength, false);\n    canReachEnd[0]= true;\n    int reachableCount= 0;\n\n    for(int currentIndex= 1; currentIndex < stringLength; ++currentIndex)\n    {\n        if(currentIndex >= minJumpDistance)\n            reachableCount+= canReachEnd[currentIndex - minJumpDistance];\n        if(currentIndex > maxJumpDistance)\n            reachableCount-= canReachEnd[currentIndex - maxJumpDistance - 1];\n        canReachEnd[currentIndex]= reachableCount > 0 && binaryString[currentIndex] == '0';\n    }\n\n    return canReachEnd[stringLength - 1];\n}",
    "output": "#include <bits/stdc++.h>\nbool canReach(std::string binaryString, int minJumpDistance, int maxJumpDistance)\n{\n    int stringLength= binaryString.size();\n    std::vector<bool> canReachEnd(stringLength, false);\n    canReachEnd[0]= true;\n    int reachableCount= 0;\n\n    for(int currentIndex= 1; currentIndex < stringLength; ++currentIndex)\n    {\n        if(currentIndex >= minJumpDistance)\n            reachableCount+= canReachEnd[currentIndex - minJumpDistance];\n        if(currentIndex > maxJumpDistance)\n            reachableCount-= canReachEnd[currentIndex - maxJumpDistance - 1];\n        canReachEnd[currentIndex]= reachableCount > 0 && binaryString[currentIndex] == '0';\n    }\n\n    return canReachEnd[stringLength - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint stoneGameDp(vector<int> &stones, int startIndex, int endIndex, vector<vector<int>> &dynamicProgramming)\n{\n    if(startIndex == endIndex)\n        return stones[startIndex];\n\n    if(dynamicProgramming[startIndex][endIndex] != 0)\n        return dynamicProgramming[startIndex][endIndex];\n\n    dynamicProgramming[startIndex][endIndex]= max(stones[startIndex] - stoneGameDp(stones, startIndex + 1, endIndex, dynamicProgramming),\n                                                  stones[endIndex] - stoneGameDp(stones, startIndex, endIndex - 1, dynamicProgramming));\n    return dynamicProgramming[startIndex][endIndex];\n}\n\nint stoneGameVII(vector<int> &stones)\n{\n    int numberOfStones= stones.size();\n    vector<vector<int>> dynamicProgramming(numberOfStones, vector<int>(numberOfStones, 0));\n\n    for(int i= numberOfStones - 1; i >= 0; --i)\n        for(int j= i + 1; j < numberOfStones; ++j)\n            dynamicProgramming[i][j]= max(stones[i] - dynamicProgramming[i + 1][j], stones[j] - dynamicProgramming[i][j - 1]);\n\n    return dynamicProgramming[0][numberOfStones - 1];\n}",
    "output": "#include <bits/stdc++.h>\nint stoneGameDp(std::vector<int> &stones, int startIndex, int endIndex, std::vector<std::vector<int>> &dynamicProgramming)\n{\n    if(startIndex == endIndex)\n        return stones[startIndex];\n\n    if(dynamicProgramming[startIndex][endIndex] != 0)\n        return dynamicProgramming[startIndex][endIndex];\n\n    dynamicProgramming[startIndex][endIndex]= std::max(stones[startIndex] - stoneGameDp(stones, startIndex + 1, endIndex, dynamicProgramming),\n                                                      stones[endIndex] - stoneGameDp(stones, startIndex, endIndex - 1, dynamicProgramming));\n    return dynamicProgramming[startIndex][endIndex];\n}\n\nint stoneGameVII(std::vector<int> &stones)\n{\n    int numberOfStones= stones.size();\n    std::vector<std::vector<int>> dynamicProgramming(numberOfStones, std::vector<int>(numberOfStones, 0));\n\n    for(int i= numberOfStones - 1; i >= 0; --i)\n        for(int j= i + 1; j < numberOfStones; ++j)\n            dynamicProgramming[i][j]= std::max(stones[i] - dynamicProgramming[i + 1][j], stones[j] - dynamicProgramming[i][j - 1]);\n\n    return dynamicProgramming[0][numberOfStones - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(int currentNode, const vector<int> &parentNodes, const vector<int> &nodeValues,\n                      vector<set<int>> &childNodes, vector<int> &result)\n{\n    for (int childIndex = 0; childIndex < childNodes[currentNode].size(); ++childIndex)\n    {\n        int child = *next(childNodes[currentNode].begin(), childIndex); // Get the child using an index\n        depthFirstSearch(child, parentNodes, nodeValues, childNodes, result);\n        childNodes[currentNode].erase(child);\n        childNodes[currentNode].insert(result[child]);\n    }\n    auto iterator = childNodes[currentNode].lower_bound(nodeValues[currentNode]);\n    result[currentNode] = (iterator == childNodes[currentNode].end()) ? nodeValues[currentNode] + 1 : *iterator - 1;\n}\n\nvector<int> smallestMissingValueSubtree(vector<int> &parentNodes, vector<int> &nodeValues)\n{\n    int nodeCount = parentNodes.size();\n    vector<set<int>> childNodes(nodeCount);\n    for (int i = 1; i < nodeCount; ++i)\n    {\n        childNodes[parentNodes[i]].insert(nodeValues[i]);\n    }\n\n    vector<int> result(nodeCount);\n    depthFirstSearch(0, parentNodes, nodeValues, childNodes, result);\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nvoid depthFirstSearch(int currentNode, const std::vector<int> &parentNodes, const std::vector<int> &nodeValues,\n                      std::vector<std::set<int>> &childNodes, std::vector<int> &result)\n{\n    for(int child : childNodes[currentNode])\n    {\n        depthFirstSearch(child, parentNodes, nodeValues, childNodes, result);\n        childNodes[currentNode].erase(child);\n        childNodes[currentNode].insert(result[child]);\n    }\n    auto iterator= childNodes[currentNode].lower_bound(nodeValues[currentNode]);\n    result[currentNode]= (iterator == childNodes[currentNode].end()) ? nodeValues[currentNode] + 1 : *iterator - 1;\n}\n\nstd::vector<int> smallestMissingValueSubtree(std::vector<int> &parentNodes, std::vector<int> &nodeValues)\n{\n    int nodeCount= parentNodes.size();\n    std::vector<std::set<int>> childNodes(nodeCount);\n    for(int i= 1; i < nodeCount; ++i)\n    {\n        childNodes[parentNodes[i]].insert(nodeValues[i]);\n    }\n\n    std::vector<int> result(nodeCount);\n    depthFirstSearch(0, parentNodes, nodeValues, childNodes, result);\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isCovered(vector<vector<int>> &ranges, int leftBound, int rightBound)\n{\n    for(int currentPoint = leftBound; currentPoint <= rightBound; currentPoint++)\n    {\n        bool isCovered = false;\n        for(int i = 0; i < ranges.size(); i++)\n        {\n            const auto &range = ranges[i];\n            if(currentPoint >= range[0] && currentPoint <= range[1])\n            {\n                isCovered = true;\n                break;\n            }\n        }\n        if(!isCovered)\n            return false;\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isCovered(std::vector<std::vector<int>> &ranges, int leftBound, int rightBound)\n{\n    for(int currentPoint= leftBound; currentPoint <= rightBound; currentPoint++)\n    {\n        bool isCovered= false;\n        for(const auto &range : ranges)\n        {\n            if(currentPoint >= range[0] && currentPoint <= range[1])\n            {\n                isCovered= true;\n                break;\n            }\n        }\n        if(!isCovered)\n            return false;\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint chalkReplacer(vector<int> &chalkAmounts, int totalChalk)\n{\n    long long totalSum= 0;\n    for(int index= 0; index < chalkAmounts.size(); index++)\n    {\n        totalSum+= chalkAmounts[index];\n    }\n    totalChalk%= totalSum;\n    for(int index= 0; index < chalkAmounts.size(); index++)\n    {\n        if(totalChalk < chalkAmounts[index])\n        {\n            return index;\n        }\n        totalChalk-= chalkAmounts[index];\n    }\n    return 0;\n}",
    "output": "#include <bits/stdc++.h>\nint chalkReplacer(std::vector<int> &chalkAmounts, int totalChalk)\n{\n    long long totalSum= 0;\n    for(int index= 0; index < chalkAmounts.size(); index++)\n    {\n        totalSum+= chalkAmounts[index];\n    }\n    totalChalk%= totalSum;\n    for(int index= 0; index < chalkAmounts.size(); index++)\n    {\n        if(totalChalk < chalkAmounts[index])\n        {\n            return index;\n        }\n        totalChalk-= chalkAmounts[index];\n    }\n    return 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findOriginalArray(vector<int> &changedArray)\n{\n    if(changedArray.size() % 2 != 0)\n        return {};\n\n    map<int, int> numberCount;\n    for(int number : changedArray)\n    {\n        numberCount[number]++;\n    }\n\n    vector<int> originalArray;\n    for(auto it = numberCount.begin(); it != numberCount.end(); ++it)\n    {\n        const int number = it->first;\n        const int frequency = it->second;\n        \n        if(frequency > numberCount[number * 2])\n            return {};\n\n        for(int i = 0; i < frequency; ++i)\n        {\n            originalArray.push_back(number);\n        }\n    }\n\n    return originalArray;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findOriginalArray(std::vector<int> &changedArray)\n{\n    if(changedArray.size() % 2 != 0)\n        return {};\n\n    std::map<int, int> numberCount;\n    for(int number : changedArray)\n    {\n        numberCount[number]++;\n    }\n\n    std::vector<int> originalArray;\n    for(const auto &[number, frequency] : numberCount)\n    {\n        if(frequency > numberCount[number * 2])\n            return {};\n\n        for(int i= 0; i < frequency; ++i)\n        {\n            originalArray.push_back(number);\n        }\n    }\n\n    return originalArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperationsToFlip(string expression)\n{\n    vector<int> zeroCount(1), oneCount(1), operators;\n    for (int i = 0; i < expression.size(); ++i)\n    {\n        const auto &character = expression[i];\n        if (character == '&')\n            operators.push_back(1);\n        else if (character == '|')\n            operators.push_back(2);\n        else if (isdigit(character))\n        {\n            if (character == '0')\n            {\n                oneCount.push_back(1);\n                zeroCount.push_back(0);\n            }\n            else\n            {\n                zeroCount.push_back(1);\n                oneCount.push_back(0);\n            }\n        }\n        else if (character == ')')\n        {\n            int currentOperator = operators.back();\n            operators.pop_back();\n            int newZeroCount, newOneCount;\n            int x = zeroCount.back();\n            zeroCount.pop_back();\n            int y = oneCount.back() + 1;\n            oneCount.pop_back();\n            if (currentOperator == 1)\n            {\n                newZeroCount = max(x, y);\n                newOneCount = oneCount.back() + min(x, zeroCount.back());\n            }\n            else\n            {\n                newZeroCount = zeroCount.back() + min(x, oneCount.back());\n                newOneCount = max(y, oneCount.back());\n            }\n            zeroCount.pop_back();\n            oneCount.pop_back();\n            zeroCount.push_back(newZeroCount);\n            oneCount.push_back(newOneCount);\n        }\n    }\n    return zeroCount.back() + 1;\n}",
    "output": "#include <bits/stdc++.h>\n// for isdigit\n\nint minOperationsToFlip(std::string expression)\n{\n    std::vector<int> zeroCount(1), oneCount(1), operators;\n    for(const auto &character : expression)\n    {\n        if(character == '&')\n            operators.push_back(1);\n        else if(character == '|')\n            operators.push_back(2);\n        else if(std::isdigit(character))\n        {\n            if(character == '0')\n            {\n                oneCount.push_back(1);\n                zeroCount.push_back(0);\n            }\n            else\n            {\n                zeroCount.push_back(1);\n                oneCount.push_back(0);\n            }\n        }\n        else if(character == ')')\n        {\n            int currentOperator= operators.back();\n            operators.pop_back();\n            int newZeroCount, newOneCount;\n            int x= zeroCount.back();\n            zeroCount.pop_back();\n            int y= oneCount.back() + 1;\n            oneCount.pop_back();\n            if(currentOperator == 1)\n            {\n                newZeroCount= std::max(x, y);\n                newOneCount= oneCount.back() + std::min(x, zeroCount.back());\n            }\n            else\n            {\n                newZeroCount= zeroCount.back() + std::min(x, oneCount.back());\n                newOneCount= std::max(y, oneCount.back());\n            }\n            zeroCount.pop_back();\n            oneCount.pop_back();\n            zeroCount.push_back(newZeroCount);\n            oneCount.push_back(newOneCount);\n        }\n    }\n    return zeroCount.back() + 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For INT_MAX\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    int size= numbers.size();\n    set<int> uniqueNumbers(numbers.begin(), numbers.end());\n    vector<int> sortedUniqueNumbers(uniqueNumbers.begin(), uniqueNumbers.end());\n    int result= INT_MAX;\n    int rightIndex= 0;\n\n    for(int leftIndex= 0; leftIndex < sortedUniqueNumbers.size(); ++leftIndex)\n    {\n        while(rightIndex < sortedUniqueNumbers.size() && sortedUniqueNumbers[rightIndex] <= sortedUniqueNumbers[leftIndex] + size - 1)\n        {\n            ++rightIndex;\n        }\n        result= min(result, size - (rightIndex - leftIndex));\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nint minOperations(std::vector<int> &numbers)\n{\n    int size= numbers.size();\n    std::set<int> uniqueNumbers(numbers.begin(), numbers.end());\n    std::vector<int> sortedUniqueNumbers(uniqueNumbers.begin(), uniqueNumbers.end());\n    int result= std::numeric_limits<int>::max();\n    int rightIndex= 0;\n\n    for(int leftIndex= 0; leftIndex < sortedUniqueNumbers.size(); ++leftIndex)\n    {\n        while(rightIndex < sortedUniqueNumbers.size() && sortedUniqueNumbers[rightIndex] <= sortedUniqueNumbers[leftIndex] + size - 1)\n        {\n            ++rightIndex;\n        }\n        result= std::min(result, size - (rightIndex - leftIndex));\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring maxValue(string numberString, int insertionDigit)\n{\n    bool isNegative = numberString[0] == '-';\n    int position = isNegative ? 1 : 0;\n\n    while(position < numberString.size())\n    {\n        if(isNegative && numberString[position] - '0' > insertionDigit || !isNegative && numberString[position] - '0' < insertionDigit)\n        {\n            break;\n        }\n        position++;\n    }\n\n    return numberString.substr(0, position) + to_string(insertionDigit) + numberString.substr(position);\n}",
    "output": "#include <bits/stdc++.h>\nstd::string maxValue(std::string numberString, int insertionDigit)\n{\n    bool isNegative= numberString[0] == '-';\n    int position= isNegative ? 1 : 0;\n\n    while(position < numberString.size())\n    {\n        if(isNegative && numberString[position] - '0' > insertionDigit || !isNegative && numberString[position] - '0' < insertionDigit)\n        {\n            break;\n        }\n        position++;\n    }\n\n    return numberString.substr(0, position) + std::to_string(insertionDigit) + numberString.substr(position);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> assignTasks(vector<int> &serverCapacities, vector<int> &taskDurations)\n{\n    int totalServers= serverCapacities.size(), totalTasks= taskDurations.size();\n    vector<int> taskAssignments(totalTasks);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> availableServers;\n\n    for(int serverIndex= 0; serverIndex < totalServers; ++serverIndex)\n    {\n        availableServers.push({serverCapacities[serverIndex], serverIndex});\n    }\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> occupiedServers;\n    int currentTaskIndex= 0;\n\n    while(currentTaskIndex < totalTasks)\n    {\n        while(!occupiedServers.empty() && occupiedServers.top().first <= currentTaskIndex)\n        {\n            availableServers.push({serverCapacities[occupiedServers.top().second], occupiedServers.top().second});\n            occupiedServers.pop();\n        }\n\n        while(!availableServers.empty() && currentTaskIndex < totalTasks)\n        {\n            taskAssignments[currentTaskIndex]= availableServers.top().second;\n            occupiedServers.push({currentTaskIndex + taskDurations[currentTaskIndex], availableServers.top().second});\n            availableServers.pop();\n            currentTaskIndex++;\n        }\n\n        if(availableServers.empty())\n        {\n            currentTaskIndex= occupiedServers.top().first;\n        }\n    }\n\n    return taskAssignments;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> assignTasks(std::vector<int> &serverCapacities, std::vector<int> &taskDurations)\n{\n    int totalServers= serverCapacities.size(), totalTasks= taskDurations.size();\n    std::vector<int> taskAssignments(totalTasks);\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> availableServers;\n\n    for(int serverIndex= 0; serverIndex < totalServers; ++serverIndex)\n    {\n        availableServers.push({serverCapacities[serverIndex], serverIndex});\n    }\n\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> occupiedServers;\n    int currentTaskIndex= 0;\n\n    while(currentTaskIndex < totalTasks)\n    {\n        while(!occupiedServers.empty() && occupiedServers.top().first <= currentTaskIndex)\n        {\n            availableServers.push({serverCapacities[occupiedServers.top().second], occupiedServers.top().second});\n            occupiedServers.pop();\n        }\n\n        while(!availableServers.empty() && currentTaskIndex < totalTasks)\n        {\n            taskAssignments[currentTaskIndex]= availableServers.top().second;\n            occupiedServers.push({currentTaskIndex + taskDurations[currentTaskIndex], availableServers.top().second});\n            availableServers.pop();\n            currentTaskIndex++;\n        }\n\n        if(availableServers.empty())\n        {\n            currentTaskIndex= occupiedServers.top().first;\n        }\n    }\n\n    return taskAssignments;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minSkips(const vector<int> &distance, int speed, int hoursBefore)\n{\n    int numberOfSegments = distance.size();\n    vector<vector<double>> timeTable(numberOfSegments + 1, vector<double>(numberOfSegments + 1, 1e6));\n\n    timeTable[0][0] = 0;\n    for(int segmentIndex = 1; segmentIndex <= numberOfSegments; ++segmentIndex)\n    {\n        timeTable[segmentIndex][0] = (timeTable[segmentIndex - 1][0] + distance[segmentIndex - 1] + speed - 1) / speed;\n    }\n\n    for(int segmentIndex = 1; segmentIndex <= numberOfSegments; ++segmentIndex)\n    {\n        for(int skips = 1; skips <= segmentIndex; ++skips)\n        {\n            timeTable[segmentIndex][skips] = min(timeTable[segmentIndex][skips], timeTable[segmentIndex - 1][skips - 1] + double(distance[segmentIndex - 1]) / speed);\n            timeTable[segmentIndex][skips] = min(timeTable[segmentIndex][skips], ceil(timeTable[segmentIndex - 1][skips] + double(distance[segmentIndex - 1]) / speed));\n        }\n    }\n\n    for(int skips = 0; skips <= numberOfSegments; ++skips)\n    {\n        if(timeTable[numberOfSegments][skips] <= hoursBefore)\n            return skips;\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint minSkips(const std::vector<int> &distance, int speed, int hoursBefore)\n{\n    int numberOfSegments= distance.size();\n    std::vector<std::vector<double>> timeTable(numberOfSegments + 1, std::vector<double>(numberOfSegments + 1, 1e6));\n\n    timeTable[0][0]= 0;\n    for(int segmentIndex= 1; segmentIndex <= numberOfSegments; ++segmentIndex)\n    {\n        timeTable[segmentIndex][0]= (timeTable[segmentIndex - 1][0] + distance[segmentIndex - 1] + speed - 1) / speed;\n    }\n\n    for(int segmentIndex= 1; segmentIndex <= numberOfSegments; ++segmentIndex)\n    {\n        for(int skips= 1; skips <= segmentIndex; ++skips)\n        {\n            timeTable[segmentIndex][skips]= std::min(timeTable[segmentIndex][skips], timeTable[segmentIndex - 1][skips - 1] + double(distance[segmentIndex - 1]) / speed);\n            timeTable[segmentIndex][skips]= std::min(timeTable[segmentIndex][skips], ceil(timeTable[segmentIndex - 1][skips] + double(distance[segmentIndex - 1]) / speed));\n        }\n    }\n\n    for(int skips= 0; skips <= numberOfSegments; ++skips)\n    {\n        if(timeTable[numberOfSegments][skips] <= hoursBefore)\n            return skips;\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring longestSubsequenceRepeatedK(const string &inputString, int repetitionCount)\n{\n    vector<int> characterCount(26, 0);\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char character = inputString[i];\n        characterCount[character - 'a']++;\n    }\n    string subsequence;\n    for (char character = 'a'; character <= 'z'; character++)\n    {\n        if (characterCount[character - 'a'] >= repetitionCount)\n            subsequence += string(characterCount[character - 'a'] / repetitionCount, character);\n    }\n\n    int subsequenceLength = subsequence.length();\n    vector<vector<int>> dpTable(subsequenceLength + 1, vector<int>(subsequenceLength + 1, 0));\n    for (int indexI = subsequenceLength - 1; indexI >= 0; indexI--)\n    {\n        for (int indexJ = indexI + 1; indexJ < subsequenceLength; indexJ++)\n        {\n            if (subsequence[indexI] == subsequence[indexJ])\n            {\n                dpTable[indexI][indexJ] = 1 + dpTable[indexI + 1][indexJ + 1];\n            }\n            else\n            {\n                dpTable[indexI][indexJ] = max(dpTable[indexI + 1][indexJ], dpTable[indexI][indexJ + 1]);\n            }\n        }\n    }\n\n    string result;\n    int currentIndexI = 0, currentIndexJ = 0;\n    while (currentIndexJ < subsequenceLength && result.length() < subsequenceLength / repetitionCount)\n    {\n        if (result.empty() || subsequence[currentIndexJ] > result.back())\n        {\n            if (dpTable[currentIndexI][currentIndexJ] >= (subsequenceLength / repetitionCount - result.length()) * 2)\n            {\n                result.push_back(subsequence[currentIndexJ]);\n                currentIndexI = currentIndexJ + 1;\n            }\n        }\n        currentIndexJ++;\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string longestSubsequenceRepeatedK(const std::string &inputString, int repetitionCount)\n{\n    std::vector<int> characterCount(26, 0);\n    for(auto character : inputString)\n    {\n        characterCount[character - 'a']++;\n    }\n    std::string subsequence;\n    for(char character= 'a'; character <= 'z'; character++)\n    {\n        if(characterCount[character - 'a'] >= repetitionCount)\n            subsequence+= std::string(characterCount[character - 'a'] / repetitionCount, character);\n    }\n\n    int subsequenceLength= subsequence.length();\n    std::vector<std::vector<int>> dpTable(subsequenceLength + 1, std::vector<int>(subsequenceLength + 1, 0));\n    for(int indexI= subsequenceLength - 1; indexI >= 0; indexI--)\n    {\n        for(int indexJ= indexI + 1; indexJ < subsequenceLength; indexJ++)\n        {\n            if(subsequence[indexI] == subsequence[indexJ])\n            {\n                dpTable[indexI][indexJ]= 1 + dpTable[indexI + 1][indexJ + 1];\n            }\n            else\n            {\n                dpTable[indexI][indexJ]= std::max(dpTable[indexI + 1][indexJ], dpTable[indexI][indexJ + 1]);\n            }\n        }\n    }\n\n    std::string result;\n    int currentIndexI= 0, currentIndexJ= 0;\n    while(currentIndexJ < subsequenceLength && result.length() < subsequenceLength / repetitionCount)\n    {\n        if(result.empty() || subsequence[currentIndexJ] > result.back())\n        {\n            if(dpTable[currentIndexI][currentIndexJ] >= (subsequenceLength / repetitionCount - result.length()) * 2)\n            {\n                result.push_back(subsequence[currentIndexJ]);\n                currentIndexI= currentIndexJ + 1;\n            }\n        }\n        currentIndexJ++;\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For std::swap\nusing namespace std;\n\nbool findRotation(vector<vector<int>> &matrix, vector<vector<int>> &target)\n{\n    for(int rotationCount= 0; rotationCount < 4; ++rotationCount)\n    {\n        if(matrix == target)\n            return true;\n        int size= matrix.size();\n        for(int row= 0; row < (size + 1) / 2; ++row)\n            for(int column= 0; column < size / 2; ++column)\n                swap(matrix[row][column], matrix[column][size - 1 - row], matrix[size - 1 - row][size - 1 - column], matrix[size - 1 - column][row]);\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool findRotation(std::vector<std::vector<int>> &matrix, std::vector<std::vector<int>> &target)\n{\n    for(int rotationCount= 0; rotationCount < 4; ++rotationCount)\n    {\n        if(matrix == target)\n            return true;\n        int size= matrix.size();\n        for(int row= 0; row < (size + 1) / 2; ++row)\n            for(int column= 0; column < size / 2; ++column)\n                std::swap(matrix[row][column], matrix[column][size - 1 - row]);\n                std::swap(matrix[size - 1 - row][size - 1 - column], matrix[size - 1 - column][row]);\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minStepsToEqualElements(vector<int> &numbers)\n{\n    int minimumElement = *min_element(numbers.begin(), numbers.end());\n    int totalSteps = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        totalSteps += (currentNumber - minimumElement);\n    }\n    return totalSteps;\n}",
    "output": "#include <bits/stdc++.h>\nint minStepsToEqualElements(std::vector<int> &numbers)\n{\n    int minimumElement= *std::min_element(numbers.begin(), numbers.end());\n    int totalSteps= 0;\n    for(int currentNumber : numbers)\n    {\n        totalSteps+= (currentNumber - minimumElement);\n    }\n    return totalSteps;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(string inputString)\n{\n    int operationCount= 0;\n    for(int index= 1; index < inputString.size(); ++index)\n    {\n        if(inputString[index] == inputString[index - 1])\n            operationCount++;\n    }\n    return operationCount;\n}",
    "output": "#include <bits/stdc++.h>\nint minOperations(std::string inputString)\n{\n    int operationCount= 0;\n    for(int index= 1; index < inputString.size(); ++index)\n    {\n        if(inputString[index] == inputString[index - 1])\n            operationCount++;\n    }\n    return operationCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minWastedSpace(vector<int> &packageSizes, vector<vector<int>> &boxSizes)\n{\n    constexpr int modulo = 1e9 + 7;\n    sort(packageSizes.begin(), packageSizes.end());\n    long long totalPackageSize = 0;\n    for (int packageSize : packageSizes)\n        totalPackageSize += packageSize;\n    long long minWastedSpace = LLONG_MAX;\n\n    for (int i = 0; i < boxSizes.size(); ++i)\n    {\n        vector<int> &boxSizeList = boxSizes[i];\n        sort(boxSizeList.begin(), boxSizeList.end());\n        if (boxSizeList.back() < packageSizes.back())\n            continue;\n        long long wastedSpace = 0;\n        auto packageIterator = packageSizes.begin();\n        for (int j = 0; j < boxSizeList.size(); ++j)\n        {\n            int boxSize = boxSizeList[j];\n            packageIterator = upper_bound(packageIterator, packageSizes.end(), boxSize);\n            wastedSpace += boxSize - *prev(packageIterator);\n        }\n        minWastedSpace = min(minWastedSpace, wastedSpace);\n    }\n    return minWastedSpace == LLONG_MAX ? -1 : (totalPackageSize + minWastedSpace) % modulo;\n}",
    "output": "#include <bits/stdc++.h>\nint minWastedSpace(std::vector<int> &packageSizes, std::vector<std::vector<int>> &boxSizes)\n{\n    constexpr int modulo= 1e9 + 7;\n    std::sort(packageSizes.begin(), packageSizes.end());\n    long long totalPackageSize= 0;\n    for(int packageSize : packageSizes)\n        totalPackageSize+= packageSize;\n    long long minWastedSpace= LLONG_MAX;\n\n    for(std::vector<int> &boxSizeList : boxSizes)\n    {\n        std::sort(boxSizeList.begin(), boxSizeList.end());\n        if(boxSizeList.back() < packageSizes.back())\n            continue;\n        long long wastedSpace= 0;\n        auto packageIterator= packageSizes.begin();\n        for(int boxSize : boxSizeList)\n        {\n            packageIterator= std::upper_bound(packageIterator, packageSizes.end(), boxSize);\n            wastedSpace+= boxSize - *std::prev(packageIterator);\n        }\n        minWastedSpace= std::min(minWastedSpace, wastedSpace);\n    }\n    return minWastedSpace == LLONG_MAX ? -1 : (totalPackageSize + minWastedSpace) % modulo;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint sumOfPoints(string expression, vector<int> &userAnswers)\n{\n    int correctPoints= 0, incorrectOrderPoints= 0;\n    int multiplicativeValue= 1, additiveValue= 0;\n    for(int index= 0; index < expression.length(); ++index)\n    {\n        if(isdigit(expression[index]))\n        {\n            int number= expression[index] - '0';\n            multiplicativeValue*= number;\n            if(index == expression.length() - 1 || expression[index + 1] == '+')\n            {\n                additiveValue+= multiplicativeValue;\n                multiplicativeValue= 1;\n            }\n        }\n    }\n\n    incorrectOrderPoints= (expression[0] - '0');\n    for(int index= 2; index < expression.length(); index+= 2)\n    {\n        if(expression[index - 1] == '+')\n            incorrectOrderPoints+= (expression[index] - '0');\n        else\n            incorrectOrderPoints*= (expression[index] - '0');\n    }\n\n    int totalPoints= 0;\n    for(int i = 0; i < userAnswers.size(); ++i)\n    {\n        int userAnswer = userAnswers[i];\n        totalPoints+= (userAnswer == correctPoints) * 5 + (userAnswer == incorrectOrderPoints) * 2;\n    }\n    return totalPoints;\n}",
    "output": "#include <bits/stdc++.h>\nint sumOfPoints(std::string expression, std::vector<int> &userAnswers)\n{\n    int correctPoints= 0, incorrectOrderPoints= 0;\n    int multiplicativeValue= 1, additiveValue= 0;\n    for(int index= 0; index < expression.length(); ++index)\n    {\n        if(std::isdigit(expression[index]))\n        {\n            int number= expression[index] - '0';\n            multiplicativeValue*= number;\n            if(index == expression.length() - 1 || expression[index + 1] == '+')\n            {\n                additiveValue+= multiplicativeValue;\n                multiplicativeValue= 1;\n            }\n        }\n    }\n\n    incorrectOrderPoints= (expression[0] - '0');\n    for(int index= 2; index < expression.length(); index+= 2)\n    {\n        if(expression[index - 1] == '+')\n            incorrectOrderPoints+= (expression[index] - '0');\n        else\n            incorrectOrderPoints*= (expression[index] - '0');\n    }\n\n    int totalPoints= 0;\n    for(int userAnswer : userAnswers)\n    {\n        totalPoints+= (userAnswer == correctPoints) * 5 + (userAnswer == incorrectOrderPoints) * 2;\n    }\n    return totalPoints;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring removeOccurrences(string sourceString, string substring)\n{\n    size_t position= 0;\n    while((position= sourceString.find(substring, position)) != string::npos)\n    {\n        sourceString.erase(position, substring.length());\n    }\n    return sourceString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string removeOccurrences(std::string sourceString, std::string substring)\n{\n    size_t position= 0;\n    while((position= sourceString.find(substring, position)) != std::string::npos)\n    {\n        sourceString.erase(position, substring.length());\n    }\n    return sourceString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long maxAlternatingSum(vector<int> &numbers)\n{\n    long long evenSum = 0, oddSum = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        evenSum = max(evenSum + currentNumber, oddSum);\n        oddSum = evenSum - currentNumber;\n    }\n    return evenSum;\n}",
    "output": "#include <bits/stdc++.h>\nlong long maxAlternatingSum(std::vector<int> &numbers)\n{\n    long long evenSum= 0, oddSum= 0;\n    for(int currentNumber : numbers)\n    {\n        evenSum= std::max(evenSum + currentNumber, oddSum);\n        oddSum= evenSum - currentNumber;\n    }\n    return evenSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass MovieRentingSystem\n{\n    unordered_map<int, unordered_map<int, int>> shopMoviePrice;\n    set<pair<int, int>> rentedMovies;\n    vector<set<pair<int, int>>> availableMovies;\n\n  public:\n    MovieRentingSystem(int numberOfShops, vector<vector<int>> &movieEntries)\n    {\n        for (const auto &entry : movieEntries)\n        {\n            int shop = entry[0], movie = entry[1], priceValue = entry[2];\n            shopMoviePrice[shop][movie] = priceValue;\n            if (availableMovies.size() <= movie)\n            {\n                availableMovies.resize(movie + 1);\n            }\n            availableMovies[movie].emplace(priceValue, shop);\n        }\n    }\n\n    vector<int> search(int movie)\n    {\n        vector<int> result;\n        auto it = availableMovies[movie].begin();\n        for (int i = 0; i < 5 && it != availableMovies[movie].end(); ++i, ++it)\n        {\n            result.push_back(it->second);\n        }\n        return result;\n    }\n\n    void rent(int shop, int movie)\n    {\n        int priceValue = shopMoviePrice[shop][movie];\n        rentedMovies.emplace(priceValue, shop);\n        availableMovies[movie].erase({priceValue, shop});\n    }\n\n    void drop(int shop, int movie)\n    {\n        int priceValue = shopMoviePrice[shop][movie];\n        rentedMovies.erase({priceValue, shop});\n        availableMovies[movie].emplace(priceValue, shop);\n    }\n\n    vector<vector<int>> report()\n    {\n        vector<vector<int>> result;\n        auto it = rentedMovies.begin();\n        for (int i = 0; i < 5 && it != rentedMovies.end(); ++i, ++it)\n        {\n            result.push_back({it->second, shopMoviePrice[it->second][it->first]}); // Corrected to access the right value\n        }\n        return result;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass MovieRentingSystem\n{\n    std::unordered_map<int, std::unordered_map<int, int>> shopMoviePrice;\n    std::set<std::pair<int, int>> rentedMovies;\n    std::vector<std::set<std::pair<int, int>>> availableMovies;\n\n  public:\n    MovieRentingSystem(int numberOfShops, std::vector<std::vector<int>> &movieEntries)\n    {\n        for(const auto &entry : movieEntries)\n        {\n            int shop= entry[0], movie= entry[1], priceValue= entry[2];\n            shopMoviePrice[shop][movie]= priceValue;\n            if(availableMovies.size() <= movie)\n            {\n                availableMovies.resize(movie + 1);\n            }\n            availableMovies[movie].emplace(priceValue, shop);\n        }\n    }\n\n    std::vector<int> search(int movie)\n    {\n        std::vector<int> result;\n        auto it= availableMovies[movie].begin();\n        for(int i= 0; i < 5 && it != availableMovies[movie].end(); ++i, ++it)\n        {\n            result.push_back(it->second);\n        }\n        return result;\n    }\n\n    void rent(int shop, int movie)\n    {\n        int priceValue= shopMoviePrice[shop][movie];\n        rentedMovies.emplace(priceValue, shop);\n        availableMovies[movie].erase({priceValue, shop});\n    }\n\n    void drop(int shop, int movie)\n    {\n        int priceValue= shopMoviePrice[shop][movie];\n        rentedMovies.erase({priceValue, shop});\n        availableMovies[movie].emplace(priceValue, shop);\n    }\n\n    std::vector<std::vector<int>> report()\n    {\n        std::vector<std::vector<int>> result;\n        auto it= rentedMovies.begin();\n        for(int i= 0; i < 5 && it != rentedMovies.end(); ++i, ++it)\n        {\n            result.push_back({it->second, shopMoviePrice[it->second]});\n        }\n        return result;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxConsecutiveAnswers(const string &answerKey, int maxFlips)\n{\n    int maxLength= 0, leftPointer= 0, trueCount= 0, falseCount= 0;\n\n    for(int rightPointer= 0; rightPointer < answerKey.size(); ++rightPointer)\n    {\n        if(answerKey[rightPointer] == 'T')\n        {\n            ++trueCount;\n        }\n        else\n        {\n            ++falseCount;\n        }\n\n        if(min(trueCount, falseCount) > maxFlips)\n        {\n            if(answerKey[leftPointer++] == 'T')\n            {\n                --trueCount;\n            }\n            else\n            {\n                --falseCount;\n            }\n        }\n        else\n        {\n            maxLength= max(maxLength, trueCount + falseCount);\n        }\n    }\n\n    return maxLength;\n}",
    "output": "#include <bits/stdc++.h>\nint maxConsecutiveAnswers(const std::string &answerKey, int maxFlips)\n{\n    int maxLength= 0, leftPointer= 0, trueCount= 0, falseCount= 0;\n\n    for(int rightPointer= 0; rightPointer < answerKey.size(); ++rightPointer)\n    {\n        if(answerKey[rightPointer] == 'T')\n        {\n            ++trueCount;\n        }\n        else\n        {\n            ++falseCount;\n        }\n\n        if(std::min(trueCount, falseCount) > maxFlips)\n        {\n            if(answerKey[leftPointer++] == 'T')\n            {\n                --trueCount;\n            }\n            else\n            {\n                --falseCount;\n            }\n        }\n        else\n        {\n            maxLength= std::max(maxLength, trueCount + falseCount);\n        }\n    }\n\n    return maxLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool makeEqual(vector<string> &words)\n{\n    unordered_set<char> uniqueCharacters;\n    int totalCharacterCount = 0;\n    for (int i = 0; i < words.size(); ++i)\n    {\n        totalCharacterCount += words[i].size();\n        for (int j = 0; j < words[i].size(); ++j)\n        {\n            char character = words[i][j];\n            uniqueCharacters.insert(character);\n        }\n    }\n    return totalCharacterCount % uniqueCharacters.size() == 0;\n}",
    "output": "#include <bits/stdc++.h>\nbool makeEqual(std::vector<std::string> &words)\n{\n    std::unordered_set<char> uniqueCharacters;\n    int totalCharacterCount= 0;\n    for(const std::string &word : words)\n    {\n        totalCharacterCount+= word.size();\n        for(char character : word)\n        {\n            uniqueCharacters.insert(character);\n        }\n    }\n    return totalCharacterCount % uniqueCharacters.size() == 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMaximumRemovals(string sourceString, string targetString, vector<int> &removableIndices)\n{\n    int lowerBound= 0, upperBound= removableIndices.size();\n    while(lowerBound < upperBound)\n    {\n        int midPoint= lowerBound + (upperBound - lowerBound + 1) / 2;\n        string modifiedString= sourceString;\n        for(int i= 0; i < midPoint; ++i)\n        {\n            modifiedString[removableIndices[i]]= '-';\n        }\n        int targetIndex= 0, sourceIndex= 0;\n        while(sourceIndex < modifiedString.size() && targetIndex < targetString.size())\n        {\n            if(modifiedString[sourceIndex] == targetString[targetIndex])\n            {\n                ++targetIndex;\n            }\n            ++sourceIndex;\n        }\n        if(targetIndex == targetString.size())\n        {\n            lowerBound= midPoint;\n        }\n        else\n        {\n            upperBound= midPoint - 1;\n        }\n    }\n    return lowerBound;\n}",
    "output": "#include <bits/stdc++.h>\nint findMaximumRemovals(std::string sourceString, std::string targetString, std::vector<int> &removableIndices)\n{\n    int lowerBound= 0, upperBound= removableIndices.size();\n    while(lowerBound < upperBound)\n    {\n        int midPoint= lowerBound + (upperBound - lowerBound + 1) / 2;\n        std::string modifiedString= sourceString;\n        for(int i= 0; i < midPoint; ++i)\n        {\n            modifiedString[removableIndices[i]]= '-';\n        }\n        int targetIndex= 0, sourceIndex= 0;\n        while(sourceIndex < modifiedString.size() && targetIndex < targetString.size())\n        {\n            if(modifiedString[sourceIndex] == targetString[targetIndex])\n            {\n                ++targetIndex;\n            }\n            ++sourceIndex;\n        }\n        if(targetIndex == targetString.size())\n        {\n            lowerBound= midPoint;\n        }\n        else\n        {\n            upperBound= midPoint - 1;\n        }\n    }\n    return lowerBound;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> earliestAndLatest(int totalPlayers, int firstPlayer, int secondPlayer)\n{\n    int earliestRound= 1, latestRound= 1;\n    while((firstPlayer + secondPlayer) != totalPlayers + 1 || abs(firstPlayer - secondPlayer) != 1)\n    {\n        if((firstPlayer + secondPlayer) <= totalPlayers + 1 && (firstPlayer - 1) / 2 == (secondPlayer - 1) / 2)\n            break;\n        if((firstPlayer + secondPlayer) > totalPlayers + 1)\n        {\n            totalPlayers= (totalPlayers + 1) / 2;\n            firstPlayer= (totalPlayers + 1) - secondPlayer;\n            secondPlayer= (totalPlayers + 1) - firstPlayer;\n        }\n        else\n        {\n            firstPlayer= (firstPlayer + 1) / 2;\n            secondPlayer= (secondPlayer + 1) / 2;\n        }\n        earliestRound++;\n        latestRound++;\n    }\n    return {earliestRound, latestRound};\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> earliestAndLatest(int totalPlayers, int firstPlayer, int secondPlayer)\n{\n    int earliestRound= 1, latestRound= 1;\n    while((firstPlayer + secondPlayer) != totalPlayers + 1 || std::abs(firstPlayer - secondPlayer) != 1)\n    {\n        if((firstPlayer + secondPlayer) <= totalPlayers + 1 && (firstPlayer - 1) / 2 == (secondPlayer - 1) / 2)\n            break;\n        if((firstPlayer + secondPlayer) > totalPlayers + 1)\n        {\n            totalPlayers= (totalPlayers + 1) / 2;\n            firstPlayer= (totalPlayers + 1) - secondPlayer;\n            secondPlayer= (totalPlayers + 1) - firstPlayer;\n        }\n        else\n        {\n            firstPlayer= (firstPlayer + 1) / 2;\n            secondPlayer= (secondPlayer + 1) / 2;\n        }\n        earliestRound++;\n        latestRound++;\n    }\n    return {earliestRound, latestRound};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool stoneGameIX(vector<int> &stones)\n{\n    int count[3] = {0, 0, 0};\n    for (int i = 0; i < stones.size(); ++i)\n    {\n        int stone = stones[i];\n        count[stone % 3]++;\n    }\n    return (count[1] && count[2]) || (count[1] > count[2] ? count[1] > count[2] + 2 : count[2] > count[1] + 1);\n}",
    "output": "#include <bits/stdc++.h>\nbool stoneGameIX(std::vector<int> &stones)\n{\n    int count[3]= {0, 0, 0};\n    for(int stone : stones)\n    {\n        count[stone % 3]++;\n    }\n    return (count[1] && count[2]) || (count[1] > count[2] ? count[1] > count[2] + 2 : count[2] > count[1] + 1);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring smallestSubsequence(string inputString, int desiredLength, char targetLetter, int maxRepetitions)\n{\n    int stringLength = inputString.size();\n    int remainingCharacters = stringLength - desiredLength;\n    int currentLetterCount = 0;\n\n    vector<char> result;\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentChar = inputString[i];\n        while (!result.empty() && result.back() > currentChar && remainingCharacters > 0)\n        {\n            if (result.back() == targetLetter)\n            {\n                if (currentLetterCount > maxRepetitions)\n                {\n                    --currentLetterCount;\n                    result.pop_back();\n                    --remainingCharacters;\n                }\n            }\n            else\n            {\n                result.pop_back();\n                --remainingCharacters;\n            }\n        }\n        if (result.size() < desiredLength)\n        {\n            if (currentChar == targetLetter)\n            {\n                ++currentLetterCount;\n            }\n            else if (desiredLength - result.size() > maxRepetitions - currentLetterCount)\n            {\n            }\n            else\n            {\n                continue;\n            }\n            result.push_back(currentChar);\n        }\n    }\n\n    return string(result.begin(), result.end());\n}",
    "output": "#include <bits/stdc++.h>\nstd::string smallestSubsequence(std::string inputString, int desiredLength, char targetLetter, int maxRepetitions)\n{\n    int stringLength= inputString.size();\n    int remainingCharacters= stringLength - desiredLength;\n    int currentLetterCount= 0;\n\n    std::vector<char> result;\n    for(char currentChar : inputString)\n    {\n        while(!result.empty() && result.back() > currentChar && remainingCharacters > 0)\n        {\n            if(result.back() == targetLetter)\n            {\n                if(currentLetterCount > maxRepetitions)\n                {\n                    --currentLetterCount;\n                    result.pop_back();\n                    --remainingCharacters;\n                }\n            }\n            else\n            {\n                result.pop_back();\n                --remainingCharacters;\n            }\n        }\n        if(result.size() < desiredLength)\n        {\n            if(currentChar == targetLetter)\n            {\n                ++currentLetterCount;\n            }\n            else if(desiredLength - result.size() > maxRepetitions - currentLetterCount)\n            {\n            }\n            else\n            {\n                continue;\n            }\n            result.push_back(currentChar);\n        }\n    }\n\n    return std::string(result.begin(), result.end());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "using namespace std;\n\nint minMoves(int totalBlocks)\n{\n    int movesArray[totalBlocks + 1];\n    movesArray[0] = 0;\n    movesArray[1] = 1;\n\n    for(int currentBlock = 2; currentBlock <= totalBlocks; currentBlock++)\n    {\n        movesArray[currentBlock] = currentBlock;\n        for(int brokenBlock = 1; brokenBlock < currentBlock; brokenBlock++)\n        {\n            int brokenCount = brokenBlock - 1;\n            int unbrokenCount = currentBlock - brokenBlock;\n            movesArray[currentBlock] = min(movesArray[currentBlock], 1 + max(movesArray[brokenCount], movesArray[unbrokenCount]));\n        }\n    }\n\n    return movesArray[totalBlocks];\n}",
    "output": "int minMoves(int totalBlocks)\n{\n    int movesArray[totalBlocks + 1];\n    movesArray[0]= 0;\n    movesArray[1]= 1;\n\n    for(int currentBlock= 2; currentBlock <= totalBlocks; currentBlock++)\n    {\n        movesArray[currentBlock]= currentBlock;\n        for(int brokenBlock= 1; brokenBlock < currentBlock; brokenBlock++)\n        {\n            int brokenCount= brokenBlock - 1;\n            int unbrokenCount= currentBlock - brokenBlock;\n            movesArray[currentBlock]= std::min(movesArray[currentBlock], 1 + std::max(movesArray[brokenCount], movesArray[unbrokenCount]));\n        }\n    }\n\n    return movesArray[totalBlocks];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring getLargestOddSubstring(string numberString)\n{\n    for(int index= 0; index < numberString.length(); ++index)\n    {\n        if((numberString[index] - '0') % 2 == 1)\n        {\n            return numberString.substr(0, index + 1);\n        }\n    }\n    return \"\";\n}",
    "output": "std::string getLargestOddSubstring(std::string numberString)\n{\n    for(int index= 0; index < numberString.length(); ++index)\n    {\n        if((numberString[index] - '0') % 2 == 1)\n        {\n            return numberString.substr(0, index + 1);\n        }\n    }\n    return \"\";\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint fullRoundsPlayed(const string &loginTime, const string &logoutTime)\n{\n    int loginHour= stoi(loginTime.substr(0, 2));\n    int loginMinute= stoi(loginTime.substr(3, 2));\n    int logoutHour= stoi(logoutTime.substr(0, 2));\n    int logoutMinute= stoi(logoutTime.substr(3, 2));\n\n    if((logoutHour * 60 + logoutMinute) < (loginHour * 60 + loginMinute))\n    {\n        logoutHour+= 24;\n    }\n\n    int totalRounds= (logoutHour * 60 + logoutMinute - (loginHour * 60 + loginMinute)) / 15;\n    return totalRounds;\n}",
    "output": "#include <bits/stdc++.h>\nint fullRoundsPlayed(const std::string &loginTime, const std::string &logoutTime)\n{\n    int loginHour= std::stoi(loginTime.substr(0, 2));\n    int loginMinute= std::stoi(loginTime.substr(3, 2));\n    int logoutHour= std::stoi(logoutTime.substr(0, 2));\n    int logoutMinute= std::stoi(logoutTime.substr(3, 2));\n\n    if((logoutHour * 60 + logoutMinute) < (loginHour * 60 + loginMinute))\n    {\n        logoutHour+= 24;\n    }\n\n    int totalRounds= (logoutHour * 60 + logoutMinute - (loginHour * 60 + loginMinute)) / 15;\n    return totalRounds;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> minAbsoluteDifference(vector<int> &numbers, vector<vector<int>> &queries)\n{\n    vector<int> result;\n\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        vector<int> query = queries[i];\n        int leftIndex = query[0];\n        int rightIndex = query[1];\n        set<int> uniqueNumbers;\n\n        for (int j = leftIndex; j <= rightIndex; ++j)\n            uniqueNumbers.insert(numbers[j]);\n\n        if (uniqueNumbers.size() == 1)\n        {\n            result.push_back(-1);\n        }\n        else\n        {\n            int minDifference = INT_MAX;\n            for (auto it = next(uniqueNumbers.begin()); it != uniqueNumbers.end(); ++it)\n                minDifference = min(minDifference, *it - *prev(it));\n\n            result.push_back(minDifference);\n        }\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> minAbsoluteDifference(std::vector<int> &numbers, std::vector<std::vector<int>> &queries)\n{\n    std::vector<int> result;\n\n    for(std::vector<int> query : queries)\n    {\n        int leftIndex= query[0];\n        int rightIndex= query[1];\n        std::set<int> uniqueNumbers;\n\n        for(int i= leftIndex; i <= rightIndex; ++i)\n            uniqueNumbers.insert(numbers[i]);\n\n        if(uniqueNumbers.size() == 1)\n        {\n            result.push_back(-1);\n        }\n        else\n        {\n            int minDifference= INT_MAX;\n            for(auto it= std::next(uniqueNumbers.begin()); it != uniqueNumbers.end(); ++it)\n                minDifference= std::min(minDifference, *it - *std::prev(it));\n\n            result.push_back(minDifference);\n        }\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(vector<vector<int>> &sourceGrid, vector<vector<int>> &targetGrid, int row, int column, bool &isSubIsland)\n{\n    if(row < 0 || row >= sourceGrid.size() || column < 0 || column >= sourceGrid[0].size() || targetGrid[row][column] == 0)\n    {\n        return;\n    }\n\n    if(sourceGrid[row][column] == 0)\n    {\n        isSubIsland = false;\n    }\n\n    targetGrid[row][column] = 0;\n\n    depthFirstSearch(sourceGrid, targetGrid, row + 1, column, isSubIsland);\n    depthFirstSearch(sourceGrid, targetGrid, row - 1, column, isSubIsland);\n    depthFirstSearch(sourceGrid, targetGrid, row, column + 1, isSubIsland);\n    depthFirstSearch(sourceGrid, targetGrid, row, column - 1, isSubIsland);\n}\n\nint countSubIslands(vector<vector<int>> &sourceGrid, vector<vector<int>> &targetGrid)\n{\n    int subIslandCount = 0;\n\n    for(int row = 0; row < sourceGrid.size(); ++row)\n    {\n        for(int column = 0; column < sourceGrid[0].size(); ++column)\n        {\n            if(targetGrid[row][column] == 1)\n            {\n                bool isSubIsland = true;\n                depthFirstSearch(sourceGrid, targetGrid, row, column, isSubIsland);\n                if(isSubIsland)\n                {\n                    ++subIslandCount;\n                }\n            }\n        }\n    }\n\n    return subIslandCount;\n}",
    "output": "#include <bits/stdc++.h>\nvoid depthFirstSearch(std::vector<std::vector<int>> &sourceGrid, std::vector<std::vector<int>> &targetGrid, int row, int column, bool &isSubIsland)\n{\n    if(row < 0 || row >= sourceGrid.size() || column < 0 || column >= sourceGrid[0].size() || targetGrid[row][column] == 0)\n    {\n        return;\n    }\n\n    if(sourceGrid[row][column] == 0)\n    {\n        isSubIsland= false;\n    }\n\n    targetGrid[row][column]= 0;\n\n    depthFirstSearch(sourceGrid, targetGrid, row + 1, column, isSubIsland);\n    depthFirstSearch(sourceGrid, targetGrid, row - 1, column, isSubIsland);\n    depthFirstSearch(sourceGrid, targetGrid, row, column + 1, isSubIsland);\n    depthFirstSearch(sourceGrid, targetGrid, row, column - 1, isSubIsland);\n}\n\nint countSubIslands(std::vector<std::vector<int>> &sourceGrid, std::vector<std::vector<int>> &targetGrid)\n{\n    int subIslandCount= 0;\n\n    for(int row= 0; row < sourceGrid.size(); ++row)\n    {\n        for(int column= 0; column < sourceGrid[0].size(); ++column)\n        {\n            if(targetGrid[row][column] == 1)\n            {\n                bool isSubIsland= true;\n                depthFirstSearch(sourceGrid, targetGrid, row, column, isSubIsland);\n                if(isSubIsland)\n                {\n                    ++subIslandCount;\n                }\n            }\n        }\n    }\n\n    return subIslandCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAlternatingSum(vector<int> &numArray)\n{\n    long oddSum = 0, evenSum = 0;\n    for (int i = 0; i < numArray.size(); ++i)\n    {\n        int currentNum = numArray[i];\n        long newOddSum = max(evenSum + currentNum, oddSum);\n        evenSum = max(oddSum - currentNum, evenSum);\n        oddSum = newOddSum;\n    }\n    return oddSum;\n}",
    "output": "#include <bits/stdc++.h>\nint maxAlternatingSum(std::vector<int> &numArray)\n{\n    long oddSum= 0, evenSum= 0;\n    for(int currentNum : numArray)\n    {\n        long newOddSum= std::max(evenSum + currentNum, oddSum);\n        evenSum= std::max(oddSum - currentNum, evenSum);\n        oddSum= newOddSum;\n    }\n    return oddSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countSquareTriples(int limit)\n{\n    int totalCount= 0;\n    for(int firstSide= 1; firstSide <= limit; firstSide++)\n    {\n        for(int secondSide= firstSide; secondSide <= limit; secondSide++)\n        {\n            int hypotenuse= sqrt(firstSide * firstSide + secondSide * secondSide);\n            if(hypotenuse * hypotenuse == firstSide * firstSide + secondSide * secondSide && hypotenuse <= limit)\n            {\n                totalCount++;\n            }\n        }\n    }\n    return totalCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countSquareTriples(int limit)\n{\n    int totalCount= 0;\n    for(int firstSide= 1; firstSide <= limit; firstSide++)\n    {\n        for(int secondSide= firstSide; secondSide <= limit; secondSide++)\n        {\n            int hypotenuse= std::sqrt(firstSide * firstSide + secondSide * secondSide);\n            if(hypotenuse * hypotenuse == firstSide * firstSide + secondSide * secondSide && hypotenuse <= limit)\n            {\n                totalCount++;\n            }\n        }\n    }\n    return totalCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint nearestExit(vector<vector<char>> &maze, vector<int> &entrance)\n{\n    int mazeRows = maze.size();\n    int mazeCols = maze[0].size();\n    vector<vector<int>> movementDirections = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    queue<pair<int, int>> positionQueue;\n    maze[entrance[0]][entrance[1]] = '+';\n    positionQueue.push({entrance[0], entrance[1]});\n    int stepCount = 0;\n\n    while (!positionQueue.empty())\n    {\n        int currentLevelSize = positionQueue.size();\n        for (int i = 0; i < currentLevelSize; ++i)\n        {\n            pair<int, int> currentPosition = positionQueue.front();\n            positionQueue.pop();\n            int currentX = currentPosition.first;\n            int currentY = currentPosition.second;\n            if ((currentX == 0 || currentX == mazeRows - 1 || currentY == 0 || currentY == mazeCols - 1) && (currentX != entrance[0] || currentY != entrance[1]))\n                return stepCount;\n\n            for (int j = 0; j < movementDirections.size(); ++j)\n            {\n                int nextX = currentX + movementDirections[j][0];\n                int nextY = currentY + movementDirections[j][1];\n                if (nextX >= 0 && nextX < mazeRows && nextY >= 0 && nextY < mazeCols && maze[nextX][nextY] == '.')\n                {\n                    maze[nextX][nextY] = '+';\n                    positionQueue.push({nextX, nextY});\n                }\n            }\n        }\n        ++stepCount;\n    }\n\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint nearestExit(std::vector<std::vector<char>> &maze, std::vector<int> &entrance)\n{\n    int mazeRows = maze.size();\n    int mazeCols = maze[0].size();\n    std::vector<std::vector<int>> movementDirections = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    std::queue<std::pair<int, int>> positionQueue;\n    maze[entrance[0]][entrance[1]] = '+';\n    positionQueue.push({entrance[0], entrance[1]});\n    int stepCount = 0;\n\n    while (!positionQueue.empty())\n    {\n        int currentLevelSize = positionQueue.size();\n        for (int i = 0; i < currentLevelSize; ++i)\n        {\n            std::pair<int, int> currentPosition = positionQueue.front();\n            positionQueue.pop();\n            int currentX = currentPosition.first;\n            int currentY = currentPosition.second;\n            if ((currentX == 0 || currentX == mazeRows - 1 || currentY == 0 || currentY == mazeCols - 1) && (currentX != entrance[0] || currentY != entrance[1]))\n                return stepCount;\n\n            for (auto direction : movementDirections)\n            {\n                int nextX = currentX + direction[0];\n                int nextY = currentY + direction[1];\n                if (nextX >= 0 && nextX < mazeRows && nextY >= 0 && nextY < mazeCols && maze[nextX][nextY] == '.')\n                {\n                    maze[nextX][nextY] = '+';\n                    positionQueue.push({nextX, nextY});\n                }\n            }\n        }\n        ++stepCount;\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool sumGame(string numberString)\n{\n    int stringLength= numberString.size();\n    int sumFirstHalf= 0, sumSecondHalf= 0, countFirstHalf= 0, countSecondHalf= 0;\n\n    for(int index= 0; index < stringLength / 2; index++)\n    {\n        if(numberString[index] == '?')\n            countFirstHalf++;\n        else\n            sumFirstHalf+= numberString[index] - '0';\n    }\n\n    for(int index= stringLength / 2; index < stringLength; index++)\n    {\n        if(numberString[index] == '?')\n            countSecondHalf++;\n        else\n            sumSecondHalf+= numberString[index] - '0';\n    }\n\n    return ((sumFirstHalf - sumSecondHalf) != ((countSecondHalf - countFirstHalf) / 2) * 9);\n}",
    "output": "#include <bits/stdc++.h>\nbool sumGame(std::string numberString)\n{\n    int stringLength= numberString.size();\n    int sumFirstHalf= 0, sumSecondHalf= 0, countFirstHalf= 0, countSecondHalf= 0;\n\n    for(int index= 0; index < stringLength / 2; index++)\n    {\n        if(numberString[index] == '?')\n            countFirstHalf++;\n        else\n            sumFirstHalf+= numberString[index] - '0';\n    }\n\n    for(int index= stringLength / 2; index < stringLength; index++)\n    {\n        if(numberString[index] == '?')\n            countSecondHalf++;\n        else\n            sumSecondHalf+= numberString[index] - '0';\n    }\n\n    return ((sumFirstHalf - sumSecondHalf) != ((countSecondHalf - countFirstHalf) / 2) * 9);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minCost(int maxTimeLimit, vector<vector<int>> &edges, vector<int> &passingFees)\n{\n    int numberOfCities = passingFees.size();\n    vector<vector<pair<int, int>>> cityGraph(numberOfCities);\n    for (int i = 0; i < edges.size(); ++i) // Convert to traditional for loop\n    {\n        const auto &edge = edges[i];\n        cityGraph[edge[0]].emplace_back(edge[1], edge[2]);\n        cityGraph[edge[1]].emplace_back(edge[0], edge[2]);\n    }\n\n    vector<vector<int>> minCostTable(numberOfCities, vector<int>(maxTimeLimit + 1, INT_MAX));\n    minCostTable[0][0] = passingFees[0];\n    priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> priorityQueue;\n    priorityQueue.emplace(0, 0, passingFees[0]);\n\n    while (!priorityQueue.empty())\n    {\n        auto [currentTime, currentCity, currentCost] = priorityQueue.top();\n        priorityQueue.pop();\n        if (currentCity == numberOfCities - 1)\n        {\n            return currentCost;\n        }\n        for (int j = 0; j < cityGraph[currentCity].size(); ++j) // Convert to traditional for loop\n        {\n            const auto &[neighboringCity, travelTime] = cityGraph[currentCity][j];\n            int nextTravelTime = currentTime + travelTime;\n            if (nextTravelTime > maxTimeLimit)\n                continue;\n            int newCost = currentCost + passingFees[neighboringCity];\n            if (newCost < minCostTable[neighboringCity][nextTravelTime])\n            {\n                minCostTable[neighboringCity][nextTravelTime] = newCost;\n                priorityQueue.emplace(nextTravelTime, neighboringCity, newCost);\n            }\n        }\n    }\n\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint minCost(int maxTimeLimit, std::vector<std::vector<int>> &edges, std::vector<int> &passingFees)\n{\n    int numberOfCities = passingFees.size();\n    std::vector<std::vector<std::pair<int, int>>> cityGraph(numberOfCities);\n    for(const auto &edge : edges)\n    {\n        cityGraph[edge[0]].emplace_back(edge[1], edge[2]);\n        cityGraph[edge[1]].emplace_back(edge[0], edge[2]);\n    }\n\n    std::vector<std::vector<int>> minCostTable(numberOfCities, std::vector<int>(maxTimeLimit + 1, std::numeric_limits<int>::max()));\n    minCostTable[0][0] = passingFees[0];\n    std::priority_queue<std::tuple<int, int, int>, std::vector<std::tuple<int, int, int>>, std::greater<>> priorityQueue;\n    priorityQueue.emplace(0, 0, passingFees[0]);\n\n    while(!priorityQueue.empty())\n    {\n        auto [currentTime, currentCity, currentCost] = priorityQueue.top();\n        priorityQueue.pop();\n        if(currentCity == numberOfCities - 1)\n        {\n            return currentCost;\n        }\n        for(const auto &[neighboringCity, travelTime] : cityGraph[currentCity])\n        {\n            int nextTravelTime = currentTime + travelTime;\n            if(nextTravelTime > maxTimeLimit)\n                continue;\n            int newCost = currentCost + passingFees[neighboringCity];\n            if(newCost < minCostTable[neighboringCity][nextTravelTime])\n            {\n                minCostTable[neighboringCity][nextTravelTime] = newCost;\n                priorityQueue.emplace(nextTravelTime, neighboringCity, newCost);\n            }\n        }\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For INT_MAX and INT_MIN\nusing namespace std;\n\nint maxProductDifference(vector<int> &numbers)\n{\n    int firstMin = INT_MAX, secondMin = INT_MAX, firstMax = INT_MIN, secondMax = INT_MIN;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        if (currentNumber < firstMin)\n        {\n            secondMin = firstMin;\n            firstMin = currentNumber;\n        }\n        else if (currentNumber < secondMin)\n        {\n            secondMin = currentNumber;\n        }\n        if (currentNumber > firstMax)\n        {\n            secondMax = firstMax;\n            firstMax = currentNumber;\n        }\n        else if (currentNumber > secondMax)\n        {\n            secondMax = currentNumber;\n        }\n    }\n    return firstMax * secondMax - firstMin * secondMin;\n}",
    "output": "#include <bits/stdc++.h>\nint maxProductDifference(std::vector<int> &numbers)\n{\n    int firstMin = std::numeric_limits<int>::max(), secondMin = std::numeric_limits<int>::max(), firstMax = std::numeric_limits<int>::min(), secondMax = std::numeric_limits<int>::min();\n    for(int currentNumber : numbers)\n    {\n        if(currentNumber < firstMin)\n        {\n            secondMin = firstMin;\n            firstMin = currentNumber;\n        }\n        else if(currentNumber < secondMin)\n        {\n            secondMin = currentNumber;\n        }\n        if(currentNumber > firstMax)\n        {\n            secondMax = firstMax;\n            firstMax = currentNumber;\n        }\n        else if(currentNumber > secondMax)\n        {\n            secondMax = currentNumber;\n        }\n    }\n    return firstMax * secondMax - firstMin * secondMin;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid rotateLayer(vector<vector<int>> &matrix, int layerIndex, int rotationCount)\n{\n    int rowCount= matrix.size(), columnCount= matrix[0].size();\n    int topBoundary= layerIndex, bottomBoundary= rowCount - 1 - layerIndex;\n    int leftBoundary= layerIndex, rightBoundary= columnCount - 1 - layerIndex;\n    int elementsInLayer= (rightBoundary - leftBoundary + 1) * 2 + (bottomBoundary - topBoundary - 1) * 2;\n    rotationCount%= elementsInLayer;\n    while(rotationCount--)\n    {\n        int tempValue= matrix[topBoundary][leftBoundary];\n        for(int j= leftBoundary; j < rightBoundary; j++)\n            matrix[topBoundary][j]= matrix[topBoundary][j + 1];\n        for(int i= topBoundary; i < bottomBoundary; i++)\n            matrix[i][rightBoundary]= matrix[i + 1][rightBoundary];\n        for(int j= rightBoundary; j > leftBoundary; j--)\n            matrix[bottomBoundary][j]= matrix[bottomBoundary][j - 1];\n        for(int i= bottomBoundary; i > topBoundary; i--)\n            matrix[i][leftBoundary]= matrix[i - 1][leftBoundary];\n        matrix[topBoundary + 1][leftBoundary]= tempValue;\n    }\n}\n\nvector<vector<int>> rotateGrid(vector<vector<int>> &grid, int rotationCount)\n{\n    int rowCount= grid.size(), columnCount= grid[0].size();\n    int totalLayers= min(rowCount, columnCount) / 2;\n    for(int layerIndex= 0; layerIndex < totalLayers; layerIndex++)\n    {\n        rotateLayer(grid, layerIndex, rotationCount);\n    }\n    return grid;\n}",
    "output": "#include <bits/stdc++.h>\nvoid rotateLayer(std::vector<std::vector<int>> &matrix, int layerIndex, int rotationCount)\n{\n    int rowCount= matrix.size(), columnCount= matrix[0].size();\n    int topBoundary= layerIndex, bottomBoundary= rowCount - 1 - layerIndex;\n    int leftBoundary= layerIndex, rightBoundary= columnCount - 1 - layerIndex;\n    int elementsInLayer= (rightBoundary - leftBoundary + 1) * 2 + (bottomBoundary - topBoundary - 1) * 2;\n    rotationCount%= elementsInLayer;\n    while(rotationCount--)\n    {\n        int tempValue= matrix[topBoundary][leftBoundary];\n        for(int j= leftBoundary; j < rightBoundary; j++)\n            matrix[topBoundary][j]= matrix[topBoundary][j + 1];\n        for(int i= topBoundary; i < bottomBoundary; i++)\n            matrix[i][rightBoundary]= matrix[i + 1][rightBoundary];\n        for(int j= rightBoundary; j > leftBoundary; j--)\n            matrix[bottomBoundary][j]= matrix[bottomBoundary][j - 1];\n        for(int i= bottomBoundary; i > topBoundary; i--)\n            matrix[i][leftBoundary]= matrix[i - 1][leftBoundary];\n        matrix[topBoundary + 1][leftBoundary]= tempValue;\n    }\n}\n\nstd::vector<std::vector<int>> rotateGrid(std::vector<std::vector<int>> &grid, int rotationCount)\n{\n    int rowCount= grid.size(), columnCount= grid[0].size();\n    int totalLayers= std::min(rowCount, columnCount) / 2;\n    for(int layerIndex= 0; layerIndex < totalLayers; layerIndex++)\n    {\n        rotateLayer(grid, layerIndex, rotationCount);\n    }\n    return grid;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long countWonderfulSubstrings(string inputWord)\n{\n    long long totalSubstrings = 0;\n    int bitmask = 0;\n    unordered_map<int, int> substringCount{{0, 1}};\n    for (int i = 0; i < inputWord.size(); ++i)\n    {\n        char currentChar = inputWord[i];\n        bitmask ^= 1 << (currentChar - 'a');\n        totalSubstrings += substringCount[bitmask];\n        for (int index = 0; index < 10; ++index)\n            totalSubstrings += substringCount[bitmask ^ (1 << index)];\n        ++substringCount[bitmask];\n    }\n    return totalSubstrings;\n}",
    "output": "#include <bits/stdc++.h>\nlong long countWonderfulSubstrings(std::string inputWord)\n{\n    long long totalSubstrings= 0;\n    int bitmask= 0;\n    std::unordered_map<int, int> substringCount{{0, 1}};\n    for(char currentChar : inputWord)\n    {\n        bitmask^= 1 << (currentChar - 'a');\n        totalSubstrings+= substringCount[bitmask];\n        for(int index= 0; index < 10; ++index)\n            totalSubstrings+= substringCount[bitmask ^ (1 << index)];\n        ++substringCount[bitmask];\n    }\n    return totalSubstrings;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint secondMinimum(int nodeCount, vector<vector<int>> &edges, int travelTime, int signalChange)\n{\n    vector<vector<int>> adjacencyList(nodeCount + 1);\n    for (const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    const int infinity = 1e9;\n    vector<int> firstDistance(nodeCount + 1, infinity);\n    vector<int> secondDistance(nodeCount + 1, infinity);\n    firstDistance[1] = 0;\n\n    queue<int> nodeQueue;\n    nodeQueue.push(1);\n\n    while (!nodeQueue.empty())\n    {\n        int currentNode = nodeQueue.front();\n        nodeQueue.pop();\n\n        int nextDistance = firstDistance[currentNode] + travelTime;\n        int waitDuration = (nextDistance / signalChange % 2 == 1) ? signalChange : 0;\n        nextDistance += waitDuration;\n\n        for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n        {\n            int nextNode = adjacencyList[currentNode][i];\n            if (nextDistance < firstDistance[nextNode])\n            {\n                swap(nextDistance, firstDistance[nextNode]);\n                nodeQueue.push(nextNode);\n            }\n            if (nextDistance < secondDistance[nextNode])\n            {\n                swap(nextDistance, secondDistance[nextNode]);\n                nodeQueue.push(nextNode);\n            }\n        }\n    }\n    return secondDistance[nodeCount];\n}",
    "output": "#include <bits/stdc++.h>\nint secondMinimum(int nodeCount, std::vector<std::vector<int>> &edges, int travelTime, int signalChange)\n{\n    std::vector<std::vector<int>> adjacencyList(nodeCount + 1);\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    const int infinity= 1e9;\n    std::vector<int> firstDistance(nodeCount + 1, infinity);\n    std::vector<int> secondDistance(nodeCount + 1, infinity);\n    firstDistance[1]= 0;\n\n    std::queue<int> nodeQueue;\n    nodeQueue.push(1);\n\n    while(!nodeQueue.empty())\n    {\n        int currentNode= nodeQueue.front();\n        nodeQueue.pop();\n\n        int nextDistance= firstDistance[currentNode] + travelTime;\n        int waitDuration= (nextDistance / signalChange % 2 == 1) ? signalChange : 0;\n        nextDistance+= waitDuration;\n\n        for(int nextNode : adjacencyList[currentNode])\n        {\n            if(nextDistance < firstDistance[nextNode])\n            {\n                std::swap(nextDistance, firstDistance[nextNode]);\n                nodeQueue.push(nextNode);\n            }\n            if(nextDistance < secondDistance[nextNode])\n            {\n                std::swap(nextDistance, secondDistance[nextNode]);\n                nodeQueue.push(nextNode);\n            }\n        }\n    }\n    return secondDistance[nodeCount];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int value, ListNode *next= NULL) : value(value), next(next) {}\n};\n\nListNode *sortedList(ListNode *head)\n{\n    if(!head || !head->next)\n        return head;\n\n    ListNode *previous= head;\n    ListNode *current= head->next;\n\n    while(current)\n    {\n        if(current->value < previous->value)\n        {\n            previous->next= current->next;\n            current->next= head;\n            head= current;\n            current= previous;\n        }\n        else\n        {\n            previous= current;\n        }\n        current= current->next;\n    }\n    return head;\n}",
    "output": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int value, ListNode *next= NULL) : value(value), next(next) {}\n};\n\nListNode *sortedList(ListNode *head)\n{\n    if(!head || !head->next)\n        return head;\n\n    ListNode *previous= head;\n    ListNode *current= head->next;\n\n    while(current)\n    {\n        if(current->value < previous->value)\n        {\n            previous->next= current->next;\n            current->next= head;\n            head= current;\n            current= previous;\n        }\n        else\n        {\n            previous= current;\n        }\n        current= current->next;\n    }\n    return head;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findPeakGrid(vector<vector<int>> &matrix)\n{\n    int rowCount= matrix.size(), columnCount= matrix[0].size();\n    int leftIndex= 0, rightIndex= columnCount - 1;\n\n    while(leftIndex < rightIndex)\n    {\n        int midIndex= (leftIndex + rightIndex) / 2;\n        int maxRowIndex= 0;\n\n        for(int i= 1; i < rowCount; i++)\n        {\n            if(matrix[i][midIndex] > matrix[maxRowIndex][midIndex])\n            {\n                maxRowIndex= i;\n            }\n        }\n\n        if(matrix[maxRowIndex][midIndex] < matrix[maxRowIndex][midIndex + 1])\n        {\n            leftIndex= midIndex + 1;\n        }\n        else\n        {\n            rightIndex= midIndex;\n        }\n    }\n\n    int finalMaxRowIndex= 0;\n    for(int i= 1; i < rowCount; i++)\n    {\n        if(matrix[i][leftIndex] > matrix[finalMaxRowIndex][leftIndex])\n        {\n            finalMaxRowIndex= i;\n        }\n    }\n\n    return {finalMaxRowIndex, leftIndex};\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findPeakGrid(std::vector<std::vector<int>> &matrix)\n{\n    int rowCount = matrix.size(), columnCount = matrix[0].size();\n    int leftIndex = 0, rightIndex = columnCount - 1;\n\n    while (leftIndex < rightIndex)\n    {\n        int midIndex = (leftIndex + rightIndex) / 2;\n        int maxRowIndex = 0;\n\n        for (int i = 1; i < rowCount; i++)\n        {\n            if (matrix[i][midIndex] > matrix[maxRowIndex][midIndex])\n            {\n                maxRowIndex = i;\n            }\n        }\n\n        if (matrix[maxRowIndex][midIndex] < matrix[maxRowIndex][midIndex + 1])\n        {\n            leftIndex = midIndex + 1;\n        }\n        else\n        {\n            rightIndex = midIndex;\n        }\n    }\n\n    int finalMaxRowIndex = 0;\n    for (int i = 1; i < rowCount; i++)\n    {\n        if (matrix[i][leftIndex] > matrix[finalMaxRowIndex][leftIndex])\n        {\n            finalMaxRowIndex = i;\n        }\n    }\n\n    return {finalMaxRowIndex, leftIndex};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> buildArray(vector<int> &inputNumbers)\n{\n    vector<int> resultArray(inputNumbers.size());\n    for(int index= 0; index < inputNumbers.size(); index++)\n    {\n        resultArray[index]= inputNumbers[inputNumbers[index]];\n    }\n    return resultArray;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> buildArray(std::vector<int> &inputNumbers)\n{\n    std::vector<int> resultArray(inputNumbers.size());\n    for(int index= 0; index < inputNumbers.size(); index++)\n    {\n        resultArray[index]= inputNumbers[inputNumbers[index]];\n    }\n    return resultArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint eliminateMonsters(vector<int> &distances, vector<int> &speeds)\n{\n    int numberOfMonsters= distances.size();\n    vector<double> timeToReach(numberOfMonsters);\n    for(int index= 0; index < numberOfMonsters; ++index)\n    {\n        timeToReach[index]= distances[index] / static_cast<double>(speeds[index]);\n    }\n    sort(timeToReach.begin(), timeToReach.end());\n    int monstersEliminated= 0;\n    for(int index= 0; index < numberOfMonsters; ++index)\n    {\n        if(monstersEliminated < timeToReach[index])\n        {\n            monstersEliminated++;\n        }\n    }\n    return monstersEliminated;\n}",
    "output": "#include <bits/stdc++.h>\nint eliminateMonsters(std::vector<int> &distances, std::vector<int> &speeds)\n{\n    int numberOfMonsters= distances.size();\n    std::vector<double> timeToReach(numberOfMonsters);\n    for(int index= 0; index < numberOfMonsters; ++index)\n    {\n        timeToReach[index]= distances[index] / static_cast<double>(speeds[index]);\n    }\n    std::sort(timeToReach.begin(), timeToReach.end());\n    int monstersEliminated= 0;\n    for(int index= 0; index < numberOfMonsters; ++index)\n    {\n        if(monstersEliminated < timeToReach[index])\n        {\n            monstersEliminated++;\n        }\n    }\n    return monstersEliminated;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int countGoodDigitStrings(int length)\n{\n    const int modulus= 1e9 + 7;\n    long long evenDigits= 5, primeDigits= 4, totalCount= 1;\n    for(int index= 0; index < length; ++index)\n    {\n        totalCount= (totalCount * (index % 2 == 0 ? evenDigits : primeDigits)) % modulus;\n    }\n    return totalCount;\n}",
    "output": "int countGoodDigitStrings(int length)\n{\n    const int modulus= 1e9 + 7;\n    long long evenDigits= 5, primeDigits= 4, totalCount= 1;\n    for(int index= 0; index < length; ++index)\n    {\n        totalCount= (totalCount * (index % 2 == 0 ? evenDigits : primeDigits)) % modulus;\n    }\n    return totalCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minCost(string sentence, int maxLength)\n{\n    vector<string> wordList;\n    string currentWord;\n    for (int i = 0; i < sentence.size(); ++i)\n    {\n        char character = sentence[i];\n        if (character == ' ')\n        {\n            wordList.push_back(currentWord);\n            currentWord.clear();\n        }\n        else\n        {\n            currentWord.push_back(character);\n        }\n    }\n    wordList.push_back(currentWord);\n    vector<int> dynamicProgramming(wordList.size() + 1, numeric_limits<int>::max());\n    dynamicProgramming[0] = 0;\n    for (int i = 0; i < wordList.size(); ++i)\n    {\n        int length = 0;\n        for (int j = i; j >= 0; --j)\n        {\n            length += wordList[j].size();\n            if (length + (i - j) <= maxLength)\n            {\n                dynamicProgramming[i + 1] = min(dynamicProgramming[i + 1], dynamicProgramming[j] + (maxLength - length - (i - j)) * (maxLength - length - (i - j)));\n            }\n            else\n            {\n                break;\n            }\n            length += 1;\n        }\n    }\n    return dynamicProgramming.back();\n}",
    "output": "#include <bits/stdc++.h>\nint minCost(std::string sentence, int maxLength)\n{\n    std::vector<std::string> wordList;\n    std::string currentWord;\n    for(const char character : sentence)\n    {\n        if(character == ' ')\n        {\n            wordList.push_back(currentWord);\n            currentWord.clear();\n        }\n        else\n        {\n            currentWord.push_back(character);\n        }\n    }\n    wordList.push_back(currentWord);\n    std::vector<int> dynamicProgramming(wordList.size() + 1, std::numeric_limits<int>::max());\n    dynamicProgramming[0]= 0;\n    for(int i= 0; i < wordList.size(); ++i)\n    {\n        int length= 0;\n        for(int j= i; j >= 0; --j)\n        {\n            length+= wordList[j].size();\n            if(length + (i - j) <= maxLength)\n            {\n                dynamicProgramming[i + 1]= std::min(dynamicProgramming[i + 1], dynamicProgramming[j] + (maxLength - length - (i - j)) * (maxLength - length - (i - j)));\n            }\n            else\n            {\n                break;\n            }\n            length+= 1;\n        }\n    }\n    return dynamicProgramming.back();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isGoodString(const string &inputString)\n{\n    unordered_map<char, int> characterFrequencyMap;\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentCharacter = inputString[i];\n        characterFrequencyMap[currentCharacter]++;\n    }\n\n    int frequencyCount = characterFrequencyMap.begin()->second;\n    for (auto it = characterFrequencyMap.begin(); it != characterFrequencyMap.end(); ++it)\n    {\n        if (it->second != frequencyCount)\n        {\n            return false;\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isGoodString(const std::string &inputString)\n{\n    std::unordered_map<char, int> characterFrequencyMap;\n    for(char currentCharacter : inputString)\n    {\n        characterFrequencyMap[currentCharacter]++;\n    }\n\n    int frequencyCount= characterFrequencyMap.begin()->second;\n    for(const auto &frequencyEntry : characterFrequencyMap)\n    {\n        if(frequencyEntry.second != frequencyCount)\n        {\n            return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findChair(vector<vector<int>> &timeIntervals, int targetFriend)\n{\n    int numberOfFriends = timeIntervals.size();\n    vector<pair<int, int>> events;\n    for (int i = 0; i < numberOfFriends; ++i)\n    {\n        events.push_back({timeIntervals[i][0], i});\n        events.push_back({timeIntervals[i][1], ~i});\n    }\n    sort(events.begin(), events.end());\n    vector<int> assignedChairs(numberOfFriends, -1);\n    set<int> availableChairs;\n    for (int i = 0; i < numberOfFriends; ++i)\n    {\n        availableChairs.insert(i);\n    }\n    for (int i = 0; i < events.size(); ++i)\n    {\n        auto &event = events[i];\n        if (event.second >= 0)\n        {\n            int friendId = event.second;\n            assignedChairs[friendId] = *availableChairs.begin();\n            availableChairs.erase(availableChairs.begin());\n            if (friendId == targetFriend)\n            {\n                return assignedChairs[friendId];\n            }\n        }\n        else\n        {\n            int friendId = ~event.second;\n            availableChairs.insert(assignedChairs[friendId]);\n        }\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint findChair(std::vector<std::vector<int>> &timeIntervals, int targetFriend)\n{\n    int numberOfFriends = timeIntervals.size();\n    std::vector<std::pair<int, int>> events;\n    for(int i = 0; i < numberOfFriends; ++i)\n    {\n        events.push_back({timeIntervals[i][0], i});\n        events.push_back({timeIntervals[i][1], ~i});\n    }\n    std::sort(events.begin(), events.end());\n    std::vector<int> assignedChairs(numberOfFriends, -1);\n    std::set<int> availableChairs;\n    for(int i = 0; i < numberOfFriends; ++i)\n    {\n        availableChairs.insert(i);\n    }\n    for(auto &event : events)\n    {\n        if(event.second >= 0)\n        {\n            int friendId = event.second;\n            assignedChairs[friendId] = *availableChairs.begin();\n            availableChairs.erase(availableChairs.begin());\n            if(friendId == targetFriend)\n            {\n                return assignedChairs[friendId];\n            }\n        }\n        else\n        {\n            int friendId = ~event.second;\n            availableChairs.insert(assignedChairs[friendId]);\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> splitPainting(vector<vector<int>> &segments)\n{\n    map<int, int> colorChanges;\n    for (int i = 0; i < segments.size(); ++i)\n    {\n        colorChanges[segments[i][0]] += segments[i][2];\n        colorChanges[segments[i][1]] -= segments[i][2];\n    }\n\n    vector<vector<int>> result;\n    int startPosition = 0, colorSum = 0;\n    for (auto it = colorChanges.begin(); it != colorChanges.end(); ++it)\n    {\n        auto change = *it;\n        if (startPosition != change.first)\n        {\n            if (colorSum)\n                result.push_back({startPosition, change.first, colorSum});\n            startPosition = change.first;\n        }\n        colorSum += change.second;\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> splitPainting(std::vector<std::vector<int>> &segments)\n{\n    std::map<int, int> colorChanges;\n    for(auto &segment : segments)\n    {\n        colorChanges[segment[0]]+= segment[2];\n        colorChanges[segment[1]]-= segment[2];\n    }\n\n    std::vector<std::vector<int>> result;\n    int startPosition= 0, colorSum= 0;\n    for(auto &change : colorChanges)\n    {\n        if(startPosition != change.first)\n        {\n            if(colorSum)\n                result.push_back({startPosition, change.first, colorSum});\n            startPosition= change.first;\n        }\n        colorSum+= change.second;\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countValidCombos(vector<string> &chessPieces, vector<vector<int>> &piecePositions, int currentIndex= 0)\n{\n    if(currentIndex == chessPieces.size())\n    {\n        return 1;\n    }\n\n    int row= piecePositions[currentIndex][0], column= piecePositions[currentIndex][1];\n    int directionRow[]= {0, 1, 0, -1, 1, 1, -1, -1};\n    int directionColumn[]= {1, 0, -1, 0, 1, -1, 1, -1};\n    int validCount= 0;\n\n    for(int direction= 0; direction < 8; ++direction)\n    {\n        if(chessPieces[currentIndex] == \"bishop\" && direction < 4)\n            continue;\n        if(chessPieces[currentIndex] == \"rook\" && direction >= 4)\n            break;\n\n        for(int distance= 1; distance <= 8; distance++)\n        {\n            int newRow= row + directionRow[direction] * distance;\n            int newColumn= column + directionColumn[direction] * distance;\n            if(newRow < 1 || newRow > 8 || newColumn < 1 || newColumn > 8)\n                break;\n            if(newRow == row && newColumn == column)\n                continue;\n\n            bool isValid= true;\n            for(int otherIndex= 0; otherIndex < piecePositions.size(); ++otherIndex)\n            {\n                if(otherIndex == currentIndex)\n                    continue;\n                int otherRow= piecePositions[otherIndex][0], otherColumn= piecePositions[otherIndex][1];\n                if(otherRow == newRow && otherColumn == newColumn)\n                {\n                    isValid= false;\n                    break;\n                }\n                if(otherRow + otherColumn == newRow + newColumn || otherRow - otherColumn == newRow - newColumn)\n                {\n                    isValid= false;\n                    break;\n                }\n                if(otherRow == newRow || otherColumn == newColumn)\n                {\n                    isValid= false;\n                    break;\n                }\n            }\n\n            if(isValid)\n            {\n                vector<int> temporaryPosition= {newRow, newColumn};\n                piecePositions[currentIndex]= temporaryPosition;\n                validCount+= countValidCombos(chessPieces, piecePositions, currentIndex + 1);\n                piecePositions[currentIndex]= {row, column};\n            }\n        }\n    }\n\n    return validCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countValidCombos(std::vector<std::string> &chessPieces, std::vector<std::vector<int>> &piecePositions, int currentIndex= 0)\n{\n    if(currentIndex == chessPieces.size())\n    {\n        return 1;\n    }\n\n    int row= piecePositions[currentIndex][0], column= piecePositions[currentIndex][1];\n    int directionRow[]= {0, 1, 0, -1, 1, 1, -1, -1};\n    int directionColumn[]= {1, 0, -1, 0, 1, -1, 1, -1};\n    int validCount= 0;\n\n    for(int direction= 0; direction < 8; ++direction)\n    {\n        if(chessPieces[currentIndex] == \"bishop\" && direction < 4)\n            continue;\n        if(chessPieces[currentIndex] == \"rook\" && direction >= 4)\n            break;\n\n        for(int distance= 1; distance <= 8; distance++)\n        {\n            int newRow= row + directionRow[direction] * distance;\n            int newColumn= column + directionColumn[direction] * distance;\n            if(newRow < 1 || newRow > 8 || newColumn < 1 || newColumn > 8)\n                break;\n            if(newRow == row && newColumn == column)\n                continue;\n\n            bool isValid= true;\n            for(int otherIndex= 0; otherIndex < piecePositions.size(); ++otherIndex)\n            {\n                if(otherIndex == currentIndex)\n                    continue;\n                int otherRow= piecePositions[otherIndex][0], otherColumn= piecePositions[otherIndex][1];\n                if(otherRow == newRow && otherColumn == newColumn)\n                {\n                    isValid= false;\n                    break;\n                }\n                if(otherRow + otherColumn == newRow + newColumn || otherRow - otherColumn == newRow - newColumn)\n                {\n                    isValid= false;\n                    break;\n                }\n                if(otherRow == newRow || otherColumn == newColumn)\n                {\n                    isValid= false;\n                    break;\n                }\n            }\n\n            if(isValid)\n            {\n                std::vector<int> temporaryPosition= {newRow, newColumn};\n                piecePositions[currentIndex]= temporaryPosition;\n                validCount+= countValidCombos(chessPieces, piecePositions, currentIndex + 1);\n                piecePositions[currentIndex]= {row, column};\n            }\n        }\n    }\n\n    return validCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findSmallestIndex(vector<int> &numberList)\n{\n    for(size_t index = 0; index < numberList.size(); ++index)\n    {\n        if(index % 10 == numberList[index])\n        {\n            return index;\n        }\n    }\n    return -1;\n}",
    "output": "int findSmallestIndex(std::vector<int> &numberList)\n{\n    for(size_t index= 0; index < numberList.size(); ++index)\n    {\n        if(index % 10 == numberList[index])\n        {\n            return index;\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> getConcatenation(vector<int> &inputNumbers)\n{\n    int inputSize= inputNumbers.size();\n    vector<int> concatenatedResult(2 * inputSize);\n    for(int index= 0; index < inputSize; index++)\n    {\n        concatenatedResult[index]= inputNumbers[index];\n        concatenatedResult[index + inputSize]= inputNumbers[index];\n    }\n    return concatenatedResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> getConcatenation(std::vector<int> &inputNumbers)\n{\n    int inputSize = inputNumbers.size();\n    std::vector<int> concatenatedResult(2 * inputSize);\n    for(int index = 0; index < inputSize; index++)\n    {\n        concatenatedResult[index] = inputNumbers[index];\n        concatenatedResult[index + inputSize] = inputNumbers[index];\n    }\n    return concatenatedResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countThreeCharPalindromes(const string &inputString)\n{\n    int palindromeCount = 0;\n    unordered_map<char, int> characterFrequency;\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentCharacter = inputString[i];\n        if (characterFrequency.find(currentCharacter) != characterFrequency.end())\n            characterFrequency[currentCharacter]++;\n        else\n            characterFrequency[currentCharacter] = 1;\n    }\n    for (auto it = characterFrequency.begin(); it != characterFrequency.end(); ++it)\n    {\n        palindromeCount += (it->second) * (it->second - 1) / 2;\n    }\n    return palindromeCount;\n}",
    "output": "int countThreeCharPalindromes(const std::string &inputString)\n{\n    int palindromeCount= 0;\n    std::unordered_map<char, int> characterFrequency;\n    for(char currentCharacter : inputString)\n    {\n        if(characterFrequency.find(currentCharacter) != characterFrequency.end())\n            characterFrequency[currentCharacter]++;\n        else\n            characterFrequency[currentCharacter]= 1;\n    }\n    for(const auto &frequencyPair : characterFrequency)\n    {\n        palindromeCount+= (frequencyPair.second) * (frequencyPair.second - 1) / 2;\n    }\n    return palindromeCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nTreeNode *mergeTrees(vector<TreeNode *> &treeList)\n{\n    while(treeList.size() > 1)\n    {\n        TreeNode *firstTree= treeList.back();\n        treeList.pop_back();\n        TreeNode *secondTree= treeList.back();\n        treeList.pop_back();\n\n        if(firstTree->val < secondTree->val)\n        {\n            firstTree->right= secondTree;\n            treeList.push_back(firstTree);\n        }\n        else\n        {\n            secondTree->right= firstTree;\n            treeList.push_back(secondTree);\n        }\n    }\n    return treeList.empty() ? NULL : treeList[0];\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nTreeNode *mergeTrees(std::vector<TreeNode *> &treeList)\n{\n    while(treeList.size() > 1)\n    {\n        TreeNode *firstTree= treeList.back();\n        treeList.pop_back();\n        TreeNode *secondTree= treeList.back();\n        treeList.pop_back();\n\n        if(firstTree->val < secondTree->val)\n        {\n            firstTree->right= secondTree;\n            treeList.push_back(firstTree);\n        }\n        else\n        {\n            secondTree->right= firstTree;\n            treeList.push_back(secondTree);\n        }\n    }\n    return treeList.empty() ? NULL : treeList[0];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int colorTheGrid(int gridHeight, int gridWidth)\n{\n    long long int modulo= 1e9 + 7;\n    long long int ways[2]= {6, 6}, previousWays[2]= {3, 3};\n\n    for(int currentRow= 2; currentRow <= max(gridHeight, gridWidth); ++currentRow)\n    {\n        long long int temp= ways[1];\n        ways[1]= (previousWays[1] * 2) % modulo;\n        ways[0]= temp;\n        previousWays[1]= (previousWays[1] + previousWays[0]) % modulo;\n        previousWays[0]= (previousWays[0] + temp) % modulo;\n    }\n\n    return (ways[gridHeight == 1] * previousWays[gridWidth == 1]) % modulo;\n}",
    "output": "int colorTheGrid(int gridHeight, int gridWidth)\n{\n    long long int modulo= 1e9 + 7;\n    long long int ways[2]= {6, 6}, previousWays[2]= {3, 3};\n\n    for(int currentRow= 2; currentRow <= max(gridHeight, gridWidth); ++currentRow)\n    {\n        long long int temp= ways[1];\n        ways[1]= (previousWays[1] * 2) % modulo;\n        ways[0]= temp;\n        previousWays[1]= (previousWays[1] + previousWays[0]) % modulo;\n        previousWays[0]= (previousWays[0] + temp) % modulo;\n    }\n\n    return (ways[gridHeight == 1] * previousWays[gridWidth == 1]) % modulo;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countVowelSubstrings(string inputWord)\n{\n    int totalCount = 0, countA = 0, countE = 0, countI = 0, countO = 0, countU = 0;\n    for (int i = 0; i < inputWord.size(); ++i)\n    {\n        char currentChar = inputWord[i];\n        if (currentChar == 'a')\n            countA++;\n        else if (currentChar == 'e')\n            countE = countA + countE;\n        else if (currentChar == 'i')\n            countI = countE + countI;\n        else if (currentChar == 'o')\n            countO = countI + countO;\n        else if (currentChar == 'u')\n            countU = countO + countU;\n    }\n    return countU;\n}",
    "output": "#include <bits/stdc++.h>\nint countVowelSubstrings(std::string inputWord)\n{\n    int totalCount= 0, countA= 0, countE= 0, countI= 0, countO= 0, countU= 0;\n    for(char currentChar : inputWord)\n    {\n        if(currentChar == 'a')\n            countA++;\n        else if(currentChar == 'e')\n            countE= countA + countE;\n        else if(currentChar == 'i')\n            countI= countE + countI;\n        else if(currentChar == 'o')\n            countO= countI + countO;\n        else if(currentChar == 'u')\n            countU= countO + countU;\n    }\n    return countU;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long countVowels(const string &inputWord)\n{\n    long long totalVowelCount= 0;\n    int currentVowelCount= 0;\n    for(int index= 0; index < inputWord.length(); index++)\n    {\n        if(inputWord[index] == 'a' || inputWord[index] == 'e' || inputWord[index] == 'i' || inputWord[index] == 'o' || inputWord[index] == 'u')\n        {\n            currentVowelCount++;\n        }\n        totalVowelCount+= currentVowelCount;\n    }\n    return totalVowelCount;\n}\n\nlong long countVowelsInSubstrings(string inputWord)\n{\n    return countVowels(inputWord);\n}",
    "output": "#include <bits/stdc++.h>\nlong long countVowels(const std::string &inputWord)\n{\n    long long totalVowelCount= 0;\n    int currentVowelCount= 0;\n    for(int index= 0; index < inputWord.length(); index++)\n    {\n        if(inputWord[index] == 'a' || inputWord[index] == 'e' || inputWord[index] == 'i' || inputWord[index] == 'o' || inputWord[index] == 'u')\n        {\n            currentVowelCount++;\n        }\n        totalVowelCount+= currentVowelCount;\n    }\n    return totalVowelCount;\n}\n\nlong long countVowelsInSubstrings(std::string inputWord)\n{\n    return countVowels(inputWord);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumMaximum(int totalStores, vector<int> &productQuantities)\n{\n    int totalProducts = 0;\n    for (int i = 0; i < productQuantities.size(); ++i)\n    {\n        totalProducts += productQuantities[i];\n    }\n\n    int averageProducts = (totalProducts + totalStores - 1) / totalStores;\n    int remainingStores = totalStores;\n    for (int i = 0; i < productQuantities.size(); ++i)\n    {\n        int quantity = productQuantities[i];\n        remainingStores -= (quantity + averageProducts - 1) / averageProducts;\n        if (remainingStores < 0)\n        {\n            averageProducts = (totalProducts + remainingStores) / (totalStores + remainingStores);\n            remainingStores = totalStores;\n        }\n    }\n    return averageProducts;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMinimumMaximum(int totalStores, std::vector<int> &productQuantities)\n{\n    int totalProducts= 0;\n    for(int quantity : productQuantities)\n    {\n        totalProducts+= quantity;\n    }\n\n    int averageProducts= (totalProducts + totalStores - 1) / totalStores;\n    int remainingStores= totalStores;\n    for(int quantity : productQuantities)\n    {\n        remainingStores-= (quantity + averageProducts - 1) / averageProducts;\n        if(remainingStores < 0)\n        {\n            averageProducts= (totalProducts + remainingStores) / (totalStores + remainingStores);\n            remainingStores= totalStores;\n        }\n    }\n    return averageProducts;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxQualityDfs(int currentNode, int timeLeft, vector<int> &visitedNodes, vector<int> &nodeValues, vector<vector<int>> &neighbors)\n{\n    int accumulatedQuality = 0;\n    for (int i = 0; i < neighbors[currentNode].size(); ++i)\n    {\n        const auto &edge = neighbors[currentNode][i];\n        int neighborNode = edge[0], travelCost = edge[1];\n        if (timeLeft >= travelCost && visitedNodes[neighborNode] == 0)\n        {\n            visitedNodes[neighborNode] = 1;\n            accumulatedQuality = max(accumulatedQuality, nodeValues[neighborNode] + maxQualityDfs(neighborNode, timeLeft - travelCost, visitedNodes, nodeValues, neighbors));\n            visitedNodes[neighborNode] = 0;\n        }\n    }\n    return accumulatedQuality;\n}\n\nint maxQuality(vector<int> &nodeValues, vector<vector<int>> &edges, int maxTime)\n{\n    vector<vector<int>> neighbors(nodeValues.size());\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        const auto &edge = edges[i];\n        neighbors[edge[0]].push_back({edge[1], edge[2]});\n        neighbors[edge[1]].push_back({edge[0], edge[2]});\n    }\n    vector<int> visitedNodes(nodeValues.size(), 0);\n    return maxQualityDfs(0, maxTime, visitedNodes, nodeValues, neighbors);\n}",
    "output": "#include <bits/stdc++.h>\nint maxQualityDfs(int currentNode, int timeLeft, std::vector<int> &visitedNodes, std::vector<int> &nodeValues, std::vector<std::vector<int>> &neighbors)\n{\n    int accumulatedQuality= 0;\n    for(const auto &edge : neighbors[currentNode])\n    {\n        int neighborNode= edge[0], travelCost= edge[1];\n        if(timeLeft >= travelCost && visitedNodes[neighborNode] == 0)\n        {\n            visitedNodes[neighborNode]= 1;\n            accumulatedQuality= std::max(accumulatedQuality, nodeValues[neighborNode] + maxQualityDfs(neighborNode, timeLeft - travelCost, visitedNodes, nodeValues, neighbors));\n            visitedNodes[neighborNode]= 0;\n        }\n    }\n    return accumulatedQuality;\n}\n\nint maxQuality(std::vector<int> &nodeValues, std::vector<std::vector<int>> &edges, int maxTime)\n{\n    std::vector<std::vector<int>> neighbors(nodeValues.size());\n    for(const auto &edge : edges)\n    {\n        neighbors[edge[0]].push_back({edge[1], edge[2]});\n        neighbors[edge[1]].push_back({edge[0], edge[2]});\n    }\n    std::vector<int> visitedNodes(nodeValues.size(), 0);\n    return maxQualityDfs(0, maxTime, visitedNodes, nodeValues, neighbors);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(vector<vector<int>> &points)\n{\n    int rowCount = points.size(), columnCount = points[0].size();\n    vector<vector<int>> dynamicProgramming(rowCount, vector<int>(columnCount));\n    dynamicProgramming[0] = points[0];\n\n    for(int currentRow = 1; currentRow < rowCount; currentRow++)\n    {\n        for(int currentColumn = 0; currentColumn < columnCount; currentColumn++)\n        {\n            int currentScore = points[currentRow][currentColumn];\n            for(int previousColumn = 0; previousColumn < columnCount; previousColumn++)\n            {\n                dynamicProgramming[currentRow][currentColumn] = max(dynamicProgramming[currentRow][currentColumn],\n                                                                     dynamicProgramming[currentRow - 1][previousColumn] + currentScore - abs(currentColumn - previousColumn));\n            }\n        }\n    }\n\n    return *max_element(dynamicProgramming[rowCount - 1].begin(), dynamicProgramming[rowCount - 1].end());\n}",
    "output": "#include <bits/stdc++.h>\nint maxScore(std::vector<std::vector<int>> &points)\n{\n    int rowCount= points.size(), columnCount= points[0].size();\n    std::vector<std::vector<int>> dynamicProgramming(rowCount, std::vector<int>(columnCount));\n    dynamicProgramming[0]= points[0];\n\n    for(int currentRow= 1; currentRow < rowCount; currentRow++)\n    {\n        for(int currentColumn= 0; currentColumn < columnCount; currentColumn++)\n        {\n            int currentScore= points[currentRow][currentColumn];\n            for(int previousColumn= 0; previousColumn < columnCount; previousColumn++)\n            {\n                dynamicProgramming[currentRow][currentColumn]= std::max(dynamicProgramming[currentRow][currentColumn],\n                                                                        dynamicProgramming[currentRow - 1][previousColumn] + currentScore - abs(currentColumn - previousColumn));\n            }\n        }\n    }\n\n    return *std::max_element(dynamicProgramming[rowCount - 1].begin(), dynamicProgramming[rowCount - 1].end());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int bitLength = 17;\nvector<int> trie[1 << bitLength];\n\nvoid insert(int value)\n{\n    int currentNode = 0;\n    for (int bitIndex = bitLength - 1; bitIndex >= 0; --bitIndex)\n    {\n        int bitValue = (value >> bitIndex) & 1;\n        if (!trie[currentNode][bitValue])\n            trie[currentNode][bitValue] = trie.size(), trie.emplace_back(2);\n        currentNode = trie[currentNode][bitValue];\n    }\n}\n\nint query(int value, int currentResult = 0)\n{\n    int currentNode = 0, answer = 0;\n    for (int bitIndex = bitLength - 1; bitIndex >= 0; --bitIndex)\n    {\n        int bitValue = ((value >> bitIndex) & 1) ^ 1;\n        if (!trie[currentNode][bitValue])\n            bitValue ^= 1;\n        answer |= (currentResult = (currentResult << 1) | bitValue);\n        currentNode = trie[currentNode][bitValue];\n    }\n    return answer;\n}\n\nvoid dfs(int node, int currentXor = 0, vector<vector<int>> &graph = {}, vector<int> &results = {})\n{\n    insert(currentXor ^= node);\n    results[node] = query(currentXor);\n    for (int i = 0; i < graph[node].size(); ++i)\n    {\n        int childNode = graph[node][i];\n        dfs(childNode, currentXor, graph, results);\n    }\n}\n\nvector<int> maxGeneticDifference(vector<int> &parentNodes, vector<vector<int>> &queries)\n{\n    int nodeCount = parentNodes.size();\n    vector<vector<int>> edges(nodeCount);\n    int rootNode;\n    for (int i = 0; i < nodeCount; ++i)\n    {\n        if (parentNodes[i] == -1)\n        {\n            rootNode = i;\n        }\n        else\n        {\n            edges[parentNodes[i]].push_back(i);\n        }\n    }\n    vector<int> results(nodeCount);\n    dfs(rootNode, 0, edges, results);\n    vector<int> output(queries.size());\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        output[i] = results[queries[i][0]] ^ queries[i][1];\n    }\n    return output;\n}",
    "output": "#include <bits/stdc++.h>\nconst int bitLength= 17;\nstd::vector<int> trie[1 << bitLength];\n\nvoid insert(int value)\n{\n    int currentNode= 0;\n    for(int bitIndex= bitLength - 1; bitIndex >= 0; --bitIndex)\n    {\n        int bitValue= (value >> bitIndex) & 1;\n        if(!trie[currentNode][bitValue])\n            trie[currentNode][bitValue]= trie.size(), trie.emplace_back(2);\n        currentNode= trie[currentNode][bitValue];\n    }\n}\n\nint query(int value, int currentResult= 0)\n{\n    int currentNode= 0, answer= 0;\n    for(int bitIndex= bitLength - 1; bitIndex >= 0; --bitIndex)\n    {\n        int bitValue= ((value >> bitIndex) & 1) ^ 1;\n        if(!trie[currentNode][bitValue])\n            bitValue^= 1;\n        answer|= (currentResult= (currentResult << 1) | bitValue);\n        currentNode= trie[currentNode][bitValue];\n    }\n    return answer;\n}\n\nvoid dfs(int node, int currentXor= 0, std::vector<std::vector<int>> &graph= {}, std::vector<int> &results= {})\n{\n    insert(currentXor^= node);\n    results[node]= query(currentXor);\n    for(int childNode : graph[node])\n        dfs(childNode, currentXor, graph, results);\n}\n\nstd::vector<int> maxGeneticDifference(std::vector<int> &parentNodes, std::vector<std::vector<int>> &queries)\n{\n    int nodeCount= parentNodes.size();\n    std::vector<std::vector<int>> edges(nodeCount);\n    int rootNode;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        if(parentNodes[i] == -1)\n        {\n            rootNode= i;\n        }\n        else\n        {\n            edges[parentNodes[i]].push_back(i);\n        }\n    }\n    std::vector<int> results(nodeCount);\n    dfs(rootNode, 0, edges, results);\n    std::vector<int> output(queries.size());\n    for(int i= 0; i < queries.size(); ++i)\n    {\n        output[i]= results[queries[i][0]] ^ queries[i][1];\n    }\n    return output;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Robot\n{\n    int width, height, currentX, currentY, currentDirection;\n    int directionX[4]= {1, 0, -1, 0};\n    int directionY[4]= {0, 1, 0, -1};\n\n  public:\n    Robot(int width, int height) : width(width), height(height), currentX(0), currentY(0), currentDirection(0) {}\n\n    void step(int num)\n    {\n        while(num-- > 0)\n        {\n            int nextX= currentX + directionX[currentDirection];\n            int nextY= currentY + directionY[currentDirection];\n            if(nextX >= 0 && nextX < width && nextY >= 0 && nextY < height)\n            {\n                currentX= nextX;\n                currentY= nextY;\n            }\n            else\n            {\n                currentDirection= (currentDirection + 1) % 4;\n                num++; // Retry the step\n            }\n        }\n    }\n\n    vector<int> getPos()\n    {\n        return {currentX, currentY};\n    }\n\n    string getDir()\n    {\n        switch(currentDirection)\n        {\n        case 0:\n            return \"East\";\n        case 1:\n            return \"North\";\n        case 2:\n            return \"West\";\n        case 3:\n            return \"South\";\n        }\n        return \"\";\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Robot\n{\n    int width, height, currentX, currentY, currentDirection;\n    int directionX[4]= {1, 0, -1, 0};\n    int directionY[4]= {0, 1, 0, -1};\n\n  public:\n    Robot(int width, int height) : width(width), height(height), currentX(0), currentY(0), currentDirection(0) {}\n\n    void step(int num)\n    {\n        while(num-- > 0)\n        {\n            int nextX= currentX + directionX[currentDirection];\n            int nextY= currentY + directionY[currentDirection];\n            if(nextX >= 0 && nextX < width && nextY >= 0 && nextY < height)\n            {\n                currentX= nextX;\n                currentY= nextY;\n            }\n            else\n            {\n                currentDirection= (currentDirection + 1) % 4;\n                num++; // Retry the step\n            }\n        }\n    }\n\n    std::vector<int> getPos()\n    {\n        return {currentX, currentY};\n    }\n\n    std::string getDir()\n    {\n        switch(currentDirection)\n        {\n        case 0:\n            return \"East\";\n        case 1:\n            return \"North\";\n        case 2:\n            return \"West\";\n        case 3:\n            return \"South\";\n        }\n        return \"\";\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> maxPrices(const vector<vector<int>> &items, const vector<int> &queries)\n{\n    vector<int> answer(queries.size());\n    vector<int> sortedItems;\n\n    for (int i = 0; i < items.size(); ++i)\n    {\n        sortedItems.push_back(items[i][0]);\n    }\n    sort(sortedItems.begin(), sortedItems.end());\n\n    int maxBeauty = 0;\n    for (int i = 0; i < sortedItems.size(); ++i)\n    {\n        maxBeauty = max(maxBeauty, items[i][1]);\n        sortedItems[i] = maxBeauty;\n    }\n\n    for (int j = 0; j < queries.size(); ++j)\n    {\n        int index = upper_bound(sortedItems.begin(), sortedItems.end(), queries[j]) - sortedItems.begin() - 1;\n        answer[j] = index >= 0 ? sortedItems[index] : 0;\n    }\n\n    return answer;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> maxPrices(const std::vector<std::vector<int>> &items, const std::vector<int> &queries)\n{\n    std::vector<int> answer(queries.size());\n    std::vector<int> sortedItems;\n\n    for(const auto &item : items)\n    {\n        sortedItems.push_back(item[0]);\n    }\n    std::sort(sortedItems.begin(), sortedItems.end());\n\n    int maxBeauty= 0;\n    for(int i= 0; i < sortedItems.size(); ++i)\n    {\n        maxBeauty= std::max(maxBeauty, items[i][1]);\n        sortedItems[i]= maxBeauty;\n    }\n\n    for(int j= 0; j < queries.size(); ++j)\n    {\n        int index= std::upper_bound(sortedItems.begin(), sortedItems.end(), queries[j]) - sortedItems.begin() - 1;\n        answer[j]= index >= 0 ? sortedItems[index] : 0;\n    }\n\n    return answer;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxTasks(vector<int> &taskDurations, vector<int> &workerStrengths, int availablePills, int strengthBoost)\n{\n    sort(taskDurations.begin(), taskDurations.end());\n    sort(workerStrengths.begin(), workerStrengths.end());\n\n    int taskCount = 0;\n    for(int taskIndex = 0, workerIndex = 0; workerIndex < availablePills; ++workerIndex)\n    {\n        while(taskIndex < taskDurations.size() && taskDurations[taskIndex] > workerStrengths[workerIndex] + strengthBoost)\n        {\n            ++taskIndex;\n        }\n        if(taskIndex < taskDurations.size())\n        {\n            ++taskCount;\n            ++taskIndex;\n        }\n    }\n\n    for(int taskIndex = 0, workerIndex = availablePills; taskIndex < taskDurations.size() && workerIndex < workerStrengths.size(); ++taskIndex)\n    {\n        if(taskDurations[taskIndex] <= workerStrengths[workerIndex])\n        {\n            ++taskCount;\n            ++workerIndex;\n        }\n    }\n\n    return taskCount;\n}",
    "output": "#include <bits/stdc++.h>\nint maxTasks(std::vector<int> &taskDurations, std::vector<int> &workerStrengths, int availablePills, int strengthBoost)\n{\n    std::sort(taskDurations.begin(), taskDurations.end());\n    std::sort(workerStrengths.begin(), workerStrengths.end());\n\n    int taskCount= 0;\n    for(int taskIndex= 0, workerIndex= 0; workerIndex < availablePills; ++workerIndex)\n    {\n        while(taskIndex < taskDurations.size() && taskDurations[taskIndex] > workerStrengths[workerIndex] + strengthBoost)\n        {\n            ++taskIndex;\n        }\n        if(taskIndex < taskDurations.size())\n        {\n            ++taskCount;\n            ++taskIndex;\n        }\n    }\n\n    for(int taskIndex= 0, workerIndex= availablePills; taskIndex < taskDurations.size() && workerIndex < workerStrengths.size(); ++taskIndex)\n    {\n        if(taskDurations[taskIndex] <= workerStrengths[workerIndex])\n        {\n            ++taskCount;\n            ++workerIndex;\n        }\n    }\n\n    return taskCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint timeToBuyTickets(vector<int> &ticketCounts, int targetIndex)\n{\n    int totalTime= 0;\n    while(ticketCounts[targetIndex] > 0)\n    {\n        for(int i= 0; i < ticketCounts.size(); ++i)\n        {\n            if(ticketCounts[i] > 0)\n            {\n                --ticketCounts[i];\n                ++totalTime;\n                if(i == targetIndex && ticketCounts[targetIndex] == 0)\n                {\n                    break;\n                }\n            }\n        }\n    }\n    return totalTime;\n}",
    "output": "#include <bits/stdc++.h>\nint timeToBuyTickets(std::vector<int> &ticketCounts, int targetIndex)\n{\n    int totalTime= 0;\n    while(ticketCounts[targetIndex] > 0)\n    {\n        for(int i= 0; i < ticketCounts.size(); ++i)\n        {\n            if(ticketCounts[i] > 0)\n            {\n                --ticketCounts[i];\n                ++totalTime;\n                if(i == targetIndex && ticketCounts[targetIndex] == 0)\n                {\n                    break;\n                }\n            }\n        }\n    }\n    return totalTime;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class Solution\n{\n  public:\n    ListNode *reverseGroup(ListNode *head, int groupSize)\n    {\n        if(head == NULL || groupSize == 1)\n            return head;\n        ListNode *previousNode= NULL;\n        ListNode *currentNode= head;\n        for(int i= 0; i < groupSize; i++)\n        {\n            ListNode *nextNode= currentNode->next;\n            currentNode->next= previousNode;\n            previousNode= currentNode;\n            currentNode= nextNode;\n        }\n        head->next= currentNode;\n        return previousNode;\n    }\n\n    ListNode *reverseEvenGroups(ListNode *head)\n    {\n        ListNode *dummyNode= new ListNode(0);\n        dummyNode->next= head;\n        ListNode *previousNode= dummyNode;\n        int totalNodes= 0;\n        for(ListNode *currentNode= head; currentNode != NULL; currentNode= currentNode->next)\n            totalNodes++;\n        for(int i= 1, groupSize= 1; totalNodes >= 0 && groupSize <= totalNodes; i++, groupSize+= i)\n        {\n            if(i % 2 == 0)\n            {\n                ListNode *tailNode= previousNode->next;\n                ListNode *nextNode= previousNode->next;\n                for(int j= 0; j < groupSize; j++)\n                    nextNode= nextNode->next;\n                previousNode->next= reverseGroup(tailNode, groupSize);\n                tailNode->next= nextNode;\n            }\n            totalNodes-= groupSize;\n            for(int j= 0; j < groupSize && previousNode != NULL; j++)\n                previousNode= previousNode->next;\n        }\n        return dummyNode->next;\n    }\n};",
    "output": "class Solution\n{\n  public:\n    ListNode *reverseGroup(ListNode *head, int groupSize)\n    {\n        if(head == NULL || groupSize == 1)\n            return head;\n        ListNode *previousNode= NULL;\n        ListNode *currentNode= head;\n        for(int i= 0; i < groupSize; i++)\n        {\n            ListNode *nextNode= currentNode->next;\n            currentNode->next= previousNode;\n            previousNode= currentNode;\n            currentNode= nextNode;\n        }\n        head->next= currentNode;\n        return previousNode;\n    }\n\n    ListNode *reverseEvenGroups(ListNode *head)\n    {\n        ListNode *dummyNode= new ListNode(0);\n        dummyNode->next= head;\n        ListNode *previousNode= dummyNode;\n        int totalNodes= 0;\n        for(ListNode *currentNode= head; currentNode != NULL; currentNode= currentNode->next)\n            totalNodes++;\n        for(int i= 1, groupSize= 1; totalNodes >= 0 && groupSize <= totalNodes; i++, groupSize+= i)\n        {\n            if(i % 2 == 0)\n            {\n                ListNode *tailNode= previousNode->next;\n                ListNode *nextNode= previousNode->next;\n                for(int j= 0; j < groupSize; j++)\n                    nextNode= nextNode->next;\n                previousNode->next= reverseGroup(tailNode, groupSize);\n                tailNode->next= nextNode;\n            }\n            totalNodes-= groupSize;\n            for(int j= 0; j < groupSize && previousNode != NULL; j++)\n                previousNode= previousNode->next;\n        }\n        return dummyNode->next;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring slantedTranspositionCipher(string encodedText, int numberOfRows)\n{\n    if(numberOfRows == 1)\n        return encodedText;\n\n    int textLength = encodedText.size();\n    int numberOfCols = (textLength + numberOfRows - 2) / (numberOfRows - 1);\n    int currentPosition = 0;\n    vector<vector<char>> matrix(numberOfRows, vector<char>(numberOfCols, ' '));\n\n    for(int colIndex = 0; colIndex < numberOfCols; ++colIndex)\n    {\n        for(int rowIndex = 0; rowIndex < numberOfRows; ++rowIndex)\n        {\n            if(colIndex % 2 == 0 || rowIndex != 0)\n            {\n                matrix[rowIndex][colIndex] = encodedText[currentPosition++];\n            }\n        }\n    }\n\n    string originalText;\n    for(int i = 0; i < matrix.size(); ++i)\n    {\n        originalText += string(matrix[i].begin(), matrix[i].end());\n    }\n\n    return originalText;\n}",
    "output": "std::string slantedTranspositionCipher(std::string encodedText, int numberOfRows)\n{\n    if(numberOfRows == 1)\n        return encodedText;\n\n    int textLength= encodedText.size();\n    int numberOfCols= (textLength + numberOfRows - 2) / (numberOfRows - 1);\n    int currentPosition= 0;\n    std::vector<std::vector<char>> matrix(numberOfRows, std::vector<char>(numberOfCols, ' '));\n\n    for(int colIndex= 0; colIndex < numberOfCols; ++colIndex)\n    {\n        for(int rowIndex= 0; rowIndex < numberOfRows; ++rowIndex)\n        {\n            if(colIndex % 2 == 0 || rowIndex != 0)\n            {\n                matrix[rowIndex][colIndex]= encodedText[currentPosition++];\n            }\n        }\n    }\n\n    std::string originalText;\n    for(const auto &row : matrix)\n    {\n        originalText+= std::string(row.begin(), row.end());\n    }\n\n    return originalText;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint alphabetPositionSum(const string &inputString, int iterations)\n{\n    int totalSum = 0;\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char character = inputString[i];\n        totalSum += character - 'a' + 1;\n    }\n    for (int iterationIndex = 0; iterationIndex < iterations; ++iterationIndex)\n    {\n        int newSum = 0;\n        while (totalSum > 0)\n        {\n            newSum += totalSum % 10;\n            totalSum /= 10;\n        }\n        totalSum = newSum;\n    }\n    return totalSum;\n}",
    "output": "int alphabetPositionSum(const std::string &inputString, int iterations)\n{\n    int totalSum= 0;\n    for(char character : inputString)\n    {\n        totalSum+= character - 'a' + 1;\n    }\n    for(int iterationIndex= 0; iterationIndex < iterations; ++iterationIndex)\n    {\n        int newSum= 0;\n        while(totalSum > 0)\n        {\n            newSum+= totalSum % 10;\n            totalSum/= 10;\n        }\n        totalSum= newSum;\n    }\n    return totalSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring maximumNumber(string numberString, vector<int> &digitChange)\n{\n    bool isMutable= false;\n    for(int index= 0; index < numberString.size(); index++)\n    {\n        int currentDigit= numberString[index] - '0';\n        if(currentDigit < digitChange[currentDigit])\n        {\n            if(!isMutable)\n                isMutable= true;\n            numberString[index]= digitChange[currentDigit] + '0';\n        }\n        else if(currentDigit > digitChange[currentDigit] && isMutable)\n        {\n            break;\n        }\n    }\n    return numberString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string maximumNumber(std::string numberString, std::vector<int> &digitChange)\n{\n    bool isMutable= false;\n    for(int index= 0; index < numberString.size(); index++)\n    {\n        int currentDigit= numberString[index] - '0';\n        if(currentDigit < digitChange[currentDigit])\n        {\n            if(!isMutable)\n                isMutable= true;\n            numberString[index]= digitChange[currentDigit] + '0';\n        }\n        else if(currentDigit > digitChange[currentDigit] && isMutable)\n        {\n            break;\n        }\n    }\n    return numberString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxCompatibilitySum(vector<vector<int>> &studentPreferences, vector<vector<int>> &mentorPreferences)\n{\n    sort(studentPreferences.begin(), studentPreferences.end());\n    sort(mentorPreferences.begin(), mentorPreferences.end());\n    int maximumCompatibilityScore = 0;\n    do\n    {\n        int currentCompatibilityScore = 0;\n        for (int studentIndex = 0; studentIndex < studentPreferences.size(); studentIndex++)\n        {\n            int matchingScore = 0;\n            for (int preferenceIndex = 0; preferenceIndex < studentPreferences[studentIndex].size(); preferenceIndex++)\n            {\n                if (studentPreferences[studentIndex][preferenceIndex] == mentorPreferences[studentIndex][preferenceIndex])\n                    matchingScore++;\n            }\n            currentCompatibilityScore += matchingScore;\n        }\n        maximumCompatibilityScore = max(maximumCompatibilityScore, currentCompatibilityScore);\n    } while (next_permutation(mentorPreferences.begin(), mentorPreferences.end()));\n    return maximumCompatibilityScore;\n}",
    "output": "#include <bits/stdc++.h>\nint maxCompatibilitySum(std::vector<std::vector<int>> &studentPreferences, std::vector<std::vector<int>> &mentorPreferences)\n{\n    std::sort(studentPreferences.begin(), studentPreferences.end());\n    std::sort(mentorPreferences.begin(), mentorPreferences.end());\n    int maximumCompatibilityScore= 0;\n    do\n    {\n        int currentCompatibilityScore= 0;\n        for(int studentIndex= 0; studentIndex < studentPreferences.size(); studentIndex++)\n        {\n            int matchingScore= 0;\n            for(int preferenceIndex= 0; preferenceIndex < studentPreferences[studentIndex].size(); preferenceIndex++)\n            {\n                if(studentPreferences[studentIndex][preferenceIndex] == mentorPreferences[studentIndex][preferenceIndex])\n                    matchingScore++;\n            }\n            currentCompatibilityScore+= matchingScore;\n        }\n        maximumCompatibilityScore= std::max(maximumCompatibilityScore, currentCompatibilityScore);\n    } while(std::next_permutation(mentorPreferences.begin(), mentorPreferences.end()));\n    return maximumCompatibilityScore;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<string>> deleteDuplicateFolder(vector<vector<string>> &folderPaths)\n{\n    unordered_map<string, unordered_set<string>> folderGraph;\n    unordered_map<string, int> folderCount;\n\n    for (int i = 0; i < folderPaths.size(); ++i)\n    {\n        const auto &path = folderPaths[i];\n        string serializedPath;\n        for (int j = 0; j < path.size(); ++j)\n        {\n            const auto &folder = path[j];\n            serializedPath += \"/\" + folder;\n            folderGraph[serializedPath].insert(folder);\n        }\n    }\n\n    for (const auto &pair : folderGraph)\n    {\n        folderCount[pair.second]++;\n    }\n\n    vector<vector<string>> uniquePaths;\n    for (int i = 0; i < folderPaths.size(); ++i)\n    {\n        const auto &path = folderPaths[i];\n        string serializedPath;\n        bool isDuplicate = false;\n        for (int j = 0; j < path.size(); ++j)\n        {\n            const auto &folder = path[j];\n            serializedPath += \"/\" + folder;\n            if (folderCount[folderGraph[serializedPath]] > 1)\n            {\n                isDuplicate = true;\n                break;\n            }\n        }\n        if (!isDuplicate)\n            uniquePaths.push_back(path);\n    }\n\n    return uniquePaths;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<std::string>> deleteDuplicateFolder(std::vector<std::vector<std::string>> &folderPaths)\n{\n    std::unordered_map<std::string, std::unordered_set<std::string>> folderGraph;\n    std::unordered_map<std::string, int> folderCount;\n\n    for(const auto &path : folderPaths)\n    {\n        std::string serializedPath;\n        for(const auto &folder : path)\n        {\n            serializedPath+= \"/\" + folder;\n            folderGraph[serializedPath].insert(folder);\n        }\n    }\n\n    for(const auto &pair : folderGraph)\n    {\n        folderCount[pair.second]++;\n    }\n\n    std::vector<std::vector<std::string>> uniquePaths;\n    for(const auto &path : folderPaths)\n    {\n        std::string serializedPath;\n        bool isDuplicate= false;\n        for(const auto &folder : path)\n        {\n            serializedPath+= \"/\" + folder;\n            if(folderCount[folderGraph[serializedPath]] > 1)\n            {\n                isDuplicate= true;\n                break;\n            }\n        }\n        if(!isDuplicate)\n            uniquePaths.push_back(path);\n    }\n\n    return uniquePaths;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool checkGoodLine(vector<vector<char>> &board, int row, int column, char color, int deltaRow, int deltaColumn)\n{\n    char opponentColor= color == 'W' ? 'B' : 'W';\n    int count= 0;\n    row+= deltaRow;\n    column+= deltaColumn;\n    while(row >= 0 && row < 8 && column >= 0 && column < 8 && board[row][column] == opponentColor)\n    {\n        count++;\n        row+= deltaRow;\n        column+= deltaColumn;\n    }\n    return row >= 0 && row < 8 && column >= 0 && column < 8 && board[row][column] == color && count >= 2;\n}\n\nbool isLegalMove(vector<vector<char>> &board, int rowMove, int columnMove, char color)\n{\n    if(board[rowMove][columnMove] != '.')\n        return false;\n    board[rowMove][columnMove]= color;\n    for(int deltaRow= -1; deltaRow <= 1; deltaRow++)\n    {\n        for(int deltaColumn= -1; deltaColumn <= 1; deltaColumn++)\n        {\n            if(!(deltaRow == 0 && deltaColumn == 0) && checkGoodLine(board, rowMove, columnMove, color, deltaRow, deltaColumn))\n            {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool checkGoodLine(std::vector<std::vector<char>> &board, int row, int column, char color, int deltaRow, int deltaColumn)\n{\n    char opponentColor= color == 'W' ? 'B' : 'W';\n    int count= 0;\n    row+= deltaRow;\n    column+= deltaColumn;\n    while(row >= 0 && row < 8 && column >= 0 && column < 8 && board[row][column] == opponentColor)\n    {\n        count++;\n        row+= deltaRow;\n        column+= deltaColumn;\n    }\n    return row >= 0 && row < 8 && column >= 0 && column < 8 && board[row][column] == color && count >= 2;\n}\n\nbool isLegalMove(std::vector<std::vector<char>> &board, int rowMove, int columnMove, char color)\n{\n    if(board[rowMove][columnMove] != '.')\n        return false;\n    board[rowMove][columnMove]= color;\n    for(int deltaRow= -1; deltaRow <= 1; deltaRow++)\n    {\n        for(int deltaColumn= -1; deltaColumn <= 1; deltaColumn++)\n        {\n            if(!(deltaRow == 0 && deltaColumn == 0) && checkGoodLine(board, rowMove, columnMove, color, deltaRow, deltaColumn))\n            {\n                return true;\n            }\n        }\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minWastedSpace(vector<int> &numSizes, int maxPartitions)\n{\n    int totalItems= numSizes.size();\n    vector<vector<int>> wastedSpaceDP(totalItems + 1, vector<int>(maxPartitions + 1, INT_MAX));\n    wastedSpaceDP[0][0]= 0;\n\n    for(int currentItem= 1; currentItem <= totalItems; ++currentItem)\n    {\n        int accumulatedSize= 0;\n        for(int previousItem= currentItem; previousItem > 0; --previousItem)\n        {\n            accumulatedSize+= numSizes[previousItem - 1];\n            for(int partitionsUsed= 0; partitionsUsed < maxPartitions; ++partitionsUsed)\n            {\n                wastedSpaceDP[currentItem][partitionsUsed + 1]= min(wastedSpaceDP[currentItem][partitionsUsed + 1],\n                                                                    wastedSpaceDP[previousItem - 1][partitionsUsed] +\n                                                                        (currentItem - previousItem + 1) * numSizes[previousItem - 1] -\n                                                                        accumulatedSize);\n            }\n        }\n    }\n\n    return *min_element(wastedSpaceDP[totalItems].begin(), wastedSpaceDP[totalItems].end());\n}",
    "output": "#include <bits/stdc++.h>\nint minWastedSpace(std::vector<int> &numSizes, int maxPartitions)\n{\n    int totalItems= numSizes.size();\n    std::vector<std::vector<int>> wastedSpaceDP(totalItems + 1, std::vector<int>(maxPartitions + 1, INT_MAX));\n    wastedSpaceDP[0][0]= 0;\n\n    for(int currentItem= 1; currentItem <= totalItems; ++currentItem)\n    {\n        int accumulatedSize= 0;\n        for(int previousItem= currentItem; previousItem > 0; --previousItem)\n        {\n            accumulatedSize+= numSizes[previousItem - 1];\n            for(int partitionsUsed= 0; partitionsUsed < maxPartitions; ++partitionsUsed)\n            {\n                wastedSpaceDP[currentItem][partitionsUsed + 1]= std::min(wastedSpaceDP[currentItem][partitionsUsed + 1],\n                                                                    wastedSpaceDP[previousItem - 1][partitionsUsed] +\n                                                                        (currentItem - previousItem + 1) * numSizes[previousItem - 1] -\n                                                                        accumulatedSize);\n            }\n        }\n    }\n\n    return *std::min_element(wastedSpaceDP[totalItems].begin(), wastedSpaceDP[totalItems].end());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "bool hasThreeDivisors(int number)\n{\n    int divisorCount= 0;\n    for(int currentDivisor= 1; currentDivisor <= sqrt(number); currentDivisor++)\n    {\n        if(number % currentDivisor == 0)\n        {\n            if(number / currentDivisor == currentDivisor)\n                divisorCount++;\n            else\n                divisorCount+= 2;\n        }\n        if(divisorCount > 3)\n            break;\n    }\n    return divisorCount == 3;\n}",
    "output": "bool hasThreeDivisors(int number)\n{\n    int divisorCount= 0;\n    for(int currentDivisor= 1; currentDivisor <= sqrt(number); currentDivisor++)\n    {\n        if(number % currentDivisor == 0)\n        {\n            if(number / currentDivisor == currentDivisor)\n                divisorCount++;\n            else\n                divisorCount+= 2;\n        }\n        if(divisorCount > 3)\n            break;\n    }\n    return divisorCount == 3;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> rearrangeArray(vector<int> &inputNumbers)\n{\n    sort(inputNumbers.begin(), inputNumbers.end());\n    for(int index= 1; index < inputNumbers.size() - 1; index+= 2)\n    {\n        swap(inputNumbers[index], inputNumbers[index + 1]);\n    }\n    return inputNumbers;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> rearrangeArray(std::vector<int> &inputNumbers)\n{\n    std::sort(inputNumbers.begin(), inputNumbers.end());\n    for(int index= 1; index < inputNumbers.size() - 1; index+= 2)\n    {\n        std::swap(inputNumbers[index], inputNumbers[index + 1]);\n    }\n    return inputNumbers;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countSpecialSubsequences(vector<int> &inputNumbers)\n{\n    long long zeroCount = 0, oneCount = 0, twoCount = 0;\n    long long modulus = 1000000007;\n    for (int i = 0; i < inputNumbers.size(); ++i)\n    {\n        int currentNumber = inputNumbers[i];\n        if (currentNumber == 0)\n        {\n            zeroCount = (zeroCount + 1) % modulus;\n        }\n        else if (currentNumber == 1)\n        {\n            oneCount = (oneCount + zeroCount) % modulus;\n        }\n        else\n        {\n            twoCount = (twoCount + oneCount) % modulus;\n        }\n    }\n    return twoCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countSpecialSubsequences(std::vector<int> &inputNumbers)\n{\n    long long zeroCount= 0, oneCount= 0, twoCount= 0;\n    long long modulus= 1000000007;\n    for(int currentNumber : inputNumbers)\n    {\n        if(currentNumber == 0)\n        {\n            zeroCount= (zeroCount + 1) % modulus;\n        }\n        else if(currentNumber == 1)\n        {\n            oneCount= (oneCount + zeroCount) % modulus;\n        }\n        else\n        {\n            twoCount= (twoCount + oneCount) % modulus;\n        }\n    }\n    return twoCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For abs\nusing namespace std;\n\nint calculateMinimumTotalCost(vector<int> &startPosition, vector<int> &homePosition, vector<int> &rowCosts, vector<int> &columnCosts)\n{\n    int rowDifference= abs(startPosition[0] - homePosition[0]);\n    int columnDifference= abs(startPosition[1] - homePosition[1]);\n\n    int totalRowCost= 0, totalColumnCost= 0;\n    for(int i= 0; i < rowDifference; i++)\n        totalRowCost+= rowCosts[i + min(startPosition[0], homePosition[0])];\n    for(int i= 0; i < columnDifference; i++)\n        totalColumnCost+= columnCosts[i + min(startPosition[1], homePosition[1])];\n\n    return totalRowCost + totalColumnCost;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMinimumTotalCost(std::vector<int> &startPosition, std::vector<int> &homePosition, std::vector<int> &rowCosts, std::vector<int> &columnCosts)\n{\n    int rowDifference= std::abs(startPosition[0] - homePosition[0]);\n    int columnDifference= std::abs(startPosition[1] - homePosition[1]);\n\n    int totalRowCost= 0, totalColumnCost= 0;\n    for(int i= 0; i < rowDifference; i++)\n        totalRowCost+= rowCosts[i + std::min(startPosition[0], homePosition[0])];\n    for(int i= 0; i < columnDifference; i++)\n        totalColumnCost+= columnCosts[i + std::min(startPosition[1], homePosition[1])];\n\n    return totalRowCost + totalColumnCost;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeToType(string word)\n{\n    int totalTime = 0, previousPosition = 0;\n    for (int i = 0; i < word.size(); ++i)\n    {\n        char character = word[i];\n        int currentPosition = character - 'a';\n        totalTime += min(abs(currentPosition - previousPosition), 26 - abs(currentPosition - previousPosition)) + 1;\n        previousPosition = currentPosition;\n    }\n    return totalTime;\n}",
    "output": "#include <bits/stdc++.h>\nint minTimeToType(std::string word)\n{\n    int totalTime= 0, previousPosition= 0;\n    for(char character : word)\n    {\n        int currentPosition= character - 'a';\n        totalTime+= std::min(abs(currentPosition - previousPosition), 26 - abs(currentPosition - previousPosition)) + 1;\n        previousPosition= currentPosition;\n    }\n    return totalTime;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxMatrixSum(vector<vector<int>> &matrix)\n{\n    int matrixSize= matrix.size();\n    int minimumValue= INT_MAX, negativeCount= 0, totalSum= 0;\n\n    for(int rowIndex= 0; rowIndex < matrixSize; ++rowIndex)\n    {\n        for(int columnIndex= 0; columnIndex < matrixSize; ++columnIndex)\n        {\n            totalSum+= abs(matrix[rowIndex][columnIndex]);\n            minimumValue= min(minimumValue, abs(matrix[rowIndex][columnIndex]));\n            if(matrix[rowIndex][columnIndex] < 0)\n            {\n                negativeCount++;\n            }\n        }\n    }\n\n    if(negativeCount % 2 == 0)\n    {\n        return totalSum;\n    }\n    else\n    {\n        return totalSum - 2 * minimumValue;\n    }\n}",
    "output": "#include <bits/stdc++.h>\nint maxMatrixSum(std::vector<std::vector<int>> &matrix)\n{\n    int matrixSize= matrix.size();\n    int minimumValue= INT_MAX, negativeCount= 0, totalSum= 0;\n\n    for(int rowIndex= 0; rowIndex < matrixSize; ++rowIndex)\n    {\n        for(int columnIndex= 0; columnIndex < matrixSize; ++columnIndex)\n        {\n            totalSum+= std::abs(matrix[rowIndex][columnIndex]);\n            minimumValue= std::min(minimumValue, std::abs(matrix[rowIndex][columnIndex]));\n            if(matrix[rowIndex][columnIndex] < 0)\n            {\n                negativeCount++;\n            }\n        }\n    }\n\n    if(negativeCount % 2 == 0)\n    {\n        return totalSum;\n    }\n    else\n    {\n        return totalSum - 2 * minimumValue;\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint countPaths(int numberOfNodes, vector<vector<int>> &roads)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numberOfNodes);\n\n    for (int i = 0; i < roads.size(); ++i)\n    {\n        auto &road = roads[i];\n        adjacencyList[road[0]].emplace_back(road[1], road[2]);\n        adjacencyList[road[1]].emplace_back(road[0], road[2]);\n    }\n\n    vector<int> distances(numberOfNodes, 1e9);\n    distances[0] = 0;\n    vector<int> pathCount(numberOfNodes);\n    pathCount[0] = 1;\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n    priorityQueue.push({0, 0});\n\n    while (!priorityQueue.empty())\n    {\n        int currentNode = priorityQueue.top().second;\n        int currentDistance = priorityQueue.top().first;\n        priorityQueue.pop();\n\n        if (currentDistance > distances[currentNode])\n            continue;\n\n        for (int j = 0; j < adjacencyList[currentNode].size(); ++j)\n        {\n            auto &neighbor = adjacencyList[currentNode][j];\n            int nextNode = neighbor.first;\n            int edgeDistance = neighbor.second;\n\n            if (currentDistance + edgeDistance > distances[nextNode])\n                continue;\n\n            if (currentDistance + edgeDistance == distances[nextNode])\n            {\n                pathCount[nextNode] = (pathCount[nextNode] + pathCount[currentNode]) % mod;\n            }\n            else\n            {\n                pathCount[nextNode] = pathCount[currentNode];\n                distances[nextNode] = currentDistance + edgeDistance;\n                priorityQueue.push({distances[nextNode], nextNode});\n            }\n        }\n    }\n\n    return pathCount[numberOfNodes - 1];\n}",
    "output": "#include <bits/stdc++.h>\nconst int mod = 1000000007;\n\nint countPaths(int numberOfNodes, std::vector<std::vector<int>> &roads)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(numberOfNodes);\n\n    for(auto &road : roads)\n    {\n        adjacencyList[road[0]].emplace_back(road[1], road[2]);\n        adjacencyList[road[1]].emplace_back(road[0], road[2]);\n    }\n\n    std::vector<int> distances(numberOfNodes, 1e9);\n    distances[0] = 0;\n    std::vector<int> pathCount(numberOfNodes);\n    pathCount[0] = 1;\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n    priorityQueue.push({0, 0});\n\n    while(!priorityQueue.empty())\n    {\n        int currentNode = priorityQueue.top().second;\n        int currentDistance = priorityQueue.top().first;\n        priorityQueue.pop();\n\n        if(currentDistance > distances[currentNode])\n            continue;\n\n        for(auto &neighbor : adjacencyList[currentNode])\n        {\n            int nextNode = neighbor.first;\n            int edgeDistance = neighbor.second;\n\n            if(currentDistance + edgeDistance > distances[nextNode])\n                continue;\n\n            if(currentDistance + edgeDistance == distances[nextNode])\n            {\n                pathCount[nextNode] = (pathCount[nextNode] + pathCount[currentNode]) % mod;\n            }\n            else\n            {\n                pathCount[nextNode] = pathCount[currentNode];\n                distances[nextNode] = currentDistance + edgeDistance;\n                priorityQueue.push({distances[nextNode], nextNode});\n            }\n        }\n    }\n\n    return pathCount[numberOfNodes - 1];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numberOfLists(string numberString)\n{\n    const int modulo= 1e9 + 7;\n    int stringLength= numberString.size();\n    vector<vector<int>> dynamicProgramming(stringLength + 1, vector<int>(stringLength + 1, 0));\n    dynamicProgramming[0][0]= 1;\n\n    for(int currentIndex= 0; currentIndex < stringLength; ++currentIndex)\n    {\n        for(int listSize= 1; listSize <= stringLength; ++listSize)\n        {\n            if(numberString[currentIndex] == '0')\n                continue;\n            for(int substringLength= 1; currentIndex + substringLength <= stringLength; ++substringLength)\n            {\n                if(substringLength > 1 && numberString[currentIndex + substringLength - 1] == '0')\n                    break;\n                dynamicProgramming[currentIndex + substringLength][listSize]=\n                    (dynamicProgramming[currentIndex + substringLength][listSize] + dynamicProgramming[currentIndex][listSize - 1]) % modulo;\n            }\n        }\n    }\n\n    int result= 0;\n    for(int i= 1; i <= stringLength; ++i)\n    {\n        result= (result + dynamicProgramming[stringLength][i]) % modulo;\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nint numberOfLists(std::string numberString)\n{\n    const int modulo = 1e9 + 7;\n    int stringLength = numberString.size();\n    std::vector<std::vector<int>> dynamicProgramming(stringLength + 1, std::vector<int>(stringLength + 1, 0));\n    dynamicProgramming[0][0] = 1;\n\n    for(int currentIndex = 0; currentIndex < stringLength; ++currentIndex)\n    {\n        for(int listSize = 1; listSize <= stringLength; ++listSize)\n        {\n            if(numberString[currentIndex] == '0')\n                continue;\n            for(int substringLength = 1; currentIndex + substringLength <= stringLength; ++substringLength)\n            {\n                if(substringLength > 1 && numberString[currentIndex + substringLength - 1] == '0')\n                    break;\n                dynamicProgramming[currentIndex + substringLength][listSize] =\n                    (dynamicProgramming[currentIndex + substringLength][listSize] + dynamicProgramming[currentIndex][listSize - 1]) % modulo;\n            }\n        }\n    }\n\n    int result = 0;\n    for(int i = 1; i <= stringLength; ++i)\n    {\n        result = (result + dynamicProgramming[stringLength][i]) % modulo;\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findSecretSharers(int totalPersons, vector<vector<int>> &meetings, int initialPerson)\n{\n    vector<int> secretHolders(totalPersons, -1);\n    secretHolders[0] = 0;\n    secretHolders[initialPerson] = 0;\n\n    sort(meetings.begin(), meetings.end(), [](const vector<int> &meetingA, const vector<int> &meetingB)\n         { return meetingA[2] < meetingB[2]; });\n\n    for (int i = 0; i < meetings.size(); ++i)\n    {\n        auto &currentMeeting = meetings[i];\n        int personX = currentMeeting[0];\n        int personY = currentMeeting[1];\n        int meetingTime = currentMeeting[2];\n\n        if (secretHolders[personX] != -1 && secretHolders[personX] <= meetingTime)\n            secretHolders[personY] = meetingTime;\n        if (secretHolders[personY] != -1 && secretHolders[personY] <= meetingTime)\n            secretHolders[personX] = meetingTime;\n    }\n\n    vector<int> result;\n    for (int index = 0; index < totalPersons; ++index)\n    {\n        if (secretHolders[index] != -1)\n            result.push_back(index);\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findSecretSharers(int totalPersons, std::vector<std::vector<int>> &meetings, int initialPerson)\n{\n    std::vector<int> secretHolders(totalPersons, -1);\n    secretHolders[0] = 0;\n    secretHolders[initialPerson] = 0;\n\n    std::sort(meetings.begin(), meetings.end(), [](const std::vector<int> &meetingA, const std::vector<int> &meetingB)\n         { return meetingA[2] < meetingB[2]; });\n\n    for(auto &currentMeeting : meetings)\n    {\n        int personX = currentMeeting[0];\n        int personY = currentMeeting[1];\n        int meetingTime = currentMeeting[2];\n\n        if(secretHolders[personX] != -1 && secretHolders[personX] <= meetingTime)\n            secretHolders[personY] = meetingTime;\n        if(secretHolders[personY] != -1 && secretHolders[personY] <= meetingTime)\n            secretHolders[personX] = meetingTime;\n    }\n\n    std::vector<int> result;\n    for(int index = 0; index < totalPersons; ++index)\n    {\n        if(secretHolders[index] != -1)\n            result.push_back(index);\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPrefixString(string targetString, vector<string> &wordList)\n{\n    string concatenatedWords = \"\";\n    for (int i = 0; i < wordList.size(); ++i)\n    {\n        string currentWord = wordList[i];\n        concatenatedWords += currentWord;\n        if (concatenatedWords == targetString)\n            return true;\n        if (concatenatedWords.size() > targetString.size())\n            break;\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool isPrefixString(std::string targetString, std::vector<std::string> &wordList)\n{\n    std::string concatenatedWords= \"\";\n    for(std::string currentWord : wordList)\n    {\n        concatenatedWords+= currentWord;\n        if(concatenatedWords == targetString)\n            return true;\n        if(concatenatedWords.size() > targetString.size())\n            break;\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minStonesRemaining(int stonePiles[], int numberOfPiles, int numberOfRemovals)\n{\n    for(int i= 0; i < numberOfRemovals; i++)\n    {\n        int maxPileIndex= distance(stonePiles, max_element(stonePiles, stonePiles + numberOfPiles));\n        stonePiles[maxPileIndex]= stonePiles[maxPileIndex] - (stonePiles[maxPileIndex] / 2);\n    }\n\n    int totalStones= 0;\n    for(int i= 0; i < numberOfPiles; i++)\n    {\n        totalStones+= stonePiles[i];\n    }\n    return totalStones;\n}",
    "output": "#include <bits/stdc++.h>\nint minStonesRemaining(int stonePiles[], int numberOfPiles, int numberOfRemovals)\n{\n    for(int i= 0; i < numberOfRemovals; i++)\n    {\n        int maxPileIndex= std::distance(stonePiles, std::max_element(stonePiles, stonePiles + numberOfPiles));\n        stonePiles[maxPileIndex]= stonePiles[maxPileIndex] - (stonePiles[maxPileIndex] / 2);\n    }\n\n    int totalStones= 0;\n    for(int i= 0; i < numberOfPiles; i++)\n    {\n        totalStones+= stonePiles[i];\n    }\n    return totalStones;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minSwapsToBalance(string inputString)\n{\n    int openBracketCount = 0;\n    int swapCount = 0;\n\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentChar = inputString[i];\n        if (currentChar == '[')\n        {\n            openBracketCount++;\n        }\n        else\n        {\n            if (openBracketCount == 0)\n            {\n                swapCount++;\n                openBracketCount++;\n            }\n            else\n            {\n                openBracketCount--;\n            }\n        }\n    }\n\n    return swapCount;\n}",
    "output": "#include <bits/stdc++.h>\nint minSwapsToBalance(std::string inputString)\n{\n    int openBracketCount= 0;\n    int swapCount= 0;\n\n    for(char currentChar : inputString)\n    {\n        if(currentChar == '[')\n        {\n            openBracketCount++;\n        }\n        else\n        {\n            if(openBracketCount == 0)\n            {\n                swapCount++;\n                openBracketCount++;\n            }\n            else\n            {\n                openBracketCount--;\n            }\n        }\n    }\n\n    return swapCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> longestObstacleCourse(vector<int> &obstacleHeights)\n{\n    vector<int> courseLengths(obstacleHeights.size()), activeHeights;\n    for(int currentIndex= 0; currentIndex < obstacleHeights.size(); ++currentIndex)\n    {\n        auto position= upper_bound(activeHeights.begin(), activeHeights.end(), obstacleHeights[currentIndex]);\n        courseLengths[currentIndex]= (position - activeHeights.begin()) + 1;\n        if(position == activeHeights.end())\n        {\n            activeHeights.push_back(obstacleHeights[currentIndex]);\n        }\n        else\n        {\n            *position= obstacleHeights[currentIndex];\n        }\n    }\n    return courseLengths;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> longestObstacleCourse(std::vector<int> &obstacleHeights)\n{\n    std::vector<int> courseLengths(obstacleHeights.size()), activeHeights;\n    for(int currentIndex= 0; currentIndex < obstacleHeights.size(); ++currentIndex)\n    {\n        auto position= std::upper_bound(activeHeights.begin(), activeHeights.end(), obstacleHeights[currentIndex]);\n        courseLengths[currentIndex]= (position - activeHeights.begin()) + 1;\n        if(position == activeHeights.end())\n        {\n            activeHeights.push_back(obstacleHeights[currentIndex]);\n        }\n        else\n        {\n            *position= obstacleHeights[currentIndex];\n        }\n    }\n    return courseLengths;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> validArrangement(vector<vector<int>> &pairs)\n{\n    unordered_map<int, vector<int>> graph;\n    for (int i = 0; i < pairs.size(); ++i)\n    {\n        graph[pairs[i][0]].push_back(pairs[i][1]);\n    }\n    vector<vector<int>> result;\n    int currentNode = pairs[0][0];\n    while (graph.size())\n    {\n        result.push_back({currentNode, graph[currentNode].back()});\n        graph[currentNode].pop_back();\n        if (graph[currentNode].empty())\n            graph.erase(currentNode);\n        currentNode = result.back()[1];\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> validArrangement(std::vector<std::vector<int>> &pairs)\n{\n    std::unordered_map<int, std::vector<int>> graph;\n    for(const auto &pair : pairs)\n    {\n        graph[pair[0]].push_back(pair[1]);\n    }\n    std::vector<std::vector<int>> result;\n    int currentNode= pairs[0][0];\n    while(graph.size())\n    {\n        result.push_back({currentNode, graph[currentNode].back()});\n        graph[currentNode].pop_back();\n        if(graph[currentNode].empty())\n            graph.erase(currentNode);\n        currentNode= result.back()[1];\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint largestEvenSum(const vector<int> &numbers, int count)\n{\n    vector<int> evenNumbers, oddNumbers;\n    for(auto number : numbers)\n    {\n        if(number % 2 == 0)\n        {\n            evenNumbers.push_back(number);\n        }\n        else\n        {\n            oddNumbers.push_back(number);\n        }\n    }\n    sort(evenNumbers.rbegin(), evenNumbers.rend());\n    sort(oddNumbers.rbegin(), oddNumbers.rend());\n\n    int totalSum = 0;\n    for(int i = 0; i < count && !evenNumbers.empty(); i++)\n    {\n        totalSum += evenNumbers.back();\n        evenNumbers.pop_back();\n    }\n\n    for(int i = 0; i < count - 1 && !oddNumbers.empty(); i += 2)\n    {\n        int firstOdd = oddNumbers.back();\n        oddNumbers.pop_back();\n        if(!oddNumbers.empty())\n        {\n            int secondOdd = oddNumbers.back();\n            oddNumbers.pop_back();\n            totalSum += firstOdd + secondOdd;\n        }\n    }\n\n    if(totalSum % 2 == 0)\n    {\n        return totalSum;\n    }\n    else\n    {\n        return -1;\n    }\n}",
    "output": "int largestEvenSum(const std::vector<int> &numbers, int count)\n{\n    std::vector<int> evenNumbers, oddNumbers;\n    for(auto number : numbers)\n    {\n        if(number % 2 == 0)\n        {\n            evenNumbers.push_back(number);\n        }\n        else\n        {\n            oddNumbers.push_back(number);\n        }\n    }\n    sort(evenNumbers.rbegin(), evenNumbers.rend());\n    sort(oddNumbers.rbegin(), oddNumbers.rend());\n\n    int totalSum= 0;\n    for(int i= 0; i < count && !evenNumbers.empty(); i++)\n    {\n        totalSum+= evenNumbers.back();\n        evenNumbers.pop_back();\n    }\n\n    for(int i= 0; i < count - 1 && !oddNumbers.empty(); i+= 2)\n    {\n        int firstOdd= oddNumbers.back();\n        oddNumbers.pop_back();\n        if(!oddNumbers.empty())\n        {\n            int secondOdd= oddNumbers.back();\n            oddNumbers.pop_back();\n            totalSum+= firstOdd + secondOdd;\n        }\n    }\n\n    if(totalSum % 2 == 0)\n    {\n        return totalSum;\n    }\n    else\n    {\n        return -1;\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countPatternsInWord(const vector<string> &patterns, const string &word)\n{\n    int matchCount = 0;\n    for (int i = 0; i < patterns.size(); ++i)\n    {\n        const string &pattern = patterns[i];\n        if (word.find(pattern) != string::npos)\n        {\n            matchCount++;\n        }\n    }\n    return matchCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countPatternsInWord(const std::vector<std::string> &patterns, const std::string &word)\n{\n    int matchCount= 0;\n    for(const std::string &pattern : patterns)\n    {\n        if(word.find(pattern) != std::string::npos)\n        {\n            matchCount++;\n        }\n    }\n    return matchCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "long long minNonZeroProduct(int power)\n{\n    const long long modulus= 1e9 + 7;\n    long long product= 1;\n    long long exponent= (1LL << power) - 2;\n    long long base= ((1LL << power) - 1) % modulus;\n\n    while(exponent > 0)\n    {\n        if(exponent % 2)\n        {\n            product= (product * base) % modulus;\n        }\n        base= (base * base) % modulus;\n        exponent/= 2;\n    }\n    return product;\n}",
    "output": "long long minNonZeroProduct(int power)\n{\n    const long long modulus= 1e9 + 7;\n    long long product= 1;\n    long long exponent= (1LL << power) - 2;\n    long long base= ((1LL << power) - 1) % modulus;\n\n    while(exponent > 0)\n    {\n        if(exponent % 2)\n        {\n            product= (product * base) % modulus;\n        }\n        base= (base * base) % modulus;\n        exponent/= 2;\n    }\n    return product;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canReachBottom(const vector<vector<int>> &grid, int currentRow, int currentCol)\n{\n    if(currentRow == grid.size() - 1)\n        return true;\n    grid[currentRow][currentCol]= 1;\n\n    int directionRow[]= {-1, 0, 1, 0};\n    int directionCol[]= {0, 1, 0, -1};\n\n    for(int directionIndex= 0; directionIndex < 4; ++directionIndex)\n    {\n        int nextRow= currentRow + directionRow[directionIndex], nextCol= currentCol + directionCol[directionIndex];\n        if(nextRow >= 0 && nextCol >= 0 && nextRow < grid.size() && nextCol < grid[0].size() && grid[nextRow][nextCol] == 0)\n        {\n            if(canReachBottom(grid, nextRow, nextCol))\n                return true;\n        }\n    }\n    return false;\n}\n\nint latestDayToCross(int totalRows, int totalCols, vector<vector<int>> &cellUpdates)\n{\n    vector<vector<int>> grid(totalRows, vector<int>(totalCols, 0));\n    int latestDay= 0;\n    for(int dayIndex= 0; dayIndex < cellUpdates.size(); ++dayIndex)\n    {\n        grid[cellUpdates[dayIndex][0] - 1][cellUpdates[dayIndex][1] - 1]= 1;\n\n        bool pathFound= false;\n        for(int colIndex= 0; colIndex < totalCols; ++colIndex)\n        {\n            if(grid[0][colIndex] == 0 && canReachBottom(grid, 0, colIndex))\n            {\n                pathFound= true;\n                break;\n            }\n        }\n\n        if(!pathFound)\n        {\n            latestDay= dayIndex;\n            break;\n        }\n    }\n    return latestDay;\n}",
    "output": "#include <bits/stdc++.h>\nbool canReachBottom(const std::vector<std::vector<int>> &grid, int currentRow, int currentCol)\n{\n    if(currentRow == grid.size() - 1)\n        return true;\n    grid[currentRow][currentCol]= 1;\n\n    int directionRow[]= {-1, 0, 1, 0};\n    int directionCol[]= {0, 1, 0, -1};\n\n    for(int directionIndex= 0; directionIndex < 4; ++directionIndex)\n    {\n        int nextRow= currentRow + directionRow[directionIndex], nextCol= currentCol + directionCol[directionIndex];\n        if(nextRow >= 0 && nextCol >= 0 && nextRow < grid.size() && nextCol < grid[0].size() && grid[nextRow][nextCol] == 0)\n        {\n            if(canReachBottom(grid, nextRow, nextCol))\n                return true;\n        }\n    }\n    return false;\n}\n\nint latestDayToCross(int totalRows, int totalCols, std::vector<std::vector<int>> &cellUpdates)\n{\n    std::vector<std::vector<int>> grid(totalRows, std::vector<int>(totalCols, 0));\n    int latestDay= 0;\n    for(int dayIndex= 0; dayIndex < cellUpdates.size(); ++dayIndex)\n    {\n        grid[cellUpdates[dayIndex][0] - 1][cellUpdates[dayIndex][1] - 1]= 1;\n\n        bool pathFound= false;\n        for(int colIndex= 0; colIndex < totalCols; ++colIndex)\n        {\n            if(grid[0][colIndex] == 0 && canReachBottom(grid, 0, colIndex))\n            {\n                pathFound= true;\n                break;\n            }\n        }\n\n        if(!pathFound)\n        {\n            latestDay= dayIndex;\n            break;\n        }\n    }\n    return latestDay;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMiddleIndex(vector<int> &numbers)\n{\n    int totalSum = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n        totalSum += numbers[i];\n\n    int leftSum = 0;\n    for (int index = 0; index < numbers.size(); ++index)\n    {\n        totalSum -= numbers[index];\n        if (leftSum == totalSum)\n            return index;\n        leftSum += numbers[index];\n    }\n\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint findMiddleIndex(std::vector<int> &numbers)\n{\n    int totalSum= 0;\n    for(int number : numbers)\n        totalSum+= number;\n\n    int leftSum= 0;\n    for(int index= 0; index < numbers.size(); ++index)\n    {\n        totalSum-= numbers[index];\n        if(leftSum == totalSum)\n            return index;\n        leftSum+= numbers[index];\n    }\n\n    return -1;\n}\n"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> findFarmland(vector<vector<int>> &land)\n{\n    int rows= land.size(), columns= land[0].size();\n    vector<vector<int>> result;\n\n    for(int rowIndex= 0; rowIndex < rows; ++rowIndex)\n    {\n        for(int columnIndex= 0; columnIndex < columns; ++columnIndex)\n        {\n            if(land[rowIndex][columnIndex] == 1)\n            {\n                int endRow= rowIndex, endColumn= columnIndex;\n                while(endRow < rows && land[endRow][columnIndex] == 1)\n                    ++endRow;\n                while(endColumn < columns && land[rowIndex][endColumn] == 1)\n                    ++endColumn;\n                for(int x= rowIndex; x < endRow; ++x)\n                {\n                    for(int y= columnIndex; y < endColumn; ++y)\n                    {\n                        land[x][y]= 0;\n                    }\n                }\n                result.push_back({rowIndex, columnIndex, endRow - 1, endColumn - 1});\n            }\n        }\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> findFarmland(std::vector<std::vector<int>> &land)\n{\n    int rows = land.size(), columns = land[0].size();\n    std::vector<std::vector<int>> result;\n\n    for(int rowIndex = 0; rowIndex < rows; ++rowIndex)\n    {\n        for(int columnIndex = 0; columnIndex < columns; ++columnIndex)\n        {\n            if(land[rowIndex][columnIndex] == 1)\n            {\n                int endRow = rowIndex, endColumn = columnIndex;\n                while(endRow < rows && land[endRow][columnIndex] == 1)\n                    ++endRow;\n                while(endColumn < columns && land[rowIndex][endColumn] == 1)\n                    ++endColumn;\n                for(int x = rowIndex; x < endRow; ++x)\n                {\n                    for(int y = columnIndex; y < endColumn; ++y)\n                    {\n                        land[x][y] = 0;\n                    }\n                }\n                result.push_back({rowIndex, columnIndex, endRow - 1, endColumn - 1});\n            }\n        }\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass LockingTree\n{\n  public:\n    vector<int> parentNodes;\n    vector<unordered_set<int>> childNodes;\n    vector<int> lockedByUser;\n\n    LockingTree(vector<int> &parent) : parentNodes(parent)\n    {\n        childNodes.resize(parent.size());\n        lockedByUser.resize(parent.size(), -1);\n        for(int childIndex= 1; childIndex < parent.size(); childIndex++)\n            childNodes[parent[childIndex]].insert(childIndex);\n    }\n\n    bool lock(int node, int user)\n    {\n        if(lockedByUser[node] == -1)\n        {\n            lockedByUser[node]= user;\n            return true;\n        }\n        return false;\n    }\n\n    bool unlock(int node, int user)\n    {\n        if(lockedByUser[node] == user)\n        {\n            lockedByUser[node]= -1;\n            return true;\n        }\n        return false;\n    }\n\n    bool upgrade(int node, int user)\n    {\n        if(lockedByUser[node] != -1)\n            return false;\n\n        int currentNode = node;\n        while(currentNode != -1)\n        {\n            if(lockedByUser[currentNode] != -1)\n                return false;\n            currentNode = parentNodes[currentNode];\n        }\n\n        bool hasLockedDescendant = false;\n        function<bool(int)> checkLockedDescendants = [&](int currentNode)\n        {\n            for(int j = 0; j < childNodes[currentNode].size(); ++j)\n            {\n                int childNode = *next(childNodes[currentNode].begin(), j);\n                if(lockedByUser[childNode] != -1)\n                {\n                    hasLockedDescendant = true;\n                    lockedByUser[childNode] = -1;\n                }\n                checkLockedDescendants(childNode);\n            }\n            return hasLockedDescendant;\n        };\n\n        if(checkLockedDescendants(node))\n        {\n            lockedByUser[node] = user;\n            return true;\n        }\n        return false;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass LockingTree\n{\n  public:\n    std::vector<int> parentNodes;\n    std::vector<std::unordered_set<int>> childNodes;\n    std::vector<int> lockedByUser;\n\n    LockingTree(std::vector<int> &parent) : parentNodes(parent)\n    {\n        childNodes.resize(parent.size());\n        lockedByUser.resize(parent.size(), -1);\n        for(int childIndex= 1; childIndex < parent.size(); childIndex++)\n            childNodes[parent[childIndex]].insert(childIndex);\n    }\n\n    bool lock(int node, int user)\n    {\n        if(lockedByUser[node] == -1)\n        {\n            lockedByUser[node]= user;\n            return true;\n        }\n        return false;\n    }\n\n    bool unlock(int node, int user)\n    {\n        if(lockedByUser[node] == user)\n        {\n            lockedByUser[node]= -1;\n            return true;\n        }\n        return false;\n    }\n\n    bool upgrade(int node, int user)\n    {\n        if(lockedByUser[node] != -1)\n            return false;\n\n        int currentNode= node;\n        while(currentNode != -1)\n        {\n            if(lockedByUser[currentNode] != -1)\n                return false;\n            currentNode= parentNodes[currentNode];\n        }\n\n        bool hasLockedDescendant= false;\n        std::function<bool(int)> checkLockedDescendants= [&](int currentNode)\n        {\n            for(int childNode : childNodes[currentNode])\n            {\n                if(lockedByUser[childNode] != -1)\n                {\n                    hasLockedDescendant= true;\n                    lockedByUser[childNode]= -1;\n                }\n                checkLockedDescendants(childNode);\n            }\n            return hasLockedDescendant;\n        };\n\n        if(checkLockedDescendants(node))\n        {\n            lockedByUser[node]= user;\n            return true;\n        }\n        return false;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo = 1e9 + 7;\n\nbool isPrime(int number)\n{\n    if (number <= 1)\n        return false;\n    for (int i = 2; i * i <= number; i++)\n    {\n        if (number % i == 0)\n            return false;\n    }\n    return true;\n}\n\nint numberOfGoodSubsets(vector<int> &inputNumbers)\n{\n    unordered_set<int> primeNumbers;\n    for (int i = 2; i <= 90; i++)\n    {\n        if (isPrime(i))\n            primeNumbers.insert(i);\n    }\n\n    vector<int> count(100, 0);\n    for (auto number : inputNumbers)\n        count[number]++;\n\n    vector<long long> dynamicProgramming(1 << 20, 0);\n    dynamicProgramming[0] = 1;\n\n    for (int currentNumber = 30; currentNumber > 0; currentNumber--)\n    {\n        if (count[currentNumber] == 0)\n            continue;\n        vector<int> primeFactors;\n        for (int prime : primeNumbers)\n        {\n            if (currentNumber % prime == 0)\n            {\n                primeFactors.push_back(prime);\n                while (currentNumber % prime == 0)\n                    currentNumber /= prime;\n            }\n        }\n        if (currentNumber > 1)\n            continue;\n\n        int mask = 0;\n        for (int prime : primeFactors)\n            mask |= 1 << (prime - 2);\n\n        for (int j = dynamicProgramming.size() - 1; j >= 0; --j)\n        {\n            if (dynamicProgramming[j] == 0)\n                continue;\n            long long currentCombination = 1;\n            for (int k = 0; k < count[mask]; ++k)\n            {\n                currentCombination = (currentCombination * 2) % modulo;\n                dynamicProgramming[j | mask] = (dynamicProgramming[j | mask] + dynamicProgramming[j] * currentCombination) % modulo;\n            }\n        }\n    }\n\n    long long answer = 0;\n    for (int i = 0; i < dynamicProgramming.size(); ++i)\n        answer = (answer + dynamicProgramming[i]) % modulo;\n\n    answer = (answer - dynamicProgramming[0] + modulo) % modulo;\n    return (answer * (1 << (count[1] - 1))) % modulo;\n}",
    "output": "#include <bits/stdc++.h>\nconst int modulo= 1e9 + 7;\n\nbool isPrime(int number)\n{\n    if(number <= 1)\n        return false;\n    for(int i= 2; i * i <= number; i++)\n    {\n        if(number % i == 0)\n            return false;\n    }\n    return true;\n}\n\nint numberOfGoodSubsets(std::vector<int> &inputNumbers)\n{\n    std::unordered_set<int> primeNumbers;\n    for(int i= 2; i <= 90; i++)\n    {\n        if(isPrime(i))\n            primeNumbers.insert(i);\n    }\n\n    std::vector<int> count(100, 0);\n    for(auto number : inputNumbers)\n        count[number]++;\n\n    std::vector<long long> dynamicProgramming(1 << 20, 0);\n    dynamicProgramming[0]= 1;\n\n    for(int currentNumber= 30; currentNumber > 0; currentNumber--)\n    {\n        if(count[currentNumber] == 0)\n            continue;\n        std::vector<int> primeFactors;\n        for(int prime : primeNumbers)\n        {\n            if(currentNumber % prime == 0)\n            {\n                primeFactors.push_back(prime);\n                while(currentNumber % prime == 0)\n                    currentNumber/= prime;\n            }\n        }\n        if(currentNumber > 1)\n            continue;\n\n        int mask= 0;\n        for(int prime : primeFactors)\n            mask|= 1 << (prime - 2);\n\n        for(int j= dynamicProgramming.size() - 1; j >= 0; --j)\n        {\n            if(dynamicProgramming[j] == 0)\n                continue;\n            long long currentCombination= 1;\n            for(int k= 0; k < count[mask]; ++k)\n            {\n                currentCombination= (currentCombination * 2) % modulo;\n                dynamicProgramming[j | mask]= (dynamicProgramming[j | mask] + dynamicProgramming[j] * currentCombination) % modulo;\n            }\n        }\n    }\n\n    long long answer= 0;\n    for(long long value : dynamicProgramming)\n        answer= (answer + value) % modulo;\n\n    answer= (answer - dynamicProgramming[0] + modulo) % modulo;\n    return (answer * (1 << (count[1] - 1))) % modulo;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int firstNumber, int secondNumber)\n{\n    return secondNumber ? gcd(secondNumber, firstNumber % secondNumber) : firstNumber;\n}\n\nint findGcd(vector<int> &numberList)\n{\n    int minimumValue = *min_element(numberList.begin(), numberList.end());\n    int maximumValue = *max_element(numberList.begin(), numberList.end());\n    return gcd(minimumValue, maximumValue);\n}",
    "output": "#include <bits/stdc++.h>\nint gcd(int firstNumber, int secondNumber)\n{\n    return secondNumber ? gcd(secondNumber, firstNumber % secondNumber) : firstNumber;\n}\n\nint findGcd(std::vector<int> &numberList)\n{\n    int minimumValue= *std::min_element(numberList.begin(), numberList.end());\n    int maximumValue= *std::max_element(numberList.begin(), numberList.end());\n    return gcd(minimumValue, maximumValue);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring findDifferentBinaryString(vector<string> &binaryStrings)\n{\n    string uniqueBinaryString;\n    for(int currentIndex= 0; currentIndex < binaryStrings.size(); currentIndex++)\n    {\n        uniqueBinaryString.push_back(binaryStrings[currentIndex][currentIndex] == '0' ? '1' : '0');\n    }\n    return uniqueBinaryString;\n}",
    "output": "std::string findDifferentBinaryString(std::vector<std::string> &binaryStrings)\n{\n    std::string uniqueBinaryString;\n    for(int currentIndex= 0; currentIndex < binaryStrings.size(); currentIndex++)\n    {\n        uniqueBinaryString.push_back(binaryStrings[currentIndex][currentIndex] == '0' ? '1' : '0');\n    }\n    return uniqueBinaryString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimizeTheDifference(vector<vector<int>> &matrix, int targetValue)\n{\n    int rowCount= matrix.size(), columnCount= matrix[0].size();\n    vector<int> dpArray(4901, 0), newDpArray(4901, 0);\n    dpArray[0]= 1;\n    for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n    {\n        fill(newDpArray.begin(), newDpArray.end(), 0);\n        for(int columnIndex= 0; columnIndex < columnCount; ++columnIndex)\n        {\n            for(int sumIndex= 0; sumIndex + matrix[rowIndex][columnIndex] < 4901; ++sumIndex)\n            {\n                newDpArray[sumIndex + matrix[rowIndex][columnIndex]]|= dpArray[sumIndex];\n            }\n        }\n        dpArray.swap(newDpArray);\n    }\n    for(int i= 0; i < 4901; ++i)\n    {\n        if(dpArray[i])\n            return abs(targetValue - i);\n    }\n    return INT_MAX;\n}",
    "output": "#include <bits/stdc++.h>\nint minimizeTheDifference(std::vector<std::vector<int>> &matrix, int targetValue)\n{\n    int rowCount = matrix.size(), columnCount = matrix[0].size();\n    std::vector<int> dpArray(4901, 0), newDpArray(4901, 0);\n    dpArray[0] = 1;\n    for(int rowIndex = 0; rowIndex < rowCount; ++rowIndex)\n    {\n        std::fill(newDpArray.begin(), newDpArray.end(), 0);\n        for(int columnIndex = 0; columnIndex < columnCount; ++columnIndex)\n        {\n            for(int sumIndex = 0; sumIndex + matrix[rowIndex][columnIndex] < 4901; ++sumIndex)\n            {\n                newDpArray[sumIndex + matrix[rowIndex][columnIndex]] |= dpArray[sumIndex];\n            }\n        }\n        dpArray.swap(newDpArray);\n    }\n    for(int i = 0; i < 4901; ++i)\n    {\n        if(dpArray[i])\n            return std::abs(targetValue - i);\n    }\n    return INT_MAX;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// Include this header for std::multiset\nusing namespace std;\n\nvector<int> recoverArray(int arraySize, vector<int> &sumValues)\n{\n    multiset<int> numberSet(sumValues.begin(), sumValues.end());\n    vector<int> recoveredArray(arraySize);\n    for(int index = 0; index < arraySize; ++index)\n    {\n        int currentNum = *next(numberSet.begin());\n        numberSet.erase(numberSet.begin());\n        for(int j = 0; j < recoveredArray.size(); ++j)\n        {\n            int previousNum = recoveredArray[j];\n            numberSet.erase(numberSet.find(currentNum - previousNum));\n        }\n        recoveredArray[index] = currentNum;\n    }\n    return recoveredArray;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> recoverArray(int arraySize, std::vector<int> &sumValues)\n{\n    std::multiset<int> numberSet(sumValues.begin(), sumValues.end());\n    std::vector<int> recoveredArray(arraySize);\n    for(int index= 0; index < arraySize; ++index)\n    {\n        int currentNum= *next(numberSet.begin());\n        numberSet.erase(numberSet.begin());\n        for(int previousNum : recoveredArray)\n        {\n            numberSet.erase(numberSet.find(currentNum - previousNum));\n        }\n        recoveredArray[index]= currentNum;\n    }\n    return recoveredArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countSmoothDescentPeriods(vector<int> &priceList)\n{\n    int totalPeriods= 0;\n    int currentDescentCount= 0;\n    for(int index= 1; index < priceList.size(); ++index)\n    {\n        if(priceList[index] == priceList[index - 1] - 1)\n        {\n            ++currentDescentCount;\n        }\n        else\n        {\n            currentDescentCount= 0;\n        }\n        totalPeriods+= currentDescentCount + 1;\n    }\n    return totalPeriods + 1;\n}",
    "output": "#include <bits/stdc++.h>\nint countSmoothDescentPeriods(std::vector<int> &priceList)\n{\n    int totalPeriods= 0;\n    int currentDescentCount= 0;\n    for(int index= 1; index < priceList.size(); ++index)\n    {\n        if(priceList[index] == priceList[index - 1] - 1)\n        {\n            ++currentDescentCount;\n        }\n        else\n        {\n            currentDescentCount= 0;\n        }\n        totalPeriods+= currentDescentCount + 1;\n    }\n    return totalPeriods + 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &inputArray, int target)\n{\n    vector<int> operationCount(inputArray.size(), 0);\n    for(int currentIndex= target; currentIndex < inputArray.size(); currentIndex++)\n    {\n        operationCount[currentIndex]= max(operationCount[currentIndex - target] + 1 - (inputArray[currentIndex] - inputArray[currentIndex - target]), 0);\n    }\n    return accumulate(operationCount.begin(), operationCount.end(), 0);\n}",
    "output": "#include <bits/stdc++.h>\nint minOperations(std::vector<int> &inputArray, int target)\n{\n    std::vector<int> operationCount(inputArray.size(), 0);\n    for(int currentIndex= target; currentIndex < inputArray.size(); currentIndex++)\n    {\n        operationCount[currentIndex]= std::max(operationCount[currentIndex - target] + 1 - (inputArray[currentIndex] - inputArray[currentIndex - target]), 0);\n    }\n    return std::accumulate(operationCount.begin(), operationCount.end(), 0);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring findKthLargestNumber(vector<string> &numberList, int k)\n{\n    sort(numberList.begin(), numberList.end(), [](const string &firstNumber, const string &secondNumber)\n         {\n             if (firstNumber.size() == secondNumber.size()) return firstNumber < secondNumber;\n             return firstNumber.size() < secondNumber.size(); });\n    return numberList[numberList.size() - k];\n}",
    "output": "#include <bits/stdc++.h>\nstd::string findKthLargestNumber(std::vector<std::string> &numberList, int k)\n{\n    std::sort(numberList.begin(), numberList.end(), [](const std::string &firstNumber, const std::string &secondNumber)\n              {\n        if (firstNumber.size() == secondNumber.size()) return firstNumber < secondNumber;\n        return firstNumber.size() < secondNumber.size(); });\n    return numberList[numberList.size() - k];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minSessions(vector<int> &taskDurations, int maximumSessionTime)\n{\n    sort(taskDurations.begin(), taskDurations.end(), greater<int>());\n    vector<int> activeSessions;\n\n    for (int i = 0; i < taskDurations.size(); ++i)\n    {\n        int task = taskDurations[i];\n        bool isAdded = false;\n        for (int j = 0; j < activeSessions.size(); ++j)\n        {\n            int &session = activeSessions[j];\n            if (session + task <= maximumSessionTime)\n            {\n                session += task;\n                isAdded = true;\n                break;\n            }\n        }\n\n        if (!isAdded)\n        {\n            activeSessions.push_back(task);\n        }\n    }\n\n    return activeSessions.size();\n}",
    "output": "#include <bits/stdc++.h>\nint minSessions(std::vector<int> &taskDurations, int maximumSessionTime)\n{\n    std::sort(taskDurations.begin(), taskDurations.end(), std::greater<int>());\n    std::vector<int> activeSessions;\n\n    for(int task : taskDurations)\n    {\n        bool isAdded= false;\n        for(int &session : activeSessions)\n        {\n            if(session + task <= maximumSessionTime)\n            {\n                session+= task;\n                isAdded= true;\n                break;\n            }\n        }\n\n        if(!isAdded)\n        {\n            activeSessions.push_back(task);\n        }\n    }\n\n    return activeSessions.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countDistinctSequences(string binaryString)\n{\n    int modulus = 1e9 + 7;\n    int zeroCount = 0, onesCount = 0;\n\n    for (int i = 0; i < binaryString.size(); ++i)\n    {\n        char character = binaryString[i];\n        if (character == '0')\n        {\n            zeroCount = (zeroCount + onesCount) % modulus;\n        }\n        else\n        {\n            onesCount = (onesCount * 2 + 1) % modulus;\n        }\n    }\n    return zeroCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countDistinctSequences(std::string binaryString)\n{\n    int modulus= 1e9 + 7;\n    int zeroCount= 0, onesCount= 0;\n\n    for(char character : binaryString)\n    {\n        if(character == '0')\n        {\n            zeroCount= (zeroCount + onesCount) % modulus;\n        }\n        else\n        {\n            onesCount= (onesCount * 2 + 1) % modulus;\n        }\n    }\n    return zeroCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairsWithDifferenceK(const vector<int> &numberList, int difference)\n{\n    unordered_map<int, int> frequencyMap;\n    int pairCount = 0;\n\n    for (int i = 0; i < numberList.size(); ++i)\n    {\n        int currentNumber = numberList[i];\n        pairCount += frequencyMap[currentNumber - difference] + frequencyMap[currentNumber + difference];\n        frequencyMap[currentNumber]++;\n    }\n\n    return pairCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countPairsWithDifferenceK(const std::vector<int> &numberList, int difference)\n{\n    std::unordered_map<int, int> frequencyMap;\n    int pairCount= 0;\n\n    for(int currentNumber : numberList)\n    {\n        pairCount+= frequencyMap[currentNumber - difference] + frequencyMap[currentNumber + difference];\n        frequencyMap[currentNumber]++;\n    }\n\n    return pairCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findOriginalArray(vector<int> &changedArray)\n{\n    unordered_map<int, int> numberCount;\n    for (int i = 0; i < changedArray.size(); ++i)\n        numberCount[changedArray[i]]++;\n\n    vector<int> sortedValues;\n    for (auto it = numberCount.begin(); it != numberCount.end(); ++it)\n        sortedValues.push_back(it->first);\n    sort(sortedValues.begin(), sortedValues.end());\n\n    vector<int> originalArray;\n    for (int i = 0; i < sortedValues.size(); ++i)\n    {\n        int number = sortedValues[i];\n        while (numberCount[number] > 0 && numberCount[number * 2] > 0)\n        {\n            originalArray.push_back(number);\n            numberCount[number]--;\n            numberCount[number * 2]--;\n        }\n        if (numberCount[number] > 0)\n            return {};\n    }\n    return originalArray;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findOriginalArray(std::vector<int> &changedArray)\n{\n    std::unordered_map<int, int> numberCount;\n    for(const int &number : changedArray)\n        numberCount[number]++;\n\n    std::vector<int> sortedValues;\n    for(const auto &entry : numberCount)\n        sortedValues.push_back(entry.first);\n    std::sort(sortedValues.begin(), sortedValues.end());\n\n    std::vector<int> originalArray;\n    for(const int &number : sortedValues)\n    {\n        while(numberCount[number] > 0 && numberCount[number * 2] > 0)\n        {\n            originalArray.push_back(number);\n            numberCount[number]--;\n            numberCount[number * 2]--;\n        }\n        if(numberCount[number] > 0)\n            return {};\n    }\n    return originalArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numberList)\n{\n    sort(numberList.begin(), numberList.end());\n    numberList.erase(unique(numberList.begin(), numberList.end()), numberList.end());\n    int uniqueCount= numberList.size();\n    int minimumOperations= uniqueCount;\n    for(int currentIndex= 0; currentIndex < uniqueCount; ++currentIndex)\n    {\n        int upperBoundIndex= upper_bound(numberList.begin() + currentIndex, numberList.end(), numberList[currentIndex] + uniqueCount - 1) - numberList.begin();\n        minimumOperations= min(minimumOperations, uniqueCount - (upperBoundIndex - currentIndex));\n    }\n    return minimumOperations;\n}",
    "output": "#include <bits/stdc++.h>\nint minOperations(std::vector<int> &numberList)\n{\n    std::sort(numberList.begin(), numberList.end());\n    numberList.erase(std::unique(numberList.begin(), numberList.end()), numberList.end());\n    int uniqueCount= numberList.size();\n    int minimumOperations= uniqueCount;\n    for(int currentIndex= 0; currentIndex < uniqueCount; ++currentIndex)\n    {\n        int upperBoundIndex= std::upper_bound(numberList.begin() + currentIndex, numberList.end(), numberList[currentIndex] + uniqueCount - 1) - numberList.begin();\n        minimumOperations= std::min(minimumOperations, uniqueCount - (upperBoundIndex - currentIndex));\n    }\n    return minimumOperations;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findNoOfInstructions(int gridSize, vector<int> &startingPosition, string instructions)\n{\n    vector<int> instructionCounts(instructions.size(), 0);\n    int currentX= startingPosition[0];\n    int currentY= startingPosition[1];\n\n    for(int instructionIndex= 0; instructionIndex < instructions.size(); ++instructionIndex)\n    {\n        int count= 0;\n        int tempX= currentX;\n        int tempY= currentY;\n        for(int j= instructionIndex; j < instructions.size(); ++j)\n        {\n            if(instructions[j] == 'L')\n            {\n                if(tempY == 0)\n                    break;\n                tempY-= 1;\n            }\n            else if(instructions[j] == 'R')\n            {\n                if(tempY == gridSize - 1)\n                    break;\n                tempY+= 1;\n            }\n            else if(instructions[j] == 'U')\n            {\n                if(tempX == 0)\n                    break;\n                tempX-= 1;\n            }\n            else\n            {\n                if(tempX == gridSize - 1)\n                    break;\n                tempX+= 1;\n            }\n            count++;\n            if(j == instructions.size() - 1)\n                break;\n        }\n        instructionCounts[instructionIndex]= count;\n    }\n\n    return instructionCounts;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findNoOfInstructions(int gridSize, std::vector<int> &startingPosition, std::string instructions)\n{\n    std::vector<int> instructionCounts(instructions.size(), 0);\n    int currentX= startingPosition[0];\n    int currentY= startingPosition[1];\n\n    for(int instructionIndex= 0; instructionIndex < instructions.size(); ++instructionIndex)\n    {\n        int count= 0;\n        int tempX= currentX;\n        int tempY= currentY;\n        for(int j= instructionIndex; j < instructions.size(); ++j)\n        {\n            if(instructions[j] == 'L')\n            {\n                if(tempY == 0)\n                    break;\n                tempY-= 1;\n            }\n            else if(instructions[j] == 'R')\n            {\n                if(tempY == gridSize - 1)\n                    break;\n                tempY+= 1;\n            }\n            else if(instructions[j] == 'U')\n            {\n                if(tempX == 0)\n                    break;\n                tempX-= 1;\n            }\n            else\n            {\n                if(tempX == gridSize - 1)\n                    break;\n                tempX+= 1;\n            }\n            count++;\n            if(j == instructions.size() - 1)\n                break;\n        }\n        instructionCounts[instructionIndex]= count;\n    }\n\n    return instructionCounts;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool hasPath(int numberOfNodes, vector<vector<int>> &edges, int sourceNode, int destinationNode)\n{\n    unordered_map<int, vector<int>> adjacencyList;\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        const vector<int> &edge = edges[i];\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n    queue<int> nodeQueue;\n    nodeQueue.push(sourceNode);\n    vector<bool> visitedNodes(numberOfNodes, false);\n    while (!nodeQueue.empty())\n    {\n        int currentNode = nodeQueue.front();\n        nodeQueue.pop();\n        visitedNodes[currentNode] = true;\n        if (currentNode == destinationNode)\n            return true;\n        for (int j = 0; j < adjacencyList[currentNode].size(); ++j)\n        {\n            int neighborNode = adjacencyList[currentNode][j];\n            if (!visitedNodes[neighborNode])\n                nodeQueue.push(neighborNode);\n        }\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool hasPath(int numberOfNodes, std::vector<std::vector<int>> &edges, int sourceNode, int destinationNode)\n{\n    std::unordered_map<int, std::vector<int>> adjacencyList;\n    for(const std::vector<int> &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n    std::queue<int> nodeQueue;\n    nodeQueue.push(sourceNode);\n    std::vector<bool> visitedNodes(numberOfNodes, false);\n    while(!nodeQueue.empty())\n    {\n        int currentNode= nodeQueue.front();\n        nodeQueue.pop();\n        visitedNodes[currentNode]= true;\n        if(currentNode == destinationNode)\n            return true;\n        for(int neighborNode : adjacencyList[currentNode])\n        {\n            if(!visitedNodes[neighborNode])\n                nodeQueue.push(neighborNode);\n        }\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numberOfWeakCharacters(vector<vector<int>> &characterProperties)\n{\n    sort(characterProperties.begin(), characterProperties.end(), [](const auto &firstCharacter, const auto &secondCharacter)\n              { return firstCharacter[0] == secondCharacter[0] ? firstCharacter[1] > secondCharacter[1] : firstCharacter[0] < secondCharacter[0]; });\n\n    int maxDefense= 0, weakCharacterCount= 0;\n    for(int i= characterProperties.size() - 1; i >= 0; --i)\n    {\n        if(characterProperties[i][1] < maxDefense)\n        {\n            weakCharacterCount++;\n        }\n        else\n        {\n            maxDefense= characterProperties[i][1];\n        }\n    }\n\n    return weakCharacterCount;\n}",
    "output": "#include <bits/stdc++.h>\nint numberOfWeakCharacters(std::vector<std::vector<int>> &characterProperties)\n{\n    std::sort(characterProperties.begin(), characterProperties.end(), [](const auto &firstCharacter, const auto &secondCharacter)\n              { return firstCharacter[0] == secondCharacter[0] ? firstCharacter[1] > secondCharacter[1] : firstCharacter[0] < secondCharacter[0]; });\n\n    int maxDefense= 0, weakCharacterCount= 0;\n    for(int i= characterProperties.size() - 1; i >= 0; --i)\n    {\n        if(characterProperties[i][1] < maxDefense)\n        {\n            weakCharacterCount++;\n        }\n        else\n        {\n            maxDefense= characterProperties[i][1];\n        }\n    }\n\n    return weakCharacterCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateFirstDayInAllRooms(vector<int> &nextVisit)\n{\n    int roomCount= nextVisit.size();\n    long long totalDays= 0, modulo= 1e9 + 7;\n    vector<long long> daysSpent(roomCount, 0);\n\n    for(int i= 1; i < roomCount; ++i)\n    {\n        daysSpent[i]= (daysSpent[i - 1] + 1 + daysSpent[i - 1] - daysSpent[nextVisit[i - 1]] + modulo) % modulo;\n        totalDays= (totalDays + daysSpent[i]) % modulo;\n    }\n    return totalDays;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateFirstDayInAllRooms(std::vector<int> &nextVisit)\n{\n    int roomCount= nextVisit.size();\n    long long totalDays= 0, modulo= 1e9 + 7;\n    std::vector<long long> daysSpent(roomCount, 0);\n\n    for(int i= 1; i < roomCount; ++i)\n    {\n        daysSpent[i]= (daysSpent[i - 1] + 1 + daysSpent[i - 1] - daysSpent[nextVisit[i - 1]] + modulo) % modulo;\n        totalDays= (totalDays + daysSpent[i]) % modulo;\n    }\n    return totalDays;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canSortUsingSwap(vector<int> &numberList)\n{\n    for(size_t currentIndex= 1; currentIndex < numberList.size(); currentIndex++)\n    {\n        if(numberList[currentIndex] < numberList[currentIndex - 1])\n        {\n            swap(numberList[currentIndex], numberList[currentIndex - 1]);\n            if(is_sorted(numberList.begin(), numberList.end()))\n            {\n                return true;\n            }\n            swap(numberList[currentIndex], numberList[currentIndex - 1]);\n        }\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool canSortUsingSwap(std::vector<int> &numberList)\n{\n    for(size_t currentIndex= 1; currentIndex < numberList.size(); currentIndex++)\n    {\n        if(numberList[currentIndex] < numberList[currentIndex - 1])\n        {\n            std::swap(numberList[currentIndex], numberList[currentIndex - 1]);\n            if(std::is_sorted(numberList.begin(), numberList.end()))\n            {\n                return true;\n            }\n            std::swap(numberList[currentIndex], numberList[currentIndex - 1]);\n        }\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canDestroyAll(int currentMass, vector<int> &asteroids)\n{\n    sort(asteroids.begin(), asteroids.end());\n    for (int i = 0; i < asteroids.size(); ++i)\n    {\n        int asteroid = asteroids[i];\n        if (currentMass >= asteroid)\n        {\n            currentMass += asteroid;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool canDestroyAll(int currentMass, std::vector<int> &asteroids)\n{\n    std::sort(asteroids.begin(), asteroids.end());\n    for(int asteroid : asteroids)\n    {\n        if(currentMass >= asteroid)\n        {\n            currentMass += asteroid;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxInvited(vector<int> &favorite)\n{\n    vector<int> inDegree(favorite.size(), 0);\n    for (int i = 0; i < favorite.size(); ++i)\n    {\n        int favoriteIndex = favorite[i];\n        inDegree[favoriteIndex]++;\n    }\n    int totalInvited = 0;\n    for (int i = 0; i < inDegree.size(); ++i)\n    {\n        int degree = inDegree[i];\n        totalInvited += max(degree - 1, 0);\n    }\n    return min(totalInvited + 2, (int)favorite.size());\n}",
    "output": "#include <bits/stdc++.h>\nint maxInvited(std::vector<int> &favorite)\n{\n    std::vector<int> inDegree(favorite.size(), 0);\n    for(int favoriteIndex : favorite)\n    {\n        inDegree[favoriteIndex]++;\n    }\n    int totalInvited= 0;\n    for(int degree : inDegree)\n    {\n        totalInvited+= std::max(degree - 1, 0);\n    }\n    return std::min(totalInvited + 2, (int)favorite.size());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring reversePrefix(string inputWord, char targetChar)\n{\n    auto iterator = find(inputWord.begin(), inputWord.end(), targetChar);\n    if(iterator != inputWord.end())\n    {\n        reverse(inputWord.begin(), iterator + 1);\n    }\n    return inputWord;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string reversePrefix(std::string inputWord, char targetChar)\n{\n    auto iterator= std::find(inputWord.begin(), inputWord.end(), targetChar);\n    if(iterator != inputWord.end())\n    {\n        std::reverse(inputWord.begin(), iterator + 1);\n    }\n    return inputWord;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint interchangeableRectangles(vector<vector<int>> &rectangleDimensions)\n{\n    unordered_map<double, int> ratioCount;\n    int pairCount = 0;\n\n    for (int i = 0; i < rectangleDimensions.size(); ++i)\n    {\n        const auto &rectangle = rectangleDimensions[i];\n        double aspectRatio = static_cast<double>(rectangle[0]) / rectangle[1];\n        pairCount += ratioCount[aspectRatio];\n        ratioCount[aspectRatio]++;\n    }\n\n    return pairCount;\n}",
    "output": "#include <bits/stdc++.h>\nint interchangeableRectangles(std::vector<std::vector<int>> &rectangleDimensions)\n{\n    std::unordered_map<double, int> ratioCount;\n    int pairCount= 0;\n\n    for(const auto &rectangle : rectangleDimensions)\n    {\n        double aspectRatio= static_cast<double>(rectangle[0]) / rectangle[1];\n        pairCount+= ratioCount[aspectRatio];\n        ratioCount[aspectRatio]++;\n    }\n\n    return pairCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxProduct(string inputString)\n{\n    int stringLength= inputString.length();\n    vector<vector<int>> palindromeLengths(stringLength, vector<int>(stringLength, 0));\n\n    for(int index= 0; index < stringLength; index++)\n        palindromeLengths[index][index]= 1;\n\n    for(int length= 2; length <= stringLength; length++)\n    {\n        for(int startIndex= 0; startIndex <= stringLength - length; startIndex++)\n        {\n            int endIndex= startIndex + length - 1;\n\n            if(inputString[startIndex] == inputString[endIndex])\n                palindromeLengths[startIndex][endIndex]= palindromeLengths[startIndex + 1][endIndex - 1] + 2;\n            else\n                palindromeLengths[startIndex][endIndex]= max(palindromeLengths[startIndex + 1][endIndex], palindromeLengths[startIndex][endIndex - 1]);\n        }\n    }\n\n    int maximumProduct= 0;\n    for(int splitIndex= 1; splitIndex < stringLength; splitIndex++)\n    {\n        maximumProduct= max(maximumProduct, palindromeLengths[0][splitIndex - 1] * palindromeLengths[splitIndex][stringLength - 1]);\n    }\n\n    return maximumProduct;\n}",
    "output": "#include <bits/stdc++.h>\nint maxProduct(std::string inputString)\n{\n    int stringLength= inputString.length();\n    std::vector<std::vector<int>> palindromeLengths(stringLength, std::vector<int>(stringLength, 0));\n\n    for(int index= 0; index < stringLength; index++)\n        palindromeLengths[index][index]= 1;\n\n    for(int length= 2; length <= stringLength; length++)\n    {\n        for(int startIndex= 0; startIndex <= stringLength - length; startIndex++)\n        {\n            int endIndex= startIndex + length - 1;\n\n            if(inputString[startIndex] == inputString[endIndex])\n                palindromeLengths[startIndex][endIndex]= palindromeLengths[startIndex + 1][endIndex - 1] + 2;\n            else\n                palindromeLengths[startIndex][endIndex]= std::max(palindromeLengths[startIndex + 1][endIndex], palindromeLengths[startIndex][endIndex - 1]);\n        }\n    }\n\n    int maximumProduct= 0;\n    for(int splitIndex= 1; splitIndex < stringLength; splitIndex++)\n    {\n        maximumProduct= std::max(maximumProduct, palindromeLengths[0][splitIndex - 1] * palindromeLengths[splitIndex][stringLength - 1]);\n    }\n\n    return maximumProduct;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(int currentNode, const vector<int> &parentNodes, const vector<int> &values, vector<set<int>> &tree, vector<int> &missingValues)\n{\n    tree[currentNode].insert(values[currentNode]);\n    for(int i= 1; i < (int)parentNodes.size(); ++i)\n    {\n        if(parentNodes[i] == currentNode)\n        {\n            depthFirstSearch(i, parentNodes, values, tree, missingValues);\n            tree[currentNode].insert(tree[i].begin(), tree[i].end());\n        }\n    }\n    int missingValue= 1;\n    while(tree[currentNode].count(missingValue))\n        ++missingValue;\n    missingValues[currentNode]= missingValue;\n}\n\nvector<int> smallestMissingValueSubtree(vector<int> &parentNodes, vector<int> &values)\n{\n    int nodeCount= parentNodes.size();\n    vector<int> missingValues(nodeCount);\n    vector<set<int>> tree(nodeCount);\n\n    depthFirstSearch(0, parentNodes, values, tree, missingValues);\n    return missingValues;\n}",
    "output": "#include <bits/stdc++.h>\nvoid depthFirstSearch(int currentNode, const std::vector<int> &parentNodes, const std::vector<int> &values, std::vector<std::set<int>> &tree, std::vector<int> &missingValues)\n{\n    tree[currentNode].insert(values[currentNode]);\n    for(int i= 1; i < (int)parentNodes.size(); ++i)\n    {\n        if(parentNodes[i] == currentNode)\n        {\n            depthFirstSearch(i, parentNodes, values, tree, missingValues);\n            tree[currentNode].insert(tree[i].begin(), tree[i].end());\n        }\n    }\n    int missingValue= 1;\n    while(tree[currentNode].count(missingValue))\n        ++missingValue;\n    missingValues[currentNode]= missingValue;\n}\n\nstd::vector<int> smallestMissingValueSubtree(std::vector<int> &parentNodes, std::vector<int> &values)\n{\n    int nodeCount= parentNodes.size();\n    std::vector<int> missingValues(nodeCount);\n    std::vector<std::set<int>> tree(nodeCount);\n\n    depthFirstSearch(0, parentNodes, values, tree, missingValues);\n    return missingValues;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> construct2DArray(vector<int> &originalArray, int rowCount, int columnCount)\n{\n    if(rowCount * columnCount != originalArray.size())\n        return {};\n    vector<vector<int>> resultArray(rowCount, vector<int>(columnCount));\n    for(int index= 0; index < originalArray.size(); ++index)\n    {\n        resultArray[index / columnCount][index % columnCount]= originalArray[index];\n    }\n    return resultArray;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> construct2DArray(std::vector<int> &originalArray, int rowCount, int columnCount)\n{\n    if(rowCount * columnCount != originalArray.size())\n        return {};\n    std::vector<std::vector<int>> resultArray(rowCount, std::vector<int>(columnCount));\n    for(int index= 0; index < originalArray.size(); ++index)\n    {\n        resultArray[index / columnCount][index % columnCount]= originalArray[index];\n    }\n    return resultArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(const vector<string> &stringList, const string &targetString)\n{\n    int pairCount= 0;\n    for(size_t firstIndex= 0; firstIndex < stringList.size(); ++firstIndex)\n    {\n        for(size_t secondIndex= firstIndex + 1; secondIndex < stringList.size(); ++secondIndex)\n        {\n            if(stringList[firstIndex] + stringList[secondIndex] == targetString ||\n               stringList[secondIndex] + stringList[firstIndex] == targetString)\n            {\n                ++pairCount;\n            }\n        }\n    }\n    return pairCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countPairs(const std::vector<std::string> &stringList, const std::string &targetString)\n{\n    int pairCount= 0;\n    for(size_t firstIndex= 0; firstIndex < stringList.size(); ++firstIndex)\n    {\n        for(size_t secondIndex= firstIndex + 1; secondIndex < stringList.size(); ++secondIndex)\n        {\n            if(stringList[firstIndex] + stringList[secondIndex] == targetString ||\n               stringList[secondIndex] + stringList[firstIndex] == targetString)\n            {\n                ++pairCount;\n            }\n        }\n    }\n    return pairCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxConsecutiveAnswers(string answerKey, int maxFlips)\n{\n    int totalAnswers= answerKey.size();\n    int startIndex= 0, maxLength= 0, maxTrueCount= 0;\n    vector<int> count(2, 0);\n\n    for(int endIndex= 0; endIndex < totalAnswers; ++endIndex)\n    {\n        maxTrueCount= max(maxTrueCount, ++count[answerKey[endIndex] == 'T']);\n\n        if(endIndex - startIndex + 1 - maxTrueCount > maxFlips)\n        {\n            count[answerKey[startIndex] == 'T']--;\n            startIndex++;\n        }\n\n        maxLength= max(maxLength, endIndex - startIndex + 1);\n    }\n\n    return maxLength;\n}",
    "output": "#include <bits/stdc++.h>\nint maxConsecutiveAnswers(std::string answerKey, int maxFlips)\n{\n    int totalAnswers = answerKey.size();\n    int startIndex = 0, maxLength = 0, maxTrueCount = 0;\n    std::vector<int> count(2, 0);\n\n    for(int endIndex = 0; endIndex < totalAnswers; ++endIndex)\n    {\n        maxTrueCount = std::max(maxTrueCount, ++count[answerKey[endIndex] == 'T']);\n\n        if(endIndex - startIndex + 1 - maxTrueCount > maxFlips)\n        {\n            count[answerKey[startIndex] == 'T']--;\n            startIndex++;\n        }\n\n        maxLength = std::max(maxLength, endIndex - startIndex + 1);\n    }\n\n    return maxLength;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countOfWays(int numbers[], int arraySize, int threshold)\n{\n    int validCount= 0, lessThanCount= 0, lessThanOrEqualCount= 0;\n    for(int index= 0; index < arraySize; ++index)\n    {\n        if(numbers[index] < threshold)\n            ++lessThanCount;\n        if(numbers[index] <= threshold)\n            ++lessThanOrEqualCount;\n    }\n\n    if(lessThanCount == arraySize)\n        return 0;\n    if(lessThanOrEqualCount - lessThanCount != arraySize - lessThanOrEqualCount)\n        return lessThanCount + 1;\n    return lessThanCount;\n}",
    "output": "int countOfWays(int numbers[], int arraySize, int threshold)\n{\n    int validCount= 0, lessThanCount= 0, lessThanOrEqualCount= 0;\n    for(int index= 0; index < arraySize; ++index)\n    {\n        if(numbers[index] < threshold)\n            ++lessThanCount;\n        if(numbers[index] <= threshold)\n            ++lessThanOrEqualCount;\n    }\n\n    if(lessThanCount == arraySize)\n        return 0;\n    if(lessThanOrEqualCount - lessThanCount != arraySize - lessThanOrEqualCount)\n        return lessThanCount + 1;\n    return lessThanCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint earliestBlooms(vector<int> &plantTime, vector<int> &growTime)\n{\n    int numberOfPlants = plantTime.size();\n    vector<pair<int, int>> plantingSchedule;\n    for (int i = 0; i < numberOfPlants; ++i)\n    {\n        plantingSchedule.push_back({plantTime[i], growTime[i]});\n    }\n    sort(plantingSchedule.begin(), plantingSchedule.end());\n\n    int currentDay = 0;\n    int maxBlooms = 0;\n    for (int i = 0; i < plantingSchedule.size(); ++i)\n    {\n        auto &plant = plantingSchedule[i];\n        currentDay += plant.first;\n        maxBlooms = max(maxBlooms, currentDay + plant.second);\n    }\n    return maxBlooms;\n}",
    "output": "#include <bits/stdc++.h>\nint earliestBlooms(std::vector<int> &plantTime, std::vector<int> &growTime)\n{\n    int numberOfPlants= plantTime.size();\n    std::vector<std::pair<int, int>> plantingSchedule;\n    for(int i= 0; i < numberOfPlants; ++i)\n    {\n        plantingSchedule.push_back({plantTime[i], growTime[i]});\n    }\n    std::sort(plantingSchedule.begin(), plantingSchedule.end());\n\n    int currentDay= 0;\n    int maxBlooms= 0;\n    for(auto &plant : plantingSchedule)\n    {\n        currentDay+= plant.first;\n        maxBlooms= std::max(maxBlooms, currentDay + plant.second);\n    }\n    return maxBlooms;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint performOperations(vector<string> &operations)\n{\n    int currentValue = 0;\n    for (int i = 0; i < operations.size(); ++i)\n    {\n        string &operation = operations[i];\n        if (operation == \"++currentValue\" || operation == \"currentValue++\")\n        {\n            currentValue++;\n        }\n        else if (operation == \"--currentValue\" || operation == \"currentValue--\")\n        {\n            currentValue--;\n        }\n    }\n    return currentValue;\n}",
    "output": "#include <bits/stdc++.h>\nint performOperations(std::vector<std::string> &operations)\n{\n    int currentValue= 0;\n    for(auto &operation : operations)\n    {\n        if(operation == \"++currentValue\" || operation == \"currentValue++\")\n        {\n            currentValue++;\n        }\n        else if(operation == \"--currentValue\" || operation == \"currentValue--\")\n        {\n            currentValue--;\n        }\n    }\n    return currentValue;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint sumOfBeauties(vector<int> &numberList)\n{\n    int size = numberList.size();\n    int totalBeauty = 0;\n\n    vector<int> leftMax(size);\n    leftMax[0] = numberList[0];\n    vector<int> rightMin(size);\n    rightMin[size - 1] = numberList[size - 1];\n\n    for(int index = 1; index < size; index++)\n    {\n        leftMax[index] = max(leftMax[index - 1], numberList[index]);\n    }\n\n    for(int index = size - 2; index >= 0; index--)\n    {\n        rightMin[index] = min(rightMin[index + 1], numberList[index]);\n    }\n\n    for(int index = 1; index <= size - 2; index++)\n    {\n        if(numberList[index] > leftMax[index - 1] && numberList[index] < rightMin[index + 1])\n        {\n            totalBeauty += 1;\n        }\n    }\n\n    return totalBeauty;\n}",
    "output": "int sumOfBeauties(std::vector<int> &numberList)\n{\n    int size= numberList.size();\n    int totalBeauty= 0;\n\n    std::vector<int> leftMax(size);\n    leftMax[0]= numberList[0];\n    std::vector<int> rightMin(size);\n    rightMin[size - 1]= numberList[size - 1];\n\n    for(int index= 1; index < size; index++)\n    {\n        leftMax[index]= std::max(leftMax[index - 1], numberList[index]);\n    }\n\n    for(int index= size - 2; index >= 0; index--)\n    {\n        rightMin[index]= std::min(rightMin[index + 1], numberList[index]);\n    }\n\n    for(int index= 1; index <= size - 2; index++)\n    {\n        if(numberList[index] > leftMax[index - 1] && numberList[index] < rightMin[index + 1])\n        {\n            totalBeauty+= 1;\n        }\n    }\n\n    return totalBeauty;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass DetectSquares\n{\n  public:\n    unordered_map<int, unordered_map<int, int>> pointCountMap;\n\n    DetectSquares()\n    {\n    }\n\n    void add(vector<int> newPoint)\n    {\n        pointCountMap[newPoint[0]][newPoint[1]]++;\n    }\n\n    int count(vector<int> queryPoint)\n    {\n        int totalSquares = 0;\n        for (auto it = pointCountMap[queryPoint[0]].begin(); it != pointCountMap[queryPoint[0]].end(); ++it)\n        {\n            const auto &horizontalPoint = *it;\n            if (horizontalPoint.first == queryPoint[1])\n                continue;\n            for (auto jt = pointCountMap[horizontalPoint.first].begin(); jt != pointCountMap[horizontalPoint.first].end(); ++jt)\n            {\n                const auto &verticalPoint = *jt;\n                if (verticalPoint.first == queryPoint[1] || abs(horizontalPoint.first - queryPoint[1]) != abs(verticalPoint.first - queryPoint[0]))\n                    continue;\n                totalSquares += horizontalPoint.second * verticalPoint.second * pointCountMap[queryPoint[0]][verticalPoint.first];\n            }\n        }\n        return totalSquares;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass DetectSquares\n{\n  public:\n    std::unordered_map<int, std::unordered_map<int, int>> pointCountMap;\n\n    DetectSquares()\n    {\n    }\n\n    void add(std::vector<int> newPoint)\n    {\n        pointCountMap[newPoint[0]][newPoint[1]]++;\n    }\n\n    int count(std::vector<int> queryPoint)\n    {\n        int totalSquares = 0;\n        for(const auto &horizontalPoint : pointCountMap[queryPoint[0]])\n        {\n            if(horizontalPoint.first == queryPoint[1])\n                continue;\n            for(const auto &verticalPoint : pointCountMap[horizontalPoint.first])\n            {\n                if(verticalPoint.first == queryPoint[1] || abs(horizontalPoint.first - queryPoint[1]) != abs(verticalPoint.first - queryPoint[0]))\n                    continue;\n                totalSquares += horizontalPoint.second * verticalPoint.second * pointCountMap[queryPoint[0]][verticalPoint.first];\n            }\n        }\n        return totalSquares;\n    }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring longestSubsequenceRepeatedK(const string &inputString, int repetitionCount)\n{\n    int characterCounts[26] = {0};\n    for (int i = 0; i < inputString.size(); ++i) {\n        char currentChar = inputString[i];\n        characterCounts[currentChar - 'a'] += 1;\n    }\n    string resultSequence;\n    for (int index = 25; index >= 0; --index)\n        resultSequence += string(characterCounts[index] / repetitionCount, 'a' + index);\n    return resultSequence;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string longestSubsequenceRepeatedK(const std::string &inputString, int repetitionCount)\n{\n    int characterCounts[26]= {0};\n    for(char currentChar : inputString)\n        characterCounts[currentChar - 'a']+= 1;\n    std::string resultSequence;\n    for(int index= 25; index >= 0; --index)\n        resultSequence+= std::string(characterCounts[index] / repetitionCount, 'a' + index);\n    return resultSequence;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxComputerRuntime(int totalComputers, vector<int> &batteryCapacities)\n{\n    sort(batteryCapacities.begin(), batteryCapacities.end());\n    int maxRuntime= 0;\n    for(int index= 0; index < batteryCapacities.size(); ++index)\n    {\n        maxRuntime= max(maxRuntime, min(totalComputers, int(batteryCapacities.size()) - index) * batteryCapacities[index]);\n    }\n    return maxRuntime;\n}",
    "output": "#include <bits/stdc++.h>\nint maxComputerRuntime(int totalComputers, std::vector<int> &batteryCapacities)\n{\n    std::sort(batteryCapacities.begin(), batteryCapacities.end());\n    int maxRuntime= 0;\n    for(int index= 0; index < batteryCapacities.size(); ++index)\n    {\n        maxRuntime= std::max(maxRuntime, std::min(totalComputers, int(batteryCapacities.size()) - index) * batteryCapacities[index]);\n    }\n    return maxRuntime;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countOfBalancedRanges(vector<int> &firstArray, vector<int> &secondArray)\n{\n    int modulus= 1e9 + 7, transitionCount[101][101][101][3]= {}; // <l1, r1, k1, last> = Number of Ways\n    transitionCount[0][0][0][0]= 2;\n    int prefixSum1[101]= {}, prefixSum2[101]= {};\n    for(int index= 0, sum1= 0, sum2= 0; index < firstArray.size(); ++index)\n    {\n        sum1+= firstArray[index], sum2+= secondArray[index];\n        prefixSum1[index + 1]= sum1, prefixSum2[index + 1]= sum2;\n    }\n    auto isValid= [&](int left, int right, int mid)\n    {\n        int leftOver1= prefixSum1[firstArray.size()] - prefixSum1[mid + 1];\n        return prefixSum1[left] + prefixSum2[right] - prefixSum2[left] == prefixSum2[mid] &&\n               prefixSum2[left] + prefixSum1[firstArray.size()] - prefixSum1[right + 1] == leftOver1;\n    };\n    int result= 0;\n    for(int right= 0; right < firstArray.size(); ++right)\n    {\n        for(int left= right + 1; --left >= 0;)\n        {\n            for(int mid= left; mid <= right; ++mid)\n            {\n                if(isValid(left, right, mid))\n                {\n                    for(int previous= 0; previous <= 2; ++previous)\n                    {\n                        result+= transitionCount[left][right][mid][previous], result%= modulus;\n                        int nextIndex= previous == 2 ? mid + 1 : mid;\n                        transitionCount[nextIndex][mid ? mid : right + 1][mid ? mid - 1 : right + 2][previous]+=\n                            transitionCount[left][right][mid][previous];\n                        transitionCount[left][right][mid][previous]=\n                            (transitionCount[left][right][mid][previous] + (!previous || previous == 2)) % modulus;\n                    }\n                }\n            }\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nint countOfBalancedRanges(std::vector<int> &firstArray, std::vector<int> &secondArray)\n{\n    int modulus= 1e9 + 7, transitionCount[101][101][101][3]= {}; // <l1, r1, k1, last> = Number of Ways\n    transitionCount[0][0][0][0]= 2;\n    int prefixSum1[101]= {}, prefixSum2[101]= {};\n    for(int index= 0, sum1= 0, sum2= 0; index < firstArray.size(); ++index)\n    {\n        sum1+= firstArray[index], sum2+= secondArray[index];\n        prefixSum1[index + 1]= sum1, prefixSum2[index + 1]= sum2;\n    }\n    auto isValid= [&](int left, int right, int mid)\n    {\n        int leftOver1= prefixSum1[firstArray.size()] - prefixSum1[mid + 1];\n        return prefixSum1[left] + prefixSum2[right] - prefixSum2[left] == prefixSum2[mid] &&\n               prefixSum2[left] + prefixSum1[firstArray.size()] - prefixSum1[right + 1] == leftOver1;\n    };\n    int result= 0;\n    for(int right= 0; right < firstArray.size(); ++right)\n    {\n        for(int left= right + 1; --left >= 0;)\n        {\n            for(int mid= left; mid <= right; ++mid)\n            {\n                if(isValid(left, right, mid))\n                {\n                    for(int previous= 0; previous <= 2; ++previous)\n                    {\n                        result+= transitionCount[left][right][mid][previous], result%= modulus;\n                        int nextIndex= previous == 2 ? mid + 1 : mid;\n                        transitionCount[nextIndex][mid ? mid : right + 1][mid ? mid - 1 : right + 2][previous]+=\n                            transitionCount[left][right][mid][previous];\n                        transitionCount[left][right][mid][previous]=\n                            (transitionCount[left][right][mid][previous] + (!previous || previous == 2)) % modulus;\n                    }\n                }\n            }\n        }\n    }\n    return result;\n}\n"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxDifference(vector<int> &numArray)\n{\n    int minValue= numArray[0];\n    int maxDifference= -1;\n\n    for(int index= 1; index < numArray.size(); ++index)\n    {\n        if(numArray[index] > minValue)\n        {\n            maxDifference= max(maxDifference, numArray[index] - minValue);\n        }\n        else\n        {\n            minValue= numArray[index];\n        }\n    }\n    return maxDifference;\n}",
    "output": "#include <bits/stdc++.h>\nint maxDifference(std::vector<int> &numArray)\n{\n    int minValue= numArray[0];\n    int maxDifference= -1;\n\n    for(int index= 1; index < numArray.size(); ++index)\n    {\n        if(numArray[index] > minValue)\n        {\n            maxDifference= std::max(maxDifference, numArray[index] - minValue);\n        }\n        else\n        {\n            minValue= numArray[index];\n        }\n    }\n    return maxDifference;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minSecondRobotPoints(vector<vector<int>> &grid)\n{\n    int columnCount= grid[0].size();\n    for(int row= 0; row < 2; ++row)\n    {\n        for(int column= 1; column < columnCount; ++column)\n        {\n            grid[row][column]+= grid[row][column - 1];\n        }\n    }\n    int dynamicProgramming[2]= {grid[0][columnCount - 1], 0};\n    for(int column= columnCount - 2; column >= 0; --column)\n    {\n        int newDynamicProgramming[2]= {\n            max(dynamicProgramming[0] - grid[0][column], dynamicProgramming[1] + grid[1][column]),\n            max(dynamicProgramming[1] - grid[1][column], dynamicProgramming[0] + grid[0][column])};\n        dynamicProgramming[0]= newDynamicProgramming[0];\n        dynamicProgramming[1]= newDynamicProgramming[1];\n    }\n    return max(dynamicProgramming[0], dynamicProgramming[1]);\n}",
    "output": "#include <bits/stdc++.h>\nint minSecondRobotPoints(std::vector<std::vector<int>> &grid)\n{\n    int columnCount= grid[0].size();\n    for(int row= 0; row < 2; ++row)\n    {\n        for(int column= 1; column < columnCount; ++column)\n        {\n            grid[row][column]+= grid[row][column - 1];\n        }\n    }\n    int dynamicProgramming[2]= {grid[0][columnCount - 1], 0};\n    for(int column= columnCount - 2; column >= 0; --column)\n    {\n        int newDynamicProgramming[2]= {\n            std::max(dynamicProgramming[0] - grid[0][column], dynamicProgramming[1] + grid[1][column]),\n            std::max(dynamicProgramming[1] - grid[1][column], dynamicProgramming[0] + grid[0][column])};\n        dynamicProgramming[0]= newDynamicProgramming[0];\n        dynamicProgramming[1]= newDynamicProgramming[1];\n    }\n    return std::max(dynamicProgramming[0], dynamicProgramming[1]);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool checkWord(vector<vector<char>> &board, string word, int rowIndex, int colIndex, int deltaRow, int deltaCol);\n\nbool canPlaceWord(vector<vector<char>> &board, string word)\n{\n    int rows= board.size(), columns= board[0].size();\n    for(int rowIndex= 0; rowIndex < rows; ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex < columns; ++colIndex)\n        {\n            if(board[rowIndex][colIndex] == word[0])\n            {\n                if(checkWord(board, word, rowIndex, colIndex, 0, 1) || checkWord(board, word, rowIndex, colIndex, 1, 0))\n                    return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool checkWord(vector<vector<char>> &board, string word, int rowIndex, int colIndex, int deltaRow, int deltaCol)\n{\n    int rows= board.size(), columns= board[0].size();\n    for(int charIndex= 0; charIndex < word.size(); ++charIndex, rowIndex+= deltaRow, colIndex+= deltaCol)\n    {\n        if(rowIndex < 0 || rowIndex >= rows || colIndex < 0 || colIndex >= columns)\n            return false;\n        if(charIndex == 0 || charIndex == word.size() - 1)\n            if(board[rowIndex][colIndex] != word[charIndex] && board[rowIndex][colIndex] != ' ')\n                return false;\n        if(charIndex > 0 && charIndex < word.size() - 1)\n            if(board[rowIndex][colIndex] != word[charIndex] && board[rowIndex][colIndex] != ' ' && board[rowIndex][colIndex] != '#')\n                return false;\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool canPlaceWord(std::vector<std::vector<char>> &board, std::string word)\n{\n    int rows= board.size(), columns= board[0].size();\n    for(int rowIndex= 0; rowIndex < rows; ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex < columns; ++colIndex)\n        {\n            if(board[rowIndex][colIndex] == word[0])\n            {\n                if(checkWord(board, word, rowIndex, colIndex, 0, 1) || checkWord(board, word, rowIndex, colIndex, 1, 0))\n                    return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool checkWord(std::vector<std::vector<char>> &board, std::string word, int rowIndex, int colIndex, int deltaRow, int deltaCol)\n{\n    int rows= board.size(), columns= board[0].size();\n    for(int charIndex= 0; charIndex < word.size(); ++charIndex, rowIndex+= deltaRow, colIndex+= deltaCol)\n    {\n        if(rowIndex < 0 || rowIndex >= rows || colIndex < 0 || colIndex >= columns)\n            return false;\n        if(charIndex == 0 || charIndex == word.size() - 1)\n            if(board[rowIndex][colIndex] != word[charIndex] && board[rowIndex][colIndex] != ' ')\n                return false;\n        if(charIndex > 0 && charIndex < word.size() - 1)\n            if(board[rowIndex][colIndex] != word[charIndex] && board[rowIndex][colIndex] != ' ' && board[rowIndex][colIndex] != '#')\n                return false;\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint sumOfPoints(const string &expression, const vector<int> &userAnswers)\n{\n    int totalPoints = 0;\n    int calculatedResult = 0, currentTerm = 1;\n    char currentSign = '+';\n\n    for (size_t index = 0; index < expression.size(); index++)\n    {\n        if (isdigit(expression[index]))\n        {\n            int currentNumber = expression[index] - '0';\n            if (currentSign == '+')\n            {\n                calculatedResult += currentTerm;\n                currentTerm = currentNumber;\n            }\n            else if (currentSign == '*')\n            {\n                currentTerm *= currentNumber;\n            }\n        }\n        else\n        {\n            currentSign = expression[index];\n        }\n    }\n    calculatedResult += currentTerm;\n\n    for (int i = 0; i < userAnswers.size(); ++i)\n    {\n        int userAnswer = userAnswers[i];\n        totalPoints += (userAnswer == calculatedResult);\n    }\n\n    return totalPoints;\n}",
    "output": "#include <bits/stdc++.h>\nint sumOfPoints(const std::string &expression, const std::vector<int> &userAnswers)\n{\n    int totalPoints= 0;\n    int calculatedResult= 0, currentTerm= 1;\n    char currentSign= '+';\n\n    for(size_t index= 0; index < expression.size(); index++)\n    {\n        if(isdigit(expression[index]))\n        {\n            int currentNumber= expression[index] - '0';\n            if(currentSign == '+')\n            {\n                calculatedResult+= currentTerm;\n                currentTerm= currentNumber;\n            }\n            else if(currentSign == '*')\n            {\n                currentTerm*= currentNumber;\n            }\n        }\n        else\n        {\n            currentSign= expression[index];\n        }\n    }\n    calculatedResult+= currentTerm;\n\n    for(int userAnswer : userAnswers)\n    {\n        totalPoints+= (userAnswer == calculatedResult);\n    }\n\n    return totalPoints;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minMoves(vector<int> &seatPositions, vector<int> &studentPositions)\n{\n    sort(seatPositions.begin(), seatPositions.end());\n    sort(studentPositions.begin(), studentPositions.end());\n\n    int totalMoves = 0;\n    for(int index = 0; index < seatPositions.size(); index++)\n    {\n        totalMoves += abs(seatPositions[index] - studentPositions[index]);\n    }\n    return totalMoves;\n}",
    "output": "#include <bits/stdc++.h>\nint minMoves(std::vector<int> &seatPositions, std::vector<int> &studentPositions)\n{\n    std::sort(seatPositions.begin(), seatPositions.end());\n    std::sort(studentPositions.begin(), studentPositions.end());\n\n    int totalMoves= 0;\n    for(int index= 0; index < seatPositions.size(); index++)\n    {\n        totalMoves+= std::abs(seatPositions[index] - studentPositions[index]);\n    }\n    return totalMoves;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool solvePuzzle(const string &colorString)\n{\n    return count(colorString.begin(), colorString.end(), 'A') % 2 == 1;\n}",
    "output": "bool solvePuzzle(const std::string &colorString)\n{\n    return std::count(colorString.begin(), colorString.end(), 'A') % 2 == 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findLonelyNumbers(vector<int> &numberList)\n{\n    unordered_map<int, int> numberCount;\n    vector<int> lonelyNumberList;\n\n    for(int i = 0; i < numberList.size(); ++i)\n    {\n        int currentNumber = numberList[i];\n        numberCount[currentNumber]++;\n    }\n\n    for(auto it = numberCount.begin(); it != numberCount.end(); ++it)\n    {\n        const auto &numberEntry = *it;\n        if(numberEntry.second == 1 && numberCount.find(numberEntry.first - 1) == numberCount.end() && numberCount.find(numberEntry.first + 1) == numberCount.end())\n        {\n            lonelyNumberList.push_back(numberEntry.first);\n        }\n    }\n\n    return lonelyNumberList;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findLonelyNumbers(std::vector<int> &numberList)\n{\n    std::unordered_map<int, int> numberCount;\n    std::vector<int> lonelyNumberList;\n\n    for(int currentNumber : numberList)\n    {\n        numberCount[currentNumber]++;\n    }\n\n    for(const auto &numberEntry : numberCount)\n    {\n        if(numberEntry.second == 1 && numberCount.find(numberEntry.first - 1) == numberCount.end() && numberCount.find(numberEntry.first + 1) == numberCount.end())\n        {\n            lonelyNumberList.push_back(numberEntry.first);\n        }\n    }\n\n    return lonelyNumberList;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint networkBecomesIdle(vector<vector<int>> &edgeList, vector<int> &patience)\n{\n    int numberOfNodes = patience.size();\n    vector<vector<int>> adjacencyList(numberOfNodes);\n\n    for (auto &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> distance(numberOfNodes, -1);\n    distance[0] = 0;\n    queue<int> nodeQueue;\n    nodeQueue.push(0);\n\n    while (!nodeQueue.empty())\n    {\n        int currentNode = nodeQueue.front();\n        nodeQueue.pop();\n\n        for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n        {\n            int neighbor = adjacencyList[currentNode][i];\n            if (distance[neighbor] == -1)\n            {\n                distance[neighbor] = distance[currentNode] + 1;\n                nodeQueue.push(neighbor);\n            }\n        }\n    }\n\n    int maximumTime = 0;\n    for (int i = 1; i < numberOfNodes; i++)\n    {\n        int time = ((2 * distance[i] - 1) / patience[i]) * patience[i] + 2 * distance[i];\n        maximumTime = max(maximumTime, time);\n    }\n\n    return maximumTime + 1;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> networkBecomesIdle(std::vector<std::vector<int>> &edgeList, std::vector<int> &patience)\n{\n    int numberOfNodes = patience.size();\n    std::vector<std::vector<int>> adjacencyList(numberOfNodes);\n\n    for(auto &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> distance(numberOfNodes, -1);\n    distance[0] = 0;\n    std::queue<int> nodeQueue;\n    nodeQueue.push(0);\n\n    while(!nodeQueue.empty())\n    {\n        int currentNode = nodeQueue.front();\n        nodeQueue.pop();\n\n        for(int neighbor : adjacencyList[currentNode])\n        {\n            if(distance[neighbor] == -1)\n            {\n                distance[neighbor] = distance[currentNode] + 1;\n                nodeQueue.push(neighbor);\n            }\n        }\n    }\n\n    int maximumTime = 0;\n    for(int i = 1; i < numberOfNodes; i++)\n    {\n        int time = ((2 * distance[i] - 1) / patience[i]) * patience[i] + 2 * distance[i];\n        maximumTime = std::max(maximumTime, time);\n    }\n\n    return maximumTime + 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// For std::gcd\nusing namespace std;\n\nint minStraightLines(vector<vector<int>> &points)\n{\n    int pointsCount= points.size();\n    unordered_set<int> uniqueSlopes;\n    for(int pointIndex1= 0; pointIndex1 < pointsCount; pointIndex1++)\n    {\n        for(int pointIndex2= pointIndex1 + 1; pointIndex2 < pointsCount; pointIndex2++)\n        {\n            if(pointIndex1 != pointIndex2)\n            {\n                int deltaX= points[pointIndex2][0] - points[pointIndex1][0];\n                int deltaY= points[pointIndex2][1] - points[pointIndex1][1];\n                int gcd= __gcd(deltaX, deltaY);\n                deltaX /= gcd;\n                deltaY /= gcd;\n                uniqueSlopes.insert(deltaY * 1000 + deltaX);\n            }\n        }\n    }\n    return uniqueSlopes.size();\n}",
    "output": "#include <bits/stdc++.h>\n// For std::gcd\n\nint minStraightLines(std::vector<std::vector<int>> &points)\n{\n    int pointsCount = points.size();\n    std::unordered_set<int> uniqueSlopes;\n    for (int pointIndex1 = 0; pointIndex1 < pointsCount; pointIndex1++)\n    {\n        for (int pointIndex2 = pointIndex1 + 1; pointIndex2 < pointsCount; pointIndex2++)\n        {\n            if (pointIndex1 != pointIndex2)\n            {\n                int deltaX = points[pointIndex2][0] - points[pointIndex1][0];\n                int deltaY = points[pointIndex2][1] - points[pointIndex1][1];\n                int gcd = std::gcd(deltaX, deltaY);\n                deltaX /= gcd;\n                deltaY /= gcd;\n                uniqueSlopes.insert(deltaY * 1000 + deltaX);\n            }\n        }\n    }\n    return uniqueSlopes.size();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minMovesToConvert(const string &inputString)\n{\n    int conversionCount= 0;\n    for(size_t currentIndex= 0; currentIndex < inputString.length() - 2; currentIndex++)\n    {\n        if(inputString[currentIndex] == 'X' && inputString[currentIndex + 1] == 'X' && inputString[currentIndex + 2] == 'X')\n        {\n            conversionCount++;\n            currentIndex+= 2; // move by 3\n        }\n    }\n    return conversionCount;\n}",
    "output": "int minMovesToConvert(const std::string &inputString)\n{\n    int conversionCount= 0;\n    for(size_t currentIndex= 0; currentIndex < inputString.length() - 2; currentIndex++)\n    {\n        if(inputString[currentIndex] == 'X' && inputString[currentIndex + 1] == 'X' && inputString[currentIndex + 2] == 'X')\n        {\n            conversionCount++;\n            currentIndex+= 2; // move by 3\n        }\n    }\n    return conversionCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> calculateMissingRolls(vector<int> &existingRolls, int desiredMean, int numberOfMissingRolls)\n{\n    int currentRollsCount = existingRolls.size();\n    int totalSum = desiredMean * (numberOfMissingRolls + currentRollsCount);\n    for (int roll : existingRolls)\n    {\n        totalSum -= roll;\n    }\n\n    if (totalSum < numberOfMissingRolls || totalSum > 6 * numberOfMissingRolls)\n    {\n        return {};\n    }\n\n    vector<int> missingRolls(numberOfMissingRolls, 1);\n    totalSum -= numberOfMissingRolls;\n    for (int index = 0; index < numberOfMissingRolls; index++)\n    {\n        int add = min(5, totalSum);\n        missingRolls[index] += add;\n        totalSum -= add;\n    }\n\n    return missingRolls;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> calculateMissingRolls(std::vector<int> &existingRolls, int desiredMean, int numberOfMissingRolls)\n{\n    int currentRollsCount= existingRolls.size();\n    int totalSum= desiredMean * (numberOfMissingRolls + currentRollsCount);\n    for(int roll : existingRolls)\n    {\n        totalSum-= roll;\n    }\n\n    if(totalSum < numberOfMissingRolls || totalSum > 6 * numberOfMissingRolls)\n    {\n        return {};\n    }\n\n    std::vector<int> missingRolls(numberOfMissingRolls, 1);\n    totalSum-= numberOfMissingRolls;\n    for(int index= 0; index < numberOfMissingRolls; index++)\n    {\n        int add= std::min(5, totalSum);\n        missingRolls[index]+= add;\n        totalSum-= add;\n    }\n\n    return missingRolls;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool aliceWins(vector<int> &stones)\n{\n    int totalSum = 0, remainderCount[3] = {0};\n    for (int i = 0; i < stones.size(); ++i)\n    {\n        int stone = stones[i];\n        totalSum += stone;\n        remainderCount[stone % 3]++;\n    }\n    if (totalSum % 3)\n    {\n        return remainderCount[totalSum % 3] % 2 == 1;\n    }\n    return remainderCount[1] % 2 == 0 || remainderCount[2] % 2 == 0 || remainderCount[1] == 0 || remainderCount[2] == 0;\n}",
    "output": "bool aliceWins(std::vector<int> &stones)\n{\n    int totalSum= 0, remainderCount[3]= {0};\n    for(int stone : stones)\n    {\n        totalSum+= stone;\n        remainderCount[stone % 3]++;\n    }\n    if(totalSum % 3)\n    {\n        return remainderCount[totalSum % 3] % 2 == 1;\n    }\n    return remainderCount[1] % 2 == 0 || remainderCount[2] % 2 == 0 || remainderCount[1] == 0 || remainderCount[2] == 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring smallestSubsequence(string inputString, int desiredLength, char targetLetter, int maxRepetitions)\n{\n    string result;\n    int targetLetterCount = 0, inputLength = inputString.length();\n    for (char currentChar : inputString)\n        if (currentChar == targetLetter)\n            targetLetterCount++;\n\n    priority_queue<char, vector<char>, greater<char>> charQueue;\n    for (int index = 0; index < inputLength; index++)\n    {\n        if (inputString[index] <= targetLetter || targetLetterCount > maxRepetitions)\n        {\n            while (!charQueue.empty() && charQueue.top() > inputString[index])\n            {\n                if (charQueue.top() == targetLetter)\n                    targetLetterCount--;\n                charQueue.pop();\n            }\n            charQueue.push(inputString[index]);\n            if (charQueue.size() > desiredLength)\n                charQueue.pop();\n        }\n        if (desiredLength - charQueue.size() == maxRepetitions)\n            targetLetterCount--;\n        maxRepetitions = max(0, maxRepetitions);\n    }\n\n    while (!charQueue.empty())\n    {\n        result.push_back(charQueue.top());\n        charQueue.pop();\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string smallestSubsequence(std::string inputString, int desiredLength, char targetLetter, int maxRepetitions)\n{\n    std::string result;\n    int targetLetterCount= 0, inputLength= inputString.length();\n    for(char currentChar : inputString)\n        if(currentChar == targetLetter)\n            targetLetterCount++;\n\n    std::priority_queue<char, std::vector<char>, std::greater<char>> charQueue;\n    for(int index= 0; index < inputLength; index++)\n    {\n        if(inputString[index] <= targetLetter || targetLetterCount > maxRepetitions)\n        {\n            while(!charQueue.empty() && charQueue.top() > inputString[index])\n            {\n                if(charQueue.top() == targetLetter)\n                    targetLetterCount--;\n                charQueue.pop();\n            }\n            charQueue.push(inputString[index]);\n            if(charQueue.size() > desiredLength)\n                charQueue.pop();\n        }\n        if(desiredLength - charQueue.size() == maxRepetitions)\n            targetLetterCount--;\n        maxRepetitions= std::max(0, maxRepetitions);\n    }\n\n    while(!charQueue.empty())\n    {\n        result.push_back(charQueue.top());\n        charQueue.pop();\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> paintingPlan(const vector<vector<int>> &paintIntervals)\n{\n    vector<int> workLog(paintIntervals.size(), 0);\n    set<int> paintedSections;\n\n    for(size_t intervalIndex= 0; intervalIndex < paintIntervals.size(); ++intervalIndex)\n    {\n        int startPoint= paintIntervals[intervalIndex][0];\n        int endPoint= paintIntervals[intervalIndex][1];\n\n        for(int section= startPoint; section < endPoint; ++section)\n        {\n            if(paintedSections.count(section) == 0)\n            {\n                paintedSections.insert(section);\n                workLog[intervalIndex]++;\n            }\n        }\n    }\n\n    return workLog;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> paintingPlan(const std::vector<std::vector<int>> &paintIntervals)\n{\n    std::vector<int> workLog(paintIntervals.size(), 0);\n    std::set<int> paintedSections;\n\n    for(std::size_t intervalIndex= 0; intervalIndex < paintIntervals.size(); ++intervalIndex)\n    {\n        int startPoint= paintIntervals[intervalIndex][0];\n        int endPoint= paintIntervals[intervalIndex][1];\n\n        for(int section= startPoint; section < endPoint; ++section)\n        {\n            if(paintedSections.count(section) == 0)\n            {\n                paintedSections.insert(section);\n                workLog[intervalIndex]++;\n            }\n        }\n    }\n\n    return workLog;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<vector<int>> &grid, int x)\n{\n    int minElement = INT_MAX;\n    for (int i = 0; i < grid.size(); ++i)\n    {\n        for (int j = 0; j < grid[i].size(); ++j)\n        {\n            minElement = min(minElement, grid[i][j]);\n        }\n    }\n\n    int minOperationsCount = INT_MAX;\n    for (int base = minElement;; --base)\n    {\n        int operationsCount = 0;\n        bool isImpossible = false;\n        for (int i = 0; i < grid.size(); ++i)\n        {\n            if (isImpossible)\n                break;\n            for (int j = 0; j < grid[i].size(); ++j)\n            {\n                int cell = grid[i][j];\n                int difference = abs(cell - base);\n                if (difference % x != 0)\n                {\n                    isImpossible = true;\n                    break;\n                }\n                operationsCount += difference / x;\n            }\n        }\n        if (isImpossible)\n            break;\n        minOperationsCount = min(minOperationsCount, operationsCount);\n    }\n\n    return minOperationsCount == INT_MAX ? -1 : minOperationsCount;\n}",
    "output": "#include <bits/stdc++.h>\nint minOperations(std::vector<std::vector<int>> &grid, int x)\n{\n    int minElement= INT_MAX;\n    for(const auto &row : grid)\n    {\n        for(int cell : row)\n        {\n            minElement= std::min(minElement, cell);\n        }\n    }\n\n    int minOperationsCount= INT_MAX;\n    for(int base= minElement;; --base)\n    {\n        int operationsCount= 0;\n        bool isImpossible= false;\n        for(const auto &row : grid)\n        {\n            if(isImpossible)\n                break;\n            for(int cell : row)\n            {\n                int difference= std::abs(cell - base);\n                if(difference % x != 0)\n                {\n                    isImpossible= true;\n                    break;\n                }\n                operationsCount+= difference / x;\n            }\n        }\n        if(isImpossible)\n            break;\n        minOperationsCount= std::min(minOperationsCount, operationsCount);\n    }\n\n    return minOperationsCount == INT_MAX ? -1 : minOperationsCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minPartitionDifference(vector<int> &numbers)\n{\n    int halfSize= numbers.size() / 2;\n    sort(numbers.rbegin(), numbers.rend());\n    return accumulate(numbers.begin(), numbers.begin() + halfSize, 0) - accumulate(numbers.begin() + halfSize, numbers.end(), 0);\n}",
    "output": "#include <bits/stdc++.h>\nint minPartitionDifference(std::vector<int> &numbers)\n{\n    int halfSize= numbers.size() / 2;\n    sort(numbers.rbegin(), numbers.rend());\n    return std::accumulate(numbers.begin(), numbers.begin() + halfSize, 0) - std::accumulate(numbers.begin() + halfSize, numbers.end(), 0);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring kthDistinctString(vector<string> &stringArray, int k)\n{\n    unordered_map<string, int> stringFrequency;\n    for (int i = 0; i < stringArray.size(); ++i)\n    {\n        stringFrequency[stringArray[i]]++;\n    }\n\n    int distinctCount = 0;\n    for (int i = 0; i < stringArray.size(); ++i)\n    {\n        const string &currentString = stringArray[i];\n        if (stringFrequency[currentString] == 1)\n        {\n            distinctCount++;\n            if (distinctCount == k)\n            {\n                return currentString;\n            }\n        }\n    }\n\n    return \"\";\n}",
    "output": "#include <bits/stdc++.h>\nstd::string kthDistinctString(std::vector<std::string> &stringArray, int k)\n{\n    std::unordered_map<std::string, int> stringFrequency;\n    for(const std::string &currentString : stringArray)\n    {\n        stringFrequency[currentString]++;\n    }\n\n    int distinctCount= 0;\n    for(const std::string &currentString : stringArray)\n    {\n        if(stringFrequency[currentString] == 1)\n        {\n            distinctCount++;\n            if(distinctCount == k)\n            {\n                return currentString;\n            }\n        }\n    }\n\n    return \"\";\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxValue(vector<vector<int>> &eventDetails)\n{\n    sort(eventDetails.begin(), eventDetails.end(), [](const vector<int> &firstEvent, const vector<int> &secondEvent)\n         { return firstEvent[1] < secondEvent[1]; });\n\n    vector<int> dynamicProgramming(eventDetails.size());\n    dynamicProgramming[0]= eventDetails[0][2];\n\n    for(int currentEventIndex= 1; currentEventIndex < eventDetails.size(); currentEventIndex++)\n    {\n        int lastNonConflictingEventIndex= -1;\n        for(int previousEventIndex= currentEventIndex - 1; previousEventIndex >= 0; previousEventIndex--)\n        {\n            if(eventDetails[previousEventIndex][1] < eventDetails[currentEventIndex][0])\n            {\n                lastNonConflictingEventIndex= previousEventIndex;\n                break;\n            }\n        }\n\n        int includedValue= eventDetails[currentEventIndex][2];\n        if(lastNonConflictingEventIndex != -1)\n        {\n            includedValue+= dynamicProgramming[lastNonConflictingEventIndex];\n        }\n\n        dynamicProgramming[currentEventIndex]= max(includedValue, dynamicProgramming[currentEventIndex - 1]);\n    }\n\n    return dynamicProgramming.back();\n}",
    "output": "#include <bits/stdc++.h>\nint maxValue(std::vector<std::vector<int>> &eventDetails)\n{\n    std::sort(eventDetails.begin(), eventDetails.end(), [](const std::vector<int> &firstEvent, const std::vector<int> &secondEvent)\n         { return firstEvent[1] < secondEvent[1]; });\n\n    std::vector<int> dynamicProgramming(eventDetails.size());\n    dynamicProgramming[0] = eventDetails[0][2];\n\n    for(int currentEventIndex = 1; currentEventIndex < eventDetails.size(); currentEventIndex++)\n    {\n        int lastNonConflictingEventIndex = -1;\n        for(int previousEventIndex = currentEventIndex - 1; previousEventIndex >= 0; previousEventIndex--)\n        {\n            if(eventDetails[previousEventIndex][1] < eventDetails[currentEventIndex][0])\n            {\n                lastNonConflictingEventIndex = previousEventIndex;\n                break;\n            }\n        }\n\n        int includedValue = eventDetails[currentEventIndex][2];\n        if(lastNonConflictingEventIndex != -1)\n        {\n            includedValue += dynamicProgramming[lastNonConflictingEventIndex];\n        }\n\n        dynamicProgramming[currentEventIndex] = std::max(includedValue, dynamicProgramming[currentEventIndex - 1]);\n    }\n\n    return dynamicProgramming.back();\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> platesBetweenCandles(const string &candleString, const vector<vector<int>> &queries)\n{\n    int stringLength = candleString.length();\n    vector<int> prefixSum(stringLength, 0);\n    int plateCount = 0;\n\n    for (int i = 1; i < stringLength; ++i)\n    {\n        prefixSum[i] = prefixSum[i - 1];\n        if (candleString[i] == '*' && candleString[i - 1] == '|')\n            plateCount++;\n        prefixSum[i] += plateCount;\n    }\n    vector<int> result;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        const auto &query = queries[i];\n        int leftIndex = query[0], rightIndex = query[1];\n        result.push_back(prefixSum[rightIndex] - (leftIndex > 0 ? prefixSum[leftIndex - 1] : 0));\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> platesBetweenCandles(const std::string &candleString, const std::vector<std::vector<int>> &queries)\n{\n    int stringLength= candleString.length();\n    std::vector<int> prefixSum(stringLength, 0);\n    int plateCount= 0;\n\n    for(int i= 1; i < stringLength; ++i)\n    {\n        prefixSum[i]= prefixSum[i - 1];\n        if(candleString[i] == '*' && candleString[i - 1] == '|')\n            plateCount++;\n        prefixSum[i]+= plateCount;\n    }\n    std::vector<int> result;\n    for(const auto &query : queries)\n    {\n        int leftIndex= query[0], rightIndex= query[1];\n        result.push_back(prefixSum[rightIndex] - (leftIndex > 0 ? prefixSum[leftIndex - 1] : 0));\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint validMoveCombinations(vector<string> chessPieces, vector<vector<int>> piecePositions)\n{\n    int numberOfPieces = chessPieces.size();\n    int validMoveCount = 0;\n\n    for(int currentPieceIndex = 0; currentPieceIndex < numberOfPieces; currentPieceIndex++)\n    {\n        for(int targetPieceIndex = 0; targetPieceIndex < numberOfPieces; targetPieceIndex++)\n        {\n            if(currentPieceIndex != targetPieceIndex && !(chessPieces[currentPieceIndex] == \"bishop\" && (piecePositions[currentPieceIndex][0] + piecePositions[currentPieceIndex][1]) % 2 != (piecePositions[targetPieceIndex][0] + piecePositions[targetPieceIndex][1]) % 2))\n            {\n                validMoveCount++;\n            }\n        }\n    }\n\n    return validMoveCount;\n}",
    "output": "#include <bits/stdc++.h>\nint validMoveCombinations(std::vector<std::string> chessPieces, std::vector<std::vector<int>> piecePositions)\n{\n    int numberOfPieces= chessPieces.size();\n    int validMoveCount= 0;\n\n    for(int currentPieceIndex= 0; currentPieceIndex < numberOfPieces; currentPieceIndex++)\n    {\n        for(int targetPieceIndex= 0; targetPieceIndex < numberOfPieces; targetPieceIndex++)\n        {\n            if(currentPieceIndex != targetPieceIndex && !(chessPieces[currentPieceIndex] == \"bishop\" && (piecePositions[currentPieceIndex][0] + piecePositions[currentPieceIndex][1]) % 2 != (piecePositions[targetPieceIndex][0] + piecePositions[targetPieceIndex][1]) % 2))\n            {\n                validMoveCount++;\n            }\n        }\n    }\n\n    return validMoveCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeToRemoveIllegalGoods(string goodsString)\n{\n    int countOnes = 0, countTwos = 0;\n    for (int i = 0; i < goodsString.size(); ++i)\n    {\n        char character = goodsString[i];\n        if (character == '1')\n        {\n            countTwos += countOnes;\n            countOnes++;\n        }\n    }\n    return countOnes + min(countOnes, countTwos);\n}",
    "output": "#include <bits/stdc++.h>\nint minTimeToRemoveIllegalGoods(std::string goodsString)\n{\n    int countOnes= 0, countTwos= 0;\n    for(char character : goodsString)\n    {\n        if(character == '1')\n        {\n            countTwos+= countOnes;\n            countOnes++;\n        }\n    }\n    return countOnes + std::min(countOnes, countTwos);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool areNumbersIncreasing(string inputString)\n{\n    istringstream stringStream(inputString);\n    string currentToken;\n    vector<int> extractedNumbers;\n\n    while(stringStream >> currentToken)\n    {\n        if(isdigit(currentToken[0]))\n        {\n            int currentNumber = stoi(currentToken);\n            if(!extractedNumbers.empty() && extractedNumbers.back() >= currentNumber)\n            {\n                return false;\n            }\n            extractedNumbers.push_back(currentNumber);\n        }\n    }\n\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool areNumbersIncreasing(std::string inputString)\n{\n    std::istringstream stringStream(inputString);\n    std::string currentToken;\n    std::vector<int> extractedNumbers;\n\n    while(stringStream >> currentToken)\n    {\n        if(isdigit(currentToken[0]))\n        {\n            int currentNumber= std::stoi(currentToken);\n            if(!extractedNumbers.empty() && extractedNumbers.back() >= currentNumber)\n            {\n                return false;\n            }\n            extractedNumbers.push_back(currentNumber);\n        }\n    }\n\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countMaxOrSubsets(vector<int> &numbers)\n{\n    int maxOrValue = 0;\n    for(int number : numbers)\n    {\n        maxOrValue |= number;\n    }\n\n    unordered_set<int> orSubsets{0};\n    for(int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        unordered_set<int> temporarySubsets = orSubsets;\n        for(auto it = orSubsets.begin(); it != orSubsets.end(); ++it)\n        {\n            int subsetValue = *it;\n            temporarySubsets.insert(subsetValue | number);\n        }\n        orSubsets.swap(temporarySubsets);\n    }\n\n    return count(orSubsets.begin(), orSubsets.end(), maxOrValue);\n}",
    "output": "#include <bits/stdc++.h>\nint countMaxOrSubsets(std::vector<int> &numbers)\n{\n    int maxOrValue= 0;\n    for(int number : numbers)\n    {\n        maxOrValue|= number;\n    }\n\n    std::unordered_set<int> orSubsets{0};\n    for(int number : numbers)\n    {\n        std::unordered_set<int> temporarySubsets= orSubsets;\n        for(int subsetValue : orSubsets)\n        {\n            temporarySubsets.insert(subsetValue | number);\n        }\n        orSubsets.swap(temporarySubsets);\n    }\n\n    return std::count(orSubsets.begin(), orSubsets.end(), maxOrValue);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findSecondMinimum(int totalNodes, const vector<vector<int>> &edges, int travelTime, int signalChange)\n{\n    vector<vector<int>> adjacencyList(totalNodes + 1);\n    for (const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> minimumTime(totalNodes + 1, -1);\n    priority_queue<int, vector<int>, greater<int>> priorityQueue;\n    minimumTime[1] = 0;\n    priorityQueue.push(0);\n\n    while (!priorityQueue.empty())\n    {\n        int current = priorityQueue.top();\n        priorityQueue.pop();\n\n        int currentNode = current >> 16;\n        int currentTime = current & 0xffff;\n\n        if (currentNode == totalNodes)\n        {\n            return currentTime; // Found the second minimum\n        }\n\n        for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n        {\n            int neighborNode = adjacencyList[currentNode][i];\n            int nextTime = currentTime + travelTime;\n            int waitingTime = (nextTime / signalChange) % 2 == 1 ? signalChange - (nextTime % signalChange) : 0;\n\n            if (minimumTime[neighborNode] == -1 || minimumTime[neighborNode] > nextTime + waitingTime)\n            {\n                if (minimumTime[neighborNode] != -1)\n                    priorityQueue.push(minimumTime[neighborNode] << 16 | neighborNode); // Push the old distance to find the second minimum one\n                minimumTime[neighborNode] = nextTime + waitingTime;\n                priorityQueue.push(minimumTime[neighborNode] << 16 | neighborNode);\n            }\n        }\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint findSecondMinimum(int totalNodes, const std::vector<std::vector<int>> &edges, int travelTime, int signalChange)\n{\n    std::vector<std::vector<int>> adjacencyList(totalNodes + 1);\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> minimumTime(totalNodes + 1, -1);\n    std::priority_queue<int, std::vector<int>, std::greater<int>> priorityQueue;\n    minimumTime[1]= 0;\n    priorityQueue.push(0);\n\n    while(!priorityQueue.empty())\n    {\n        int current= priorityQueue.top();\n        priorityQueue.pop();\n\n        int currentNode= current >> 16;\n        int currentTime= current & 0xffff;\n\n        if(currentNode == totalNodes)\n        {\n            return currentTime; // Found the second minimum\n        }\n\n        for(int neighborNode : adjacencyList[currentNode])\n        {\n            int nextTime= currentTime + travelTime;\n            int waitingTime= (nextTime / signalChange) % 2 == 1 ? signalChange - (nextTime % signalChange) : 0;\n\n            if(minimumTime[neighborNode] == -1 || minimumTime[neighborNode] > nextTime + waitingTime)\n            {\n                if(minimumTime[neighborNode] != -1)\n                    priorityQueue.push(minimumTime[neighborNode] << 16 | neighborNode); // Push the old distance to find the second minimum one\n                minimumTime[neighborNode]= nextTime + waitingTime;\n                priorityQueue.push(minimumTime[neighborNode] << 16 | neighborNode);\n            }\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxAndSum(const vector<int> &numbers, int totalSlots, size_t currentIndex, int usedSlots, int currentSum)\n{\n    if(currentIndex == numbers.size())\n    {\n        return currentSum;\n    }\n    int maximumSum= 0;\n    for(int slotIndex= 1; slotIndex <= totalSlots; ++slotIndex)\n    {\n        if(!((1 << (slotIndex - 1)) & usedSlots))\n        {\n            int newSum= currentSum + (numbers[currentIndex] & slotIndex);\n            int newUsedSlots= (usedSlots | (1 << (slotIndex - 1)));\n            maximumSum= max(maximumSum, calculateMaxAndSum(numbers, totalSlots, currentIndex + 1, newUsedSlots, newSum));\n            if(currentIndex + 1 < numbers.size())\n            {\n                newSum= newSum + (numbers[currentIndex + 1] & slotIndex);\n                maximumSum= max(maximumSum, calculateMaxAndSum(numbers, totalSlots, currentIndex + 2, newUsedSlots, newSum));\n            }\n        }\n    }\n    return maximumSum;\n}\n\nint maxAndSum(vector<int> &numbers, int totalSlots)\n{\n    return calculateMaxAndSum(numbers, totalSlots, 0, 0, 0);\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMaxAndSum(const std::vector<int> &numbers, int totalSlots, size_t currentIndex, int usedSlots, int currentSum)\n{\n    if(currentIndex == numbers.size())\n    {\n        return currentSum;\n    }\n    int maximumSum= 0;\n    for(int slotIndex= 1; slotIndex <= totalSlots; ++slotIndex)\n    {\n        if(!((1 << (slotIndex - 1)) & usedSlots))\n        {\n            int newSum= currentSum + (numbers[currentIndex] & slotIndex);\n            int newUsedSlots= (usedSlots | (1 << (slotIndex - 1)));\n            maximumSum= std::max(maximumSum, calculateMaxAndSum(numbers, totalSlots, currentIndex + 1, newUsedSlots, newSum));\n            if(currentIndex + 1 < numbers.size())\n            {\n                newSum= newSum + (numbers[currentIndex + 1] & slotIndex);\n                maximumSum= std::max(maximumSum, calculateMaxAndSum(numbers, totalSlots, currentIndex + 2, newUsedSlots, newSum));\n            }\n        }\n    }\n    return maximumSum;\n}\n\nint maxAndSum(std::vector<int> &numbers, int totalSlots)\n{\n    return calculateMaxAndSum(numbers, totalSlots, 0, 0, 0);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint getNextBalancedNumber(int currentNumber)\n{\n    while(true)\n    {\n        currentNumber++;\n        map<int, int> digitCount;\n        int tempNumber = currentNumber;\n        while(tempNumber)\n        {\n            digitCount[tempNumber % 10]++;\n            tempNumber /= 10;\n        }\n        bool isBalanced = true;\n        for (auto it = digitCount.begin(); it != digitCount.end(); ++it)\n        {\n            if(it->first != it->second)\n            {\n                isBalanced = false;\n                break;\n            }\n        }\n        if(isBalanced)\n            return currentNumber;\n    }\n}",
    "output": "int getNextBalancedNumber(int currentNumber)\n{\n    while(true)\n    {\n        currentNumber++;\n        std::map<int, int> digitCount;\n        int tempNumber= currentNumber;\n        while(tempNumber)\n        {\n            digitCount[tempNumber % 10]++;\n            tempNumber/= 10;\n        }\n        bool isBalanced= true;\n        for(const auto &pair : digitCount)\n        {\n            if(pair.first != pair.second)\n            {\n                isBalanced= false;\n                break;\n            }\n        }\n        if(isBalanced)\n            return currentNumber;\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minMonths(int numberOfTasks, vector<vector<int>> &taskRelations, vector<int> &taskTime)\n{\n    vector<int> dependencyOrder(numberOfTasks, 0);\n    for (int i = 0; i < taskRelations.size(); ++i)\n    {\n        auto &relation = taskRelations[i];\n        dependencyOrder[relation[1] - 1] = max(dependencyOrder[relation[1] - 1], relation[0]);\n    }\n\n    int totalTime = 0;\n    for (int i = 0; i < numberOfTasks; ++i)\n        totalTime = max(totalTime, taskTime[i] + dependencyOrder[i]);\n\n    return totalTime;\n}",
    "output": "#include <bits/stdc++.h>\nint minMonths(int numberOfTasks, std::vector<std::vector<int>> &taskRelations, std::vector<int> &taskTime)\n{\n    std::vector<int> dependencyOrder(numberOfTasks, 0);\n    for(auto &relation : taskRelations)\n        dependencyOrder[relation[1] - 1]= std::max(dependencyOrder[relation[1] - 1], relation[0]);\n    int totalTime= 0;\n    for(int i= 0; i < numberOfTasks; ++i)\n        totalTime= std::max(totalTime, taskTime[i] + dependencyOrder[i]);\n    return totalTime;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool almostEquivalent(string firstWord, string secondWord)\n{\n    unordered_map<char, int> firstWordFrequency, secondWordFrequency;\n\n    for (int i = 0; i < firstWord.size(); ++i)\n    {\n        char character = firstWord[i];\n        firstWordFrequency[character]++;\n    }\n    for (int i = 0; i < secondWord.size(); ++i)\n    {\n        char character = secondWord[i];\n        secondWordFrequency[character]++;\n    }\n    for (char character = 'a'; character <= 'z'; character++)\n    {\n        if (abs(firstWordFrequency[character] - secondWordFrequency[character]) > 3)\n        {\n            return false;\n        }\n    }\n\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool almostEquivalent(std::string firstWord, std::string secondWord)\n{\n    std::unordered_map<char, int> firstWordFrequency, secondWordFrequency;\n\n    for(char character : firstWord)\n    {\n        firstWordFrequency[character]++;\n    }\n    for(char character : secondWord)\n    {\n        secondWordFrequency[character]++;\n    }\n    for(char character= 'a'; character <= 'z'; character++)\n    {\n        if(std::abs(firstWordFrequency[character] - secondWordFrequency[character]) > 3)\n        {\n            return false;\n        }\n    }\n\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class Robot\n{\n  public:\n    int positionX, positionY, direction;\n    Robot() : positionX(0), positionY(0), direction(1) {}\n    void move(int steps)\n    {\n        switch(direction)\n        {\n        case 0:\n            positionY+= steps;\n            break;\n        case 1:\n            positionX+= steps;\n            break;\n        case 2:\n            positionY-= steps;\n            break;\n        case 3:\n            positionX-= steps;\n            break;\n        }\n    }\n    void turnLeft() { direction= (direction + 3) % 4; }\n    void turnRight() { direction= (direction + 1) % 4; }\n};",
    "output": "class Robot\n{\n  public:\n    int positionX, positionY, direction;\n    Robot() : positionX(0), positionY(0), direction(1) {}\n    void move(int steps)\n    {\n        switch(direction)\n        {\n        case 0:\n            positionY+= steps;\n            break;\n        case 1:\n            positionX+= steps;\n            break;\n        case 2:\n            positionY-= steps;\n            break;\n        case 3:\n            positionX-= steps;\n            break;\n        }\n    }\n    void turnLeft() { direction= (direction + 3) % 4; }\n    void turnRight() { direction= (direction + 1) % 4; }\n};"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> maxBeauty(vector<vector<int>> &items, vector<int> &queries)\n{\n    vector<int> maxBeautyItems(10001, 0);\n    for (int i = 0; i < items.size(); ++i)\n    {\n        maxBeautyItems[items[i][0]] = max(maxBeautyItems[items[i][0]], items[i][1]);\n    }\n\n    for (int index = 1; index < maxBeautyItems.size(); ++index)\n    {\n        maxBeautyItems[index] = max(maxBeautyItems[index], maxBeautyItems[index - 1]);\n    }\n\n    vector<int> result;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        result.push_back(maxBeautyItems[queries[i]]);\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> maxBeauty(std::vector<std::vector<int>> &items, std::vector<int> &queries)\n{\n    std::vector<int> maxBeautyItems(10001, 0);\n    for(auto &item : items)\n    {\n        maxBeautyItems[item[0]] = std::max(maxBeautyItems[item[0]], item[1]);\n    }\n\n    for(int index = 1; index < maxBeautyItems.size(); ++index)\n    {\n        maxBeautyItems[index] = std::max(maxBeautyItems[index], maxBeautyItems[index - 1]);\n    }\n\n    std::vector<int> result;\n    for(int query : queries)\n    {\n        result.push_back(maxBeautyItems[query]);\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxTasks(vector<int> &taskList, vector<int> &workerList, int pillCount, int strengthBoost)\n{\n    sort(taskList.begin(), taskList.end());\n    sort(workerList.begin(), workerList.end());\n    int currentTaskIndex = 0;\n    int remainingPills = pillCount;\n    int completedTaskCount = 0;\n\n    for (int i = 0; i < workerList.size(); ++i)\n    {\n        int workerStrength = workerList[i];\n        while (remainingPills > 0 && workerStrength + strengthBoost >= taskList[currentTaskIndex])\n        {\n            workerStrength += strengthBoost;\n            --remainingPills;\n        }\n\n        if (workerStrength >= taskList[currentTaskIndex])\n        {\n            ++currentTaskIndex;\n            ++completedTaskCount;\n        }\n\n        if (currentTaskIndex >= taskList.size())\n        {\n            break;\n        }\n    }\n\n    return completedTaskCount;\n}",
    "output": "#include <bits/stdc++.h>\nint maxTasks(std::vector<int> &taskList, std::vector<int> &workerList, int pillCount, int strengthBoost)\n{\n    std::sort(taskList.begin(), taskList.end());\n    std::sort(workerList.begin(), workerList.end());\n    int currentTaskIndex= 0;\n    int remainingPills= pillCount;\n    int completedTaskCount= 0;\n\n    for(int workerStrength : workerList)\n    {\n        while(remainingPills > 0 && workerStrength + strengthBoost >= taskList[currentTaskIndex])\n        {\n            workerStrength+= strengthBoost;\n            --remainingPills;\n        }\n\n        if(workerStrength >= taskList[currentTaskIndex])\n        {\n            ++currentTaskIndex;\n            ++completedTaskCount;\n        }\n\n        if(currentTaskIndex >= taskList.size())\n        {\n            break;\n        }\n    }\n\n    return completedTaskCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findSmallestIndex(vector<int> &numberList)\n{\n    for(int currentIndex= 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        if(currentIndex % 10 == numberList[currentIndex])\n        {\n            return currentIndex;\n        }\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint findSmallestIndex(std::vector<int> &numberList)\n{\n    for(int currentIndex= 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        if(currentIndex % 10 == numberList[currentIndex])\n        {\n            return currentIndex;\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nvector<int> criticalDistance(ListNode *head)\n{\n    int minimumDistance= INT_MAX, maximumDistance= INT_MIN;\n    int lastCriticalPoint= -1, currentIndex= 0;\n\n    for(ListNode *currentNode= head->next; currentNode && currentNode->next; currentNode= currentNode->next)\n    {\n        if((currentNode->value > currentNode->next->value && currentNode->value > currentNode->prev->value) ||\n           (currentNode->value < currentNode->next->value && currentNode->value < currentNode->prev->value))\n        {\n\n            if(lastCriticalPoint != -1)\n            {\n                minimumDistance= min(minimumDistance, currentIndex - lastCriticalPoint);\n                maximumDistance= max(maximumDistance, currentIndex - lastCriticalPoint);\n            }\n            lastCriticalPoint= currentIndex;\n        }\n        currentIndex++;\n    }\n\n    if(minimumDistance != INT_MAX)\n    {\n        return {minimumDistance, maximumDistance};\n    }\n    return {-1, -1};\n}",
    "output": "#include <bits/stdc++.h>\nstruct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nstd::vector<int> criticalDistance(ListNode *head)\n{\n    int minimumDistance= INT_MAX, maximumDistance= INT_MIN;\n    int lastCriticalPoint= -1, currentIndex= 0;\n\n    for(ListNode *currentNode= head->next; currentNode && currentNode->next; currentNode= currentNode->next)\n    {\n        if((currentNode->value > currentNode->next->value && currentNode->value > currentNode->prev->value) ||\n           (currentNode->value < currentNode->next->value && currentNode->value < currentNode->prev->value))\n        {\n\n            if(lastCriticalPoint != -1)\n            {\n                minimumDistance= std::min(minimumDistance, currentIndex - lastCriticalPoint);\n                maximumDistance= std::max(maximumDistance, currentIndex - lastCriticalPoint);\n            }\n            lastCriticalPoint= currentIndex;\n        }\n        currentIndex++;\n    }\n\n    if(minimumDistance != INT_MAX)\n    {\n        return {minimumDistance, maximumDistance};\n    }\n    return {-1, -1};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers, int startValue, int goalValue)\n{\n    unordered_set<int> seenValues = {startValue};\n    queue<int> queue = {startValue};\n    int currentLevel = 0;\n\n    while (!queue.empty())\n    {\n        int size = queue.size();\n        for (int i = 0; i < size; ++i)\n        {\n            int currentValue = queue.front();\n            queue.pop();\n            if (currentValue == goalValue)\n                return currentLevel;\n            for (int j = 0; j < numbers.size(); ++j)\n            {\n                int nextValue = currentValue + numbers[j];\n                if (nextValue >= 0 && nextValue <= 1000 && seenValues.count(nextValue) == 0)\n                {\n                    seenValues.insert(nextValue);\n                    queue.push(nextValue);\n                }\n            }\n        }\n        ++currentLevel;\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint minOperations(std::vector<int> &numbers, int startValue, int goalValue)\n{\n    std::unordered_set<int> seenValues= {startValue};\n    std::queue<int> queue= {startValue};\n    int currentLevel= 0;\n\n    while(!queue.empty())\n    {\n        int size= queue.size();\n        for(int i= 0; i < size; ++i)\n        {\n            int currentValue= queue.front();\n            queue.pop();\n            if(currentValue == goalValue)\n                return currentLevel;\n            for(int number : numbers)\n            {\n                int nextValue= currentValue + number;\n                if(nextValue >= 0 && nextValue <= 1000 && seenValues.count(nextValue) == 0)\n                {\n                    seenValues.insert(nextValue);\n                    queue.push(nextValue);\n                }\n            }\n        }\n        ++currentLevel;\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool areEncodedStringsEqual(string encodedStringOne, string encodedStringTwo)\n{\n    string decodedStringOne= \"\", decodedStringTwo= \"\";\n\n    for(int index= 0; index < encodedStringOne.size(); ++index)\n    {\n        if(isdigit(encodedStringOne[index]))\n        {\n            int repeatCount= encodedStringOne[index] - '0';\n            while(repeatCount--)\n                decodedStringOne+= encodedStringOne[index - 1];\n        }\n        else\n            decodedStringOne+= encodedStringOne[index];\n    }\n\n    for(int index= 0; index < encodedStringTwo.size(); ++index)\n    {\n        if(isdigit(encodedStringTwo[index]))\n        {\n            int repeatCount= encodedStringTwo[index] - '0';\n            while(repeatCount--)\n                decodedStringTwo+= encodedStringTwo[index - 1];\n        }\n        else\n            decodedStringTwo+= encodedStringTwo[index];\n    }\n\n    return decodedStringOne == decodedStringTwo;\n}",
    "output": "#include <bits/stdc++.h>\nbool areEncodedStringsEqual(std::string encodedStringOne, std::string encodedStringTwo)\n{\n    std::string decodedStringOne= \"\", decodedStringTwo= \"\";\n\n    for(int index= 0; index < encodedStringOne.size(); ++index)\n    {\n        if(std::isdigit(encodedStringOne[index]))\n        {\n            int repeatCount= encodedStringOne[index] - '0';\n            while(repeatCount--)\n                decodedStringOne+= encodedStringOne[index - 1];\n        }\n        else\n            decodedStringOne+= encodedStringOne[index];\n    }\n\n    for(int index= 0; index < encodedStringTwo.size(); ++index)\n    {\n        if(std::isdigit(encodedStringTwo[index]))\n        {\n            int repeatCount= encodedStringTwo[index] - '0';\n            while(repeatCount--)\n                decodedStringTwo+= encodedStringTwo[index - 1];\n        }\n        else\n            decodedStringTwo+= encodedStringTwo[index];\n    }\n\n    return decodedStringOne == decodedStringTwo;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countPrefixes(vector<string> &words, string prefix)\n{\n    int prefixCount = 0;\n    for (int i = 0; i < words.size(); ++i)\n    {\n        const auto &word = words[i];\n        if (word.find(prefix) == 0)\n        {\n            prefixCount++;\n        }\n    }\n    return prefixCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countPrefixes(std::vector<std::string> &words, std::string prefix)\n{\n    int prefixCount= 0;\n    for(const auto &word : words)\n    {\n        if(word.find(prefix) == 0)\n        {\n            prefixCount++;\n        }\n    }\n    return prefixCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countVowelSubstrings(string inputWord)\n{\n    int vowelSubstringCount= 0, wordLength= inputWord.size();\n    set<char> uniqueVowels;\n\n    for(int startIndex= 0; startIndex < wordLength; startIndex++)\n    {\n        if(inputWord[startIndex] == 'a' || inputWord[startIndex] == 'e' || inputWord[startIndex] == 'i' || inputWord[startIndex] == 'o' || inputWord[startIndex] == 'u')\n        {\n            uniqueVowels.clear();\n            for(int endIndex= startIndex; endIndex < wordLength; endIndex++)\n            {\n                if(inputWord[endIndex] == 'a' || inputWord[endIndex] == 'e' || inputWord[endIndex] == 'i' || inputWord[endIndex] == 'o' || inputWord[endIndex] == 'u')\n                {\n                    uniqueVowels.insert(inputWord[endIndex]);\n                }\n                if(uniqueVowels.size() == 5)\n                    vowelSubstringCount++;\n            }\n        }\n    }\n    return vowelSubstringCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countVowelSubstrings(std::string inputWord)\n{\n    int vowelSubstringCount= 0, wordLength= inputWord.size();\n    std::set<char> uniqueVowels;\n\n    for(int startIndex= 0; startIndex < wordLength; startIndex++)\n    {\n        if(inputWord[startIndex] == 'a' || inputWord[startIndex] == 'e' || inputWord[startIndex] == 'i' || inputWord[startIndex] == 'o' || inputWord[startIndex] == 'u')\n        {\n            uniqueVowels.clear();\n            for(int endIndex= startIndex; endIndex < wordLength; endIndex++)\n            {\n                if(inputWord[endIndex] == 'a' || inputWord[endIndex] == 'e' || inputWord[endIndex] == 'i' || inputWord[endIndex] == 'o' || inputWord[endIndex] == 'u')\n                {\n                    uniqueVowels.insert(inputWord[endIndex]);\n                }\n                if(uniqueVowels.size() == 5)\n                    vowelSubstringCount++;\n            }\n        }\n    }\n    return vowelSubstringCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long sumOfVowelsInTheSubstrings(string inputWord)\n{\n    long long vowelSum= 0;\n    int wordLength= inputWord.length();\n\n    for(int index= 0; index < wordLength; index++)\n    {\n        if(inputWord[index] == 'a' || inputWord[index] == 'e' || inputWord[index] == 'i' || inputWord[index] == 'o' || inputWord[index] == 'u')\n        {\n            vowelSum+= static_cast<long long>(index + 1) * (wordLength - index);\n        }\n    }\n    return vowelSum;\n}",
    "output": "#include <bits/stdc++.h>\nlong long sumOfVowelsInTheSubstrings(std::string inputWord)\n{\n    long long vowelSum= 0;\n    int wordLength= inputWord.length();\n\n    for(int index= 0; index < wordLength; index++)\n    {\n        if(inputWord[index] == 'a' || inputWord[index] == 'e' || inputWord[index] == 'i' || inputWord[index] == 'o' || inputWord[index] == 'u')\n        {\n            vowelSum+= static_cast<long long>(index + 1) * (wordLength - index);\n        }\n    }\n    return vowelSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minX(int numberOfProducts, vector<int> &productQuantities)\n{\n    int totalQuantity = 0;\n    for (int i = 0; i < productQuantities.size(); ++i)\n    {\n        int quantity = productQuantities[i];\n        totalQuantity += quantity;\n    }\n\n    return (totalQuantity + numberOfProducts - 1) / numberOfProducts;\n}",
    "output": "#include <bits/stdc++.h>\nint minX(int numberOfProducts, std::vector<int> &productQuantities)\n{\n    int totalQuantity= 0;\n    for(int quantity : productQuantities)\n    {\n        totalQuantity+= quantity;\n    }\n\n    return (totalQuantity + numberOfProducts - 1) / numberOfProducts;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxQualityRec(const vector<vector<int>> &adjacencyMatrix, const vector<int> &values, int currentNode, int timeLeft, unordered_set<int> &visitedNodes)\n{\n    if(timeLeft < 0)\n    {\n        return INT_MIN;\n    }\n\n    int maxQuality = 0;\n    visitedNodes.insert(currentNode);\n    for(int i = 0; i < adjacencyMatrix[currentNode].size(); ++i)\n    {\n        if(adjacencyMatrix[currentNode][i] != -1)\n        {\n            int travelTime = adjacencyMatrix[currentNode][i];\n            int oldValue = adjacencyMatrix[currentNode][i];\n            adjacencyMatrix[currentNode][i] = adjacencyMatrix[i][currentNode] = -1;\n            maxQuality = max(maxQuality, maxQualityRec(adjacencyMatrix, values, i, timeLeft - travelTime, visitedNodes));\n            adjacencyMatrix[currentNode][i] = adjacencyMatrix[i][currentNode] = oldValue;\n        }\n    }\n    visitedNodes.erase(currentNode);\n    return maxQuality + (visitedNodes.count(currentNode + 1) == 0 ? values[currentNode] : 0);\n}\n\nint maxQuality(int nodeCount, const vector<int> &values, const vector<vector<int>> &edges, int maxTime)\n{\n    vector<vector<int>> adjacencyMatrix(nodeCount, vector<int>(nodeCount, -1));\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        const auto &edge = edges[i];\n        adjacencyMatrix[edge[0]][edge[1]] = adjacencyMatrix[edge[1]][edge[0]] = edge[2];\n    }\n\n    unordered_set<int> visitedNodes;\n    return maxQualityRec(adjacencyMatrix, values, 0, maxTime, visitedNodes);\n}",
    "output": "#include <bits/stdc++.h>\n// Include this for INT_MIN\n\nint maxQualityRec(const std::vector<std::vector<int>> &adjacencyMatrix, const std::vector<int> &values, int currentNode, int timeLeft, std::unordered_set<int> &visitedNodes)\n{\n    if(timeLeft < 0)\n    {\n        return INT_MIN;\n    }\n\n    int maxQuality= 0;\n    visitedNodes.insert(currentNode);\n    for(int i= 0; i < adjacencyMatrix[currentNode].size(); ++i)\n    {\n        if(adjacencyMatrix[currentNode][i] != -1)\n        {\n            int travelTime= adjacencyMatrix[currentNode][i];\n            int oldValue= adjacencyMatrix[currentNode][i];\n            adjacencyMatrix[currentNode][i]= adjacencyMatrix[i][currentNode]= -1;\n            maxQuality= std::max(maxQuality, maxQualityRec(adjacencyMatrix, values, i, timeLeft - travelTime, visitedNodes));\n            adjacencyMatrix[currentNode][i]= adjacencyMatrix[i][currentNode]= oldValue;\n        }\n    }\n    visitedNodes.erase(currentNode);\n    return maxQuality + (visitedNodes.count(currentNode + 1) == 0 ? values[currentNode] : 0);\n}\n\nint maxQuality(int nodeCount, const std::vector<int> &values, const std::vector<std::vector<int>> &edges, int maxTime)\n{\n    std::vector<std::vector<int>> adjacencyMatrix(nodeCount, std::vector<int>(nodeCount, -1));\n    for(const auto &edge : edges)\n    {\n        adjacencyMatrix[edge[0]][edge[1]]= adjacencyMatrix[edge[1]][edge[0]]= edge[2];\n    }\n\n    std::unordered_set<int> visitedNodes;\n    return maxQualityRec(adjacencyMatrix, values, 0, maxTime, visitedNodes);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countOnceInBoth(const vector<string> &firstWordList, const vector<string> &secondWordList)\n{\n    unordered_map<string, int> firstWordCounter, secondWordCounter;\n\n    for (int i = 0; i < firstWordList.size(); ++i)\n        firstWordCounter[firstWordList[i]]++;\n    for (int i = 0; i < secondWordList.size(); ++i)\n        secondWordCounter[secondWordList[i]]++;\n\n    int uniqueCount = 0;\n    for (auto it = firstWordCounter.begin(); it != firstWordCounter.end(); ++it)\n        if (it->second == 1 && secondWordCounter[it->first] == 1)\n            uniqueCount++;\n\n    return uniqueCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countOnceInBoth(const std::vector<std::string> &firstWordList, const std::vector<std::string> &secondWordList)\n{\n    std::unordered_map<std::string, int> firstWordCounter, secondWordCounter;\n\n    for(const auto &word : firstWordList)\n        firstWordCounter[word]++;\n    for(const auto &word : secondWordList)\n        secondWordCounter[word]++;\n\n    int uniqueCount= 0;\n    for(const auto &wordCountPair : firstWordCounter)\n        if(wordCountPair.second == 1 && secondWordCounter[wordCountPair.first] == 1)\n            uniqueCount++;\n\n    return uniqueCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minBuckets(string street)\n{\n    int totalBuckets= 0, currentIndex= 0, streetLength= street.size();\n    while(currentIndex < streetLength)\n    {\n        if(street[currentIndex] == 'H')\n        {\n            if(currentIndex + 1 < streetLength && street[currentIndex + 1] == '.')\n            {\n                totalBuckets++;\n                currentIndex+= 2;\n            }\n            else if(currentIndex + 2 < streetLength && street[currentIndex + 2] == '.')\n            {\n                totalBuckets++;\n                currentIndex+= 3;\n            }\n            else\n            {\n                return -1;\n            }\n        }\n        else\n        {\n            currentIndex+= 1;\n        }\n    }\n    return totalBuckets;\n}",
    "output": "#include <bits/stdc++.h>\nint minBuckets(std::string street)\n{\n    int totalBuckets= 0, currentIndex= 0, streetLength= street.size();\n    while(currentIndex < streetLength)\n    {\n        if(street[currentIndex] == 'H')\n        {\n            if(currentIndex + 1 < streetLength && street[currentIndex + 1] == '.')\n            {\n                totalBuckets++;\n                currentIndex+= 2;\n            }\n            else if(currentIndex + 2 < streetLength && street[currentIndex + 2] == '.')\n            {\n                totalBuckets++;\n                currentIndex+= 3;\n            }\n            else\n            {\n                return -1;\n            }\n        }\n        else\n        {\n            currentIndex+= 1;\n        }\n    }\n    return totalBuckets;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minCost(vector<vector<int>> &costGrid, vector<int> &startPosition, vector<int> &homePosition, vector<int> &rowCosts, vector<int> &colCosts)\n{\n    return abs(rowCosts[startPosition[0]] - rowCosts[homePosition[0]]) + abs(colCosts[startPosition[1]] - colCosts[homePosition[1]]);\n}",
    "output": "#include <bits/stdc++.h>\nint minCost(std::vector<std::vector<int>> &costGrid, std::vector<int> &startPosition, std::vector<int> &homePosition, std::vector<int> &rowCosts, std::vector<int> &colCosts)\n{\n    return std::abs(rowCosts[startPosition[0]] - rowCosts[homePosition[0]]) + std::abs(colCosts[startPosition[1]] - colCosts[homePosition[1]]);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countPyramids(vector<vector<int>> &grid)\n{\n    int rowCount= grid.size(), columnCount= grid[0].size(), pyramidCount= 0;\n    for(int rowIndex= 1; rowIndex < rowCount - 1; ++rowIndex)\n    {\n        for(int columnIndex= 1; columnIndex < columnCount - 1; ++columnIndex)\n        {\n            if(grid[rowIndex][columnIndex] == grid[rowIndex - 1][columnIndex] + grid[rowIndex][columnIndex - 1] - grid[rowIndex - 1][columnIndex - 1] && grid[rowIndex][columnIndex] == grid[rowIndex + 1][columnIndex] + grid[rowIndex][columnIndex + 1] - grid[rowIndex + 1][columnIndex + 1])\n            {\n                pyramidCount+= grid[rowIndex][columnIndex];\n            }\n        }\n    }\n    return pyramidCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countPyramids(std::vector<std::vector<int>> &grid)\n{\n    int rowCount= grid.size(), columnCount= grid[0].size(), pyramidCount= 0;\n    for(int rowIndex= 1; rowIndex < rowCount - 1; ++rowIndex)\n    {\n        for(int columnIndex= 1; columnIndex < columnCount - 1; ++columnIndex)\n        {\n            if(grid[rowIndex][columnIndex] == grid[rowIndex - 1][columnIndex] + grid[rowIndex][columnIndex - 1] - grid[rowIndex - 1][columnIndex - 1] && grid[rowIndex][columnIndex] == grid[rowIndex + 1][columnIndex] + grid[rowIndex][columnIndex + 1] - grid[rowIndex + 1][columnIndex + 1])\n            {\n                pyramidCount+= grid[rowIndex][columnIndex];\n            }\n        }\n    }\n    return pyramidCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> cellRange(const string &range)\n{\n    int startRow= range[1] - '0';\n    int endRow= range[4] - '0';\n    int startColumn= range[0] - 'A' + 1;\n    int endColumn= range[3] - 'A' + 1;\n\n    vector<string> result;\n    for(int column= startColumn; column <= endColumn; ++column)\n    {\n        for(int row= startRow; row <= endRow; ++row)\n        {\n            result.push_back(string(1, 'A' + column - 1) + to_string(row));\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> cellRange(const std::string &range)\n{\n    int startRow= range[1] - '0';\n    int endRow= range[4] - '0';\n    int startColumn= range[0] - 'A' + 1;\n    int endColumn= range[3] - 'A' + 1;\n\n    std::vector<std::string> result;\n    for(int column= startColumn; column <= endColumn; ++column)\n    {\n        for(int row= startRow; row <= endRow; ++row)\n        {\n            result.push_back(std::string(1, 'A' + column - 1) + std::to_string(row));\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint timeToBuyTickets(vector<int> &ticketCounts, int customerIndex)\n{\n    int totalTime= 0;\n    while(ticketCounts[customerIndex] > 0)\n    {\n        for(int i= 0; i < ticketCounts.size(); i++)\n        {\n            if(ticketCounts[i] > 0)\n            {\n                ticketCounts[i]--;\n                totalTime++;\n                if(i == customerIndex && ticketCounts[customerIndex] == 0)\n                    return totalTime;\n            }\n        }\n    }\n    return totalTime;\n}",
    "output": "#include <bits/stdc++.h>\nint timeToBuyTickets(std::vector<int> &ticketCounts, int customerIndex)\n{\n    int totalTime= 0;\n    while(ticketCounts[customerIndex] > 0)\n    {\n        for(int i= 0; i < ticketCounts.size(); i++)\n        {\n            if(ticketCounts[i] > 0)\n            {\n                ticketCounts[i]--;\n                totalTime++;\n                if(i == customerIndex && ticketCounts[customerIndex] == 0)\n                    return totalTime;\n            }\n        }\n    }\n    return totalTime;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *reverseLinkedList(ListNode *head)\n{\n    ListNode *previous= NULL, *current= head, *nextNode= NULL;\n    while(current != NULL)\n    {\n        nextNode= current->next;\n        current->next= previous;\n        previous= current;\n        current= nextNode;\n    }\n    return previous;\n}\n\nListNode *reverseEvenGroups(ListNode *head)\n{\n    ListNode *dummyNode= new ListNode(-1);\n    dummyNode->next= head;\n    ListNode *previousGroupTail= dummyNode, *current= head;\n    int totalCount= 0;\n    while(current != NULL)\n    {\n        totalCount++;\n        current= current->next;\n    }\n    current= head;\n    for(int i= 2; i <= totalCount; i= i + 2)\n    {\n        ListNode *nextGroupHead= current;\n        for(int j= 0; j < i; j++)\n        {\n            if(nextGroupHead == NULL)\n                break;\n            nextGroupHead= nextGroupHead->next;\n        }\n        ListNode *previousGroupTailTemp= previousGroupTail;\n        for(int j= 0; j < i; j++)\n        {\n            if(current == NULL)\n                break;\n            ListNode *nextNode= current->next;\n            current->next= previousGroupTailTemp->next;\n            previousGroupTailTemp->next= current;\n            current= nextNode;\n        }\n        for(int j= 0; j < i; j++)\n        {\n            previousGroupTail= previousGroupTail->next;\n        }\n    }\n    return dummyNode->next;\n}",
    "output": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *reverseLinkedList(ListNode *head)\n{\n    ListNode *previous= NULL, *current= head, *nextNode= NULL;\n    while(current != NULL)\n    {\n        nextNode= current->next;\n        current->next= previous;\n        previous= current;\n        current= nextNode;\n    }\n    return previous;\n}\n\nListNode *reverseEvenGroups(ListNode *head)\n{\n    ListNode *dummyNode= new ListNode(-1);\n    dummyNode->next= head;\n    ListNode *previousGroupTail= dummyNode, *current= head;\n    int totalCount= 0;\n    while(current != NULL)\n    {\n        totalCount++;\n        current= current->next;\n    }\n    current= head;\n    for(int i= 2; i <= totalCount; i= i + 2)\n    {\n        ListNode *nextGroupHead= current;\n        for(int j= 0; j < i; j++)\n        {\n            if(nextGroupHead == NULL)\n                break;\n            nextGroupHead= nextGroupHead->next;\n        }\n        ListNode *previousGroupTailTemp= previousGroupTail;\n        for(int j= 0; j < i; j++)\n        {\n            if(current == NULL)\n                break;\n            ListNode *nextNode= current->next;\n            current->next= previousGroupTailTemp->next;\n            previousGroupTailTemp->next= current;\n            current= nextNode;\n        }\n        for(int j= 0; j < i; j++)\n        {\n            previousGroupTail= previousGroupTail->next;\n        }\n    }\n    return dummyNode->next;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring decodeSlantedCipher(const string &encodedText, int rowCount)\n{\n    vector<string> textMatrix(rowCount, string(encodedText.size() / rowCount + 1, ' '));\n    int characterIndex = 0;\n    for(int diagonalIndex = 0; diagonalIndex < 2 * (rowCount - 1); ++diagonalIndex)\n    {\n        for(int currentRow = max(0, diagonalIndex - rowCount + 1); currentRow <= min(diagonalIndex, rowCount - 1); ++currentRow)\n        {\n            if(characterIndex < encodedText.size())\n            {\n                textMatrix[currentRow][diagonalIndex - currentRow] = encodedText[characterIndex++];\n            }\n        }\n    }\n    string originalText;\n    for(int i = 0; i < rowCount; ++i)\n    {\n        originalText += textMatrix[i];\n    }\n    return originalText;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string decodeSlantedCipher(const std::string &encodedText, int rowCount)\n{\n    std::vector<std::string> textMatrix(rowCount, std::string(encodedText.size() / rowCount + 1, ' '));\n    int characterIndex= 0;\n    for(int diagonalIndex= 0; diagonalIndex < 2 * (rowCount - 1); ++diagonalIndex)\n    {\n        for(int currentRow= std::max(0, diagonalIndex - rowCount + 1); currentRow <= std::min(diagonalIndex, rowCount - 1); ++currentRow)\n        {\n            if(characterIndex < encodedText.size())\n            {\n                textMatrix[currentRow][diagonalIndex - currentRow]= encodedText[characterIndex++];\n            }\n        }\n    }\n    std::string originalText;\n    for(int i= 0; i < rowCount; ++i)\n    {\n        originalText+= textMatrix[i];\n    }\n    return originalText;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<bool> checkFriends(int numberOfPeople, vector<vector<int>> &restrictions, vector<vector<int>> &friendshipRequests)\n{\n    vector<unordered_set<int>> friendGraph(numberOfPeople);\n    for (int i = 0; i < restrictions.size(); i++)\n    {\n        friendGraph[restrictions[i][0]].insert(restrictions[i][1]);\n        friendGraph[restrictions[i][1]].insert(restrictions[i][0]);\n    }\n\n    vector<bool> requestResults(friendshipRequests.size());\n    for (int requestIndex = 0; requestIndex < friendshipRequests.size(); requestIndex++)\n    {\n        int personA = friendshipRequests[requestIndex][0];\n        int personB = friendshipRequests[requestIndex][1];\n        if (friendGraph[personA].count(personB) == 0 && friendGraph[personB].count(personA) == 0)\n        {\n            friendGraph[personA].insert(personB);\n            friendGraph[personB].insert(personA);\n            requestResults[requestIndex] = true;\n        }\n        else\n        {\n            requestResults[requestIndex] = false;\n        }\n    }\n    return requestResults;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<bool> checkFriends(int numberOfPeople, std::vector<std::vector<int>> &restrictions, std::vector<std::vector<int>> &friendshipRequests)\n{\n    std::vector<std::unordered_set<int>> friendGraph(numberOfPeople);\n    for(auto &restriction : restrictions)\n    {\n        friendGraph[restriction[0]].insert(restriction[1]);\n        friendGraph[restriction[1]].insert(restriction[0]);\n    }\n\n    std::vector<bool> requestResults(friendshipRequests.size());\n    for(int requestIndex= 0; requestIndex < friendshipRequests.size(); requestIndex++)\n    {\n        int personA= friendshipRequests[requestIndex][0];\n        int personB= friendshipRequests[requestIndex][1];\n        if(friendGraph[personA].count(personB) == 0 && friendGraph[personB].count(personA) == 0)\n        {\n            friendGraph[personA].insert(personB);\n            friendGraph[personB].insert(personA);\n            requestResults[requestIndex]= true;\n        }\n        else\n        {\n            requestResults[requestIndex]= false;\n        }\n    }\n    return requestResults;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canFitStamps(vector<vector<int>> &grid, int stampHeight, int stampWidth)\n{\n    int rowCount= grid.size(), columnCount= grid[0].size();\n    for(int rowIndex= 0; rowIndex + stampHeight - 1 < rowCount; ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex + stampWidth - 1 < columnCount; ++colIndex)\n        {\n            bool canFit= true;\n            for(int heightIndex= 0; heightIndex < stampHeight && canFit; ++heightIndex)\n            {\n                for(int widthIndex= 0; widthIndex < stampWidth && canFit; ++widthIndex)\n                {\n                    if(grid[rowIndex + heightIndex][colIndex + widthIndex] == 1)\n                    {\n                        canFit= false;\n                    }\n                }\n            }\n            if(canFit)\n            {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
    "output": "#include <bits/stdc++.h>\nbool canFitStamps(std::vector<std::vector<int>> &grid, int stampHeight, int stampWidth)\n{\n    int rowCount= grid.size(), columnCount= grid[0].size();\n    for(int rowIndex= 0; rowIndex + stampHeight - 1 < rowCount; ++rowIndex)\n    {\n        for(int colIndex= 0; colIndex + stampWidth - 1 < columnCount; ++colIndex)\n        {\n            bool canFit= true;\n            for(int heightIndex= 0; heightIndex < stampHeight && canFit; ++heightIndex)\n            {\n                for(int widthIndex= 0; widthIndex < stampWidth && canFit; ++widthIndex)\n                {\n                    if(grid[rowIndex + heightIndex][colIndex + widthIndex] == 1)\n                    {\n                        canFit= false;\n                    }\n                }\n            }\n            if(canFit)\n            {\n                return true;\n            }\n        }\n    }\n    return false;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> arrangePairs(vector<vector<int>> &pairs)\n{\n    unordered_map<int, vector<int>> adjacencyMap;\n    for (int i = 0; i < pairs.size(); ++i)\n    {\n        adjacencyMap[pairs[i][0]] = pairs[i];\n    }\n\n    vector<vector<int>> result;\n    int startingPoint = pairs[0][0];\n    while (!adjacencyMap.empty())\n    {\n        auto iterator = adjacencyMap.find(startingPoint);\n        result.push_back(iterator->second);\n        startingPoint = iterator->second[1];\n        adjacencyMap.erase(iterator);\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> arrangePairs(std::vector<std::vector<int>> &pairs)\n{\n    std::unordered_map<int, std::vector<int>> adjacencyMap;\n    for(const auto &pair : pairs)\n    {\n        adjacencyMap[pair[0]]= pair;\n    }\n\n    std::vector<std::vector<int>> result;\n    int startingPoint= pairs[0][0];\n    while(!adjacencyMap.empty())\n    {\n        auto iterator= adjacencyMap.find(startingPoint);\n        result.push_back(iterator->second);\n        startingPoint= iterator->second[1];\n        adjacencyMap.erase(iterator);\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring convertToBaseK(int number, int base)\n{\n    string baseKNumber= \"\";\n    while(number)\n    {\n        baseKNumber+= to_string(number % base);\n        number/= base;\n    }\n    return baseKNumber;\n}\n\nbool isKMirror(int number, int base)\n{\n    string base10Number= to_string(number);\n    string baseKNumber= convertToBaseK(number, base);\n    return (base10Number == string(base10Number.rbegin(), base10Number.rend())) &&\n           (baseKNumber == string(baseKNumber.rbegin(), baseKNumber.rend()));\n}\n\nint sumKMirrorNumbers(int base, int count)\n{\n    int totalSum= 0;\n    int currentNumber= 0;\n    while(count)\n    {\n        if(isKMirror(currentNumber, base))\n        {\n            totalSum+= currentNumber;\n            count--;\n        }\n        currentNumber++;\n    }\n    return totalSum;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string convertToBaseK(int number, int base)\n{\n    std::string baseKNumber= \"\";\n    while(number)\n    {\n        baseKNumber+= std::to_string(number % base);\n        number/= base;\n    }\n    return baseKNumber;\n}\n\nbool isKMirror(int number, int base)\n{\n    std::string base10Number= std::to_string(number);\n    std::string baseKNumber= convertToBaseK(number, base);\n    return (base10Number == std::string(base10Number.rbegin(), base10Number.rend())) &&\n           (baseKNumber == std::string(baseKNumber.rbegin(), baseKNumber.rend()));\n}\n\nint sumKMirrorNumbers(int base, int count)\n{\n    int totalSum= 0;\n    int currentNumber= 0;\n    while(count)\n    {\n        if(isKMirror(currentNumber, base))\n        {\n            totalSum+= currentNumber;\n            count--;\n        }\n        currentNumber++;\n    }\n    return totalSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minWeightSubgraph(int totalNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(totalNodes);\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        adjacencyList[edges[i][0]].emplace_back(edges[i][1], edges[i][2]);\n    }\n\n    auto dijkstra = [&](int source)\n    {\n        vector<int> distance(totalNodes, numeric_limits<int>::max());\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> priorityQueue;\n        distance[source] = 0;\n        priorityQueue.emplace(0, source);\n\n        while (!priorityQueue.empty())\n        {\n            int currentNode = priorityQueue.top().second;\n            int currentDistance = priorityQueue.top().first;\n            priorityQueue.pop();\n            if (currentDistance != distance[currentNode])\n                continue;\n            for (int j = 0; j < adjacencyList[currentNode].size(); ++j)\n            {\n                auto &[neighbor, weight] = adjacencyList[currentNode][j];\n                if (currentDistance + weight < distance[neighbor])\n                {\n                    distance[neighbor] = currentDistance + weight;\n                    priorityQueue.emplace(distance[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distance;\n    };\n\n    vector<int> distanceFromSource1 = dijkstra(source1);\n    vector<int> distanceFromSource2 = dijkstra(source2);\n\n    int result = distanceFromSource1[destination] + distanceFromSource2[destination];\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        int nodeU = edges[i][0], nodeV = edges[i][1], weight = edges[i][2];\n        result = min(result, distanceFromSource1[nodeU] + distanceFromSource2[nodeV] + weight);\n        result = min(result, distanceFromSource1[nodeV] + distanceFromSource2[nodeU] + weight);\n    }\n\n    return result == numeric_limits<int>::max() ? -1 : result;\n}",
    "output": "#include <bits/stdc++.h>\nint minWeightSubgraph(int totalNodes, std::vector<std::vector<int>> &edges, int source1, int source2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(totalNodes);\n    for(auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distance(totalNodes, std::numeric_limits<int>::max());\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<>> priorityQueue;\n        distance[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n            if(currentDistance != distance[currentNode])\n                continue;\n            for(auto &[neighbor, weight] : adjacencyList[currentNode])\n            {\n                if(currentDistance + weight < distance[neighbor])\n                {\n                    distance[neighbor]= currentDistance + weight;\n                    priorityQueue.emplace(distance[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distance;\n    };\n\n    std::vector<int> distanceFromSource1= dijkstra(source1);\n    std::vector<int> distanceFromSource2= dijkstra(source2);\n\n    int result= distanceFromSource1[destination] + distanceFromSource2[destination];\n    for(auto &edge : edges)\n    {\n        int nodeU= edge[0], nodeV= edge[1], weight= edge[2];\n        result= std::min(result, distanceFromSource1[nodeU] + distanceFromSource2[nodeV] + weight);\n        result= std::min(result, distanceFromSource1[nodeV] + distanceFromSource2[nodeU] + weight);\n    }\n\n    return result == std::numeric_limits<int>::max() ? -1 : result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> largestSumSequence(vector<int> &numberList, int sequenceLength)\n{\n    priority_queue<int, vector<int>, greater<int>> minHeap;\n\n    for (int i = 0; i < numberList.size(); ++i)\n    {\n        int currentNumber = numberList[i];\n        minHeap.push(currentNumber);\n        if (minHeap.size() > sequenceLength)\n        {\n            minHeap.pop();\n        }\n    }\n\n    vector<int> result(minHeap.size());\n    while (!minHeap.empty())\n    {\n        result[minHeap.size() - 1] = minHeap.top();\n        minHeap.pop();\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> largestSumSequence(std::vector<int> &numberList, int sequenceLength)\n{\n    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;\n\n    for(int currentNumber : numberList)\n    {\n        minHeap.push(currentNumber);\n        if(minHeap.size() > sequenceLength)\n        {\n            minHeap.pop();\n        }\n    }\n\n    std::vector<int> result(minHeap.size());\n    while(!minHeap.empty())\n    {\n        result[minHeap.size() - 1]= minHeap.top();\n        minHeap.pop();\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBombsDetonated(vector<vector<int>> &bombs)\n{\n    int numberOfBombs= bombs.size();\n    int maxBombsDetonated= 0;\n\n    for(int currentBombIndex= 0; currentBombIndex < numberOfBombs; ++currentBombIndex)\n    {\n        int detonatedCount= 0;\n        for(int targetBombIndex= 0; targetBombIndex < numberOfBombs; ++targetBombIndex)\n        {\n            int deltaX= bombs[currentBombIndex][0] - bombs[targetBombIndex][0];\n            int deltaY= bombs[currentBombIndex][1] - bombs[targetBombIndex][1];\n            int distanceSquared= deltaX * deltaX + deltaY * deltaY;\n            int rangeSquared= bombs[currentBombIndex][2] * bombs[currentBombIndex][2] + bombs[targetBombIndex][2] * bombs[targetBombIndex][2];\n            if(distanceSquared <= rangeSquared)\n            {\n                detonatedCount++;\n            }\n        }\n        maxBombsDetonated= max(maxBombsDetonated, detonatedCount);\n    }\n\n    return maxBombsDetonated;\n}",
    "output": "#include <bits/stdc++.h>\nint maxBombsDetonated(std::vector<std::vector<int>> &bombs)\n{\n    int numberOfBombs= bombs.size();\n    int maxBombsDetonated= 0;\n\n    for(int currentBombIndex= 0; currentBombIndex < numberOfBombs; ++currentBombIndex)\n    {\n        int detonatedCount= 0;\n        for(int targetBombIndex= 0; targetBombIndex < numberOfBombs; ++targetBombIndex)\n        {\n            int deltaX= bombs[currentBombIndex][0] - bombs[targetBombIndex][0];\n            int deltaY= bombs[currentBombIndex][1] - bombs[targetBombIndex][1];\n            int distanceSquared= deltaX * deltaX + deltaY * deltaY;\n            int rangeSquared= bombs[currentBombIndex][2] * bombs[currentBombIndex][2] + bombs[targetBombIndex][2] * bombs[targetBombIndex][2];\n            if(distanceSquared <= rangeSquared)\n            {\n                detonatedCount++;\n            }\n        }\n        maxBombsDetonated= std::max(maxBombsDetonated, detonatedCount);\n    }\n\n    return maxBombsDetonated;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    priority_queue<int, vector<int>, less<int>> maxHeap(numbers.begin(), numbers.end());\n    int initialSum = accumulate(numbers.begin(), numbers.end(), 0);\n    int targetSum = initialSum / 2;\n    int sumSoFar = 0;\n    int operationCount = 0;\n\n    while(sumSoFar <= targetSum)\n    {\n        int largestNumber = maxHeap.top();\n        maxHeap.pop();\n        sumSoFar += largestNumber / 2;\n        operationCount += 1;\n    }\n\n    return operationCount;\n}",
    "output": "#include <bits/stdc++.h>\nint minOperations(std::vector<int> &numbers)\n{\n    std::priority_queue<int, std::vector<int>, std::less<int>> maxHeap(numbers.begin(), numbers.end());\n    int initialSum= std::accumulate(numbers.begin(), numbers.end(), 0);\n    int targetSum= initialSum / 2;\n    int sumSoFar= 0;\n    int operationCount= 0;\n\n    while(sumSoFar <= targetSum)\n    {\n        int largestNumber= maxHeap.top();\n        maxHeap.pop();\n        sumSoFar+= largestNumber / 2;\n        operationCount+= 1;\n    }\n\n    return operationCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minVisibleWhiteTiles(string floor, int numCarpets, int carpetLength)\n{\n    int floorLength= floor.size(), minimumVisibleTiles= floorLength;\n    for(int startIndex= 0; startIndex < floorLength - carpetLength + 1; ++startIndex)\n    {\n        int whiteTileCount= 0;\n        for(int offset= 0; offset < carpetLength; ++offset)\n            whiteTileCount+= (floor[startIndex + offset] == '1');\n        for(int carpetCount= 1; carpetCount <= numCarpets && carpetCount * carpetLength - 1 <= startIndex + carpetLength; ++carpetCount)\n        {\n            minimumVisibleTiles= min(minimumVisibleTiles, floorLength - whiteTileCount * carpetCount);\n            if(startIndex + carpetLength < floorLength)\n            {\n                whiteTileCount-= (floor[startIndex + carpetLength - carpetCount * carpetLength] == '1');\n                whiteTileCount+= (floor[startIndex + carpetLength] == '1');\n            }\n        }\n    }\n    return minimumVisibleTiles;\n}",
    "output": "#include <bits/stdc++.h>\nint minVisibleWhiteTiles(std::string floor, int numCarpets, int carpetLength)\n{\n    int floorLength= floor.size(), minimumVisibleTiles= floorLength;\n    for(int startIndex= 0; startIndex < floorLength - carpetLength + 1; ++startIndex)\n    {\n        int whiteTileCount= 0;\n        for(int offset= 0; offset < carpetLength; ++offset)\n            whiteTileCount+= (floor[startIndex + offset] == '1');\n        for(int carpetCount= 1; carpetCount <= numCarpets && carpetCount * carpetLength - 1 <= startIndex + carpetLength; ++carpetCount)\n        {\n            minimumVisibleTiles= std::min(minimumVisibleTiles, floorLength - whiteTileCount * carpetCount);\n            if(startIndex + carpetLength < floorLength)\n            {\n                whiteTileCount-= (floor[startIndex + carpetLength - carpetCount * carpetLength] == '1');\n                whiteTileCount+= (floor[startIndex + carpetLength] == '1');\n            }\n        }\n    }\n    return minimumVisibleTiles;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> sortedTargetIndices(vector<int> &numberList, int targetValue)\n{\n    vector<int> targetIndices;\n    for(int index= 0; index < numberList.size(); index++)\n    {\n        if(numberList[index] == targetValue)\n        {\n            targetIndices.push_back(index);\n        }\n    }\n    sort(targetIndices.begin(), targetIndices.end());\n    return targetIndices;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> sortedTargetIndices(std::vector<int> &numberList, int targetValue)\n{\n    std::vector<int> targetIndices;\n    for(int index= 0; index < numberList.size(); index++)\n    {\n        if(numberList[index] == targetValue)\n        {\n            targetIndices.push_back(index);\n        }\n    }\n    std::sort(targetIndices.begin(), targetIndices.end());\n    return targetIndices;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> calculateKRadiusAverage(vector<int> &numbers, int radius)\n{\n    int totalNumbers= numbers.size();\n    vector<int> averages(totalNumbers, -1);\n    for(int currentIndex= radius; currentIndex < totalNumbers - radius; ++currentIndex)\n    {\n        int sum= 0;\n        for(int j= currentIndex - radius; j <= currentIndex + radius; ++j)\n        {\n            sum+= numbers[j];\n        }\n        averages[currentIndex]= sum / (2 * radius + 1);\n    }\n    return averages;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> calculateKRadiusAverage(std::vector<int> &numbers, int radius)\n{\n    int totalNumbers= numbers.size();\n    std::vector<int> averages(totalNumbers, -1);\n    for(int currentIndex= radius; currentIndex < totalNumbers - radius; ++currentIndex)\n    {\n        int sum= 0;\n        for(int j= currentIndex - radius; j <= currentIndex + radius; ++j)\n        {\n            sum+= numbers[j];\n        }\n        averages[currentIndex]= sum / (2 * radius + 1);\n    }\n    return averages;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minDeletions(vector<int> &numbers)\n{\n    int size= numbers.size();\n    if(size <= 2)\n        return 0;\n\n    int minIndex= 0, maxIndex= 0;\n\n    for(int i= 1; i < size; i++)\n    {\n        if(numbers[i] < numbers[minIndex])\n            minIndex= i;\n        if(numbers[i] > numbers[maxIndex])\n            maxIndex= i;\n    }\n\n    return min({max(minIndex, maxIndex), size - min(minIndex, maxIndex) - 1, minIndex + size - maxIndex - 1});\n}",
    "output": "#include <bits/stdc++.h>\nint minDeletions(std::vector<int> &numbers)\n{\n    int size= numbers.size();\n    if(size <= 2)\n        return 0;\n\n    int minIndex= 0, maxIndex= 0;\n\n    for(int i= 1; i < size; i++)\n    {\n        if(numbers[i] < numbers[minIndex])\n            minIndex= i;\n        if(numbers[i] > numbers[maxIndex])\n            maxIndex= i;\n    }\n\n    return std::min({std::max(minIndex, maxIndex), size - std::min(minIndex, maxIndex) - 1, minIndex + size - maxIndex - 1});\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> identifyPeopleWithSecret(int totalPeople, vector<vector<int>> &meetingsList, int initialPerson)\n{\n    unordered_set<int> secretHolders;\n    secretHolders.insert(initialPerson);\n\n    for (int currentTime = 0; !meetingsList.empty(); ++currentTime)\n    {\n        vector<vector<int>> upcomingMeetings;\n        for (int i = 0; i < meetingsList.size(); ++i)\n        {\n            const auto &meeting = meetingsList[i];\n            if (meeting[2] > currentTime)\n            {\n                upcomingMeetings.push_back(meeting);\n                continue;\n            }\n            if (secretHolders.count(meeting[0]) || secretHolders.count(meeting[1]))\n            {\n                secretHolders.insert(meeting[0]);\n                secretHolders.insert(meeting[1]);\n            }\n        }\n        meetingsList = upcomingMeetings;\n    }\n\n    return vector<int>(secretHolders.begin(), secretHolders.end());\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> identifyPeopleWithSecret(int totalPeople, std::vector<std::vector<int>> &meetingsList, int initialPerson)\n{\n    std::unordered_set<int> secretHolders;\n    secretHolders.insert(initialPerson);\n\n    for(int currentTime= 0; !meetingsList.empty(); ++currentTime)\n    {\n        std::vector<std::vector<int>> upcomingMeetings;\n        for(const auto &meeting : meetingsList)\n        {\n            if(meeting[2] > currentTime)\n            {\n                upcomingMeetings.push_back(meeting);\n                continue;\n            }\n            if(secretHolders.count(meeting[0]) || secretHolders.count(meeting[1]))\n            {\n                secretHolders.insert(meeting[0]);\n                secretHolders.insert(meeting[1]);\n            }\n        }\n        meetingsList = upcomingMeetings;\n    }\n\n    return std::vector<int>(secretHolders.begin(), secretHolders.end());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int calculateMinimumHealth(int damageArray[], int numberOfDamages, int armorValue)\n{\n    int totalHealth= 0;\n    for(int index= numberOfDamages - 1; index >= 0; --index)\n    {\n        totalHealth+= damageArray[index];\n        if(totalHealth > armorValue)\n        {\n            totalHealth-= armorValue;\n            armorValue= 0;\n        }\n    }\n    return totalHealth + 1;\n}",
    "output": "int calculateMinimumHealth(int damageArray[], int numberOfDamages, int armorValue)\n{\n    int totalHealth= 0;\n    for(int index= numberOfDamages - 1; index >= 0; --index)\n    {\n        totalHealth+= damageArray[index];\n        if(totalHealth > armorValue)\n        {\n            totalHealth-= armorValue;\n            armorValue= 0;\n        }\n    }\n    return totalHealth + 1;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generatePermutations(vector<int> &digits, vector<int> &currentPermutation, set<int> &uniqueNumbers, vector<bool> &isUsed)\n{\n    if(currentPermutation.size() == digits.size())\n    {\n        int number = 0;\n        for(int digit : currentPermutation) // This can be kept as is since it's a simple range-based for loop\n        {\n            number = number * 10 + digit;\n        }\n        uniqueNumbers.insert(number);\n        return;\n    }\n    for(int index = 0; index < digits.size(); ++index)\n    {\n        if(!isUsed[index])\n        {\n            isUsed[index] = true;\n            currentPermutation.push_back(digits[index]);\n            generatePermutations(digits, currentPermutation, uniqueNumbers, isUsed);\n            currentPermutation.pop_back();\n            isUsed[index] = false;\n        }\n    }\n}\n\nvector<int> getUniquePermutations(vector<int> &digits)\n{\n    vector<int> currentPermutation;\n    set<int> uniqueNumbers;\n    vector<bool> isUsed(digits.size(), false);\n    sort(digits.begin(), digits.end());\n\n    generatePermutations(digits, currentPermutation, uniqueNumbers, isUsed);\n\n    return vector<int>(uniqueNumbers.begin(), uniqueNumbers.end());\n}",
    "output": "#include <bits/stdc++.h>\nvoid generatePermutations(std::vector<int> &digits, std::vector<int> &currentPermutation, std::set<int> &uniqueNumbers, std::vector<bool> &isUsed)\n{\n    if(currentPermutation.size() == digits.size())\n    {\n        int number= 0;\n        for(int digit : currentPermutation)\n        {\n            number= number * 10 + digit;\n        }\n        uniqueNumbers.insert(number);\n        return;\n    }\n    for(int index= 0; index < digits.size(); ++index)\n    {\n        if(!isUsed[index])\n        {\n            isUsed[index]= true;\n            currentPermutation.push_back(digits[index]);\n            generatePermutations(digits, currentPermutation, uniqueNumbers, isUsed);\n            currentPermutation.pop_back();\n            isUsed[index]= false;\n        }\n    }\n}\n\nstd::vector<int> getUniquePermutations(std::vector<int> &digits)\n{\n    std::vector<int> currentPermutation;\n    std::set<int> uniqueNumbers;\n    std::vector<bool> isUsed(digits.size(), false);\n    std::sort(digits.begin(), digits.end());\n\n    generatePermutations(digits, currentPermutation, uniqueNumbers, isUsed);\n\n    return std::vector<int>(uniqueNumbers.begin(), uniqueNumbers.end());\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "struct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *deleteMiddle(ListNode *head)\n{\n    if(!head || !head->next)\n        return head;\n    ListNode *slowPointer= head;\n    ListNode *fastPointer= head;\n    ListNode *previousNode= NULL;\n\n    while(fastPointer && fastPointer->next)\n    {\n        previousNode= slowPointer;\n        slowPointer= slowPointer->next;\n        fastPointer= fastPointer->next->next;\n    }\n\n    previousNode->next= slowPointer->next;\n    delete slowPointer;\n    return head;\n}",
    "output": "struct ListNode\n{\n    int value;\n    ListNode *next;\n    ListNode(int x) : value(x), next(NULL) {}\n};\n\nListNode *deleteMiddle(ListNode *head)\n{\n    if(!head || !head->next)\n        return head;\n    ListNode *slowPointer= head;\n    ListNode *fastPointer= head;\n    ListNode *previousNode= NULL;\n\n    while(fastPointer && fastPointer->next)\n    {\n        previousNode= slowPointer;\n        slowPointer= slowPointer->next;\n        fastPointer= fastPointer->next->next;\n    }\n\n    previousNode->next= slowPointer->next;\n    delete slowPointer;\n    return head;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nstring findPath(TreeNode *currentNode, int targetValue, string path)\n{\n    if(!currentNode)\n        return \"\";\n    if(currentNode->value == targetValue)\n        return path;\n    string leftPath= findPath(currentNode->leftChild, targetValue, path + \"L\");\n    string rightPath= findPath(currentNode->rightChild, targetValue, path + \"R\");\n    return leftPath.empty() ? rightPath : leftPath;\n}\n\nstring shortestPath(TreeNode *rootNode, int startValue, int destinationValue)\n{\n    string startPath= findPath(rootNode, startValue, \"\");\n    string destinationPath= findPath(rootNode, destinationValue, \"\");\n    int index= 0;\n    while(index < startPath.size() && index < destinationPath.size() && startPath[index] == destinationPath[index])\n        index++;\n    string result= \"\";\n    for(int j= startPath.size() - 1; j >= index; j--)\n        result+= \"U\";\n    for(int j= index; j < destinationPath.size(); j++)\n        result+= destinationPath[j];\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n};\n\nstd::string findPath(TreeNode *currentNode, int targetValue, std::string path)\n{\n    if(!currentNode)\n        return \"\";\n    if(currentNode->value == targetValue)\n        return path;\n    std::string leftPath= findPath(currentNode->leftChild, targetValue, path + \"L\");\n    std::string rightPath= findPath(currentNode->rightChild, targetValue, path + \"R\");\n    return leftPath.empty() ? rightPath : leftPath;\n}\n\nstd::string shortestPath(TreeNode *rootNode, int startValue, int destinationValue)\n{\n    std::string startPath= findPath(rootNode, startValue, \"\");\n    std::string destinationPath= findPath(rootNode, destinationValue, \"\");\n    int index= 0;\n    while(index < startPath.size() && index < destinationPath.size() && startPath[index] == destinationPath[index])\n        index++;\n    std::string result= \"\";\n    for(int j= startPath.size() - 1; j >= index; j--)\n        result+= \"U\";\n    for(int j= index; j < destinationPath.size(); j++)\n        result+= destinationPath[j];\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxCoins(vector<vector<int>> &coinPiles, int numberOfCoins)\n{\n    priority_queue<int> maxHeap;\n    for (int i = 0; i < coinPiles.size(); ++i)\n    {\n        for (int j = 0; j < coinPiles[i].size(); ++j)\n        {\n            maxHeap.push(coinPiles[i][j]);\n        }\n    }\n\n    int totalMaxValue = 0;\n    while (numberOfCoins > 0)\n    {\n        totalMaxValue += maxHeap.top();\n        maxHeap.pop();\n        numberOfCoins--;\n    }\n    return totalMaxValue;\n}",
    "output": "#include <bits/stdc++.h>\nint maxCoins(std::vector<std::vector<int>> &coinPiles, int numberOfCoins)\n{\n    std::priority_queue<int> maxHeap;\n    for(const auto &pile : coinPiles)\n    {\n        for(const auto &coin : pile)\n        {\n            maxHeap.push(coin);\n        }\n    }\n\n    int totalMaxValue = 0;\n    while(numberOfCoins > 0)\n    {\n        totalMaxValue += maxHeap.top();\n        maxHeap.pop();\n        numberOfCoins--;\n    }\n    return totalMaxValue;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxWordsInSentence(vector<string> &sentences)\n{\n    int maxWordsCount = 0;\n    for (int i = 0; i < sentences.size(); ++i)\n    {\n        const string &sentence = sentences[i];\n        istringstream inputStringStream(sentence);\n        int wordCount = 0;\n        string word;\n        while (inputStringStream >> word)\n        {\n            wordCount++;\n        }\n        maxWordsCount = max(maxWordsCount, wordCount);\n    }\n    return maxWordsCount;\n}",
    "output": "#include <bits/stdc++.h>\nint maxWordsInSentence(std::vector<std::string> &sentences)\n{\n    int maxWordsCount= 0;\n    for(const std::string &sentence : sentences)\n    {\n        std::istringstream inputStringStream(sentence);\n        int wordCount= 0;\n        std::string word;\n        while(inputStringStream >> word)\n        {\n            wordCount++;\n        }\n        maxWordsCount= std::max(maxWordsCount, wordCount);\n    }\n    return maxWordsCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> makeableRecipes(vector<string> &recipeNames, vector<vector<string>> &ingredientList, vector<string> &availableSupplies)\n{\n    unordered_map<string, unordered_set<string>> recipeDependencies;\n    unordered_set<string> availableIngredients(availableSupplies.begin(), availableSupplies.end());\n    for(size_t index= 0; index < recipeNames.size(); ++index)\n    {\n        recipeDependencies[recipeNames[index]] = unordered_set<string>(ingredientList[index].begin(), ingredientList[index].end());\n    }\n\n    queue<string> queue;\n    for (size_t i = 0; i < availableIngredients.size(); ++i) // Changed to traditional for loop\n    {\n        queue.push(*(availableIngredients.begin()++)); // Using iterator to access elements\n    }\n\n    while(!queue.empty())\n    {\n        const string currentIngredient = queue.front();\n        queue.pop();\n        for(auto it = recipeDependencies.begin(); it != recipeDependencies.end(); ++it) // Changed to traditional for loop\n        {\n            if(it->second.count(currentIngredient))\n            {\n                it->second.erase(currentIngredient);\n                if(it->second.empty())\n                {\n                    availableIngredients.insert(it->first);\n                    queue.push(it->first);\n                }\n            }\n        }\n    }\n\n    vector<string> result;\n    for(size_t i = 0; i < recipeNames.size(); ++i) // Changed to traditional for loop\n    {\n        if(availableIngredients.count(recipeNames[i]))\n        {\n            result.push_back(recipeNames[i]);\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> makeableRecipes(std::vector<std::string> &recipeNames, std::vector<std::vector<std::string>> &ingredientList, std::vector<std::string> &availableSupplies)\n{\n    std::unordered_map<std::string, std::unordered_set<std::string>> recipeDependencies;\n    std::unordered_set<std::string> availableIngredients(availableSupplies.begin(), availableSupplies.end());\n    for(size_t index= 0; index < recipeNames.size(); ++index)\n    {\n        recipeDependencies[recipeNames[index]]= std::unordered_set<std::string>(ingredientList[index].begin(), ingredientList[index].end());\n    }\n\n    std::queue<std::string> queue;\n    for(const auto &supply : availableIngredients)\n    {\n        queue.push(supply);\n    }\n\n    while(!queue.empty())\n    {\n        const std::string currentIngredient= queue.front();\n        queue.pop();\n        for(const auto &recipe : recipeDependencies)\n        {\n            if(recipe.second.count(currentIngredient))\n            {\n                recipe.second.erase(currentIngredient);\n                if(recipe.second.empty())\n                {\n                    availableIngredients.insert(recipe.first);\n                    queue.push(recipe.first);\n                }\n            }\n        }\n    }\n\n    std::vector<std::string> result;\n    for(const auto &recipe : recipeNames)\n    {\n        if(availableIngredients.count(recipe))\n        {\n            result.push_back(recipe);\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidParenthesesString(string parenthesesString, string lockStatus)\n{\n    int balanceCount= 0;\n    for(int index= 0; index < parenthesesString.length(); index++)\n    {\n        if(lockStatus[index] == '0')\n        {\n            parenthesesString[index] == '(' ? balanceCount++ : balanceCount--;\n            if(balanceCount < 0)\n                return false;\n        }\n    }\n    return balanceCount == 0;\n}",
    "output": "bool isValidParenthesesString(std::string parenthesesString, std::string lockStatus)\n{\n    int balanceCount= 0;\n    for(int index= 0; index < parenthesesString.length(); index++)\n    {\n        if(lockStatus[index] == '0')\n        {\n            parenthesesString[index] == '(' ? balanceCount++ : balanceCount--;\n            if(balanceCount < 0)\n                return false;\n        }\n    }\n    return balanceCount == 0;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring getAbbreviatedProduct(int startValue, int endValue)\n{\n    long long totalProduct = 1;\n    for(int currentValue = startValue; currentValue <= endValue; ++currentValue)\n    {\n        totalProduct *= currentValue;\n    }\n    return to_string(totalProduct);\n}",
    "output": "#include <bits/stdc++.h>\nstd::string getAbbreviatedProduct(int startValue, int endValue)\n{\n    long long totalProduct= 1;\n    for(int currentValue= startValue; currentValue <= endValue; ++currentValue)\n    {\n        totalProduct*= currentValue;\n    }\n    return std::to_string(totalProduct);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateStringSumScores(const string &inputString)\n{\n    int totalScore= 0;\n    int consecutivePrefixLength= 0;\n\n    for(int index= inputString.size() - 1; index >= 0; index--)\n    {\n        if(inputString[index] == inputString[inputString.size() - 1])\n        {\n            consecutivePrefixLength++;\n        }\n        else\n        {\n            consecutivePrefixLength= 0;\n        }\n        totalScore+= consecutivePrefixLength;\n    }\n    return totalScore;\n}",
    "output": "int calculateStringSumScores(const std::string &inputString)\n{\n    int totalScore= 0;\n    int consecutivePrefixLength= 0;\n\n    for(int index= inputString.size() - 1; index >= 0; index--)\n    {\n        if(inputString[index] == inputString[inputString.size() - 1])\n        {\n            consecutivePrefixLength++;\n        }\n        else\n        {\n            consecutivePrefixLength= 0;\n        }\n        totalScore+= consecutivePrefixLength;\n    }\n    return totalScore;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumOperations(string currentTime, string targetTime)\n{\n    int currentHours= stoi(currentTime.substr(0, 2)), currentMinutes= stoi(currentTime.substr(3));\n    int targetHours= stoi(targetTime.substr(0, 2)), targetMinutes= stoi(targetTime.substr(3));\n    int currentTotalMinutes= currentHours * 60 + currentMinutes, targetTotalMinutes= targetHours * 60 + targetMinutes;\n\n    int operationCount= 0;\n    while(currentTotalMinutes < targetTotalMinutes)\n    {\n        if(targetTotalMinutes - currentTotalMinutes >= 60)\n            currentTotalMinutes+= 60;\n        else if(targetTotalMinutes - currentTotalMinutes >= 15)\n            currentTotalMinutes+= 15;\n        else if(targetTotalMinutes - currentTotalMinutes >= 5)\n            currentTotalMinutes+= 5;\n        else\n            currentTotalMinutes+= 1;\n\n        operationCount++;\n    }\n    return operationCount;\n}",
    "output": "#include <bits/stdc++.h>\nint calculateMinimumOperations(std::string currentTime, std::string targetTime)\n{\n    int currentHours= std::stoi(currentTime.substr(0, 2)), currentMinutes= std::stoi(currentTime.substr(3));\n    int targetHours= std::stoi(targetTime.substr(0, 2)), targetMinutes= std::stoi(targetTime.substr(3));\n    int currentTotalMinutes= currentHours * 60 + currentMinutes, targetTotalMinutes= targetHours * 60 + targetMinutes;\n\n    int operationCount= 0;\n    while(currentTotalMinutes < targetTotalMinutes)\n    {\n        if(targetTotalMinutes - currentTotalMinutes >= 60)\n            currentTotalMinutes+= 60;\n        else if(targetTotalMinutes - currentTotalMinutes >= 15)\n            currentTotalMinutes+= 15;\n        else if(targetTotalMinutes - currentTotalMinutes >= 5)\n            currentTotalMinutes+= 5;\n        else\n            currentTotalMinutes+= 1;\n\n        operationCount++;\n    }\n    return operationCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<set<int>> twoLists(vector<vector<int>> &matchResults)\n{\n    unordered_map<int, int> lossCountMap;\n    set<int> participantSet;\n\n    for (auto &match : matchResults)\n    {\n        int winningParticipant = match[0];\n        int losingParticipant = match[1];\n        lossCountMap[losingParticipant]++;\n        participantSet.insert(winningParticipant);\n        participantSet.insert(losingParticipant);\n    }\n\n    set<int> noLossesSet;\n    set<int> oneLossSet;\n\n    for (set<int>::iterator it = participantSet.begin(); it != participantSet.end(); ++it)\n    {\n        int participant = *it;\n        if (lossCountMap[participant] == 0)\n        {\n            noLossesSet.insert(participant);\n        }\n        else if (lossCountMap[participant] == 1)\n        {\n            oneLossSet.insert(participant);\n        }\n    }\n\n    return {noLossesSet, oneLossSet};\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::set<int>> twoLists(std::vector<std::vector<int>> &matchResults)\n{\n    std::unordered_map<int, int> lossCountMap;\n    std::set<int> participantSet;\n\n    for(auto &match : matchResults)\n    {\n        int winningParticipant= match[0];\n        int losingParticipant= match[1];\n        lossCountMap[losingParticipant]++;\n        participantSet.insert(winningParticipant);\n        participantSet.insert(losingParticipant);\n    }\n\n    std::set<int> noLossesSet;\n    std::set<int> oneLossSet;\n\n    for(int participant : participantSet)\n    {\n        if(lossCountMap[participant] == 0)\n        {\n            noLossesSet.insert(participant);\n        }\n        else if(lossCountMap[participant] == 1)\n        {\n            oneLossSet.insert(participant);\n        }\n    }\n\n    return {noLossesSet, oneLossSet};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countRodsWithAllColors(const string &rings)\n{\n    int rodColors[10]= {0};\n\n    for(size_t index= 0; index < rings.length(); index+= 2)\n    {\n        int color= rings[index] - 'A';\n        int rod= rings[index + 1] - '0';\n\n        rodColors[rod]|= (1 << color);\n    }\n\n    return count(rodColors, rodColors + 10, 7);\n}",
    "output": "#include <bits/stdc++.h>\nint countRodsWithAllColors(const std::string &rings)\n{\n    int rodColors[10]= {0};\n\n    for(size_t index= 0; index < rings.length(); index+= 2)\n    {\n        int color= rings[index] - 'A';\n        int rod= rings[index + 1] - '0';\n\n        rodColors[rod]|= (1 << color);\n    }\n\n    return std::count(rodColors, rodColors + 10, 7);\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint sumOfSubarrayRanges(vector<int> &numbers)\n{\n    int size= numbers.size();\n    int totalSum= 0;\n    for(int startIndex= 0; startIndex < size; ++startIndex)\n    {\n        for(int endIndex= startIndex; endIndex < size; ++endIndex)\n        {\n            totalSum+= *max_element(numbers.begin() + startIndex, numbers.begin() + endIndex + 1) -\n                       *min_element(numbers.begin() + startIndex, numbers.begin() + endIndex + 1);\n        }\n    }\n    return totalSum;\n}",
    "output": "#include <bits/stdc++.h>\nint sumOfSubarrayRanges(std::vector<int> &numbers)\n{\n    int size= numbers.size();\n    int totalSum= 0;\n    for(int startIndex= 0; startIndex < size; ++startIndex)\n    {\n        for(int endIndex= startIndex; endIndex < size; ++endIndex)\n        {\n            totalSum+= *std::max_element(numbers.begin() + startIndex, numbers.begin() + endIndex + 1) -\n                       *std::min_element(numbers.begin() + startIndex, numbers.begin() + endIndex + 1);\n        }\n    }\n    return totalSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxFruits(vector<vector<int>> &fruitPositions, int startPosition, int maxDistance)\n{\n    int numberOfFruits= fruitPositions.size();\n    vector<int> fruitsOnLeft(numberOfFruits + 1, 0), fruitsOnRight(numberOfFruits + 1, 0);\n    int rightIndex= 0;\n\n    for(int currentIndex= 0; currentIndex < numberOfFruits; currentIndex++)\n    {\n        while(rightIndex < numberOfFruits && fruitPositions[rightIndex][0] - fruitPositions[currentIndex][0] <= maxDistance)\n        {\n            fruitsOnRight[currentIndex + 1]+= fruitPositions[rightIndex][1];\n            rightIndex++;\n        }\n        fruitsOnRight[currentIndex + 1]+= fruitsOnRight[currentIndex];\n        if(rightIndex < numberOfFruits && fruitPositions[rightIndex][0] - startPosition <= maxDistance)\n        {\n            fruitsOnRight[0]+= fruitPositions[rightIndex][1];\n            rightIndex++;\n        }\n    }\n\n    rightIndex= numberOfFruits - 1;\n    for(int currentIndex= numberOfFruits - 1; currentIndex >= 0; currentIndex--)\n    {\n        while(rightIndex >= 0 && fruitPositions[rightIndex][0] - fruitPositions[currentIndex][0] <= maxDistance)\n        {\n            fruitsOnLeft[currentIndex]+= fruitPositions[rightIndex][1];\n            rightIndex--;\n        }\n        fruitsOnLeft[currentIndex]+= fruitsOnLeft[currentIndex + 1];\n    }\n\n    int maximumFruits= 0;\n    for(int currentIndex= 0; currentIndex < numberOfFruits; currentIndex++)\n    {\n        int remainingDistance= max(0, maxDistance - abs(fruitPositions[currentIndex][0] - startPosition));\n        int upperBoundIndex= upper_bound(fruitPositions.begin(), fruitPositions.end(), vector<int>{fruitPositions[currentIndex][0] + remainingDistance, 0}) - fruitPositions.begin();\n        maximumFruits= max(maximumFruits, fruitsOnLeft[currentIndex] + fruitsOnRight[upperBoundIndex]);\n    }\n    return maximumFruits;\n}",
    "output": "#include <bits/stdc++.h>\nint maxFruits(std::vector<std::vector<int>> &fruitPositions, int startPosition, int maxDistance)\n{\n    int numberOfFruits = fruitPositions.size();\n    std::vector<int> fruitsOnLeft(numberOfFruits + 1, 0), fruitsOnRight(numberOfFruits + 1, 0);\n    int rightIndex = 0;\n\n    for(int currentIndex = 0; currentIndex < numberOfFruits; currentIndex++)\n    {\n        while(rightIndex < numberOfFruits && fruitPositions[rightIndex][0] - fruitPositions[currentIndex][0] <= maxDistance)\n        {\n            fruitsOnRight[currentIndex + 1] += fruitPositions[rightIndex][1];\n            rightIndex++;\n        }\n        fruitsOnRight[currentIndex + 1] += fruitsOnRight[currentIndex];\n        if(rightIndex < numberOfFruits && fruitPositions[rightIndex][0] - startPosition <= maxDistance)\n        {\n            fruitsOnRight[0] += fruitPositions[rightIndex][1];\n            rightIndex++;\n        }\n    }\n\n    rightIndex = numberOfFruits - 1;\n    for(int currentIndex = numberOfFruits - 1; currentIndex >= 0; currentIndex--)\n    {\n        while(rightIndex >= 0 && fruitPositions[rightIndex][0] - fruitPositions[currentIndex][0] <= maxDistance)\n        {\n            fruitsOnLeft[currentIndex] += fruitPositions[rightIndex][1];\n            rightIndex--;\n        }\n        fruitsOnLeft[currentIndex] += fruitsOnLeft[currentIndex + 1];\n    }\n\n    int maximumFruits = 0;\n    for(int currentIndex = 0; currentIndex < numberOfFruits; currentIndex++)\n    {\n        int remainingDistance = std::max(0, maxDistance - abs(fruitPositions[currentIndex][0] - startPosition));\n        int upperBoundIndex = std::upper_bound(fruitPositions.begin(), fruitPositions.end(), std::vector<int>{fruitPositions[currentIndex][0] + remainingDistance, 0}) - fruitPositions.begin();\n        maximumFruits = std::max(maximumFruits, fruitsOnLeft[currentIndex] + fruitsOnRight[upperBoundIndex]);\n    }\n    return maximumFruits;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// Include for std::reverse\nusing namespace std;\n\nstring findFirstPalindrome(const vector<string> &wordList)\n{\n    for (int i = 0; i < wordList.size(); ++i)\n    {\n        const string &currentWord = wordList[i];\n        string reversedWord = currentWord;\n        reverse(reversedWord.begin(), reversedWord.end());\n        if (currentWord == reversedWord)\n        {\n            return currentWord;\n        }\n    }\n    return \"\";\n}",
    "output": "#include <bits/stdc++.h>\nstd::string findFirstPalindrome(const std::vector<std::string> &wordList)\n{\n    for(const std::string &currentWord : wordList)\n    {\n        std::string reversedWord= currentWord;\n        std::reverse(reversedWord.begin(), reversedWord.end());\n        if(currentWord == reversedWord)\n        {\n            return currentWord;\n        }\n    }\n    return \"\";\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring addSpaces(const string &inputString, const vector<int> &spaceIndices)\n{\n    string resultString;\n    int spaceIndex= 0;\n    for(int currentIndex= 0; currentIndex < inputString.size(); currentIndex++)\n    {\n        while(spaceIndex < spaceIndices.size() && currentIndex == spaceIndices[spaceIndex])\n        {\n            resultString+= ' ';\n            spaceIndex++;\n        }\n        resultString+= inputString[currentIndex];\n    }\n    return resultString;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string addSpaces(const std::string &inputString, const std::vector<int> &spaceIndices)\n{\n    std::string resultString;\n    int spaceIndex= 0;\n    for(int currentIndex= 0; currentIndex < inputString.size(); currentIndex++)\n    {\n        while(spaceIndex < spaceIndices.size() && currentIndex == spaceIndices[spaceIndex])\n        {\n            resultString+= ' ';\n            spaceIndex++;\n        }\n        resultString+= inputString[currentIndex];\n    }\n    return resultString;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint smoothDescentPeriods(vector<int> &priceList)\n{\n    int descentPeriodCount = 0;\n    for(int currentIndex = 1; currentIndex < priceList.size(); ++currentIndex)\n    {\n        if(priceList[currentIndex] == priceList[currentIndex - 1] - 1)\n        {\n            while(currentIndex < priceList.size() && priceList[currentIndex] == priceList[currentIndex - 1] - 1)\n            {\n                currentIndex++;\n            }\n            descentPeriodCount++;\n        }\n    }\n    return descentPeriodCount;\n}",
    "output": "#include <bits/stdc++.h>\nint smoothDescentPeriods(std::vector<int> &priceList)\n{\n    int descentPeriodCount= 0;\n    for(int currentIndex= 1; currentIndex < priceList.size(); ++currentIndex)\n    {\n        if(priceList[currentIndex] == priceList[currentIndex - 1] - 1)\n        {\n            while(currentIndex < priceList.size() && priceList[currentIndex] == priceList[currentIndex - 1] - 1)\n            {\n                currentIndex++;\n            }\n            descentPeriodCount++;\n        }\n    }\n    return descentPeriodCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperationsToKIncreasing(vector<int> &inputArray, int step)\n{\n    int totalOperations= 0;\n    for(int currentIndex= step; currentIndex < inputArray.size(); currentIndex++)\n    {\n        if(inputArray[currentIndex] <= inputArray[currentIndex - step])\n        {\n            totalOperations+= (inputArray[currentIndex - step] - inputArray[currentIndex] + 1);\n            inputArray[currentIndex]= inputArray[currentIndex - step] + 1;\n        }\n    }\n    return totalOperations;\n}",
    "output": "#include <bits/stdc++.h>\nint minOperationsToKIncreasing(std::vector<int> &inputArray, int step)\n{\n    int totalOperations= 0;\n    for(int currentIndex= step; currentIndex < inputArray.size(); currentIndex++)\n    {\n        if(inputArray[currentIndex] <= inputArray[currentIndex - step])\n        {\n            totalOperations+= (inputArray[currentIndex - step] - inputArray[currentIndex] + 1);\n            inputArray[currentIndex]= inputArray[currentIndex - step] + 1;\n        }\n    }\n    return totalOperations;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring capitalizeTitle(string title)\n{\n    bool isNewWord= true;\n    for(int index= 0; index < title.length(); ++index)\n    {\n        if(isNewWord && isalpha(title[index]))\n        {\n            title[index]= toupper(title[index]);\n            isNewWord= false;\n        }\n        else if(title[index] == ' ')\n        {\n            isNewWord= true;\n        }\n        else\n        {\n            title[index]= tolower(title[index]);\n        }\n    }\n    return title;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string capitalizeTitle(std::string title)\n{\n    bool isNewWord = true;\n    for(int index = 0; index < title.length(); ++index)\n    {\n        if(isNewWord && std::isalpha(title[index]))\n        {\n            title[index] = std::toupper(title[index]);\n            isNewWord = false;\n        }\n        else if(title[index] == ' ')\n        {\n            isNewWord = true;\n        }\n        else\n        {\n            title[index] = std::tolower(title[index]);\n        }\n    }\n    return title;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int maxTwinSum(ListNode *head)\n{\n    int currentSum= 0, maxSum= 0, nodeCount= 0;\n    ListNode *slowPointer= head, *fastPointer= head;\n\n    while(fastPointer && fastPointer->next)\n    {\n        fastPointer= fastPointer->next->next;\n        nodeCount++;\n    }\n\n    for(int index= 0; index < nodeCount; index++)\n    {\n        currentSum= slowPointer->val + fastPointer->val;\n        maxSum= max(maxSum, currentSum);\n        slowPointer= slowPointer->next;\n        fastPointer= fastPointer->prev;\n    }\n\n    return maxSum;\n}",
    "output": "int maxTwinSum(ListNode *head)\n{\n    int currentSum= 0, maxSum= 0, nodeCount= 0;\n    ListNode *slowPointer= head, *fastPointer= head;\n\n    while(fastPointer && fastPointer->next)\n    {\n        fastPointer= fastPointer->next->next;\n        nodeCount++;\n    }\n\n    for(int index= 0; index < nodeCount; index++)\n    {\n        currentSum= slowPointer->val + fastPointer->val;\n        maxSum= max(maxSum, currentSum);\n        slowPointer= slowPointer->next;\n        fastPointer= fastPointer->prev;\n    }\n\n    return maxSum;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint longestPalindrome(vector<string> &wordList)\n{\n    unordered_map<char, int> characterCount;\n    int totalLength = 0;\n    bool hasOddCount = false;\n\n    for (int i = 0; i < wordList.size(); ++i)\n    {\n        characterCount[wordList[i][0]]++;\n        characterCount[wordList[i][1]]++;\n    }\n\n    for (auto it = characterCount.begin(); it != characterCount.end(); ++it)\n    {\n        totalLength += it->second / 2 * 2;\n        hasOddCount |= it->second % 2;\n    }\n\n    return totalLength + hasOddCount;\n}",
    "output": "#include <bits/stdc++.h>\nint longestPalindrome(std::vector<std::string> &wordList)\n{\n    std::unordered_map<char, int> characterCount;\n    int totalLength= 0;\n    bool hasOddCount= false;\n\n    for(const auto &word : wordList)\n    {\n        characterCount[word[0]]++;\n        characterCount[word[1]]++;\n    }\n\n    for(const auto &charPair : characterCount)\n    {\n        totalLength+= charPair.second / 2 * 2;\n        hasOddCount|= charPair.second % 2;\n    }\n\n    return totalLength + hasOddCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> calculateRobotInstructions(int gridSize, vector<int> &startingPosition, const string &movements)\n{\n    vector<int> instructionCount(movements.length(), 0);\n\n    for(int currentIndex= 0; currentIndex < movements.length(); ++currentIndex)\n    {\n        int currentRow= startingPosition[0];\n        int currentCol= startingPosition[1];\n\n        for(int movementIndex= currentIndex; movementIndex < movements.length(); ++movementIndex)\n        {\n            if(movements[movementIndex] == 'L')\n                --currentCol;\n            else if(movements[movementIndex] == 'R')\n                ++currentCol;\n            else if(movements[movementIndex] == 'U')\n                --currentRow;\n            else if(movements[movementIndex] == 'D')\n                ++currentRow;\n\n            if(currentRow < 0 || currentRow >= gridSize || currentCol < 0 || currentCol >= gridSize)\n            {\n                break;\n            }\n\n            instructionCount[currentIndex]++;\n        }\n    }\n\n    return instructionCount;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> calculateRobotInstructions(int gridSize, std::vector<int> &startingPosition, const std::string &movements)\n{\n    std::vector<int> instructionCount(movements.length(), 0);\n\n    for(int currentIndex= 0; currentIndex < movements.length(); ++currentIndex)\n    {\n        int currentRow= startingPosition[0];\n        int currentCol= startingPosition[1];\n\n        for(int movementIndex= currentIndex; movementIndex < movements.length(); ++movementIndex)\n        {\n            if(movements[movementIndex] == 'L')\n                --currentCol;\n            else if(movements[movementIndex] == 'R')\n                ++currentCol;\n            else if(movements[movementIndex] == 'U')\n                --currentRow;\n            else if(movements[movementIndex] == 'D')\n                ++currentRow;\n\n            if(currentRow < 0 || currentRow >= gridSize || currentCol < 0 || currentCol >= gridSize)\n            {\n                break;\n            }\n\n            instructionCount[currentIndex]++;\n        }\n    }\n\n    return instructionCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> sumOfIntervals(vector<int> &inputArray)\n{\n    int arraySize = inputArray.size();\n    vector<vector<int>> indexGroups(101);\n    vector<int> intervalSums(arraySize, 0);\n\n    for(int i = 0; i < arraySize; ++i)\n    {\n        indexGroups[inputArray[i]].push_back(i);\n    }\n\n    for(int i = 0; i < arraySize; ++i)\n    {\n        for(int j = 0; j < indexGroups[inputArray[i]].size(); ++j)\n        {\n            int index = indexGroups[inputArray[i]][j];\n            intervalSums[i] += abs(index - i);\n        }\n    }\n\n    return intervalSums;\n}",
    "output": "#include <bits/stdc++.h>\n// for abs function\n\nstd::vector<int> sumOfIntervals(std::vector<int> &inputArray)\n{\n    int arraySize = inputArray.size();\n    std::vector<std::vector<int>> indexGroups(101);\n    std::vector<int> intervalSums(arraySize, 0);\n\n    for(int i = 0; i < arraySize; ++i)\n    {\n        indexGroups[inputArray[i]].push_back(i);\n    }\n\n    for(int i = 0; i < arraySize; ++i)\n    {\n        for(int index : indexGroups[inputArray[i]])\n        {\n            intervalSums[i] += std::abs(index - i);\n        }\n    }\n\n    return intervalSums;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> recoverArray(int arraySize, vector<int> &inputNumbers)\n{\n    sort(inputNumbers.begin(), inputNumbers.end());\n    vector<int> recoveredArray(arraySize);\n    for(int currentIndex= 0; currentIndex < arraySize; ++currentIndex)\n    {\n        recoveredArray[currentIndex]= inputNumbers[currentIndex * 2];\n    }\n    return recoveredArray;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> recoverArray(int arraySize, std::vector<int> &inputNumbers)\n{\n    std::sort(inputNumbers.begin(), inputNumbers.end());\n    std::vector<int> recoveredArray(arraySize);\n    for(int currentIndex= 0; currentIndex < arraySize; ++currentIndex)\n    {\n        recoveredArray[currentIndex]= inputNumbers[currentIndex * 2];\n    }\n    return recoveredArray;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(vector<int> &scores, vector<vector<int>> &edges)\n{\n    vector<vector<int>> adjacencyList(scores.size());\n    int maximumResult = -1;\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        const auto &edge = edges[i];\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        const auto &edge = edges[i];\n        for (int j = 0; j < adjacencyList[edge[0]].size(); ++j)\n        {\n            int neighbor = adjacencyList[edge[0]][j];\n            for (int k = 0; k < adjacencyList[edge[1]].size(); ++k)\n            {\n                int next = adjacencyList[edge[1]][k];\n                if (next != neighbor && next != edge[0])\n                {\n                    maximumResult = max(maximumResult, scores[edge[0]] + scores[edge[1]] + scores[neighbor] + scores[next]);\n                }\n            }\n        }\n    }\n\n    return maximumResult;\n}",
    "output": "#include <bits/stdc++.h>\nint maxScore(std::vector<int> &scores, std::vector<std::vector<int>> &edges)\n{\n    std::vector<std::vector<int>> adjacencyList(scores.size());\n    int maximumResult= -1;\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    for(const auto &edge : edges)\n    {\n        for(int neighbor : adjacencyList[edge[0]])\n        {\n            for(int next : adjacencyList[edge[1]])\n            {\n                if(next != neighbor && next != edge[0])\n                {\n                    maximumResult= std::max(maximumResult, scores[edge[0]] + scores[edge[1]] + scores[neighbor] + scores[next]);\n                }\n            }\n        }\n    }\n\n    return maximumResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isAOnlyBeforeB(const string &inputString)\n{\n    int lastIndexOfA= -1;\n    for(size_t currentIndex= 0; currentIndex < inputString.length(); ++currentIndex)\n    {\n        if(inputString[currentIndex] == 'a')\n        {\n            lastIndexOfA= currentIndex;\n        }\n        else if(inputString[currentIndex] == 'b' && lastIndexOfA > -1)\n        {\n            return false;\n        }\n    }\n    return true;\n}",
    "output": "bool isAOnlyBeforeB(const std::string &inputString)\n{\n    int lastIndexOfA= -1;\n    for(size_t currentIndex= 0; currentIndex < inputString.length(); ++currentIndex)\n    {\n        if(inputString[currentIndex] == 'a')\n        {\n            lastIndexOfA= currentIndex;\n        }\n        else if(inputString[currentIndex] == 'b' && lastIndexOfA > -1)\n        {\n            return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numOfBeams(vector<string> &bank)\n{\n    int rowCount= bank.size();\n    int columnCount= bank[0].size();\n    int totalBeams= 0;\n\n    for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n    {\n        for(int columnIndex= 0; columnIndex < columnCount; ++columnIndex)\n        {\n            if(bank[rowIndex][columnIndex] == '1')\n            {\n                for(int nextColumnIndex= columnIndex + 1; nextColumnIndex < columnCount && bank[rowIndex][nextColumnIndex] != '1'; ++nextColumnIndex)\n                {\n                    totalBeams+= bank[rowIndex][nextColumnIndex] == '0';\n                }\n                for(int nextRowIndex= rowIndex + 1; nextRowIndex < rowCount && bank[nextRowIndex][columnIndex] != '1'; ++nextRowIndex)\n                {\n                    totalBeams+= bank[nextRowIndex][columnIndex] == '0';\n                }\n            }\n        }\n    }\n\n    return totalBeams;\n}",
    "output": "#include <bits/stdc++.h>\nint numOfBeams(std::vector<std::string> &bank)\n{\n    int rowCount= bank.size();\n    int columnCount= bank[0].size();\n    int totalBeams= 0;\n\n    for(int rowIndex= 0; rowIndex < rowCount; ++rowIndex)\n    {\n        for(int columnIndex= 0; columnIndex < columnCount; ++columnIndex)\n        {\n            if(bank[rowIndex][columnIndex] == '1')\n            {\n                for(int nextColumnIndex= columnIndex + 1; nextColumnIndex < columnCount && bank[rowIndex][nextColumnIndex] != '1'; ++nextColumnIndex)\n                {\n                    totalBeams+= bank[rowIndex][nextColumnIndex] == '0';\n                }\n                for(int nextRowIndex= rowIndex + 1; nextRowIndex < rowCount && bank[nextRowIndex][columnIndex] != '1'; ++nextRowIndex)\n                {\n                    totalBeams+= bank[nextRowIndex][columnIndex] == '0';\n                }\n            }\n        }\n    }\n\n    return totalBeams;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canDestroyAllAsteroids(int initialMass, vector<int> &asteroidList)\n{\n    sort(asteroidList.begin(), asteroidList.end());\n    for (int i = 0; i < asteroidList.size(); ++i)\n    {\n        int currentAsteroid = asteroidList[i];\n        if (initialMass >= currentAsteroid)\n        {\n            initialMass += currentAsteroid;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool canDestroyAllAsteroids(int initialMass, std::vector<int> &asteroidList)\n{\n    std::sort(asteroidList.begin(), asteroidList.end());\n    for(int currentAsteroid : asteroidList)\n    {\n        if(initialMass >= currentAsteroid)\n        {\n            initialMass += currentAsteroid;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxInvites(vector<int> &favoriteList)\n{\n    int numberOfPeople = favoriteList.size();\n    vector<int> inviteCount(numberOfPeople, 0);\n    int maxInvites = 0;\n\n    for(int personIndex = 0; personIndex < numberOfPeople; ++personIndex)\n    {\n        inviteCount[personIndex] = (personIndex == favoriteList[favoriteList[personIndex]]) ? 2 : 1;\n        maxInvites = max(maxInvites, inviteCount[personIndex]);\n    }\n\n    return maxInvites;\n}",
    "output": "#include <bits/stdc++.h>\nint maxInvites(std::vector<int> &favoriteList)\n{\n    int numberOfPeople= favoriteList.size();\n    std::vector<int> inviteCount(numberOfPeople, 0);\n    int maxInvites= 0;\n\n    for(int personIndex= 0; personIndex < numberOfPeople; ++personIndex)\n    {\n        inviteCount[personIndex]= (personIndex == favoriteList[favoriteList[personIndex]]) ? 2 : 1;\n        maxInvites= std::max(maxInvites, inviteCount[personIndex]);\n    }\n\n    return maxInvites;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int currentCity, int remainingHighways, int costSoFar, vector<vector<int>> &highways, vector<bool> &visited)\n{\n    if(remainingHighways == 0)\n    {\n        return costSoFar;\n    }\n\n    visited[currentCity] = true;\n    int maxCost = -1;\n\n    for (int i = 0; i < highways.size(); ++i)\n    {\n        vector<int> &highway = highways[i];\n        int nextCity = -1;\n        if(highway[0] == currentCity && !visited[highway[1]])\n        {\n            nextCity = highway[1];\n        }\n        else if(highway[1] == currentCity && !visited[highway[0]])\n        {\n            nextCity = highway[0];\n        }\n\n        if(nextCity != -1)\n        {\n            int cost = depthFirstSearch(nextCity, remainingHighways - 1, costSoFar + highway[2], highways, visited);\n            maxCost = max(maxCost, cost);\n        }\n    }\n\n    visited[currentCity] = false;\n    return maxCost;\n}\n\nint maxCost(int numberOfCities, vector<vector<int>> &highways, int numberOfHighways)\n{\n    vector<bool> visited(numberOfCities, false);\n    int maxCost = -1;\n\n    for(int i = 0; i < numberOfCities; i++)\n    {\n        int cost = depthFirstSearch(i, numberOfHighways, 0, highways, visited);\n        maxCost = max(maxCost, cost);\n    }\n\n    return maxCost;\n}",
    "output": "#include <bits/stdc++.h>\nint depthFirstSearch(int currentCity, int remainingHighways, int costSoFar, std::vector<std::vector<int>> &highways, std::vector<bool> &visited)\n{\n    if(remainingHighways == 0)\n    {\n        return costSoFar;\n    }\n\n    visited[currentCity]= true;\n    int maxCost= -1;\n\n    for(std::vector<int> &highway : highways)\n    {\n        int nextCity= -1;\n        if(highway[0] == currentCity && !visited[highway[1]])\n        {\n            nextCity= highway[1];\n        }\n        else if(highway[1] == currentCity && !visited[highway[0]])\n        {\n            nextCity= highway[0];\n        }\n\n        if(nextCity != -1)\n        {\n            int cost= depthFirstSearch(nextCity, remainingHighways - 1, costSoFar + highway[2], highways, visited);\n            maxCost= std::max(maxCost, cost);\n        }\n    }\n\n    visited[currentCity]= false;\n    return maxCost;\n}\n\nint maxCost(int numberOfCities, std::vector<std::vector<int>> &highways, int numberOfHighways)\n{\n    std::vector<bool> visited(numberOfCities, false);\n    int maxCost= -1;\n\n    for(int i= 0; i < numberOfCities; i++)\n    {\n        int cost= depthFirstSearch(i, numberOfHighways, 0, highways, visited);\n        maxCost= std::max(maxCost, cost);\n    }\n\n    return maxCost;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minCost(vector<int> &cost)\n{\n    sort(cost.begin(), cost.end(), greater<>());\n    int totalItems = cost.size();\n\n    int minimumCost = 0;\n\n    for(int index = 0; index < totalItems; index += 3)\n    {\n        minimumCost += cost[index];\n        if(index + 1 < totalItems)\n            minimumCost += cost[index + 1];\n    }\n\n    return minimumCost;\n}",
    "output": "#include <bits/stdc++.h>\nint minCost(std::vector<int> &cost)\n{\n    std::sort(cost.begin(), cost.end(), std::greater<>());\n    int totalItems= cost.size();\n\n    int minimumCost= 0;\n\n    for(int index= 0; index < totalItems; index+= 3)\n    {\n        minimumCost+= cost[index];\n        if(index + 1 < totalItems)\n            minimumCost+= cost[index + 1];\n    }\n\n    return minimumCost;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countSequences(vector<int> &differences, int lowerBound, int upperBound)\n{\n    int sequenceCount = 0, size = differences.size();\n    vector<int> hiddenValues(size + 1);\n\n    hiddenValues[0] = lowerBound;\n    while (true)\n    {\n        bool isValid = true;\n        for (int i = 1; i <= size; i++)\n        {\n            hiddenValues[i] = hiddenValues[i - 1] + differences[i - 1];\n            if (hiddenValues[i] < lowerBound || hiddenValues[i] > upperBound)\n            {\n                isValid = false;\n                break;\n            }\n        }\n        if (isValid)\n            sequenceCount++;\n\n        if (hiddenValues[0] == upperBound)\n            break;\n        hiddenValues[0]++;\n    }\n    return sequenceCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countSequences(std::vector<int> &differences, int lowerBound, int upperBound)\n{\n    int sequenceCount= 0, size= differences.size();\n    std::vector<int> hiddenValues(size + 1);\n\n    hiddenValues[0]= lowerBound;\n    while(true)\n    {\n        bool isValid= true;\n        for(int i= 1; i <= size; i++)\n        {\n            hiddenValues[i]= hiddenValues[i - 1] + differences[i - 1];\n            if(hiddenValues[i] < lowerBound || hiddenValues[i] > upperBound)\n            {\n                isValid= false;\n                break;\n            }\n        }\n        if(isValid)\n            sequenceCount++;\n\n        if(hiddenValues[0] == upperBound)\n            break;\n        hiddenValues[0]++;\n    }\n    return sequenceCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> findKHighestRankedItems(vector<vector<int>> &itemGrid, vector<int> &priceRange, vector<int> &startPosition, int k)\n{\n    int rowCount = itemGrid.size(), columnCount = itemGrid[0].size();\n    vector<vector<int>> movementDirections = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    vector<vector<int>> rankedItems;\n    priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> itemQueue;\n    vector<vector<bool>> visitedCells(rowCount, vector<bool>(columnCount));\n\n    itemQueue.push({0, -itemGrid[startPosition[0]][startPosition[1]], startPosition[0], startPosition[1]});\n    visitedCells[startPosition[0]][startPosition[1]] = true;\n\n    while (!itemQueue.empty() && k > 0)\n    {\n        int queueSize = itemQueue.size();\n        for (int i = 0; i < queueSize; i++)\n        {\n            auto currentItem = itemQueue.top();\n            itemQueue.pop();\n            int stepsTaken = currentItem[0], itemPrice = -currentItem[1], currentRow = currentItem[2], currentCol = currentItem[3];\n\n            if (itemPrice >= priceRange[0] && itemPrice <= priceRange[1])\n            {\n                rankedItems.push_back({currentRow, currentCol});\n                k--;\n            }\n\n            for (int j = 0; j < movementDirections.size(); j++)\n            {\n                int newRow = currentRow + movementDirections[j][0];\n                int newCol = currentCol + movementDirections[j][1];\n                if (newRow >= 0 && newRow < rowCount && newCol >= 0 && newCol < columnCount && !visitedCells[newRow][newCol])\n                {\n                    visitedCells[newRow][newCol] = true;\n                    itemQueue.push({stepsTaken + 1, -itemGrid[newRow][newCol], newRow, newCol});\n                }\n            }\n        }\n    }\n\n    return rankedItems;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> findKHighestRankedItems(std::vector<std::vector<int>> &itemGrid, std::vector<int> &priceRange, std::vector<int> &startPosition, int k)\n{\n    int rowCount = itemGrid.size(), columnCount = itemGrid[0].size();\n    std::vector<std::vector<int>> movementDirections = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    std::vector<std::vector<int>> rankedItems;\n    std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, std::greater<std::vector<int>>> itemQueue;\n    std::vector<std::vector<bool>> visitedCells(rowCount, std::vector<bool>(columnCount));\n\n    itemQueue.push({0, -itemGrid[startPosition[0]][startPosition[1]], startPosition[0], startPosition[1]});\n    visitedCells[startPosition[0]][startPosition[1]] = true;\n\n    while(!itemQueue.empty() && k > 0)\n    {\n        int queueSize = itemQueue.size();\n        for(int i = 0; i < queueSize; i++)\n        {\n            auto currentItem = itemQueue.top();\n            itemQueue.pop();\n            int stepsTaken = currentItem[0], itemPrice = -currentItem[1], currentRow = currentItem[2], currentCol = currentItem[3];\n\n            if(itemPrice >= priceRange[0] && itemPrice <= priceRange[1])\n            {\n                rankedItems.push_back({currentRow, currentCol});\n                k--;\n            }\n\n            for(const auto &direction : movementDirections)\n            {\n                int newRow = currentRow + direction[0];\n                int newCol = currentCol + direction[1];\n                if(newRow >= 0 && newRow < rowCount && newCol >= 0 && newCol < columnCount && !visitedCells[newRow][newCol])\n                {\n                    visitedCells[newRow][newCol] = true;\n                    itemQueue.push({stepsTaken + 1, -itemGrid[newRow][newCol], newRow, newCol});\n                }\n            }\n        }\n    }\n\n    return rankedItems;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod= 1e9 + 7;\n\nint corridorWays(string corridor)\n{\n    int corridorLength= corridor.size();\n    vector<int> ways(corridorLength + 1, 0);\n    ways[0]= 1;\n\n    int occupiedSeats= 0;\n    for(int index= 0; index < corridorLength; index++)\n    {\n        if(corridor[index] == 'S')\n        {\n            occupiedSeats++;\n            if(occupiedSeats % 2 == 0)\n            {\n                ways[index + 1]= ways[max(0, index - 1)];\n            }\n            ways[index + 1]= (ways[index + 1] + ways[index]) % mod;\n        }\n        else\n        {\n            ways[index + 1]= ways[index];\n        }\n    }\n\n    return ways[corridorLength];\n}",
    "output": "#include <bits/stdc++.h>\nconst int mod= 1e9 + 7;\n\nint corridorWays(std::string corridor)\n{\n    int corridorLength= corridor.size();\n    std::vector<int> ways(corridorLength + 1, 0);\n    ways[0]= 1;\n\n    int occupiedSeats= 0;\n    for(int index= 0; index < corridorLength; index++)\n    {\n        if(corridor[index] == 'S')\n        {\n            occupiedSeats++;\n            if(occupiedSeats % 2 == 0)\n            {\n                ways[index + 1]= ways[std::max(0, index - 1)];\n            }\n            ways[index + 1]= (ways[index + 1] + ways[index]) % mod;\n        }\n        else\n        {\n            ways[index + 1]= ways[index];\n        }\n    }\n\n    return ways[corridorLength];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidMatrix(vector<vector<int>> &inputMatrix)\n{\n    int matrixSize = inputMatrix.size();\n    for(int rowIndex = 0; rowIndex < matrixSize; ++rowIndex)\n    {\n        unordered_set<int> uniqueRowValues, uniqueColValues;\n        for(int colIndex = 0; colIndex < matrixSize; ++colIndex)\n        {\n            uniqueRowValues.insert(inputMatrix[rowIndex][colIndex]);\n            uniqueColValues.insert(inputMatrix[colIndex][rowIndex]);\n        }\n        if(uniqueRowValues.size() != matrixSize || uniqueColValues.size() != matrixSize)\n            return false;\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool isValidMatrix(std::vector<std::vector<int>> &inputMatrix)\n{\n    int matrixSize= inputMatrix.size();\n    for(int rowIndex= 0; rowIndex < matrixSize; ++rowIndex)\n    {\n        std::unordered_set<int> uniqueRowValues, uniqueColValues;\n        for(int colIndex= 0; colIndex < matrixSize; ++colIndex)\n        {\n            uniqueRowValues.insert(inputMatrix[rowIndex][colIndex]);\n            uniqueColValues.insert(inputMatrix[colIndex][rowIndex]);\n        }\n        if(uniqueRowValues.size() != matrixSize || uniqueColValues.size() != matrixSize)\n            return false;\n    }\n    return true;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minSwaps(vector<int> &numbers)\n{\n    int totalOnes = 0, maxOnesInWindow = 0, currentOnesInWindow = 0, leftPointer = 0;\n\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        totalOnes += numbers[i];\n    }\n\n    for (int rightPointer = 0; rightPointer < numbers.size(); ++rightPointer)\n    {\n        currentOnesInWindow += numbers[rightPointer];\n\n        if (rightPointer - leftPointer + 1 > totalOnes)\n        {\n            currentOnesInWindow -= numbers[leftPointer];\n            ++leftPointer;\n        }\n\n        maxOnesInWindow = max(maxOnesInWindow, currentOnesInWindow);\n    }\n\n    return totalOnes - maxOnesInWindow;\n}",
    "output": "#include <bits/stdc++.h>\nint minSwaps(std::vector<int> &numbers)\n{\n    int totalOnes= 0, maxOnesInWindow= 0, currentOnesInWindow= 0, leftPointer= 0;\n\n    for(int number : numbers)\n    {\n        totalOnes+= number;\n    }\n\n    for(int rightPointer= 0; rightPointer < numbers.size(); ++rightPointer)\n    {\n        currentOnesInWindow+= numbers[rightPointer];\n\n        if(rightPointer - leftPointer + 1 > totalOnes)\n        {\n            currentOnesInWindow-= numbers[leftPointer];\n            ++leftPointer;\n        }\n\n        maxOnesInWindow= std::max(maxOnesInWindow, currentOnesInWindow);\n    }\n\n    return totalOnes - maxOnesInWindow;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countConvertibleWords(vector<string> &startWords, vector<string> &targetWords)\n{\n    int convertibleCount = 0;\n    for (int i = 0; i < targetWords.size(); ++i)\n    {\n        const auto &targetWord = targetWords[i];\n        for (int j = 0; j < startWords.size(); ++j)\n        {\n            const auto &startWord = startWords[j];\n            if (startWord.length() + 1 == targetWord.length() && targetWord.substr(0, startWord.length()) == startWord)\n            {\n                convertibleCount++;\n                break;\n            }\n        }\n    }\n    return convertibleCount;\n}",
    "output": "#include <bits/stdc++.h>\nint countConvertibleWords(std::vector<std::string> &startWords, std::vector<std::string> &targetWords)\n{\n    int convertibleCount= 0;\n    for(const auto &targetWord : targetWords)\n    {\n        for(const auto &startWord : startWords)\n        {\n            if(startWord.length() + 1 == targetWord.length() && targetWord.substr(0, startWord.length()) == startWord)\n            {\n                convertibleCount++;\n                break;\n            }\n        }\n    }\n    return convertibleCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint earliestBloomingDay(vector<int> &plantTimes, vector<int> &growTimes)\n{\n    vector<int> bloomDays;\n    for(size_t index= 0; index < plantTimes.size(); index++)\n    {\n        bloomDays.push_back(plantTimes[index] + growTimes[index]);\n    }\n    sort(bloomDays.begin(), bloomDays.end());\n    int earliestDay= 0;\n    for(size_t index= 0; index < bloomDays.size(); index++)\n    {\n        earliestDay= max(earliestDay, bloomDays[index]);\n        earliestDay++;\n    }\n    return earliestDay;\n}",
    "output": "#include <bits/stdc++.h>\nint earliestBloomingDay(std::vector<int> &plantTimes, std::vector<int> &growTimes)\n{\n    std::vector<int> bloomDays;\n    for(size_t index= 0; index < plantTimes.size(); index++)\n    {\n        bloomDays.push_back(plantTimes[index] + growTimes[index]);\n    }\n    std::sort(bloomDays.begin(), bloomDays.end());\n    int earliestDay= 0;\n    for(size_t index= 0; index < bloomDays.size(); index++)\n    {\n        earliestDay= std::max(earliestDay, bloomDays[index]);\n        earliestDay++;\n    }\n    return earliestDay;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int directionX[]= {0, 1, 0, -1};\nconst int directionY[]= {1, 0, -1, 0};\n\nint getMaxSafeMinutes(vector<vector<int>> &grid)\n{\n    int rowCount= grid.size();\n    int columnCount= grid[0].size();\n\n    vector<vector<int>> distance(rowCount, vector<int>(columnCount, -1));\n    queue<pair<int, int>> positionQueue;\n\n    if(grid[rowCount - 1][columnCount - 1] != 1)\n    {\n        distance[rowCount - 1][columnCount - 1]= 0;\n        positionQueue.push({rowCount - 1, columnCount - 1});\n    }\n\n    while(!positionQueue.empty())\n    {\n        int currentX= positionQueue.front().first;\n        int currentY= positionQueue.front().second;\n        positionQueue.pop();\n        for(int direction= 0; direction < 4; direction++)\n        {\n            int nextX= currentX + directionX[direction];\n            int nextY= currentY + directionY[direction];\n            if(nextX >= 0 && nextX < rowCount && nextY >= 0 && nextY < columnCount && grid[nextX][nextY] == 0 && distance[nextX][nextY] == -1)\n            {\n                distance[nextX][nextY]= distance[currentX][currentY] + 1;\n                positionQueue.push({nextX, nextY});\n            }\n        }\n    }\n\n    if(distance[0][0] == -1)\n        return -1;\n\n    int result= 0;\n    for(int testMinute= distance[0][0]; testMinute < (int)1e9; testMinute++)\n    {\n        bool isSafe= true;\n        for(int row= 0; row < rowCount; row++)\n        {\n            for(int column= 0; column < columnCount; column++)\n            {\n                if(grid[row][column] == 1)\n                {\n                    ...",
    "output": "#include <bits/stdc++.h>\nconst int directionX[]= {0, 1, 0, -1};\nconst int directionY[]= {1, 0, -1, 0};\n\nint getMaxSafeMinutes(std::vector<std::vector<int>> &grid)\n{\n    int rowCount= grid.size();\n    int columnCount= grid[0].size();\n\n    std::vector<std::vector<int>> distance(rowCount, std::vector<int>(columnCount, -1));\n    std::queue<std::pair<int, int>> positionQueue;\n\n    if(grid[rowCount - 1][columnCount - 1] != 1)\n    {\n        distance[rowCount - 1][columnCount - 1]= 0;\n        positionQueue.push({rowCount - 1, columnCount - 1});\n    }\n\n    while(!positionQueue.empty())\n    {\n        int currentX= positionQueue.front().first;\n        int currentY= positionQueue.front().second;\n        positionQueue.pop();\n        for(int direction= 0; direction < 4; direction++)\n        {\n            int nextX= currentX + directionX[direction];\n            int nextY= currentY + directionY[direction];\n            if(nextX >= 0 && nextX < rowCount && nextY >= 0 && nextY < columnCount && grid[nextX][nextY] == 0 && distance[nextX][nextY] == -1)\n            {\n                distance[nextX][nextY]= distance[currentX][currentY] + 1;\n                positionQueue.push({nextX, nextY});\n            }\n        }\n    }\n\n    if(distance[0][0] == -1)\n        return -1;\n\n    int result= 0;\n    for(int testMinute= distance[0][0]; testMinute < (int)1e9; testMinute++)\n    {\n        bool isSafe= true;\n        for(int row= 0; row < rowCount; row++)\n        {\n            for(int column= 0; column < columnCount; column++)\n            {\n                if(grid[row][column] == 1)\n                }\n            }\n        }\n    }\n    return result;}\n"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring maxNumberAfterRemoveDigit(const string &originalNumber, const char digitToRemove)\n{\n    size_t digitIndex = originalNumber.find(digitToRemove);\n    string resultingNumber = originalNumber;\n    resultingNumber.erase(digitIndex, 1);\n    return resultingNumber;\n}",
    "output": "std::string maxNumberAfterRemoveDigit(const std::string &originalNumber, const char digitToRemove)\n{\n    size_t digitIndex= originalNumber.find(digitToRemove);\n    std::string resultingNumber= originalNumber;\n    resultingNumber.erase(digitIndex, 1);\n    return resultingNumber;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> partitionString(const string &inputString, int partitionSize, char fillCharacter)\n{\n    vector<string> stringPartitions;\n    string currentPartition;\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char character = inputString[i];\n        currentPartition += character;\n        if (currentPartition.size() == partitionSize)\n        {\n            stringPartitions.push_back(currentPartition);\n            currentPartition.clear();\n        }\n    }\n    if (!currentPartition.empty())\n    {\n        currentPartition += string(partitionSize - currentPartition.size(), fillCharacter);\n        stringPartitions.push_back(currentPartition);\n    }\n    return stringPartitions;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> partitionString(const std::string &inputString, int partitionSize, char fillCharacter)\n{\n    std::vector<std::string> stringPartitions;\n    std::string currentPartition;\n    for(char character : inputString)\n    {\n        currentPartition+= character;\n        if(currentPartition.size() == partitionSize)\n        {\n            stringPartitions.push_back(currentPartition);\n            currentPartition.clear();\n        }\n    }\n    if(!currentPartition.empty())\n    {\n        currentPartition+= std::string(partitionSize - currentPartition.size(), fillCharacter);\n        stringPartitions.push_back(currentPartition);\n    }\n    return stringPartitions;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> highestScoreDivisions(vector<int> &divisionScores)\n{\n    int zeroCount = 0, oneCount = 0;\n    for (int score : divisionScores)\n    {\n        if (score == 1)\n            oneCount++;\n    }\n\n    int maxScore = -1, currentScore = 0;\n    vector<int> maxScoreIndices;\n    for (int index = 0; index < divisionScores.size(); index++)\n    {\n        if (divisionScores[index] == 0)\n        {\n            currentScore++;\n        }\n        else\n        {\n            oneCount--;\n        }\n\n        if (currentScore > maxScore)\n        {\n            maxScore = currentScore;\n            maxScoreIndices.clear();\n            maxScoreIndices.push_back(index);\n        }\n        else if (currentScore == maxScore)\n        {\n            maxScoreIndices.push_back(index);\n        }\n    }\n    return maxScoreIndices;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> highestScoreDivisions(std::vector<int> &divisionScores)\n{\n    int zeroCount= 0, oneCount= 0;\n    for(int score : divisionScores)\n    {\n        if(score == 1)\n            oneCount++;\n    }\n\n    int maxScore= -1, currentScore= 0;\n    std::vector<int> maxScoreIndices;\n    for(int index= 0; index < divisionScores.size(); index++)\n    {\n        if(divisionScores[index] == 0)\n        {\n            currentScore++;\n        }\n        else\n        {\n            oneCount--;\n        }\n\n        if(currentScore > maxScore)\n        {\n            maxScore= currentScore;\n            maxScoreIndices.clear();\n            maxScoreIndices.push_back(index);\n        }\n        else if(currentScore == maxScore)\n        {\n            maxScoreIndices.push_back(index);\n        }\n    }\n    return maxScoreIndices;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPoints(vector<vector<int>> &questions)\n{\n    int numberOfQuestions = questions.size();\n    vector<int> dynamicProgramming(numberOfQuestions + 1, 0);\n\n    for(int questionIndex = numberOfQuestions - 1; questionIndex >= 0; questionIndex--)\n    {\n        int skipNextQuestionIndex = questionIndex + questions[questionIndex][1];\n        dynamicProgramming[questionIndex] = max(dynamicProgramming[questionIndex + 1], questions[questionIndex][0] + (skipNextQuestionIndex < numberOfQuestions ? dynamicProgramming[skipNextQuestionIndex] : 0));\n    }\n\n    return dynamicProgramming[0];\n}",
    "output": "#include <bits/stdc++.h>\nint maxPoints(std::vector<std::vector<int>> &questions)\n{\n    int numberOfQuestions= questions.size();\n    std::vector<int> dynamicProgramming(numberOfQuestions + 1, 0);\n\n    for(int questionIndex= numberOfQuestions - 1; questionIndex >= 0; questionIndex--)\n    {\n        int skipNextQuestionIndex= questionIndex + questions[questionIndex][1];\n        dynamicProgramming[questionIndex]= std::max(dynamicProgramming[questionIndex + 1], questions[questionIndex][0] + (skipNextQuestionIndex < numberOfQuestions ? dynamicProgramming[skipNextQuestionIndex] : 0));\n    }\n\n    return dynamicProgramming[0];\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxRunningTime(int numberOfDevices, vector<int> &batteryCapacities)\n{\n    sort(batteryCapacities.begin(), batteryCapacities.end(), greater<int>());\n    int totalRunningTime= 0;\n    for(int i= 0; i < numberOfDevices; ++i)\n    {\n        totalRunningTime+= batteryCapacities[i];\n    }\n    return totalRunningTime / numberOfDevices;\n}",
    "output": "#include <bits/stdc++.h>\nint maxRunningTime(int numberOfDevices, std::vector<int> &batteryCapacities)\n{\n    std::sort(batteryCapacities.begin(), batteryCapacities.end(), std::greater<int>());\n    int totalRunningTime= 0;\n    for(int i= 0; i < numberOfDevices; ++i)\n    {\n        totalRunningTime+= batteryCapacities[i];\n    }\n    return totalRunningTime / numberOfDevices;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int splitAndMinimize(int inputNumber)\n{\n    int thousandsPlace= inputNumber / 1000;\n    int hundredsPlace= (inputNumber % 1000) / 100;\n    int tensPlace= (inputNumber % 100) / 10;\n    int unitsPlace= inputNumber % 10;\n    return ((thousandsPlace * 10 + tensPlace) * 10 + hundredsPlace) * 10 + unitsPlace;\n}",
    "output": "int splitAndMinimize(int inputNumber)\n{\n    int thousandsPlace= inputNumber / 1000;\n    int hundredsPlace= (inputNumber % 1000) / 100;\n    int tensPlace= (inputNumber % 100) / 10;\n    int unitsPlace= inputNumber % 10;\n    return ((thousandsPlace * 10 + tensPlace) * 10 + hundredsPlace) * 10 + unitsPlace;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> rearrangeArrayAroundPivot(vector<int> &numbers, int pivot)\n{\n    partition(numbers.begin(), numbers.end(), [pivot](int currentNumber)\n              { return currentNumber < pivot; });\n    return numbers;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> rearrangeArrayAroundPivot(std::vector<int> &numbers, int pivot)\n{\n    std::partition(numbers.begin(), numbers.end(), [pivot](int currentNumber)\n                   { return currentNumber < pivot; });\n    return numbers;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "int minCost(int startAt, int moveCost, int pushCost, int targetSeconds)\n{\n    int minimumCost= INT_MAX;\n\n    for(int minutes= 0; minutes <= 99; minutes++)\n    {\n        for(int seconds= 0; seconds <= 99; seconds++)\n        {\n            if(minutes * 60 + seconds == targetSeconds)\n            {\n                int minuteMoveCost= abs(minutes - startAt) * moveCost;\n                int secondMoveCost= abs(seconds - minutes) * moveCost;\n                int totalPushCost= (seconds > 0 ? 2 : 0) + (seconds / 10 != 0 ? 1 : 0) + (minutes / 10 != 0 ? 1 : 0);\n\n                minimumCost= min(minimumCost, minuteMoveCost + secondMoveCost + totalPushCost * pushCost);\n            }\n        }\n    }\n    return minimumCost;\n}",
    "output": "int minCost(int startAt, int moveCost, int pushCost, int targetSeconds)\n{\n    int minimumCost= INT_MAX;\n\n    for(int minutes= 0; minutes <= 99; minutes++)\n    {\n        for(int seconds= 0; seconds <= 99; seconds++)\n        {\n            if(minutes * 60 + seconds == targetSeconds)\n            {\n                int minuteMoveCost= abs(minutes - startAt) * moveCost;\n                int secondMoveCost= abs(seconds - minutes) * moveCost;\n                int totalPushCost= (seconds > 0 ? 2 : 0) + (seconds / 10 != 0 ? 1 : 0) + (minutes / 10 != 0 ? 1 : 0);\n\n                minimumCost= min(minimumCost, minuteMoveCost + secondMoveCost + totalPushCost * pushCost);\n            }\n        }\n    }\n    return minimumCost;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minDifference(vector<int> &numbers)\n{\n    int groupSize= numbers.size() / 3;\n    vector<int> prefixSum(groupSize + 2), suffixSum(groupSize + 2);\n    multiset<int> slidingWindow;\n\n    for(int index= 0; index < groupSize; ++index)\n        slidingWindow.insert(numbers[index]);\n    prefixSum[0]= accumulate(begin(slidingWindow), end(slidingWindow), 0);\n\n    for(int index= groupSize, j= 1; index < 2 * groupSize; ++index, ++j)\n    {\n        slidingWindow.erase(slidingWindow.find(numbers[index - groupSize]));\n        slidingWindow.insert(numbers[index]);\n        prefixSum[j]= accumulate(begin(slidingWindow), end(slidingWindow), 0);\n    }\n\n    slidingWindow.clear();\n\n    for(int index= 0; index < groupSize; ++index)\n        slidingWindow.insert(numbers[3 * groupSize - index - 1]);\n    suffixSum[groupSize]= accumulate(begin(slidingWindow), end(slidingWindow), 0);\n\n    for(int index= groupSize - 1, j= 1; index < 2 * groupSize - 1; --index, ++j)\n    {\n        slidingWindow.erase(slidingWindow.find(numbers[3 * groupSize - j]));\n        slidingWindow.insert(numbers[2 * groupSize - j]);\n        suffixSum[index]= accumulate(begin(slidingWindow), end(slidingWindow), 0);\n    }\n\n    int minimumDifference= INT_MAX;\n\n    for(int index= 0; index <= groupSize; ++index)\n    {\n        minimumDifference= min(minimumDifference, abs(prefixSum[index] - suffixSum[index]));\n    }\n\n    return minimumDifference;\n}",
    "output": "#include <bits/stdc++.h>\nint minDifference(std::vector<int> &numbers)\n{\n    int groupSize= numbers.size() / 3;\n    std::vector<int> prefixSum(groupSize + 2), suffixSum(groupSize + 2);\n    std::multiset<int> slidingWindow;\n\n    for(int index= 0; index < groupSize; ++index)\n        slidingWindow.insert(numbers[index]);\n    prefixSum[0]= std::accumulate(std::begin(slidingWindow), std::end(slidingWindow), 0);\n\n    for(int index= groupSize, j= 1; index < 2 * groupSize; ++index, ++j)\n    {\n        slidingWindow.erase(slidingWindow.find(numbers[index - groupSize]));\n        slidingWindow.insert(numbers[index]);\n        prefixSum[j]= std::accumulate(std::begin(slidingWindow), std::end(slidingWindow), 0);\n    }\n\n    slidingWindow.clear();\n\n    for(int index= 0; index < groupSize; ++index)\n        slidingWindow.insert(numbers[3 * groupSize - index - 1]);\n    suffixSum[groupSize]= std::accumulate(std::begin(slidingWindow), std::end(slidingWindow), 0);\n\n    for(int index= groupSize - 1, j= 1; index < 2 * groupSize - 1; --index, ++j)\n    {\n        slidingWindow.erase(slidingWindow.find(numbers[3 * groupSize - j]));\n        slidingWindow.insert(numbers[2 * groupSize - j]);\n        suffixSum[index]= std::accumulate(std::begin(slidingWindow), std::end(slidingWindow), 0);\n    }\n\n    int minimumDifference= std::numeric_limits<int>::max();\n\n    for(int index= 0; index <= groupSize; ++index)\n    {\n        minimumDifference= std::min(minimumDifference, std::abs(prefixSum[index] - suffixSum[index]));\n    }\n\n    return minimumDifference;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minKeypresses(const string &inputString)\n{\n    vector<int> keypressCount(26);\n    for(int index = 0; index < 26; ++index)\n    {\n        keypressCount[index] = (index % 9) + 1;\n    }\n    int totalKeypresses = 0;\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentCharacter = inputString[i];\n        totalKeypresses += keypressCount[currentCharacter - 'a'];\n    }\n    return totalKeypresses;\n}",
    "output": "#include <bits/stdc++.h>\nint minKeypresses(const std::string &inputString)\n{\n    std::vector<int> keypressCount(26);\n    for(int index= 0; index < 26; ++index)\n    {\n        keypressCount[index]= (index % 9) + 1;\n    }\n    int totalKeypresses= 0;\n    for(char currentCharacter : inputString)\n    {\n        totalKeypresses+= keypressCount[currentCharacter - 'a'];\n    }\n    return totalKeypresses;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countElementsWithSmallerAndGreater(const vector<int> &numbers)\n{\n    int totalElements = numbers.size();\n    int resultCount = 0;\n    for (int currentIndex = 0; currentIndex < totalElements; currentIndex++)\n    {\n        bool hasSmaller = false, hasGreater = false;\n        for (int comparisonIndex = 0; comparisonIndex < totalElements; comparisonIndex++)\n        {\n            if (currentIndex == comparisonIndex)\n                continue;\n            if (numbers[comparisonIndex] > numbers[currentIndex])\n                hasGreater = true;\n            if (numbers[comparisonIndex] < numbers[currentIndex])\n                hasSmaller = true;\n            if (hasSmaller && hasGreater)\n            {\n                resultCount++;\n                break;\n            }\n        }\n    }\n    return resultCount;\n}",
    "output": "int countElementsWithSmallerAndGreater(const std::vector<int> &numbers)\n{\n    int totalElements= numbers.size();\n    int resultCount= 0;\n    for(int currentIndex= 0; currentIndex < totalElements; currentIndex++)\n    {\n        bool hasSmaller= false, hasGreater= false;\n        for(int comparisonIndex= 0; comparisonIndex < totalElements; comparisonIndex++)\n        {\n            if(currentIndex == comparisonIndex)\n                continue;\n            if(numbers[comparisonIndex] > numbers[currentIndex])\n                hasGreater= true;\n            if(numbers[comparisonIndex] < numbers[currentIndex])\n                hasSmaller= true;\n            if(hasSmaller && hasGreater)\n            {\n                resultCount++;\n                break;\n            }\n        }\n    }\n    return resultCount;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findLonelyNumbers(vector<int> &inputNumbers)\n{\n    unordered_set<int> numberSet(inputNumbers.begin(), inputNumbers.end());\n    vector<int> lonelyNumbers;\n    for (int i = 0; i < inputNumbers.size(); ++i)\n    {\n        int currentNumber = inputNumbers[i];\n        if (!numberSet.count(currentNumber - 1) && !numberSet.count(currentNumber + 1))\n        {\n            lonelyNumbers.push_back(currentNumber);\n        }\n    }\n    return lonelyNumbers;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findLonelyNumbers(std::vector<int> &inputNumbers)\n{\n    std::unordered_set<int> numberSet(inputNumbers.begin(), inputNumbers.end());\n    std::vector<int> lonelyNumbers;\n    for(int currentNumber : inputNumbers)\n    {\n        if(!numberSet.count(currentNumber - 1) && !numberSet.count(currentNumber + 1))\n        {\n            lonelyNumbers.push_back(currentNumber);\n        }\n    }\n    return lonelyNumbers;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> rearrangeArray(vector<int> &inputNumbers)\n{\n    vector<int> rearrangedResult(inputNumbers.size());\n    sort(inputNumbers.begin(), inputNumbers.end());\n    int halfSize = inputNumbers.size() / 2;\n    int index = 0;\n    for(int i = 0; i < halfSize; i++)\n    {\n        rearrangedResult[index] = inputNumbers[i];\n        rearrangedResult[index + 1] = inputNumbers[halfSize + i];\n        index += 2;\n    }\n    return rearrangedResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> rearrangeArray(std::vector<int> &inputNumbers)\n{\n    std::vector<int> rearrangedResult(inputNumbers.size());\n    std::sort(inputNumbers.begin(), inputNumbers.end());\n    int halfSize= inputNumbers.size() / 2;\n    int index= 0;\n    for(int i= 0; i < halfSize; i++)\n    {\n        rearrangedResult[index]= inputNumbers[i];\n        rearrangedResult[index + 1]= inputNumbers[halfSize + i];\n        index+= 2;\n    }\n    return rearrangedResult;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maximumGoodPeople(vector<vector<int>> &statements)\n{\n    int numberOfPeople= statements.size();\n    int countGoodPeople= 0;\n    for(int personIndex= 0; personIndex < numberOfPeople; personIndex++)\n    {\n        bool isGoodPerson= true;\n        for(int otherPersonIndex= 0; otherPersonIndex < numberOfPeople; otherPersonIndex++)\n        {\n            if(statements[otherPersonIndex][personIndex] == 1 && statements[personIndex][otherPersonIndex] == 0)\n            {\n                isGoodPerson= false;\n                break;\n            }\n        }\n        if(isGoodPerson)\n            countGoodPeople++;\n    }\n    return countGoodPeople;\n}",
    "output": "#include <bits/stdc++.h>\nint maximumGoodPeople(std::vector<std::vector<int>> &statements)\n{\n    int numberOfPeople= statements.size();\n    int countGoodPeople= 0;\n    for(int personIndex= 0; personIndex < numberOfPeople; personIndex++)\n    {\n        bool isGoodPerson= true;\n        for(int otherPersonIndex= 0; otherPersonIndex < numberOfPeople; otherPersonIndex++)\n        {\n            if(statements[otherPersonIndex][personIndex] == 1 && statements[personIndex][otherPersonIndex] == 0)\n            {\n                isGoodPerson= false;\n                break;\n            }\n        }\n        if(isGoodPerson)\n            countGoodPeople++;\n    }\n    return countGoodPeople;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> anagramOperations(vector<string> &wordList)\n{\n    for(int currentIndex= 1; currentIndex < wordList.size(); ++currentIndex)\n    {\n        string currentWord= wordList[currentIndex];\n        string previousWord= wordList[currentIndex - 1];\n        sort(currentWord.begin(), currentWord.end());\n        sort(previousWord.begin(), previousWord.end());\n        if(currentWord == previousWord)\n        {\n            wordList.erase(wordList.begin() + currentIndex);\n            --currentIndex;\n        }\n    }\n    return wordList;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> anagramOperations(std::vector<std::string> &wordList)\n{\n    for(int currentIndex= 1; currentIndex < wordList.size(); ++currentIndex)\n    {\n        std::string currentWord= wordList[currentIndex];\n        std::string previousWord= wordList[currentIndex - 1];\n        std::sort(currentWord.begin(), currentWord.end());\n        std::sort(previousWord.begin(), previousWord.end());\n        if(currentWord == previousWord)\n        {\n            wordList.erase(wordList.begin() + currentIndex);\n            --currentIndex;\n        }\n    }\n    return wordList;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\n// for std::find\nusing namespace std;\n\nint findFinalValue(vector<int> &numbers, int originalValue)\n{\n    while(find(numbers.begin(), numbers.end(), originalValue) != numbers.end())\n    {\n        originalValue++;\n    }\n    return originalValue;\n}",
    "output": "#include <bits/stdc++.h>\nint findFinalValue(std::vector<int> &numbers, int originalValue)\n{\n    while(std::find(numbers.begin(), numbers.end(), originalValue) != numbers.end())\n    {\n        originalValue++;\n    }\n    return originalValue;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring findSubstring(const string &inputString, int hashBase, int hashModulo, int substringLength, int targetHashValue)\n{\n    long long currentHashValue= 0;\n    long long powerK= 1;\n\n    for(int index= 0; index < substringLength; ++index)\n    {\n        currentHashValue= (currentHashValue * hashBase + (inputString[index] - 'a' + 1)) % hashModulo;\n        powerK= (powerK * hashBase) % hashModulo;\n    }\n\n    if(currentHashValue == targetHashValue)\n        return inputString.substr(0, substringLength);\n\n    for(int index= substringLength; index < inputString.size(); ++index)\n    {\n        currentHashValue= ((currentHashValue - (inputString[index - substringLength] - 'a' + 1) * powerK) % hashModulo + hashModulo) % hashModulo;\n        currentHashValue= (currentHashValue * hashBase + (inputString[index] - 'a' + 1)) % hashModulo;\n        if(currentHashValue == targetHashValue)\n            return inputString.substr(index - substringLength + 1, substringLength);\n    }\n\n    throw std::runtime_error(\"No matching substring found\");\n}",
    "output": "#include <bits/stdc++.h>\nstring findSubstring(const std::string &inputString, int hashBase, int hashModulo, int substringLength, int targetHashValue)\n{\n    long long currentHashValue= 0;\n    long long powerK= 1;\n\n    for(int index= 0; index < substringLength; ++index)\n    {\n        currentHashValue= (currentHashValue * hashBase + (inputString[index] - 'a' + 1)) % hashModulo;\n        powerK= (powerK * hashBase) % hashModulo;\n    }\n\n    if(currentHashValue == targetHashValue)\n        return inputString.substr(0, substringLength);\n\n    for(int index= substringLength; index < inputString.size(); ++index)\n    {\n        currentHashValue= ((currentHashValue - (inputString[index - substringLength] - 'a' + 1) * powerK) % hashModulo + hashModulo) % hashModulo;\n        currentHashValue= (currentHashValue * hashBase + (inputString[index] - 'a' + 1)) % hashModulo;\n        if(currentHashValue == targetHashValue)\n            return inputString.substr(index - substringLength + 1, substringLength);\n    }\n\n    throw std::runtime_error(\"No matching substring found\");\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> groupStrings(vector<string> &inputWords)\n{\n    unordered_map<string, int> groupMap;\n    int uniqueGroupsCount = 0;\n\n    for (int i = 0; i < inputWords.size(); ++i)\n    {\n        const string &currentWord = inputWords[i];\n        string sortedKey(currentWord);\n        sort(sortedKey.begin(), sortedKey.end());\n\n        if (groupMap.find(sortedKey) == groupMap.end())\n        {\n            groupMap[sortedKey] = uniqueGroupsCount;\n            uniqueGroupsCount++;\n        }\n    }\n\n    return {uniqueGroupsCount, inputWords.size() - uniqueGroupsCount};\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> groupStrings(std::vector<std::string> &inputWords)\n{\n    std::unordered_map<std::string, int> groupMap;\n    int uniqueGroupsCount= 0;\n\n    for(const std::string &currentWord : inputWords)\n    {\n        std::string sortedKey(currentWord);\n        sort(sortedKey.begin(), sortedKey.end());\n\n        if(groupMap.find(sortedKey) == groupMap.end())\n        {\n            groupMap[sortedKey]= uniqueGroupsCount;\n            uniqueGroupsCount++;\n        }\n    }\n\n    return {uniqueGroupsCount, inputWords.size() - uniqueGroupsCount};\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findClosestNodes(int nodeCount, vector<vector<int>> &edges, vector<vector<int>> &queries)\n{\n    vector<int> result;\n\n    vector<vector<int>> adjacencyList(nodeCount);\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        adjacencyList[edges[i][0]].push_back(edges[i][1]);\n        adjacencyList[edges[i][1]].push_back(edges[i][0]);\n    }\n\n    auto bfs = [&](int startNode, int targetNode)\n    {\n        queue<int> nodeQueue;\n        vector<bool> visitedNodes(nodeCount, false);\n        nodeQueue.push(startNode);\n        visitedNodes[startNode] = true;\n\n        while (!nodeQueue.empty())\n        {\n            int currentNode = nodeQueue.front();\n            nodeQueue.pop();\n\n            if (currentNode == targetNode)\n            {\n                return currentNode;\n            }\n\n            for (int j = 0; j < adjacencyList[currentNode].size(); ++j)\n            {\n                int neighbor = adjacencyList[currentNode][j];\n                if (!visitedNodes[neighbor])\n                {\n                    nodeQueue.push(neighbor);\n                    visitedNodes[neighbor] = true;\n                }\n            }\n        }\n        return -1;\n    };\n\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        int lowestCommonAncestor = bfs(queries[i][0], queries[i][1]);\n        int closestNode1 = bfs(lowestCommonAncestor, queries[i][0]);\n        int closestNode2 = bfs(lowestCommonAncestor, queries[i][1]);\n        result.push_back(closestNode1 == queries[i][2] ? queries[i][0] : queries[i][1]);\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> findClosestNodes(int nodeCount, std::vector<std::vector<int>> &edges, std::vector<std::vector<int>> &queries)\n{\n    std::vector<int> result;\n\n    std::vector<std::vector<int>> adjacencyList(nodeCount);\n    for(auto &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    auto bfs= [&](int startNode, int targetNode)\n    {\n        std::queue<int> nodeQueue;\n        std::vector<bool> visitedNodes(nodeCount, false);\n        nodeQueue.push(startNode);\n        visitedNodes[startNode]= true;\n\n        while(!nodeQueue.empty())\n        {\n            int currentNode= nodeQueue.front();\n            nodeQueue.pop();\n\n            if(currentNode == targetNode)\n            {\n                return currentNode;\n            }\n\n            for(int neighbor : adjacencyList[currentNode])\n            {\n                if(!visitedNodes[neighbor])\n                {\n                    nodeQueue.push(neighbor);\n                    visitedNodes[neighbor]= true;\n                }\n            }\n        }\n        return -1;\n    };\n\n    for(auto &query : queries)\n    {\n        int lowestCommonAncestor= bfs(query[0], query[1]);\n        int closestNode1= bfs(lowestCommonAncestor, query[0]);\n        int closestNode2= bfs(lowestCommonAncestor, query[1]);\n        result.push_back(closestNode1 == query[2] ? query[0] : query[1]);\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> getThreeConsecutiveIntegers(int inputNumber)\n{\n    if(inputNumber % 3 == 0)\n    {\n        return {inputNumber / 3 - 1, inputNumber / 3, inputNumber / 3 + 1};\n    }\n    else if(inputNumber % 3 == 1)\n    {\n        return {(inputNumber - 2) / 3, (inputNumber + 1) / 3, (inputNumber + 4) / 3};\n    }\n    else\n    {\n        return {};\n    }\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> getThreeConsecutiveIntegers(int inputNumber)\n{\n    if(inputNumber % 3 == 0)\n    {\n        return {inputNumber / 3 - 1, inputNumber / 3, inputNumber / 3 + 1};\n    }\n    else if(inputNumber % 3 == 1)\n    {\n        return {(inputNumber - 2) / 3, (inputNumber + 1) / 3, (inputNumber + 4) / 3};\n    }\n    else\n    {\n        return {};\n    }\n}"
  },
  {
    "instruction": "Conver the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use range-based for loops wherever possible",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> maxUniqueEvenSum(int targetSum)\n{\n    vector<int> result;\n    int currentEvenNumber= 2;\n    while(targetSum > 0)\n    {\n        if(targetSum >= currentEvenNumber)\n        {\n            result.push_back(currentEvenNumber);\n            targetSum-= currentEvenNumber;\n            currentEvenNumber+= 2;\n        }\n        else\n        {\n            break;\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> maxUniqueEvenSum(int targetSum)\n{\n    std::vector<int> result;\n    int currentEvenNumber= 2;\n    while(targetSum > 0)\n    {\n        if(targetSum >= currentEvenNumber)\n        {\n            result.push_back(currentEvenNumber);\n            targetSum-= currentEvenNumber;\n            currentEvenNumber+= 2;\n        }\n        else\n        {\n            break;\n        }\n    }\n    return result;\n}"
  }
]